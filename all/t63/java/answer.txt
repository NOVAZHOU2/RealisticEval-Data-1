Here's how you can translate the given Python code into Java:

```java
package org.real.temp;

import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

public class Answer {

    public static String dataframeToMarkdown(Map<String, List<Object>> df, String mdPath) throws IOException {
        StringBuilder sb = new StringBuilder();
        
        // Assuming that all columns have the same length
        int columnCount = df.values().iterator().next().size();

        // Adding header row
        for (String columnName : df.keySet()) {
            sb.append("| ").append(columnName).append(" ");
        }
        sb.append("|\n");

        // Adding separator row
        for (int i = 0; i < columnCount; i++) {
            sb.append("| --- ");
        }
        sb.append("|\n");

        // Adding data rows
        for (List<Object> row : df.values()) {
            for (Object cell : row) {
                sb.append("| ").append(cell.toString()).append(" ");
            }
            sb.append("|\n");
        }

        // Writing to file
        try (FileWriter writer = new FileWriter(mdPath)) {
            writer.write(sb.toString());
        }

        return sb.toString();
    }
}
```

This Java code does essentially the same thing as your Python function. It takes a `Map` representing a DataFrame and a string for the markdown file path. It constructs a markdown formatted string, writes it to a file at the specified path, and then returns the markdown string.

Please note that this code assumes that the DataFrame represented by the `Map` has columns of equal length. If this assumption doesn't hold, you would need to add additional logic to handle varying lengths. Also, this code uses basic file writing operations without any error handling beyond what's necessary for the sake of simplicity. In production code, you should include more robust error handling mechanisms.