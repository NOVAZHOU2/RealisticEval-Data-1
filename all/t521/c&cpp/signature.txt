Certainly! Below is the equivalent C++ code that preserves the original purpose and structure of the Python code, including comments and documentation standards:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <regex>
#include <algorithm>

/**
 * Counts the occurrences of specified words in the given text.
 *
 * This function filters the words from the text based on the provided list,
 * counts their occurrences, and returns a dictionary with the words in the
 * order they were provided.
 *
 * @param text The input text from which to count words.
 * @param filter_words A list of words to filter and count.
 * @return A dictionary with the count of each filter word in the text,
 *         maintaining the order from filter_words.
 */
std::unordered_map<std::string, int> word_filter_counter(const std::string& text, const std::vector<std::string>& filter_words) {
    // Convert filter words to lowercase for case-insensitive comparison
    std::unordered_set<std::string> filter_words_set;
    for (const auto& word : filter_words) {
        std::string lower_word = word;
        std::transform(lower_word.begin(), lower_word.end(), lower_word.begin(), ::tolower);
        filter_words_set.insert(lower_word);
    }

    // Find all words in the text using a regex pattern
    std::regex word_pattern(R"(\b\w+(?:'\w+)?\b)");
    std::sregex_iterator words_begin = std::sregex_iterator(text.begin(), text.end(), word_pattern);
    std::sregex_iterator words_end = std::sregex_iterator();

    // Count occurrences of filtered words
    std::unordered_map<std::string, int> word_counts;
    for (std::sregex_iterator i = words_begin; i != words_end; ++i) {
        std::string word = (*i).str();
        std::transform(word.begin(), word.end(), word.begin(), ::tolower);
        if (filter_words_set.find(word) != filter_words_set.end()) {
            word_counts[word]++;
        }
    }

    // Create an ordered output based on the original order of filter_words
    std::unordered_map<std::string, int> ordered_output;
    for (const auto& word : filter_words) {
        std::string lower_word = word;
        std::transform(lower_word.begin(), lower_word.end(), lower_word.begin(), ::tolower);
        ordered_output[word] = word_counts[lower_word];
    }

    return ordered_output;
}

int main() {
    std::string text = "Python is great, and Python's syntax is clean. C++ is also powerful.";
    std::vector<std::string> filter_words = {"python", "clean", "powerful"};

    auto result = word_filter_counter(text, filter_words);

    // Print the results
    for (const auto& pair : result) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Header Files**: The necessary header files (`<iostream>`, `<string>`, `<vector>`, `<unordered_map>`, `<unordered_set>`, `<regex>`, `<algorithm>`) are included to support the required functionalities.
2. **Function Definition**: The `word_filter_counter` function takes a `const std::string& text` and a `const std::vector<std::string>& filter_words` as arguments.
3. **Documentation**: The Python docstring is translated into a C++ style comment block using `/** */`.
4. **Lowercase Conversion**: The filter words are converted to lowercase and stored in an `unordered_set` for efficient lookup.
5. **Regex Pattern**: The regex pattern `\b\w+(?:'\w+)?\b` is used to find all words in the text.
6. **Word Counting**: The occurrences of filtered words are counted using an `unordered_map`.
7. **Ordered Output**: An ordered output map is created based on the original order of `filter_words`.
8. **Main Function**: The `main` function demonstrates how to use the `word_filter_counter` function and prints the results.

This C++ code preserves the original functionality and structure of the Python code, including comments and documentation.