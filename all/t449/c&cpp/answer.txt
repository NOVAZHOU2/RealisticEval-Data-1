Certainly! Below is the equivalent C++ code for converting a string to Base64 encoding:

```cpp
#include <iostream>
#include <vector>
#include <string>

std::string base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

std::string encode_to_base64(const std::string &input) {
    std::string output;
    int val = 0, valb = -6;

    for (unsigned char c : input) {
        val = (val << 8) + c;
        valb += 8;
        while (valb >= 0) {
            output.push_back(base64_chars[(val >> valb) & 0x3F]);
            valb -= 6;
        }
    }

    if (valb > -6) output.push_back(base64_chars[((val << 8) >> (valb + 8)) & 0x3F]);

    while (output.size() % 4 != 0) output.push_back('=');

    return output;
}

int main() {
    std::string input = "Hello, World!";
    std::string encoded = encode_to_base64(input);
    std::cout << "Encoded: " << encoded << std::endl;
    return 0;
}
```

### Explanation:
- **base64_chars**: This string contains all the characters used in Base64 encoding.
- **encode_to_base64**: This function takes an input string and converts it to Base64 encoding.
  - It initializes `val` and `valb` to handle the bit manipulation.
  - For each character in the input string, it shifts `val` left by 8 bits and adds the ASCII value of the character. It then adjusts `valb` accordingly.
  - When `valb` is greater than or equal to 0, it extracts 6 bits from `val`, finds the corresponding character in `base64_chars`, and appends it to the output string.
  - If there are remaining bits in `val`, it handles them appropriately.
  - Finally, it pads the output with '=' characters to ensure the length is a multiple of 4.

This code should work correctly for converting strings to Base64 encoding in C++.