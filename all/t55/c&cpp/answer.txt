Here is a C++ version of your Python function:

```C++
#include <iostream>
#include <vector>
#include <algorithm>

int minRemovalsToMakeUnique(std::vector<int> nums) {
    std::sort(nums.begin(), nums.end());
    int count = 0;
    for(int i = 1; i < nums.size(); ++i){
        if(nums[i] <= nums[i-1]){
            int diff = nums[i-1] - nums[i];
            nums[i] += diff + 1;
            count += diff + 1;
        }
    }
    return count;
}

int main() {
    std::vector<int> nums = {3, 3, 1, 2, 2, 1};
    std::cout << "Minimum removals to make unique: " << minRemovalsToMakeUnique(nums);
    return 0;
}
```

And here's a C version of the same function:

```C
#include <stdio.h>
#include <stdlib.h>

void sortArray(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1])
                swap(&arr[j], &arr[j+1]);
        }
    }
}

void swap(int *xp, int *yp) {
    int temp = *xp;
    *xp = *yp;
    *yp = temp;
}

int minRemovalsToMakeUnique(int nums[], int size) {
    sortArray(nums, size);

    int count = 0;

    for(int i = 1; i < size; ++i){
        if(nums[i] <= nums[i-1]){
            int diff = nums[i-1] - nums[i];
            nums[i] += diff + 1;
            count += diff + 1;
        }
    }

    return count;
}

int main() {
    int nums[] = {3, 3, 1, 2, 2, 1};
    int size = sizeof(nums)/sizeof(nums[0]);

    printf("Minimum removals to make unique: %d\n", minRemovalsToMakeUnique(nums, size));
    
    return 0;
}
```
In both versions, we first sort the array and then iterate over it. If we find any element which is less than or equal to its previous element, we increment the current element to be one more than the previous element and increase our count accordingly. The `minRemovalsToMakeUnique` function returns the total count which represents the minimum number of removals needed to make all elements unique.