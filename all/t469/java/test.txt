Certainly! Below is the equivalent Java test class using JUnit, placed in the package `org.real.temp` and named `Tester`. The test cases are structured using JUnit annotations and assertions to ensure the functionality and logic are preserved.

```java
package org.real.temp;

import org.junit.Test;
import static org.junit.Assert.assertEquals;

/**
 * Test class for the getScale function.
 */
public class Tester {

    /**
     * Test for the identity matrix (no scaling).
     */
    @Test
    public void testIdentityMatrix() {
        double[] matrix = {1, 0, 0, 0, 1, 0, 0, 0, 1};
        double[] expectedScale = {1.0, 1.0};
        double[] actualScale = getScale(matrix);
        assertEquals(expectedScale[0], actualScale[0], 0.001);
        assertEquals(expectedScale[1], actualScale[1], 0.001);
    }

    /**
     * Test for a scaling matrix (2x in x and 3x in y).
     */
    @Test
    public void testScalingMatrix() {
        double[] matrix = {2, 0, 0, 0, 3, 0, 0, 0, 1};
        double[] expectedScale = {2.0, 3.0};
        double[] actualScale = getScale(matrix);
        assertEquals(expectedScale[0], actualScale[0], 0.001);
        assertEquals(expectedScale[1], actualScale[1], 0.001);
    }

    /**
     * Test case with uniform scaling.
     */
    @Test
    public void testUniformScaling() {
        double[] matrix = {2, 0, 0, 0, 2, 0, 0, 0, 1};
        double[] expectedScale = {2.0, 2.0};
        double[] actualScale = getScale(matrix);
        assertEquals(expectedScale[0], actualScale[0], 0.001);
        assertEquals(expectedScale[1], actualScale[1], 0.001);
    }

    /**
     * Test case with non-uniform scaling.
     */
    @Test
    public void testNonUniformScaling() {
        double[] matrix = {3, 0, 0, 0, 5, 0, 0, 0, 1};
        double[] expectedScale = {3.0, 5.0};
        double[] actualScale = getScale(matrix);
        assertEquals(expectedScale[0], actualScale[0], 0.001);
        assertEquals(expectedScale[1], actualScale[1], 0.001);
    }

    /**
     * Test case with reflection matrix.
     */
    @Test
    public void testReflectionMatrix() {
        double[] matrix = {-1, 0, 0, 0, 1, 0, 0, 0, 1};
        double[] expectedScale = {1.0, 1.0};
        double[] actualScale = getScale(matrix);
        assertEquals(expectedScale[0], actualScale[0], 0.001);
        assertEquals(expectedScale[1], actualScale[1], 0.001);
    }

    // Utility method to get the scale factors
    private double[] getScale(double[] matrix) {
        // Ensure the matrix is a 3x3 array
        if (matrix == null || matrix.length != 9) {
            throw new IllegalArgumentException("Input must be a 3x3 affine transformation matrix.");
        }

        // Extract the relevant sub-matrices for calculating scale factors
        double[] subMatrixX = Arrays.copyOfRange(matrix, 0, 2);
        double[] subMatrixY = Arrays.copyOfRange(matrix, 3, 5);

        // Calculate the scale factors using the norm of the columns
        double scaleX = calculateNorm(subMatrixX);
        double scaleY = calculateNorm(subMatrixY);

        return new double[]{scaleX, scaleY};
    }

    /**
     * Helper method to calculate the Euclidean norm of a vector.
     *
     * @param vector The vector for which to calculate the norm.
     * @return The Euclidean norm of the vector.
     */
    private double calculateNorm(double[] vector) {
        double sumOfSquares = 0.0;
        for (double value : vector) {
            sumOfSquares += value * value;
        }
        return Math.sqrt(sumOfSquares);
    }
}
```

### Explanation:
1. **Package and Class Definition**: The Java test class is defined within the package `org.real.temp` and named `Tester`.
2. **JUnit Annotations**: Each test method is annotated with `@Test` to indicate it is a test case.
3. **Assertions**: The `assertEquals` method is used to compare the expected and actual scale factors with a tolerance (`0.001`) to handle floating-point comparisons.
4. **Utility Methods**: The `getScale` method is included to perform the actual calculations, ensuring consistency with the original Python implementation.
5. **Helper Method**: The `calculateNorm` method is used to compute the Euclidean norm of the sub-matrices.
6. **Test Cases**: Each test case is structured to match the Python test cases, ensuring the same functionality and logic.

This Java code preserves the functionality and structure of the original Python test cases while adhering to JUnit conventions and best practices.