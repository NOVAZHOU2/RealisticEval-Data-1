Certainly! Below is the equivalent C++ code for the provided Python function. This code includes necessary type declarations, error handling, and uses the Eigen library for matrix operations, which is a popular C++ template library for linear algebra.

First, you need to install the Eigen library if it is not already installed. You can typically include it directly in your project or link it statically.

Hereâ€™s the C++ code:

```cpp
#include <Eigen/Dense>
#include <stdexcept>
#include <iostream>

using Eigen::MatrixXd;
using std::pair;
using std::runtime_error;

pair<double, double> get_scale(const MatrixXd& matrix) {
    /**
     * Given a 3x3 affine transformation matrix, return the corresponding scaling factors
     * along the x and y axes.
     *
     * Args:
     *     matrix (MatrixXd): A 3x3 affine transformation matrix.
     *
     * Returns:
     *     pair<double, double>: A pair containing the scale factors (scale_x, scale_y).
     */
    // Ensure the matrix is a 3x3 matrix
    if (matrix.rows() != 3 || matrix.cols() != 3) {
        throw runtime_error("Input must be a 3x3 affine transformation matrix.");
    }

    // Calculate the scale factors using the norm of the columns
    double scale_x = matrix.block(0, 0, 2, 1).norm();  // Using the first two rows for x-scale
    double scale_y = matrix.block(0, 1, 2, 1).norm();  // Using the first two rows for y-scale

    return make_pair(scale_x, scale_y);
}

int main() {
    // Example usage
    MatrixXd matrix(3, 3);
    matrix << 1.0, 2.0, 0.0,
              0.0, 1.0, 0.0,
              0.0, 0.0, 1.0;

    try {
        auto scales = get_scale(matrix);
        std::cout << "Scale X: " << scales.first << ", Scale Y: " << scales.second << std::endl;
    } catch (const runtime_error& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Eigen Library**: The Eigen library is used for matrix operations. It provides a convenient way to work with matrices and vectors in C++.
2. **Type Definitions**: `MatrixXd` is used to represent a dynamic matrix of doubles.
3. **Error Handling**: A `runtime_error` is thrown if the input matrix is not a 3x3 matrix.
4. **Matrix Slicing**: The `block()` method is used to extract the first two rows of each column for calculating the scale factors.
5. **Return Type**: A `std::pair<double, double>` is used to return the scale factors.

This code should provide the same functionality as the Python version, ensuring consistency in logic and structure while adapting to C++ syntax and features.