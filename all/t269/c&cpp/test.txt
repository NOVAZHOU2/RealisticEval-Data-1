To convert the given Python unittest test class into an equivalent test class using Catch2 in C++, we need to define the equivalent functionality and write tests using Catch2's syntax and assertions. Below is the step-by-step process:

1. **Define the `is_compliant_ip` function** in C++.
2. **Create a test suite** using Catch2 to verify the function's behavior.

Here’s how you can do it:

### Step 1: Define the `is_compliant_ip` Function

First, let's define the `is_compliant_ip` function in C++. This function checks whether the IP address is a legal IP address.

```cpp
#include <string>
#include <vector>
#include <sstream>

bool is_compliant_ip(const std::string& ip) {
    // Split the IP address by dots
    std::istringstream iss(ip);
    std::vector<int> parts;
    int part;
    while (iss >> part) {
        if (iss && part >= 0 && part <= 255) {
            parts.push_back(part);
        } else {
            return false; // Invalid part or trailing characters
        }
        if (iss.peek() == '.') {
            iss.ignore();
        } else {
            break;
        }
    }
    return parts.size() == 4; // Valid IP has exactly 4 parts
}
```

### Step 2: Create the Test Suite with Catch2

Next, let's create the test suite using Catch2. We will write tests to ensure the `is_compliant_ip` function behaves as expected.

```cpp
#include "catch2/catch_test_macros.hpp"

TEST_CASE("Test is_compliant_ip") {
    SECTION("Valid IP addresses") {
        REQUIRE(is_compliant_ip("192.168.1.1") == true);
        REQUIRE(is_compliant_ip("10.0.0.1") == true);
        REQUIRE(is_compliant_ip("255.255.255.255") == true);
    }

    SECTION("Invalid IP addresses") {
        REQUIRE(is_compliant_ip("192.168.1.256") == false); // Out of range
        REQUIRE(is_compliant_ip("192.168.1.") == false); // Missing part
        REQUIRE(is_compliant_ip("192.168..1") == false); // Extra dot
        REQUIRE(is_compliant_ip("192.168.1.1.1") == false); // Too many parts
        REQUIRE(is_compliant_ip("192.168.1.0a") == false); // Non-numeric part
        REQUIRE(is_compliant_ip("192.168.-1.1") == false); // Negative number
    }
}
```

### Full Code

Combining everything together, here’s the full code:

```cpp
#include <string>
#include <vector>
#include <sstream>
#include "catch2/catch_test_macros.hpp"

// Function to check if the IP address is valid
bool is_compliant_ip(const std::string& ip) {
    // Split the IP address by dots
    std::istringstream iss(ip);
    std::vector<int> parts;
    int part;
    while (iss >> part) {
        if (iss && part >= 0 && part <= 255) {
            parts.push_back(part);
        } else {
            return false; // Invalid part or trailing characters
        }
        if (iss.peek() == '.') {
            iss.ignore();
        } else {
            break;
        }
    }
    return parts.size() == 4; // Valid IP has exactly 4 parts
}

TEST_CASE("Test is_compliant_ip") {
    SECTION("Valid IP addresses") {
        REQUIRE(is_compliant_ip("192.168.1.1") == true);
        REQUIRE(is_compliant_ip("10.0.0.1") == true);
        REQUIRE(is_compliant_ip("255.255.255.255") == true);
    }

    SECTION("Invalid IP addresses") {
        REQUIRE(is_compliant_ip("192.168.1.256") == false); // Out of range
        REQUIRE(is_compliant_ip("192.168.1.") == false); // Missing part
        REQUIRE(is_compliant_ip("192.168..1") == false); // Extra dot
        REQUIRE(is_compliant_ip("192.168.1.1.1") == false); // Too many parts
        REQUIRE(is_compliant_ip("192.168.1.0a") == false); // Non-numeric part
        REQUIRE(is_compliant_ip("192.168.-1.1") == false); // Negative number
    }
}
```

This C++ code defines the `is_compliant_ip` function and includes a test suite using Catch2 to validate its correctness.