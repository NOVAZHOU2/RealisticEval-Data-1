Firstly, I'll define the function `is_compliant_ip` in TypeScript. For the sake of this example, let's assume a correct implementation would check for a valid IPv4 address (we can test for other types of IPs like IPv6 in a similar way). Then, I'll create a describe block with several it blocks to represent each of your test cases. Here's a potential conversion:

```typescript
function isCompliantIp(ip: string): boolean {
    const ipParts = ip.split('.');
    // Check if the IP has exactly 4 parts and all parts are numbers within range 0-255
    return ipParts.length === 4 && ipParts.every(part => !isNaN(Number(part)) && Number(part) >= 0 && Number(part) <= 255);
}

describe('isCompliantIp', () => {
    it('returns true for a valid IP address', () => {
        expect(isCompliantIp('192.168.0.1')).toBe(true);
    });

    it('returns false for an invalid IP address', () => {
        expect(isCompliantIp('256.168.0.1')).toBe(false); // Invalid because 256 is out of range
    });

    it('returns false for an IP address with more than 4 parts', () => {
        expect(isCompliantIp('192.168.0.1.1')).toBe(false); // Invalid because there are more than 4 parts
    });

    it('returns false for an IP address with less than 4 parts', () => {
        expect(isCompliantIp('192.168.0')).toBe(false); // Invalid because there are less than 4 parts
    });

    it('returns false for an IP address with non-numeric parts', () => {
        expect(isCompliantIp('192.168.0.one')).toBe(false); // Invalid because 'one' is not a number
    });
});
```

This TypeScript code defines a function `isCompliantIp` which checks if a given string is a valid IPv4 address by ensuring it consists of four parts separated by dots, where each part is a number between 0 and 255. The `describe` block contains several test cases using `expect` and `toBe` from Jest to validate the function against various scenarios, mirroring the functionality and intent of your original Python unittests.