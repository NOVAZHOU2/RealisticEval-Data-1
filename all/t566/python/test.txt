Hereâ€™s how you can convert the provided TypeScript Jest test cases into Python unittest test cases. The logic remains the same, ensuring that each test checks the expected behavior of the is_same_day function.
python
import unittest
from datetime import datetime

def is_same_day(timestamp1: int, timestamp2: int) -> bool:
    """
    Checks if two timestamps correspond to the same day.

    :param timestamp1: The first timestamp to compare.
    :param timestamp2: The second timestamp to compare.
    :returns: True if both timestamps are on the same day, false otherwise.
    """
    date1 = datetime.fromtimestamp(timestamp1)
    date2 = datetime.fromtimestamp(timestamp2)
    return (date1.year == date2.year and
            date1.month == date2.month and
            date1.day == date2.day)

class TestIsSameDay(unittest.TestCase):

    def test_different_days(self):
        timestamp1 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # October 1, 2024, 10:00 AM UTC
        timestamp2 = int(datetime(2024, 10, 2, 10, 0, 0).timestamp())  # October 2, 2024, 10:00 AM UTC
        self.assertFalse(is_same_day(timestamp1, timestamp2))

    def test_same_day_different_times(self):
        timestamp1 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # October 1, 2024, 12:00 AM UTC
        timestamp2 = int(datetime(2024, 10, 1, 12, 30, 0).timestamp())  # October 1, 2024, 12:30 PM UTC
        self.assertTrue(is_same_day(timestamp1, timestamp2))

    def test_same_day_different_time_zones(self):
        timestamp1 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # UTC
        timestamp2 = int(datetime.fromisoformat('2024-10-01T12:00:00+02:00').timestamp())  # October 1, 2024, 12:00 PM UTC+2
        self.assertTrue(is_same_day(timestamp1, timestamp2))

    def test_midnight_same_day(self):
        timestamp1 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # October 1, 2024, 12:00 AM UTC
        timestamp2 = int(datetime(2024, 10, 1, 0, 0, 0).timestamp())  # Same timestamp
        self.assertTrue(is_same_day(timestamp1, timestamp2))

    def test_different_years(self):
        timestamp1 = int(datetime(2023, 10, 1, 10, 0, 0).timestamp())  # October 1, 2023, 10:00 AM UTC
        timestamp2 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # October 1, 2024, 10:00 AM UTC
        self.assertFalse(is_same_day(timestamp1, timestamp2))

    def test_invalid_timestamps(self):
        timestamp1 = int(datetime.fromisoformat('invalid').timestamp())  # This will raise an error, so handle it
        timestamp2 = int(datetime(2024, 10, 1, 10, 0, 0).timestamp())  # Valid timestamp
        with self.assertRaises(ValueError):
            is_same_day(timestamp1, timestamp2)

if __name__ == '__main__':
    unittest.main()
Explanation:
Imports: The code imports unittest for testing and datetime for date manipulation.
Function Definition: The is_same_day function is defined as in the previous response.
Test Class: A class TestIsSameDay is created, which inherits from unittest.TestCase.
Test Methods:
Each method corresponds to a test case in the original Jest code.
The timestamps are created using datetime and converted to Unix time using .timestamp().
Assertions are made using self.assertTrue() and self.assertFalse().
Invalid Timestamps: The invalid timestamp test is set to raise a ValueError, which is a standard way to handle errors in Python. If you have specific behavior for invalid timestamps, adjust the exception accordingly.
You can run these tests using any Python environment that supports unittest. Let me know if you need any further changes or explanations!