Sure, hereâ€™s the C++ version of the provided Python function, including comments and type conversions:

```cpp
#include <string>
#include <vector>
#include <unordered_map>

// Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.
// 
// Args:
//     data: The input data which can be a dictionary or a list.
//
// Returns:
//     The converted data which can be a dictionary or a list.

union DataValue {
    int intValue;
    double doubleValue;
    std::string stringValue;

    DataValue() {}
    DataValue(int val) : intValue(val) {}
    DataValue(double val) : doubleValue(val) {}
    DataValue(const std::string& val) : stringValue(val) {}

    bool isInt() const { return typeid(*this) == typeid(intValue); }
    bool isDouble() const { return typeid(*this) == typeid(doubleValue); }
    bool isString() const { return typeid(*this) == typeid(stringValue); }

    operator int() const { return intValue; }
    operator double() const { return doubleValue; }
    operator std::string() const { return stringValue; }
};

using DataList = std::vector<DataValue>;
using DataDict = std::unordered_map<std::string, DataValue>;

DataDict convertStringToNumberInDict(const DataDict& dict);
DataList convertStringToNumberInList(const DataList& list);

DataDict convertStringToNumberInDict(const DataDict& dict) {
    DataDict newDict;
    for (const auto& pair : dict) {
        if (pair.second.isString()) {
            const std::string& str = pair.second;
            try {
                size_t pos;
                int intVal = std::stoi(str, &pos);
                if (pos == str.size()) {
                    newDict[pair.first] = intVal;
                } else {
                    double doubleVal = std::stod(str, &pos);
                    if (pos == str.size()) {
                        newDict[pair.first] = doubleVal;
                    } else {
                        newDict[pair.first] = str;
                    }
                }
            } catch (std::invalid_argument& e) {
                newDict[pair.first] = str;
            } catch (std::out_of_range& e) {
                newDict[pair.first] = str;
            }
        } else {
            newDict[pair.first] = pair.second;
        }
    }
    return newDict;
}

DataList convertStringToNumberInList(const DataList& list) {
    DataList newList;
    for (const auto& item : list) {
        if (item.isString()) {
            const std::string& str = item;
            try {
                size_t pos;
                int intVal = std::stoi(str, &pos);
                if (pos == str.size()) {
                    newList.push_back(intVal);
                } else {
                    double doubleVal = std::stod(str, &pos);
                    if (pos == str.size()) {
                        newList.push_back(doubleVal);
                    } else {
                        newList.push_back(str);
                    }
                }
            } catch (std::invalid_argument& e) {
                newList.push_back(str);
            } catch (std::out_of_range& e) {
                newList.push_back(str);
            }
        } else {
            newList.push_back(item);
        }
    }
    return newList;
}

union DataUnion {
    DataDict dict;
    DataList list;

    DataUnion() {}
    DataUnion(DataDict d) : dict(d) {}
    DataUnion(DataList l) : list(l) {}

    bool isDict() const { return typeid(*this) == typeid(dict); }
    bool isList() const { return typeid(*this) == typeid(list); }

    operator DataDict() const { return dict; }
    operator DataList() const { return list; }
};

DataUnion convert_strings_to_numbers(DataUnion data) {
    if (data.isDict()) {
        return convertStringToNumberInDict(data.dict);
    } else if (data.isList()) {
        return convertStringToNumberInList(data.list);
    } else {
        throw std::runtime_error("Invalid data type");
    }
}
```

This C++ code includes the necessary types and functions to handle the conversion of strings to numbers within nested structures like dictionaries and lists. It uses unions to represent the union types and includes helper functions to perform the conversion.