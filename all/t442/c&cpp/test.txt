Certainly! Below is the equivalent C++ code using the Catch2 testing framework. This includes the implementation of the `convert_strings_to_numbers` function and the corresponding test cases.

### C++ Code with Catch2 Testing Framework

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <string>
#include <variant>
#include <sstream>
#include <catch2/catch_test_macros.hpp>

// Helper function to check if a string contains a dot
bool containsDot(const std::string& str) {
    return str.find('.') != std::string::npos;
}

// Function to attempt conversion of a string to a number
template<typename T>
T stringToNumber(const std::string& str) {
    std::istringstream iss(str);
    T number;
    iss >> number;
    if (iss.fail() || !iss.eof()) {
        throw std::invalid_argument("Conversion failed");
    }
    return number;
}

/**
 * Convert strings in nested structures (e.g., dictionaries, arrays) to numbers (integers or floating-point numbers) as much as possible.
 *
 * @param data A dictionary or list containing nested structures.
 * @return A dictionary or list with strings converted to numbers where possible.
 */
std::variant<std::map<std::string, std::variant<std::string, int, double>>, std::vector<std::variant<std::string, int, double>>> convertStringsToNumbers(
    const std::variant<std::map<std::string, std::variant<std::string, int, double>>, std::vector<std::variant<std::string, int, double>>>& data
) {
    if (std::holds_alternative<std::map<std::string, std::variant<std::string, int, double>>>(data)) {
        auto map = std::get<std::map<std::string, std::variant<std::string, int, double>>>(data);
        std::map<std::string, std::variant<std::string, int, double>> newMap;
        for (const auto& [key, value] : map) {
            newMap[key] = convertStringsToNumbers(value);
        }
        return newMap;
    } else if (std::holds_alternative<std::vector<std::variant<std::string, int, double>>>(data)) {
        auto vec = std::get<std::vector<std::variant<std::string, int, double>>>(data);
        std::vector<std::variant<std::string, int, double>> newVec;
        for (const auto& item : vec) {
            newVec.push_back(convertStringsToNumbers(item));
        }
        return newVec;
    } else if (std::holds_alternative<std::string>(data)) {
        std::string str = std::get<std::string>(data);
        try {
            if (containsDot(str)) {
                return stringToNumber<double>(str);
            } else {
                return stringToNumber<int>(str);
            }
        } catch (const std::invalid_argument&) {
            return str; // Return original string if conversion fails
        }
    } else {
        return data; // Return data unchanged if it's not a string
    }
}

TEST_CASE("Test convert_strings_to_numbers") {
    SECTION("Convert dictionary") {
        std::map<std::string, std::variant<std::string, int, double>> input = {
            {"a", "123"},
            {"b", "456.789"},
            {"c", "not_a_number"}
        };
        auto output = convertStringsToNumbers(input);
        REQUIRE(std::holds_alternative<std::map<std::string, std::variant<std::string, int, double>>>(output));

        auto convertedMap = std::get<std::map<std::string, std::variant<std::string, int, double>>>(output);
        REQUIRE(convertedMap.size() == 3);

        REQUIRE(std::holds_alternative<int>(convertedMap.at("a")));
        REQUIRE(std::get<int>(convertedMap.at("a")) == 123);

        REQUIRE(std::holds_alternative<double>(convertedMap.at("b")));
        REQUIRE(std::get<double>(convertedMap.at("b")) == 456.789);

        REQUIRE(std::holds_alternative<std::string>(convertedMap.at("c")));
        REQUIRE(std::get<std::string>(convertedMap.at("c")) == "not_a_number");
    }

    SECTION("Convert list") {
        std::vector<std::variant<std::string, int, double>> input = {
            "123",
            "456.789",
            "not_a_number"
        };
        auto output = convertStringsToNumbers(input);
        REQUIRE(std::holds_alternative<std::vector<std::variant<std::string, int, double>>>(output));

        auto convertedVec = std::get<std::vector<std::variant<std::string, int, double>>>(output);
        REQUIRE(convertedVec.size() == 3);

        REQUIRE(std::holds_alternative<int>(convertedVec[0]));
        REQUIRE(std::get<int>(convertedVec[0]) == 123);

        REQUIRE(std::holds_alternative<double>(convertedVec[1]));
        REQUIRE(std::get<double>(convertedVec[1]) == 456.789);

        REQUIRE(std::holds_alternative<std::string>(convertedVec[2]));
        REQUIRE(std::get<std::string>(convertedVec[2]) == "not_a_number");
    }
}

int main(int argc, char* argv[]) {
    return Catch::Session().run(argc, argv);
}
```

### Explanation:
1. **Imports**: The necessary headers (`<iostream>`, `<vector>`, `<map>`, `<string>`, `<variant>`, `<sstream>`, `<catch2/catch_test_macros.hpp>`) are included to support the required functionalities and the Catch2 testing framework.
2. **Helper Functions**:
   - `containsDot`: Checks if a string contains a dot.
   - `stringToNumber`: Attempts to convert a string to a number, throwing an exception if the conversion fails.
3. **Function Documentation**:
   - The `convertStringsToNumbers` function is documented with a multi-line comment block (`/** ... */`) that explains its purpose, arguments, and return value.
4. **Function Implementation**:
   - The function handles nested structures (`std::map` and `std::vector`) and individual strings, converting strings to numbers where possible.
5. **Test Cases**:
   - The `TEST_CASE` macro defines the overall test case.
   - The `SECTION` macros define individual sections of the test case.
   - Assertions using `REQUIRE` verify the correctness of the function's behavior.
6. **Main Function**:
   - The `main` function runs the Catch2 test suite.

This translation ensures that the functionality and logic of the tests are preserved, using appropriate assertions in Catch2.