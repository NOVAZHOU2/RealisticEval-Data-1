Certainly! Hereâ€™s the equivalent TypeScript test class using Jest, ensuring that the functionality and logic of the tests are preserved. We will map the Python `unittest` assertions to Jest assertions and include the necessary type annotations.

### TypeScript Code

First, let's define the `convertStringsToNumbers` function in TypeScript:

```typescript
function convertStringsToNumbers(data: any): any {
    if (typeof data === 'object' && data !== null) {
        if (Array.isArray(data)) {
            return data.map(item => convertStringsToNumbers(item));
        } else {
            const result: Record<string, any> = {};
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    result[key] = convertStringsToNumbers(data[key]);
                }
            }
            return result;
        }
    } else if (typeof data === 'string') {
        try {
            // Try converting to float first, then to int if possible
            const num = parseFloat(data);
            if (!isNaN(num)) {
                if (data.includes('.')) {
                    return num;
                } else {
                    return parseInt(data, 10);
                }
            }
        } catch (error) {
            // Ignore the error and return the original string
        }
    }
    return data;  // Return data unchanged if it's not a string
}
```

Now, let's define the Jest test class:

```typescript
import { describe, it, expect } from '@jest/globals';

describe('TestConvertStringsToNumbers', () => {
    it('test_flat_dict', () => {
        const data = { a: '1', b: '2.5', c: 'not a number' };
        const expected = { a: 1, b: 2.5, c: 'not a number' };
        expect(convertStringsToNumbers(data)).toEqual(expected);
    });

    it('test_nested_dict', () => {
        const data = { x: { y: '10', z: '3.14' }, w: '20.0' };
        const expected = { x: { y: 10, z: 3.14 }, w: 20.0 };
        expect(convertStringsToNumbers(data)).toEqual(expected);
    });

    it('test_list_of_strings', () => {
        const data = ['1', '2.5', '3', 'invalid'];
        const expected = [1, 2.5, 3, 'invalid'];
        expect(convertStringsToNumbers(data)).toEqual(expected);
    });

    it('test_mixed_structure', () => {
        const data = { numbers: ['1', '2.0', 3], more_numbers: [{ num: '4' }, '5'] };
        const expected = { numbers: [1, 2.0, 3], more_numbers: [{ num: 4 }, 5] };
        expect(convertStringsToNumbers(data)).toEqual(expected);
    });

    it('test_empty_structure', () => {
        const data = {};
        const expected = {};
        expect(convertStringsToNumbers(data)).toEqual(expected);
    });
});
```

### Explanation:
1. **Import Jest**:
   - We import `describe`, `it`, and `expect` from `@jest/globals` to use Jest's global functions.

2. **Test Cases**:
   - Each test case is defined using `it` and `expect` to perform assertions.
   - The `toEqual` matcher is used to compare the actual and expected values.

3. **Data Structures**:
   - The test data and expected results are defined as JavaScript objects and arrays.

4. **Function Call**:
   - The `convertStringsToNumbers` function is called with the test data, and the result is compared against the expected result using `expect`.

This TypeScript code preserves the functionality and logic of the Python unittest tests while adapting to Jest's syntax and assertion methods.