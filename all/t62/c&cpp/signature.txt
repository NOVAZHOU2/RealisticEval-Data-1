Sure, here is the C++ version of your Python code with the same structure and comments:

```cpp
#include <iostream>
#include <vector>

// Define the TreeNode class
class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;

    // Constructor to initialize the TreeNode object
    TreeNode(int key) : val(key), left(nullptr), right(nullptr) {}
};

// Define the BinaryTree class
class BinaryTree {
private:
    TreeNode* root; // Pointer to the root node of the binary tree

    // Helper function for insertion
    void _insert(TreeNode*& node, int key);

    // Helper function for inorder traversal
    void _inorderTraversal(TreeNode* node, std::vector<int>& result);

    // Helper function for preorder traversal
    void _preorderTraversal(TreeNode* node, std::vector<int>& result);

    // Helper function for postorder traversal
    void _postorderTraversal(TreeNode* node, std::vector<int>& result);

public:
    // Constructor to initialize the BinaryTree object
    BinaryTree() : root(nullptr) {}

    // Function to insert a new node into the binary tree
    void insert(int key);

    // Function to perform inorder traversal and return the result
    std::vector<int> inorderTraversal();

    // Function to perform preorder traversal and return the result
    std::vector<int> preorderTraversal();

    // Function to perform postorder traversal and return the result
    std::vector<int> postorderTraversal();
};

// Implementation of the insert function
void BinaryTree::insert(int key) {
    if (root == nullptr) {
        root = new TreeNode(key);
    } else {
        _insert(root, key);
    }
}

// Implementation of the _insert helper function
void BinaryTree::_insert(TreeNode*& node, int key) {
    if (node == nullptr) {
        node = new TreeNode(key);
    } else if (key < node->val) {
        _insert(node->left, key);
    } else {
        _insert(node->right, key);
    }
}

// Implementation of the inorderTraversal function
std::vector<int> BinaryTree::inorderTraversal() {
    std::vector<int> result;
    _inorderTraversal(root, result);
    return result;
}

// Implementation of the _inorderTraversal helper function
void BinaryTree::_inorderTraversal(TreeNode* node, std::vector<int>& result) {
    if (node != nullptr) {
        _inorderTraversal(node->left, result);
        result.push_back(node->val);
        _inorderTraversal(node->right, result);
    }
}

// Implementation of the preorderTraversal function
std::vector<int> BinaryTree::preorderTraversal() {
    std::vector<int> result;
    _preorderTraversal(root, result);
    return result;
}

// Implementation of the _preorderTraversal helper function
void BinaryTree::_preorderTraversal(TreeNode* node, std::vector<int>& result) {
    if (node != nullptr) {
        result.push_back(node->val);
        _preorderTraversal(node->left, result);
        _preorderTraversal(node->right, result);
    }
}

// Implementation of the postorderTraversal function
std::vector<int> BinaryTree::postorderTraversal() {
    std::vector<int> result;
    _postorderTraversal(root, result);
    return result;
}

// Implementation of the _postorderTraversal helper function
void BinaryTree::_postorderTraversal(TreeNode* node, std::vector<int>& result) {
    if (node != nullptr) {
        _postorderTraversal(node->left, result);
        _postorderTraversal(node->right, result);
        result.push_back(node->val);
    }
}
```

This C++ code defines the `TreeNode` and `BinaryTree` classes with the same structure and functionality as your original Python code. The `insert`, `inorderTraversal`, `preorderTraversal`, and `postorderTraversal` methods have been implemented with appropriate comments and helper functions.