To convert your Python unit test class to a C++ test case using Catch2, you need to create a C++ class that mirrors the functionality of your `BinaryTree` class and then write tests for it. Below is an example of how you might do this:

### C++ Code

```cpp
#include <iostream>
#include <vector>
#include "catch.hpp"

// Define the TreeNode struct
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// Define the BinaryTree class
class BinaryTree {
private:
    TreeNode* root;

    void _insert(TreeNode*& node, int key);
    std::vector<int> _inorderTraversal(TreeNode* node) const;
    std::vector<int> _preorderTraversal(TreeNode* node) const;
    std::vector<int> _postorderTraversal(TreeNode* node) const;

public:
    BinaryTree() : root(nullptr) {}

    void insert(int key);
    std::vector<int> inorderTraversal() const;
    std::vector<int> preorderTraversal() const;
    std::vector<int> postorderTraversal() const;
};

void BinaryTree::_insert(TreeNode*& node, int key) {
    if (node == nullptr) {
        node = new TreeNode(key);
    } else if (key < node->val) {
        _insert(node->left, key);
    } else {
        _insert(node->right, key);
    }
}

std::vector<int> BinaryTree::_inorderTraversal(TreeNode* node) const {
    std::vector<int> result;
    if (node != nullptr) {
        result = _inorderTraversal(node->left);
        result.push_back(node->val);
        result.insert(result.end(), _inorderTraversal(node->right).begin(), _inorderTraversal(node->right).end());
    }
    return result;
}

std::vector<int> BinaryTree::_preorderTraversal(TreeNode* node) const {
    std::vector<int> result;
    if (node != nullptr) {
        result.push_back(node->val);
        result.insert(result.end(), _preorderTraversal(node->left).begin(), _preorderTraversal(node->left).end());
        result.insert(result.end(), _preorderTraversal(node->right).begin(), _preorderTraversal(node->right).end());
    }
    return result;
}

std::vector<int> BinaryTree::_postorderTraversal(TreeNode* node) const {
    std::vector<int> result;
    if (node != nullptr) {
        result.insert(result.end(), _postorderTraversal(node->left).begin(), _postorderTraversal(node->left).end());
        result.insert(result.end(), _postorderTraversal(node->right).begin(), _postorderTraversal(node->right).end());
        result.push_back(node->val);
    }
    return result;
}

void BinaryTree::insert(int key) {
    _insert(root, key);
}

std::vector<int> BinaryTree::inorderTraversal() const {
    return _inorderTraversal(root);
}

std::vector<int> BinaryTree::preorderTraversal() const {
    return _preorderTraversal(root);
}

std::vector<int> BinaryTree::postorderTraversal() const {
    return _postorderTraversal(root);
}

// Test cases using Catch2
TEST_CASE("Binary Tree Tests", "[binarytree]") {
    BinaryTree bt;
    bt.insert(50);
    bt.insert(30);
    bt.insert(70);
    bt.insert(20);
    bt.insert(40);
    bt.insert(60);
    bt.insert(80);

    SECTION("Inorder Traversal") {
        std::vector<int> expected = {20, 30, 40, 50, 60, 70, 80};
        REQUIRE(bt.inorderTraversal() == expected);
    }

    SECTION("Preorder Traversal") {
        std::vector<int> expected = {50, 30, 20, 40, 70, 60, 80};
        REQUIRE(bt.preorderTraversal() == expected);
    }

    SECTION("Postorder Traversal") {
        std::vector<int> expected = {20, 40, 30, 60, 80, 70, 50};
        REQUIRE(bt.postorderTraversal() == expected);
    }
}
```

### Explanation

1. **TreeNode Struct**: This is a simple representation of a tree node.
2. **BinaryTree Class**: This class contains methods to insert nodes and perform various traversals.
   - `_insert`: A private helper method to insert a node into the tree.
   - `_inorderTraversal`, `_preorderTraversal`, `_postorderTraversal`: Private helper methods to perform the respective traversals.
   - `insert`, `inorderTraversal`, `preorderTraversal`, `postorderTraversal`: Public methods to insert nodes and get the traversal results.
3. **Catch2 Test Cases**: The test cases check the correctness of the insertion and traversal methods.

Make sure you have Catch2 installed and properly configured in your development environment. If you're using a build system like CMake, you can add Catch2 as a subdirectory or include it via a package manager.