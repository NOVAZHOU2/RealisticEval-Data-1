Certainly! Let's convert the given Python function into its equivalent C++ version, including comments and documentation standards.

### Python Code:
```python
import numpy as np

def matrix_vector_multiplication(matrix: np.array, vector: np.array):
    """
    Multiplies a given matrix by a vector using NumPy's dot product.

    Parameters:
    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows
                            and n is the number of columns.
    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector
                            compatible for multiplication with the given matrix.

    Returns:
    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of
                   the matrix and the vector.
    """

    # Perform matrix-vector multiplication using the dot product function.
    result = np.dot(matrix, vector)

    # Return the resulting vector from the multiplication.
    return result
```

### Equivalent C++ Code:
```cpp
#include <iostream>
#include <vector>

/**
 * Multiplies a given matrix by a vector.
 *
 * @param matrix A 2D array (matrix) of shape (m, n) where m is the number of rows
 *               and n is the number of columns.
 * @param vector A 1D array (vector) of shape (n,) that represents a vector
 *               compatible for multiplication with the given matrix.
 * @return A 1D array (resulting vector) of shape (m,) representing the product of
 *         the matrix and the vector.
 */
std::vector<double> matrixVectorMultiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {
    // Check if the dimensions are compatible
    if (matrix.empty() || vector.empty() || matrix[0].size() != vector.size()) {
        throw std::invalid_argument("Matrix and vector dimensions are incompatible.");
    }

    // Initialize the result vector with the number of rows in the matrix
    std::vector<double> result(matrix.size());

    // Perform matrix-vector multiplication using nested loops
    for (size_t i = 0; i < matrix.size(); ++i) {
        double sum = 0.0;
        for (size_t j = 0; j < matrix[0].size(); ++j) {
            sum += matrix[i][j] * vector[j];
        }
        result[i] = sum;
    }

    // Return the resulting vector from the multiplication
    return result;
}

int main() {
    // Example usage
    std::vector<std::vector<double>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    std::vector<double> vector = {1, 2, 3};

    try {
        std::vector<double> result = matrixVectorMultiplication(matrix, vector);
        std::cout << "Result vector: ";
        for (double val : result) {
            std::cout << val << " ";
        }
        std::cout << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Function Definition**: The function `matrixVectorMultiplication` takes a 2D vector (`matrix`) and a 1D vector (`vector`) as inputs.
2. **Documentation**: The function is documented using C++ style comments, including a multi-line comment block for the function description and parameters.
3. **Dimension Checking**: It checks if the dimensions of the matrix and vector are compatible.
4. **Result Initialization**: It initializes a result vector with the same number of rows as the matrix.
5. **Matrix-Vector Multiplication**: It performs the matrix-vector multiplication using nested loops.
6. **Example Usage**: The `main` function demonstrates how to use the `matrixVectorMultiplication` function and prints the result.

This approach ensures that the functionality, logic, and structure of the original Python code are preserved while adapting to C++ syntax and features.