Certainly! The provided Python code uses NumPy for matrix-vector multiplication. In C++, we don't have a direct equivalent to NumPy, but we can use standard C++ libraries or third-party libraries like Eigen, Armadillo, or even use basic C++ constructs to perform matrix operations.

For this example, I'll provide a solution using basic C++ constructs and the standard library to perform matrix-vector multiplication. We will assume that the input matrix and vector are stored in two-dimensional and one-dimensional arrays, respectively.

Here's the equivalent C++ code:

```cpp
#include <iostream>
#include <vector>

// Function to perform matrix-vector multiplication
std::vector<double> matrixVectorMultiplication(const std::vector<std::vector<double>>& matrix, const std::vector<double>& vector) {
    int rows = matrix.size();
    int cols = matrix[0].size();
    if (cols != vector.size()) {
        throw std::invalid_argument("Matrix columns must match vector size.");
    }

    std::vector<double> result(rows, 0.0);

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            result[i] += matrix[i][j] * vector[j];
        }
    }

    return result;
}

int main() {
    // Example usage
    std::vector<std::vector<double>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    std::vector<double> vector = {1, 2, 3};

    try {
        std::vector<double> result = matrixVectorMultiplication(matrix, vector);
        std::cout << "Result vector: ";
        for (double value : result) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Header Files**: `#include <iostream>` and `#include <vector>` are included for input/output and vector handling.
2. **Function Definition**: `matrixVectorMultiplication` performs the matrix-vector multiplication.
   - It first checks if the number of columns in the matrix matches the size of the vector.
   - It initializes a result vector with the same number of rows as the matrix.
   - It iterates over each row and column to compute the dot product.
3. **Main Function**:
   - An example matrix and vector are defined.
   - The function is called, and the result is printed.
   - Error handling is included to catch any exceptions thrown during computation.

This approach provides a basic implementation of matrix-vector multiplication without relying on external libraries. If you need more advanced features or performance optimizations, consider using a specialized library like Eigen or Armadillo.