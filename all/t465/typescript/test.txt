Certainly! Here’s the equivalent TypeScript test class using Jest, ensuring that the functionality and logic of the tests are preserved. We will use Jest’s assertion methods to replicate the behavior of `np.testing.assert_array_equal`.

First, ensure you have Jest installed:
```sh
npm install --save-dev jest @types/jest
```

Next, add the Jest configuration to your `package.json`:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

Now, let’s write the TypeScript test class:

```typescript
import { matrixVectorMultiplication } from './path/to/matrixVectorMultiplication'; // Import the function to test
import * as math from 'mathjs';

describe('TestMatrixVectorMultiplication', () => {
  it('test_case_1', () => {
    // Test with a simple 2x2 matrix and a 2-element vector
    const matrix: number[][] = [[1, 2], [3, 4]];
    const vector: number[] = [5, 6];
    const expectedResult: number[] = [17, 39];  // [1*5 + 2*6, 3*5 + 4*6]
    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);
  });

  it('test_case_2', () => {
    // Test with a 3x3 matrix and a 3-element vector
    const matrix: number[][] = [[1, 0, 2], [0, 1, 2], [1, 1, 0]];
    const vector: number[] = [3, 4, 5];
    const expectedResult: number[] = [13, 14, 7];  // [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]
    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);
  });

  it('test_case_3', () => {
    // Test with a zero matrix and a vector
    const matrix: number[][] = [[0, 0], [0, 0]];
    const vector: number[] = [1, 1];
    const expectedResult: number[] = [0, 0];  // Zero matrix multiplied by any vector yields zero
    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);
  });

  it('test_case_4', () => {
    // Test with a matrix having negative values
    const matrix: number[][] = [[-1, -2], [-3, -4]];
    const vector: number[] = [1, 1];
    const expectedResult: number[] = [-3, -7];  // [-1*1 + -2*1, -3*1 + -4*1]
    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);
  });

  it('test_case_5', () => {
    // Test with non-square matrix (2x3) and a compatible vector (3-element)
    const matrix: number[][] = [[1, 2, 3], [4, 5, 6]];
    const vector: number[] = [1, 0, 1];
    const expectedResult: number[] = [4, 10];  // [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]
    expect(matrixVectorMultiplication(matrix, vector)).toEqual(expectedResult);
  });
});

// The matrixVectorMultiplication function implementation
import * as math from 'mathjs';

/**
 * Multiplies a given matrix by a vector using the dot product.
 *
 * @param matrix - A 2D array (matrix) of shape (m, n) where m is the number of rows
 *                 and n is the number of columns.
 * @param vector - A 1D array (vector) of shape (n,) that represents a vector
 *                 compatible for multiplication with the given matrix.
 * @returns A 1D array (resulting vector) of shape (m,) representing the product of
 *          the matrix and the vector.
 */
function matrixVectorMultiplication(matrix: number[][], vector: number[]): number[] {
  // Perform matrix-vector multiplication using the dot product function.
  const result = math.multiply(matrix, vector);

  // Return the resulting vector from the multiplication.
  return result;
}

export { matrixVectorMultiplication };
```

### Explanation:
1. **Imports**: We import `matrixVectorMultiplication` from the file where it is defined and `math` from `mathjs`.
2. **Jest Configuration**: We use `describe` and `it` blocks to structure the tests.
3. **Test Cases**: Each test case is structured similarly to the Python unittest cases, using Jest’s `expect` and `toEqual` assertions to verify the results.
4. **Function Implementation**: The `matrixVectorMultiplication` function is implemented using `math.multiply` from `mathjs`.

This setup ensures that the tests are equivalent to the Python unittests and that the functionality is preserved.