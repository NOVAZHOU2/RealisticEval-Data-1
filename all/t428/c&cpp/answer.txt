Sure! Below is the equivalent C++ code that replicates the functionality of the provided Python code. This includes parsing a Python type hint string and returning the individual types as a list of strings.

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <sstream>

// A simple parser for Python type hints using C++
class TypeHintParser {
public:
    std::vector<std::string> parseTypeHint(const std::string& type_hint_string) {
        // Create a source function definition with the type hint string
        std::string source = "def f() -> " + type_hint_string + ": pass";
        
        // List to store the parsed type strings
        std::vector<std::string> type_strings;
        
        // Parse the source code into tokens
        std::istringstream iss(source);
        std::string token;
        while (iss >> token) {
            if (token == "def" || token == "f" || token == ":" || token == "pass") continue;
            if (token == "->") break;

            // Process the type hint string
            processTypeString(token, type_strings);
        }

        return type_strings;
    }

private:
    void processTypeString(const std::string& type_string, std::vector<std::string>& type_strings) {
        std::istringstream iss(type_string);
        std::string segment;
        std::string current_qual_name;

        while (iss >> segment) {
            if (segment == "[") {
                // Start of a new qualified name
                current_qual_name.clear();
            } else if (segment == "]") {
                // End of a qualified name
                if (!current_qual_name.empty()) {
                    type_strings.push_back(current_qual_name);
                    current_qual_name.clear();
                }
            } else if (segment == ",") {
                // Comma separator
                if (!current_qual_name.empty()) {
                    type_strings.push_back(current_qual_name);
                    current_qual_name.clear();
                }
            } else {
                // Regular type segment
                if (!current_qual_name.empty()) {
                    current_qual_name += ".";
                }
                current_qual_name += segment;
            }
        }

        // Push the last qualified name if any
        if (!current_qual_name.empty()) {
            type_strings.push_back(current_qual_name);
        }
    }
};

int main() {
    TypeHintParser parser;
    std::string type_hint = "Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]";
    std::vector<std::string> parsed_types = parser.parseTypeHint(type_hint);

    for (const auto& type : parsed_types) {
        std::cout << type << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Class `TypeHintParser`**: This class contains the logic for parsing type hints.
2. **`parseTypeHint` Method**: This method takes a type hint string, creates a source function definition, and parses it into tokens.
3. **`processTypeString` Method**: This method processes each type string segment and appends it to the `type_strings` vector.
4. **Main Function**: This function demonstrates how to use the `TypeHintParser` class by parsing a sample type hint string and printing the parsed types.

This C++ code should replicate the functionality of the provided Python code, including handling nested types and extracting individual type names.