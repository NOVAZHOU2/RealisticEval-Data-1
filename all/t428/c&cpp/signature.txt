To convert the provided Python function into its C++ equivalent, we need to consider several aspects such as the absence of direct equivalents for Python's `typing` module and `ast` module in C++. We will use standard C++ libraries and techniques to achieve similar functionality. 

Hereâ€™s how you can translate the Python function into C++:

1. **Function Declaration**: Define the function with the equivalent C++ types.
2. **Comments and Documentation**: Translate the Python docstring into C++ style comments.
3. **Function Implementation**: Implement the logic using C++ features.

Below is the C++ version of the given Python function:

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <sstream>

// Parses a Python type hint string and returns the individual types as a vector of strings.
// Args:
//     type_hint_string (std::string): The type hint string to parse.
// Returns:
//     std::vector<std::string>: The individual types parsed from the type hint string.
//
// Example:
//     std::string type_hint = "Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]";
//     auto parsed_types = parse_type_hint(type_hint);
//     // Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',
//                'str', 'Optional', 'int']
std::vector<std::string> parse_type_hint(const std::string& type_hint_string) {
    std::vector<std::string> result;
    std::istringstream iss(type_hint_string);
    std::string token;

    while (std::getline(iss, token, '[')) {
        size_t start = 0;
        size_t end = token.find(']');
        if (end != std::string::npos) {
            std::string type = token.substr(start, end - start);
            result.push_back(type);
            start = end + 1;
        }

        while ((end = token.find(',', start)) != std::string::npos) {
            std::string type = token.substr(start, end - start);
            result.push_back(type);
            start = end + 1;
        }

        if (start < token.length()) {
            std::string type = token.substr(start);
            result.push_back(type);
        }
    }

    return result;
}

int main() {
    std::string type_hint = "Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]";
    auto parsed_types = parse_type_hint(type_hint);

    for (const auto& type : parsed_types) {
        std::cout << type << std::endl;
    }

    return 0;
}
```

### Explanation:
- **Headers**: Included necessary headers (`<iostream>`, `<vector>`, `<string>`, `<sstream>`).
- **Function Declaration**: Defined `parse_type_hint` with a `std::string` argument and returns a `std::vector<std::string>`.
- **Documentation**: Translated the Python docstring into C++ comments.
- **Implementation**: Used `std::istringstream` to parse the input string and split it into tokens based on delimiters `[`, `]`, and `,`.

This approach provides a basic implementation that parses the type hint string and splits it into individual types. It may require further refinement depending on specific requirements or additional parsing logic.