Certainly! Below is the equivalent TypeScript code that matches the functionality and logic of the provided Python code:

```typescript
import * as ast from 'python-abstract-syntax-tree'; // Assuming a fictional package for Python AST parsing

function parseTypeHint(typeHintString: string): string[] {
    /**
     * Parses a Python type hint string and returns the individual types as a list of strings.
     *
     * @param typeHintString - The type hint string to parse.
     * @returns The individual types parsed from the type hint string.
     *
     * Example:
     * const typeHint = "Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]";
     * const parsedTypes = parseTypeHint(typeHint);
     * console.log(parsedTypes);
     * // Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int', 'str', 'Optional', 'int']
     */
    const source = `def f() -> ${typeHintString}: pass`;
    const tree = ast.parse(source);

    const typeStrings: string[] = [];

    function processNode(node: ast.AST, qualNames?: string[]): void {
        qualNames = qualNames || [];

        if (node.type === 'Name') {
            // Add simple type names (e.g., str, int)
            typeStrings.push(qualNames.concat([node.id]).reverse().join('.'));
        } else if (node.type === 'Subscript') {
            // Process the value and slice of a subscript (e.g., List[str])
            processNode(node.value, qualNames);
            processNode(node.slice, qualNames);
        } else if (node.type === 'Attribute') {
            // Process attributes (e.g., typing.List)
            processNode(node.value, qualNames.concat([node.attr]));
        } else if (node.type === 'Tuple') {
            // Process each element in a tuple type hint
            for (const elt of node.elts) {
                processNode(elt, qualNames);
            }
        }
    }

    // Extract the return annotation from the parsed tree
    const returnsAnnotation = tree.body[0].returns;
    // Process the return annotation to fill typeStrings
    processNode(returnsAnnotation);

    return typeStrings;
}

// Example usage
const typeHint = "Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]";
const parsedTypes = parseTypeHint(typeHint);
console.log(parsedTypes);
```

### Notes:
1. **Python AST Parsing**: Since TypeScript does not have native support for Python's AST, we assume the existence of a fictional package named `python-abstract-syntax-tree` for parsing Python ASTs. In practice, you would need a suitable library or implement the parsing logic yourself.
2. **Type Annotations**: TypeScript uses different syntax and conventions for type annotations compared to Python. This example assumes a basic conversion to illustrate the logic.
3. **Function Definitions**: The function definitions and logic have been adjusted to fit TypeScript's syntax and conventions.

This TypeScript code maintains the core functionality of parsing Python type hints and extracting individual type strings.