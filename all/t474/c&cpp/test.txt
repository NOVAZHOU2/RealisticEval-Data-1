Certainly! Below is the equivalent test class using Catch2 in C++. I'll ensure that the functionality and logic of the tests are preserved, and I'll use appropriate assertions in Catch2.

First, make sure you have Catch2 installed and included in your project. You can download Catch2 from [here](https://github.com/catchorg/Catch2).

Hereâ€™s the C++ code with the test class using Catch2:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <catch2/catch_test_macros.hpp>

// Determines if two values are siblings in a binary tree represented as an array.
//
// Args:
//     tree (std::vector<int>): the binary tree level-order representation
//     val1 (int): first value to check for sibling relationship
//     val2 (int): second value to check for sibling relationship
//
// Returns:
//     bool: true if val1 and val2 are siblings, false otherwise

bool are_siblings(const std::vector<int>& tree, int val1, int val2) {
    // A node cannot be a sibling to itself
    if (val1 == val2) {
        return false;
    }

    // Find indices of the values
    auto it1 = std::find(tree.begin(), tree.end(), val1);
    auto it2 = std::find(tree.begin(), tree.end(), val2);

    // Check if one of the values is not in the tree
    if (it1 == tree.end() || it2 == tree.end()) {
        return false;
    }

    // Calculate indices from iterators
    size_t index1 = std::distance(tree.begin(), it1);
    size_t index2 = std::distance(tree.begin(), it2);

    // Check if they have the same parent
    return (index1 - 1) / 2 == (index2 - 1) / 2 && index1 != index2;
}

TEST_CASE("TestAreSiblings", "[are_siblings]") {
    const std::vector<int> tree = {1, 2, 3, 4, 5, 6, 7};

    SECTION("test_basic_case") {
        // Test with nodes 4 and 5, which are siblings
        bool result = are_siblings(tree, 4, 5);
        REQUIRE(result);
    }

    SECTION("test_non_sibling_case") {
        // Test with nodes 4 and 6, which are not siblings
        bool result = are_siblings(tree, 4, 6);
        REQUIRE_FALSE(result);
    }

    SECTION("test_root_node_case") {
        // Test with node 1 (root) and any other node, should return False
        bool result = are_siblings(tree, 1, 2);
        REQUIRE_FALSE(result);
    }

    SECTION("test_non_existent_values") {
        // Test with non-existent values
        bool result = are_siblings(tree, 8, 9);
        REQUIRE_FALSE(result);
    }

    SECTION("test_same_node_case") {
        // Test with the same node for both values
        bool result = are_siblings(tree, 4, 4);
        REQUIRE_FALSE(result);
    }
}

int main(int argc, char* argv[]) {
    // Run Catch2 tests
    int result = Catch::Session().run(argc, argv);
    return result;
}
```

### Explanation:
1. **Include Directives**: Include necessary headers (`<iostream>`, `<vector>`, `<algorithm>`, `<catch2/catch_test_macros.hpp>`).
2. **Function Documentation**: Use C++ style comments to document the function, including arguments and return values.
3. **Function Signature**: Define the `are_siblings` function with the appropriate C++ types (`std::vector<int>` for the tree and `int` for the values).
4. **Test Class**: Use Catch2's `TEST_CASE` macro to define the test suite.
5. **Sections**: Use `SECTION` macros within the test case to define individual test sections.
6. **Assertions**:
   - `REQUIRE(result)` asserts that the result is true.
   - `REQUIRE_FALSE(result)` asserts that the result is false.
7. **Main Function**: Run the Catch2 tests using `Catch::Session().run(argc, argv)`.

This conversion ensures that the functionality and logic of the tests are preserved while adapting to the syntax and conventions of C++ and Catch2.