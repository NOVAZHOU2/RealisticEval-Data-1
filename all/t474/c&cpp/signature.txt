Sure! Here is the equivalent C++ code for the provided Python function, including the function signature, comments, and documentation:

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// Determines if two values are siblings in a binary tree represented as an array.
//
// Args:
//     tree (std::vector<int>): the binary tree level-order representation
//     val1 (int): first value to check for sibling relationship
//     val2 (int): second value to check for sibling relationship
//
// Returns:
//     bool: true if val1 and val2 are siblings, false otherwise

bool are_siblings(const std::vector<int>& tree, int val1, int val2) {
    // A node cannot be a sibling to itself
    if (val1 == val2) {
        return false;
    }

    // Find indices of the values
    auto it1 = std::find(tree.begin(), tree.end(), val1);
    auto it2 = std::find(tree.begin(), tree.end(), val2);

    // Check if one of the values is not in the tree
    if (it1 == tree.end() || it2 == tree.end()) {
        return false;
    }

    // Calculate indices from iterators
    size_t index1 = std::distance(tree.begin(), it1);
    size_t index2 = std::distance(tree.begin(), it2);

    // Check if they have the same parent
    return (index1 - 1) / 2 == (index2 - 1) / 2 && index1 != index2;
}

int main() {
    // Example usage
    std::vector<int> tree = {1, 2, 3, 4, 5, 6, 7};
    int val1 = 4;
    int val2 = 5;

    bool result = are_siblings(tree, val1, val2);
    std::cout << "Are " << val1 << " and " << val2 << " siblings? " << (result ? "Yes" : "No") << std::endl;

    return 0;
}
```

### Explanation:
1. **Include Directives**: Include necessary headers (`<iostream>`, `<vector>`, `<algorithm>`).
2. **Function Documentation**: Use C++ style comments to document the function, including arguments and return values.
3. **Function Signature**: Define the `are_siblings` function with the appropriate C++ types (`std::vector<int>` for the tree and `int` for the values).
4. **Self-Sibling Check**: If `val1` and `val2` are the same, return `false`.
5. **Finding Indices**: Use `std::find` to locate the positions of `val1` and `val2` in the vector. If either value is not found, return `false`.
6. **Index Calculation**: Calculate the indices of `val1` and `val2` using `std::distance`.
7. **Parent Check**: Verify if the indices indicate that `val1` and `val2` have the same parent by comparing `(index1 - 1) / 2` and `(index2 - 1) / 2`. Also, ensure that `index1` and `index2` are different.
8. **Example Usage**: The `main` function demonstrates how to use the `are_siblings` function with an example tree and values.

This conversion preserves the original purpose and structure of the Python code while adapting it to C++ syntax and conventions.