Here is the equivalent C++ code for your Python function:

```c++
#include <vector>
using namespace std;

bool areSiblings(vector<int>& tree, int val1, int val2) {
    // Check if both nodes are present in the tree.
    auto it1 = find(tree.begin(), tree.end(), val1);
    auto it2 = find(tree.begin(), tree.end(), val2);

    // If either of the node is not found return false.
    if(it1 == tree.end() || it2 == tree.end()) return false;
    
    // Get parent index.
    int parentIndex = (it1 - tree.begin() - 1) / 2;
    
    // Check if they have same parent.
    return parentIndex == (it2 - tree.begin() - 1) / 2;
}
```

And here's the equivalent C code:

```c
#include <stdbool.h>

bool areSiblings(int* tree, int size, int val1, int val2){
    int i;
    bool foundVal1 = false, foundVal2 = false;
    int parentIndex1 = -1, parentIndex2 = -1;

    for(i = 0; i < size; i++){
        if(tree[i] == val1){
            foundVal1 = true;
            parentIndex1 = (i-1)/2;
        }
        else if(tree[i] == val2){
            foundVal2 = true;
            parentIndex2 = (i-1)/2;
        }

        if(foundVal1 && foundVal2)
            break;
    }

    if(!foundVal1 || !foundVal2)
        return false;

    return parentIndex1 == parentIndex2;
}
```
Please note that these implementations assume that the tree is a complete binary tree. In other words, all levels except possibly the last one are completely filled and all nodes in the last level are as far left as possible. Also, the root node is at position 0.