Hereâ€™s the equivalent C++ code for the provided Python function `are_siblings`. The code will maintain the same functionality, including handling exceptions for values not found in the tree:

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

// Function to determine if two values are siblings in a binary tree represented as a vector.
bool are_siblings(const std::vector<int>& tree, int val1, int val2) {
    // A node cannot be a sibling to itself
    if (val1 == val2) {
        return false;
    }

    auto it1 = std::find(tree.begin(), tree.end(), val1);
    auto it2 = std::find(tree.begin(), tree.end(), val2);

    // If either value is not found in the tree
    if (it1 == tree.end() || it2 == tree.end()) {
        return false;
    }

    // Calculate the indices of the values
    size_t index1 = std::distance(tree.begin(), it1);
    size_t index2 = std::distance(tree.begin(), it2);

    // Check if they have the same parent
    return (index1 - 1) / 2 == (index2 - 1) / 2 && index1 != index2;
}

int main() {
    // Example usage
    std::vector<int> tree = {1, 2, 3, 4, 5, 6, 7};
    int val1 = 4;
    int val2 = 5;

    bool result = are_siblings(tree, val1, val2);
    std::cout << "Are " << val1 << " and " << val2 << " siblings? " << (result ? "Yes" : "No") << std::endl;

    return 0;
}
```

### Explanation:
1. **Function Declaration**: The function `are_siblings` takes a `std::vector<int>` representing the binary tree and two integers `val1` and `val2`.
2. **Self-Sibling Check**: If `val1` and `val2` are the same, the function returns `false` because a node cannot be its own sibling.
3. **Finding Indices**: Uses `std::find` to locate the positions of `val1` and `val2` in the `tree` vector. If either value is not found, the function returns `false`.
4. **Index Calculation**: Calculates the indices of `val1` and `val2` using `std::distance`.
5. **Parent Check**: Checks if the two values have the same parent by comparing their indices adjusted by subtracting one and performing integer division by two.
6. **Example Usage**: Demonstrates how to use the function with a sample binary tree and two values.

This C++ code preserves the original functionality and logic of the Python code.