Here is a simple implementation of the Bloom Filter data structure in C and C++. This version uses bitwise operations to store the bits, so it requires a fixed-size array.

C Code:

```c
#include <stdio.h>
#include <stdlib.h>

#define SIZE 1024
#define HASH_COUNT 3

typedef struct {
    unsigned char *bitArray;
} BloomFilter;

BloomFilter* createBloomFilter() {
    BloomFilter *filter = (BloomFilter*)malloc(sizeof(BloomFilter));
    filter->bitArray = (unsigned char*)calloc(SIZE/8, sizeof(unsigned char)); // Assuming 8 bits per byte
    return filter;
}

void addElement(BloomFilter *filter, int item) {
    int index1 = item % SIZE;
    int index2 = (item / SIZE) % SIZE;
    int index3 = (item ^ 0x55555555) % SIZE; // XOR operation to get another unique index
    
    filter->bitArray[index1] |= 1 << (item & 7);
    filter->bitArray[index2] |= 1 << (item & 7);
    filter->bitArray[index3] |= 1 << (item & 7);
}

int containsElement(BloomFilter *filter, int item) {
    int index1 = item % SIZE;
    int index2 = (item / SIZE) % SIZE;
    int index3 = (item ^ 0x55555555) % SIZE; // XOR operation to get another unique index
    
    if (!(filter->bitArray[index1] & (1 << (item & 7)))) 
        return 0;
    if (!(filter->bitArray[index2] & (1 << (item & 7)))) 
        return 0;
    if (!(filter->bitArray[index3] & (1 << (item & 7)))) 
        return 0;
    
    return 1;
}

int main() {
    BloomFilter *filter = createBloomFilter();
    addElement(filter, 10);
    printf("%d\n", containsElement(filter, 10)); // Should print 1
    printf("%d\n", containsElement(filter, 20)); // Should print 0
    free(filter->bitArray);
    free(filter);
    return 0;
}
```

C++ Code:

```cpp
#include <iostream>
#include <vector>
#include <bitset>

const int SIZE = 1024;
const int HASH_COUNT = 3;

class BloomFilter {
private:
    std::vector<bool> bitArray;

public:
    BloomFilter() : bitArray(SIZE) {}

    void add(int item) {
        int index1 = item % SIZE;
        int index2 = (item / SIZE) % SIZE;
        int index3 = (item ^ 0x55555555) % SIZE; // XOR operation to get another unique index
        
        bitArray[index1] = true;
        bitArray[index2] = true;
        bitArray[index3] = true;
    }

    bool contains(int item) {
        int index1 = item % SIZE;
        int index2 = (item / SIZE) % SIZE;
        int index3 = (item ^ 0x55555555) % SIZE; // XOR operation to get another unique index
        
        if (!bitArray[index1]) 
            return false;
        if (!bitArray[index2]) 
            return false;
        if (!bitArray[index3]) 
            return false;
        
        return true;
    }
};

int main() {
    BloomFilter filter;
    filter.add(10);
    std::cout << filter.contains(10) << '\n'; // Should print 1
    std::cout << filter.contains(20) << '\n'; // Should print 0
    return 0;
}
```
Please note that these codes are very basic implementations and may not be efficient or accurate enough for real-world applications due to their simplicity. In real-world applications, you should consider using more sophisticated hashing functions and larger bit arrays to minimize false positives and negatives.