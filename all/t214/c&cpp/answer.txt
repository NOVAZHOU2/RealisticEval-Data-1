To convert the Python code snippet into C/C++ code, we need to consider that C/C++ does not have built-in support for regular expressions like Python does with `re` module. Therefore, we will use a third-party library such as PCRE (Perl Compatible Regular Expressions).

Here's how you can implement the same functionality in C:

### Dependencies
First, ensure you have the PCRE library installed on your system. On Ubuntu, you can install it using:
```sh
sudo apt-get install libpcre3-dev
```

### C Code

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pcre.h>

typedef struct {
    pcre *regex;
    char *replacement;
} RegexMapping;

RegexMapping* read_mapping_file(const char* mapping_file_path, int *mapping_count) {
    FILE *file = fopen(mapping_file_path, "r");
    if (!file) {
        perror("Failed to open file");
        return NULL;
    }

    // Estimate initial number of mappings (can be adjusted)
    *mapping_count = 100;
    RegexMapping *mappings = malloc(*mapping_count * sizeof(RegexMapping));
    if (!mappings) {
        perror("Failed to allocate memory");
        fclose(file);
        return NULL;
    }

    char line[256];
    int count = 0;
    while (fgets(line, sizeof(line), file)) {
        if (count >= *mapping_count) {
            *mapping_count *= 2;
            mappings = realloc(mappings, *mapping_count * sizeof(RegexMapping));
            if (!mappings) {
                perror("Failed to reallocate memory");
                fclose(file);
                return NULL;
            }
        }

        char *pattern_end = strchr(line, ' ');
        if (!pattern_end) {
            fprintf(stderr, "Invalid format in line: %s", line);
            continue;
        }

        *pattern_end = '\0';
        pattern_end++;

        const char *error;
        int erroffset;
        mappings[count].regex = pcre_compile(pattern_end, 0, &error, &erroffset, NULL);
        if (!mappings[count].regex) {
            fprintf(stderr, "PCRE compilation failed at offset %d: %s\n", erroffset, error);
            free(mappings);
            fclose(file);
            return NULL;
        }

        size_t len = strlen(line) - (pattern_end - line);
        mappings[count].replacement = malloc(len + 1);
        if (!mappings[count].replacement) {
            perror("Failed to allocate memory for replacement");
            pcre_free(mappings[count].regex);
            free(mappings);
            fclose(file);
            return NULL;
        }
        strncpy(mappings[count].replacement, line, len);
        mappings[count].replacement[len] = '\0';

        count++;
    }

    fclose(file);
    *mapping_count = count;
    return mappings;
}

void free_mappings(RegexMapping *mappings, int count) {
    for (int i = 0; i < count; i++) {
        pcre_free(mappings[i].regex);
        free(mappings[i].replacement);
    }
    free(mappings);
}

int main() {
    const char *mapping_file_path = "path/to/mapping/file.txt";
    int mapping_count;
    RegexMapping *mappings = read_mapping_file(mapping_file_path, &mapping_count);

    if (mappings) {
        printf("Read %d mappings.\n", mapping_count);
        free_mappings(mappings, mapping_count);
    } else {
        printf("Failed to read mappings.\n");
    }

    return 0;
}
```

### Explanation
1. **Reading File**: The function `read_mapping_file` reads the file line by line.
2. **Pattern and Replacement Extraction**: For each line, it extracts the regex pattern and replacement string.
3. **Compiling Regex**: It uses `pcre_compile` to compile the regex pattern.
4. **Memory Management**: It dynamically allocates memory for storing the regex patterns and replacements.
5. **Error Handling**: It handles errors during file reading and regex compilation.
6. **Freeing Memory**: The `free_mappings` function frees the allocated memory for regex objects and replacement strings.

This C code provides a similar functionality to the provided Python code but uses PCRE for handling regular expressions. Make sure to adjust the path to the mapping file accordingly.