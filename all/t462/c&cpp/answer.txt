Certainly! Below is the equivalent C++ code for the given Python function. The C++ version will maintain the same functionality and logic:

```cpp
#include <iostream>
#include <vector>

std::vector<int> spiralOrder(const std::vector<std::vector<int>>& matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return {};
    }

    int rows = matrix.size();
    int cols = matrix[0].size();
    int top = 0, bottom = rows - 1;
    int left = 0, right = cols - 1;
    std::vector<int> result;

    while (top <= bottom && left <= right) {
        // Traverse Right
        for (int col = left; col <= right; ++col) {
            result.push_back(matrix[top][col]);
        }
        top++;

        // Traverse Down
        for (int row = top; row <= bottom; ++row) {
            result.push_back(matrix[row][right]);
        }
        right--;

        // Traverse Left
        if (top <= bottom) {
            for (int col = right; col >= left; --col) {
                result.push_back(matrix[bottom][col]);
            }
            bottom--;
        }

        // Traverse Up
        if (left <= right) {
            for (int row = bottom; row >= top; --row) {
                result.push_back(matrix[row][left]);
            }
            left++;
        }
    }

    return result;
}

int main() {
    std::vector<std::vector<int>> matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    std::vector<int> result = spiralOrder(matrix);

    for (int num : result) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Explanation:
1. **Function Definition**: `spiralOrder` is defined to take a 2D vector of integers (`std::vector<std::vector<int>>`) and return a 1D vector of integers (`std::vector<int>`).
2. **Initialization**: The dimensions of the matrix (`rows` and `cols`) and boundary pointers (`top`, `bottom`, `left`, `right`) are initialized.
3. **Traversal**: The function iterates over the matrix in a spiral order, appending the values to the `result` vector.
4. **Main Function**: Demonstrates calling `spiralOrder` with a sample matrix and prints the result.

This C++ code maintains the same logic and structure as the original Python code, ensuring that the matrix elements are returned in spiral order.