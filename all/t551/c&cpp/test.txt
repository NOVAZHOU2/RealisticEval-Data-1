Sure, here is an equivalent C++ test case using Catch2 for the provided Python `unittest` test class. The function `get_mids_from_edges` is assumed to be implemented in C++ and included in your project.

First, ensure you have Catch2 installed and properly set up in your project. If not, you can download it from [Catch2's GitHub repository](https://github.com/catchorg/Catch2).

Here's how you can write the C++ test case:

```cpp
#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
#include "catch.hpp"
#include <vector>
#include <cmath>

// Assuming get_mids_from_edges is defined somewhere in your project
std::vector<double> get_mids_from_edges(const std::vector<int>& edges);

TEST_CASE("Calculate midpoints from edges", "[midpoints]") {
    SECTION("Single element") {
        std::vector<int> edges = {0};
        std::vector<double> expected_midpoints = {0.0};
        REQUIRE(get_mids_from_edges(edges) == Approx(expected_midpoints));
    }

    SECTION("Two elements") {
        std::vector<int> edges = {0, 1};
        std::vector<double> expected_midpoints = {0.5};
        REQUIRE(get_mids_from_edges(edges) == Approx(expected_midpoints));
    }

    SECTION("Three elements") {
        std::vector<int> edges = {0, 1, 2};
        std::vector<double> expected_midpoints = {0.5, 1.5};
        REQUIRE(get_mids_from_edges(edges) == Approx(expected_midpoints));
    }
}
```

### Explanation:

1. **Include Catch2 Header**: The `#include "catch.hpp"` directive includes the Catch2 library header.
2. **Define Main Function**: The `#define CATCH_CONFIG_MAIN` macro tells Catch to automatically generate the `main()` function.
3. **Test Case Definition**: The `TEST_CASE` macro defines a new test case named "Calculate midpoints from edges".
4. **Sections**: Each `SECTION` within a `TEST_CASE` represents a specific scenario or sub-test.
5. **Assertions**: The `REQUIRE` macro is used to assert that the result of `get_mids_from_edges` matches the expected midpoints. The `Approx` matcher allows for floating-point comparison with a tolerance.

Make sure that the implementation of `get_mids_from_edges` is correctly defined and linked in your project. Here is a simple implementation for reference:

```cpp
#include <vector>
#include <cmath>

std::vector<double> get_mids_from_edges(const std::vector<int>& edges) {
    std::vector<double> midpoints;
    for (size_t i = 0; i < edges.size() - 1; ++i) {
        midpoints.push_back(static_cast<double>(edges[i] + edges[i + 1]) / 2);
    }
    return midpoints;
}
```

This implementation calculates the midpoints between consecutive elements in the input vector and returns them as a `std::vector<double>`.