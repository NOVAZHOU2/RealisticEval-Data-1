Sure, here is how you can convert the given Python `unittest` test class into a Jest test case in JavaScript. I'll assume you have a function called `extractLogEntries` that performs the desired operations.

First, let's define the `extractLogEntries` function in JavaScript:

```javascript
function extractLogEntries(logFilePath) {
    // Your implementation here
}
```

Now, let's create a Jest test case for this function:

```javascript
const fs = require('fs');
const path = require('path');

// Mock the fs module to simulate file reading and writing
jest.mock('fs', () => ({
    readFileSync: jest.fn(),
    writeFileSync: jest.fn()
}));

describe('extractLogEntries', () => {
    const logFilePath = 'path/to/logfile.log';
    const expectedWarningLogs = ['WARNING: This is a warning message'];
    const expectedErrorLogs = ['ERROR: This is an error message'];
    const expectedCriticalLogs = ['CRITICAL: This is a critical message'];
    const expectedAlertLogs = ['ALERT: This is an alert message'];

    beforeEach(() => {
        // Reset mocks before each test
        fs.readFileSync.mockReset();
        fs.writeFileSync.mockReset();

        // Simulate reading the log file
        fs.readFileSync.mockReturnValue(`
            WARNING: This is a warning message
            INFO: This is an info message
            ERROR: This is an error message
            CRITICAL: This is a critical message
            DEBUG: This is a debug message
            ALERT: This is an alert message
        `.trim());
    });

    it('should extract WARNING logs and save them to a separate file', () => {
        extractLogEntries(logFilePath);

        expect(fs.writeFileSync).toHaveBeenCalledWith(
            path.join(__dirname, 'warnings.log'),
            expectedWarningLogs.join('\n')
        );
    });

    it('should extract ERROR logs and save them to a separate file', () => {
        extractLogEntries(logFilePath);

        expect(fs.writeFileSync).toHaveBeenCalledWith(
            path.join(__dirname, 'errors.log'),
            expectedErrorLogs.join('\n')
        );
    });

    it('should extract CRITICAL logs and save them to a separate file', () => {
        extractLogEntries(logFilePath);

        expect(fs.writeFileSync).toHaveBeenCalledWith(
            path.join(__dirname, 'criticals.log'),
            expectedCriticalLogs.join('\n')
        );
    });

    it('should extract ALERT logs and save them to a separate file', () => {
        extractLogEntries(logFilePath);

        expect(fs.writeFileSync).toHaveBeenCalledWith(
            path.join(__dirname, 'alerts.log'),
            expectedAlertLogs.join('\n')
        );
    });
});
```

In this Jest test case:

1. We mock the `fs` module to simulate file reading and writing using `jest.mock`.
2. We define some sample log messages for each level (`WARNING`, `ERROR`, `CRITICAL`, `ALERT`).
3. In the `beforeEach` hook, we reset the mocks and simulate reading the log file.
4. We then write individual tests for each log level to ensure that the function correctly extracts and saves the logs to separate files.

Make sure to replace the placeholder paths and content with your actual implementation details.