Sure, here's how you can implement the `rotate_list_elements` function in C++:

```cpp
#include <vector>

std::vector<int> rotate_list_elements(const std::vector<int>& elements) {
    if (elements.empty()) {
        return {};
    }

    std::vector<int> rotated(elements.size());
    for (size_t i = 0; i < elements.size(); ++i) {
        rotated[i] = elements[(i + 1) % elements.size()];
    }
    return rotated;
}
```

And here's how you can implement it in C:

```c
#include <stdlib.h>
#include <stdio.h>

int* rotate_list_elements(int* elements, size_t size, size_t* new_size) {
    if (size == 0) {
        *new_size = 0;
        return NULL;
    }

    int* rotated = (int*)malloc(size * sizeof(int));
    for (size_t i = 0; i < size; ++i) {
        rotated[i] = elements[(i + 1) % size];
    }

    *new_size = size;
    return rotated;
}

// Example usage
int main() {
    int elements[] = {1, 2, 3, 4, 5};
    size_t size = sizeof(elements) / sizeof(elements[0]);
    size_t new_size;

    int* rotated = rotate_list_elements(elements, size, &new_size);

    for (size_t i = 0; i < new_size; ++i) {
        printf("%d ", rotated[i]);
    }

    free(rotated);
    return 0;
}
```

### Explanation:
- **C++ Implementation**:
  - The function `rotate_list_elements` takes a constant reference to a vector of integers and returns a new vector with the elements rotated to the left by one position.
  - It handles the edge case where the input vector is empty.
  - The rotation is done using modulo arithmetic to wrap around the indices.

- **C Implementation**:
  - The function `rotate_list_elements` takes an array of integers, its size, and a pointer to store the new size of the rotated array.
  - It dynamically allocates memory for the rotated array and performs the rotation similarly to the C++ version.
  - The example usage demonstrates how to call the function and print the rotated array.

Both implementations ensure that the first element is moved to the end of the list and all other elements are shifted one position to the left.