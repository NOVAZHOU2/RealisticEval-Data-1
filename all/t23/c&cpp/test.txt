Certainly! Below is the equivalent C++ test class using the Catch2 testing framework. This conversion ensures that the functionality and logic of the tests are preserved, with appropriate assertions and setup.

First, make sure you have Catch2 installed and included in your project. You can include Catch2 by adding the header file and using the `CATCH_TEST_CASE` macro for each test case.

Here is the complete C++ code:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <utility>
#include <cmath>

// Define a union type for the return value
union IntersectionResult {
    std::pair<double, double> point;
    bool isNone;

    IntersectionResult() : isNone(true) {}
    IntersectionResult(double x, double y) : point(x, y), isNone(false) {}

    // Destructor
    ~IntersectionResult() {}

    // Equality operator for checking if the result is None
    bool operator==(const std::pair<double, double>& p) const {
        return !isNone && point == p;
    }

    // Equality operator for checking if the result is None
    bool operator==(bool none) const {
        return isNone == none;
    }
};

IntersectionResult getLineSegmentIntersection(const std::pair<std::pair<double, double>, std::pair<double, double>>& seg1,
                                              const std::pair<std::pair<double, double>, std::pair<double, double>>& seg2) {
    // Unpack segment points
    auto [p1, p2] = seg1;
    auto [p3, p4] = seg2;

    double x1 = p1.first, y1 = p1.second;
    double x2 = p2.first, y2 = p2.second;
    double x3 = p3.first, y3 = p3.second;
    double x4 = p4.first, y4 = p4.second;

    // Compute direction vectors and determinant
    double dx1 = x2 - x1, dy1 = y2 - y1;
    double dx2 = x4 - x3, dy2 = y4 - y3;
    double determinant = dx1 * dy2 - dx2 * dy1;

    // Check for parallel lines or identical segments
    if (std::abs(determinant) < 1e-10) {
        return {};
    }

    // Calculate intersection parameters
    double t1 = ((x3 - x1) * dy2 - (y3 - y1) * dx2) / determinant;
    double t2 = ((x3 - x1) * dy1 - (y3 - y1) * dx1) / determinant;

    // Allow for a small tolerance in the intersection check
    double tolerance = 1e-10;

    // Check if intersection is within the bounds of the line segments
    if (0 - tolerance <= t1 && t1 <= 1 + tolerance && 0 - tolerance <= t2 && t2 <= 1 + tolerance) {
        double x = x1 + t1 * dx1;
        double y = y1 + t1 * dy1;
        return {round(x * 1e7) / 1e7, round(y * 1e7) / 1e7};
    }

    return {};
}

TEST_CASE("Test Line Segment Intersection") {
    SECTION("Intersection") {
        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(4.0, 4.0));
        auto seg2 = std::make_pair(std::make_pair(1.0, 4.0), std::make_pair(4.0, 1.0));
        auto expected = std::make_pair(2.5, 2.5);
        auto result = getLineSegmentIntersection(seg1, seg2);
        REQUIRE(result == expected);
    }

    SECTION("No Intersection") {
        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(2.0, 2.0));
        auto seg2 = std::make_pair(std::make_pair(3.0, 3.0), std::make_pair(4.0, 4.0));
        auto result = getLineSegmentIntersection(seg1, seg2);
        REQUIRE(result == true); // True indicates no intersection
    }

    SECTION("Parallel Segments") {
        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(2.0, 2.0));
        auto seg2 = std::make_pair(std::make_pair(1.0, 2.0), std::make_pair(2.0, 3.0));
        auto result = getLineSegmentIntersection(seg1, seg2);
        REQUIRE(result == true); // True indicates no intersection
    }

    SECTION("No Intersection Due to Offset") {
        auto seg1 = std::make_pair(std::make_pair(1.0, 1.0), std::make_pair(3.0, 3.0));
        auto seg2 = std::make_pair(std::make_pair(3.0, 2.0), std::make_pair(4.0, 2.0));
        auto result = getLineSegmentIntersection(seg1, seg2);
        REQUIRE(result == true); // True indicates no intersection
    }

    SECTION("Intersection with Large Coordinates") {
        auto seg1 = std::make_pair(std::make_pair(1000.0, 1000.0), std::make_pair(2000.0, 2000.0));
        auto seg2 = std::make_pair(std::make_pair(1000.0, 2000.0), std::make_pair(2000.0, 1000.0));
        auto expected = std::make_pair(1500.0, 1500.0);
        auto result = getLineSegmentIntersection(seg1, seg2);
        REQUIRE(result == expected);
    }
}

int main(int argc, char* argv[]) {
    // Run all tests with Catch2
    int result = Catch::Session().run(argc, argv);
    return result;
}
```

### Explanation:
1. **Catch2 Header**: Include the Catch2 header file to use its testing macros.
2. **Union Type**: Define the `IntersectionResult` union to represent the `Union[tuple, None]` behavior from Python.
3. **Function Definition**: Implement the `getLineSegmentIntersection` function as previously described.
4. **Test Cases**:
   - **Intersection**: Tests the intersection of two segments.
   - **No Intersection**: Tests segments that do not intersect.
   - **Parallel Segments**: Tests parallel segments that do not intersect.
   - **No Intersection Due to Offset**: Tests segments that do not intersect due to an offset.
   - **Intersection with Large Coordinates**: Tests segments with large coordinates.
5. **Assertions**: Use `REQUIRE` for assertions to ensure the expected results match the actual results.
6. **Main Function**: Run all tests with Catch2.

This C++ code preserves the functionality and logic of the original Python tests while adhering to C++ standards and practices.