Sure! Below is the equivalent TypeScript Jest test case for your Python `unittest` test class:

```typescript
import { describe, it, expect } from '@jest/globals';

describe('calculateRedProportion', () => {
    it('should return 0 for an empty array', () => {
        const pixels: [number, number, number][] = [];
        const result = calculateRedProportion(pixels);
        expect(result).toBe(0);
    });

    it('should return 1 for all red pixels', () => {
        const pixels: [number, number, number][] = [
            [255, 0, 0],
            [255, 0, 0],
            [255, 0, 0]
        ];
        const result = calculateRedProportion(pixels);
        expect(result).toBe(1);
    });

    it('should return 0.5 for half red pixels', () => {
        const pixels: [number, number, number][] = [
            [255, 0, 0],
            [0, 0, 0],
            [255, 0, 0],
            [0, 0, 0]
        ];
        const result = calculateRedProportion(pixels);
        expect(result).toBe(0.5);
    });

    it('should return 0.33 for one third red pixels', () => {
        const pixels: [number, number, number][] = [
            [255, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ];
        const result = calculateRedProportion(pixels);
        expect(result).toBeCloseTo(0.33);
    });
});

function calculateRedProportion(pixels: [number, number, number][]) {
    if (pixels.length === 0) return 0;

    let redCount = 0;
    for (const pixel of pixels) {
        if (pixel[0] > 0 && pixel[1] === 0 && pixel[2] === 0) {
            redCount++;
        }
    }

    return redCount / pixels.length;
}
```

In this TypeScript code, we use Jest's `describe`, `it`, and `expect` functions to write the test cases. The `calculateRedProportion` function is implemented similarly to your Python function but uses TypeScript syntax. The `toBeCloseTo` matcher is used to compare floating-point numbers because exact equality can be problematic due to precision issues.