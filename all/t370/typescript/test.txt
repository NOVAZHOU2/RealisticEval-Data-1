Certainly! Here is the equivalent Jest test class in TypeScript, including the necessary type annotations and Jest assertions:

```typescript
import { decompose } from './decompose'; // Import the decompose function

describe('TestDecomposeFunction', () => {
  it('should handle edge case with larger shape', () => {
    expect(decompose(60, [4, 4, 4])).toEqual([3, 3, 0]);
  });

  it('should handle the last valid index', () => {
    expect(decompose(63, [4, 4, 4])).toEqual([3, 3, 3]);
  });

  it('should handle single dimension case', () => {
    expect(decompose(2, [5])).toEqual([2]);
  });

  it('should throw an error for invalid cases', () => {
    // Test case 5: Out of bounds case (negative index)
    expect(() => decompose(-1, [3, 4, 5])).toThrow('Index out of bounds');

    // Test case 6: Out of bounds case (index too large)
    expect(() => decompose(100, [3, 4, 5])).toThrow('Index out of bounds');
  });
});
```

### Explanation:
1. **Import Statement**:
   - Import the `decompose` function from the appropriate module.

2. **Describe Block**:
   - Use the `describe` block to group the test cases under a descriptive name.

3. **It Blocks**:
   - Each test case is defined using the `it` block, which takes a description and a callback function.

4. **Assertions**:
   - Use Jest assertions such as `expect` and `toEqual` to check the equality of the results.
   - Use `toThrow` to check that the function throws the expected error.

5. **Type Annotations**:
   - The `decompose` function is assumed to be imported from another module, and its type signature is inferred from the usage.

Here is the complete TypeScript code, including the `decompose` function and the Jest test class:

```typescript
// decompose.ts
export function decompose(n: number, shape: number[]): [number, ...number[]] {
    /**
     * Decompose a flat index `n` into a multidimensional index based on the given shape.
     *
     * @param n - Flat index (non-negative integer).
     * @param shape - Array representing the dimensions of the multi-dimensional array.
     * @returns A tuple representing the multidimensional index corresponding to `n`.
     * @throws {Error} If `n` is out of bounds for the array defined by `shape`.
     */
    // Calculate the total size of the array
    let size = 1;
    for (const dim of shape) {
        size *= dim;
    }

    // Check if the index is within bounds
    if (n < 0 || n >= size) {
        throw new Error("Index out of bounds");
    }

    // Decompose the index
    const result: number[] = [];
    for (let dim of shape.slice().reverse()) {
        result.push(n % dim);
        n = Math.floor(n / dim);  // Update n by integer division
    }

    // Reverse the result to match the original shape order and return as tuple
    return result.reverse() as [number, ...number[]];
}

// test-decompose.ts
import { decompose } from './decompose';

describe('TestDecomposeFunction', () => {
  it('should handle edge case with larger shape', () => {
    expect(decompose(60, [4, 4, 4])).toEqual([3, 3, 0]);
  });

  it('should handle the last valid index', () => {
    expect(decompose(63, [4, 4, 4])).toEqual([3, 3, 3]);
  });

  it('should handle single dimension case', () => {
    expect(decompose(2, [5])).toEqual([2]);
  });

  it('should throw an error for invalid cases', () => {
    // Test case 5: Out of bounds case (negative index)
    expect(() => decompose(-1, [3, 4, 5])).toThrow('Index out of bounds');

    // Test case 6: Out of bounds case (index too large)
    expect(() => decompose(100, [3, 4, 5])).toThrow('Index out of bounds');
  });
});
```

This TypeScript code preserves the functionality and logic of the original Python unittest class while adapting it to Jest's testing framework.