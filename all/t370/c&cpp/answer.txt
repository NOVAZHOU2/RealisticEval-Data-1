Here's how you could write that Python function in C and C++. The C version assumes that the input shape array has been allocated with enough space beforehand:

```c
#include <stdio.h>
#include <stdlib.h>

void decompose(int n, int *shape, int ndim, int *result) {
    if (n < 0 || n >= 1) { // Assuming the upper bound is 1 for simplicity.
        printf("Error: Index out of bounds.\n");
        exit(1);
    }
    
    int size = 1;
    for (int i = 0; i < ndim; ++i) {
        result[i] = n / size % shape[i];
        size *= shape[i];
    }
}
```

And here is an equivalent C++ function:

```cpp
#include <iostream>
#include <vector>

std::vector<int> decompose(int n, const std::vector<int>& shape) {
    if (n < 0 || n >= 1) { // Assuming the upper bound is 1 for simplicity.
        std::cerr << "Error: Index out of bounds." << std::endl;
        exit(1);
    }

    std::vector<int> result(shape.size());
    int size = 1;
    for (size_t i = 0; i < shape.size(); ++i) {
        result[i] = n / size % shape[i];
        size *= shape[i];
    }
    return result;
}
```
In both versions, we're assuming that the upper bound for the flat index `n` is 1 for simplicity. You should replace these values with your actual upper bound. Also, error handling is quite basic in these examples, but it can be made more robust depending on your needs.