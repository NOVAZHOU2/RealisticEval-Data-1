Certainly! Below is the equivalent Java test class using JUnit, placed in the package `org.real.temp` and named `Tester`. The test cases are converted to use JUnit annotations and assertion methods, ensuring that the functionality and logic of the tests are preserved.

```java
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThrows;

public class Tester {

    /**
     * Test edge case with a larger shape.
     */
    @Test
    public void testEdgeCaseWithLargerShape() {
        assertEquals("(3, 3, 0)", decompose(60, new int[]{4, 4, 4}).toString());
    }

    /**
     * Test the last valid index.
     */
    @Test
    public void testLastValidIndex() {
        assertEquals("(3, 3, 3)", decompose(63, new int[]{4, 4, 4}).toString());
    }

    /**
     * Test single dimension case.
     */
    @Test
    public void testSingleDimensionCase() {
        assertEquals("(2,)", decompose(2, new int[]{5}).toString());
    }

    /**
     * Test invalid cases.
     */
    @Test
    public void testInvalidCases() {
        // Test case 5: Out of bounds case (negative index)
        assertThrows(IllegalArgumentException.class, () -> decompose(-1, new int[]{3, 4, 5}));

        // Test case 6: Out of bounds case (index too large)
        assertThrows(IllegalArgumentException.class, () -> decompose(100, new int[]{3, 4, 5}));
    }

    // Helper method to decompose the index
    private List<Integer> decompose(int n, int[] shape) {
        // Calculate the total size of the array
        int size = 1;
        for (int dim : shape) {
            size *= dim;
        }

        // Check if the index is within bounds
        if (n < 0 || n >= size) {
            throw new IllegalArgumentException("Index out of bounds");
        }

        // Decompose the index
        List<Integer> result = new ArrayList<>();
        for (int i = shape.length - 1; i >= 0; i--) {
            result.add(n % shape[i]);
            n /= shape[i];  // Update n by integer division
        }

        // Reverse the result to match the original shape order
        Collections.reverse(result);

        return result;
    }
}
```

### Explanation:
1. **Package and Class Declaration**:
   ```java
   public class Tester {
   ```
   The Java test class is declared as `public class Tester`.

2. **JUnit Annotations**:
   ```java
   @Test
   ```
   Each test method is annotated with `@Test` to indicate that it is a test case.

3. **Assertion Methods**:
   ```java
   assertEquals("(3, 3, 0)", decompose(60, new int[]{4, 4, 4}).toString());
   ```
   The `assertEquals` method is used to verify that the expected and actual results match.

4. **Exception Handling**:
   ```java
   assertThrows(IllegalArgumentException.class, () -> decompose(-1, new int[]{3, 4, 5}));
   ```
   The `assertThrows` method is used to verify that the specified exception is thrown.

5. **Helper Method**:
   ```java
   private List<Integer> decompose(int n, int[] shape) {
       // Implementation of the decompose method
   }
   ```
   The `decompose` method is implemented as a helper method within the test class to ensure consistency with the original functionality.

6. **Test Cases**:
   - `testEdgeCaseWithLargerShape`: Verifies the edge case with a larger shape.
   - `testLastValidIndex`: Verifies the last valid index.
   - `testSingleDimensionCase`: Verifies the single dimension case.
   - `testInvalidCases`: Verifies the invalid cases (out-of-bounds indices).

This Java test class preserves the functionality and logic of the original Python test cases while adhering to JUnit conventions and best practices.