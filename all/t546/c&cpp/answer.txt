Sure, here's how you can translate your Python function `read_tsv_from_stdin` into C++:

```cpp
#include <iostream>
#include <vector>
#include <sstream>

std::vector<std::vector<std::string>> readTsvFromStdin() {
    std::vector<std::vector<std::string>> rows;
    std::string line;

    while (std::getline(std::cin, line)) {
        std::istringstream iss(line);
        std::vector<std::string> fields;
        std::string field;

        // Split the line by tabs
        while (std::getline(iss, field, '\t')) {
            fields.push_back(field);
        }

        // Pad with empty strings if necessary
        while (fields.size() < rows.empty() ? 0 : rows.back().size()) {
            fields.push_back("");
        }

        // Add the current row to the list
        rows.push_back(fields);
    }

    return rows;
}

int main() {
    auto tsvData = readTsvFromStdin();

    for (const auto& row : tsvData) {
        for (const auto& field : row) {
            std::cout << field << "\t";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Reading Input**: The function reads lines from `std::cin`.
2. **Splitting Lines**: Each line is split using `std::getline` with the delimiter set to `'\t'`.
3. **Padding Fields**: If the number of fields in the current row is less than the maximum number of fields found so far, it pads with empty strings.
4. **Storing Rows**: Each processed row is added to the `rows` vector.
5. **Output**: The function prints out the parsed TSV data.

This C++ code should behave similarly to your original Python function, reading TSV data from standard input and handling rows of varying lengths by padding them with empty strings.