Here's the equivalent TypeScript code for your Python function:

```typescript
import * as readline from 'readline';

async function readTsvFromStdin(): Promise<string[][]> {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });

    let tsvData: string[][] = [];
    let maxLength = 0;

    for await (const line of rl) {
        const rowData = line.split('\t');
        if (rowData.length > maxLength) {
            maxLength = rowData.length;
        }
        tsvData.push(rowData);
    }

    // Pad shorter rows with empty strings
    for (let i = 0; i < tsvData.length; i++) {
        while (tsvData[i].length < maxLength) {
            tsvData[i].push('');
        }
    }

    return tsvData;
}

// Example usage:
(async () => {
    try {
        const data = await readTsvFromStdin();
        console.log(data);
    } catch (error) {
        console.error('Error reading TSV:', error);
    }
})();
```

### Explanation:
1. **Importing `readline`**: The `readline` module in Node.js is used to read data from the standard input line by line.
2. **Creating a Readable Stream**: We create a readable stream using `readline.createInterface` which reads from `process.stdin`.
3. **Reading Lines**: We use an asynchronous loop (`for await`) to read each line from the input.
4. **Splitting Lines into Rows**: Each line is split by tabs (`\t`) to get the row data.
5. **Padding Rows**: We keep track of the maximum row length and pad any shorter rows with empty strings.
6. **Returning Data**: Finally, we return the array of padded rows.

This TypeScript code should work similarly to your original Python code, reading TSV data from standard input and padding rows to ensure uniformity.