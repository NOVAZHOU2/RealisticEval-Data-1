Certainly! Below is the conversion of the provided Python unittest test class into a TypeScript test class using Jest. I'll make sure to include all necessary type annotations and map the unittest assertions to their Jest equivalents.

### Python Code (unittest)
```python
import unittest

class TestStringMethods(unittest.TestCase):
    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
```

### TypeScript Code (jest)
```typescript
import { describe, it, expect } from '@jest/globals';

describe('Test String Methods', () => {
  it('should correctly convert strings to uppercase', () => {
    expect('foo'.toUpperCase()).toBe('FOO');
  });

  it('should correctly determine if a string is uppercase', () => {
    expect('FOO'.toUpperCase()).toBe('FOO');
    expect('Foo'.toUpperCase()).not.toBe('FOO');
  });

  it('should correctly split strings', () => {
    const s = 'hello world';
    expect(s.split(' ')).toEqual(['hello', 'world']);
    
    // Check that s.split fails when the separator is not a string
    expect(() => s.split(2 as any)).toThrow(TypeError);
  });
});
```

### Explanation:
1. **Imports**: We import `describe`, `it`, and `expect` from `@jest/globals` to use Jest's global functions.
2. **Test Suite**: We define a test suite using `describe` which groups related tests together.
3. **Test Cases**:
   - `test_upper`: This test checks that converting `'foo'` to uppercase results in `'FOO'`.
   - `test_isupper`: This test checks that `'FOO'` is uppercase and `'Foo'` is not.
   - `test_split`: This test checks the splitting functionality and also verifies that passing a non-string separator results in a TypeError.

By following these steps, we ensure that the tests are functionally equivalent and adhere to TypeScript and Jest conventions.