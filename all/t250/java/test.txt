To convert the given Python unittest test class into a Java JUnit test case, you need to follow these steps:

1. Define the `invert_dictionary` function in Java.
2. Create a Java class named `Tester` that contains the test methods using JUnit annotations.

Here's how you can do it:

### Step 1: Define the `invert_dictionary` Function in Java

First, create a utility class or a helper class where you will define the `invertDictionary` method.

```java
import java.util.*;

public class DictionaryUtils {
    public static Map<Object, Object> invertDictionary(Map<Object, Object> originalDict) {
        Map<Object, Object> invertedDict = new HashMap<>();
        for (Map.Entry<Object, Object> entry : originalDict.entrySet()) {
            Object key = entry.getKey();
            Object value = entry.getValue();

            if (!invertedDict.containsKey(value)) {
                invertedDict.put(value, new ArrayList<>());
            }
            ((List<Object>) invertedDict.get(value)).add(key);
        }
        return invertedDict;
    }
}
```

### Step 2: Create the `Tester` Class Using JUnit

Now, create the `Tester` class in the package `org.real.temp` and write your test methods using JUnit.

```java
package org.real.temp;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Tester {

    @Test
    public void testInvertDictionary() {
        // Test case 1
        Map<String, Integer> input1 = new HashMap<>();
        input1.put("a", 1);
        input1.put("b", 2);
        input1.put("c", 3);

        Map<Integer, List<String>> expectedOutput1 = new HashMap<>();
        expectedOutput1.put(1, Arrays.asList("a"));
        expectedOutput1.put(2, Arrays.asList("b"));
        expectedOutput1.put(3, Arrays.asList("c"));

        assertEquals(expectedOutput1, DictionaryUtils.invertDictionary(input1));

        // Test case 2
        Map<String, String> input2 = new HashMap<>();
        input2.put("apple", "fruit");
        input2.put("banana", "fruit");
        input2.put("carrot", "vegetable");

        Map<String, List<String>> expectedOutput2 = new HashMap<>();
        expectedOutput2.put("fruit", Arrays.asList("apple", "banana"));
        expectedOutput2.put("vegetable", Arrays.asList("carrot"));

        assertEquals(expectedOutput2, DictionaryUtils.invertDictionary(input2));
    }

    @Test
    public void testInvertDictionaryWithDuplicateValues() {
        // Test case with duplicate values
        Map<String, String> input3 = new HashMap<>();
        input3.put("one", "1");
        input3.put("two", "2");
        input3.put("three", "1");

        Map<String, List<String>> expectedOutput3 = new HashMap<>();
        expectedOutput3.put("1", Arrays.asList("one", "three"));
        expectedOutput3.put("2", Arrays.asList("two"));

        assertEquals(expectedOutput3, DictionaryUtils.invertDictionary(input3));
    }
}
```

### Explanation

1. **DictionaryUtils Class**: This class contains the `invertDictionary` method which performs the inversion of the dictionary as described in the Python code.
2. **Tester Class**: This class contains the test methods using JUnit annotations (`@Test`). Each method tests different scenarios to ensure the `invertDictionary` method works correctly.

Make sure you have the JUnit library included in your project dependencies. If you're using Maven, add the following dependency to your `pom.xml`:

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <version>5.8.1</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.8.1</version>
    <scope>test</scope>
</dependency>
```

This setup should allow you to run the tests using a JUnit runner in your IDE or via the command line.