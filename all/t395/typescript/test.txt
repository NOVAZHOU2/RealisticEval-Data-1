Certainly! Here’s the equivalent TypeScript test class using Jest, ensuring that the functionality and logic of the tests are preserved. We will use Jest’s assertion methods to match the behavior of Python’s `unittest` framework.

First, let's include the TypeScript code for the `sumCalibrationValues` function:

```typescript
/**
 * Sums up calibration values extracted from the document.
 * Each calibration value is formed by combining the first and last digits of numbers found in each line
 * into a two-digit number.
 *
 * @param {Iterable<string>} calibrationDocument - An iterable of strings, each representing a line of text.
 * @returns {number} The total sum of all calibration values.
 */
function sumCalibrationValues(calibrationDocument: Iterable<string>): number {
    let totalSum = 0;

    for (const line of calibrationDocument) {
        // Filter out non-digit characters
        const digits = Array.from(line).filter(char => !isNaN(parseInt(char)));

        // Extract the first and last digits
        if (digits.length > 0) {
            const firstDigit = parseInt(digits[0]);
            const lastDigit = parseInt(digits[digits.length - 1]);

            // Combine to form a two-digit number
            const calibrationValue = firstDigit * 10 + lastDigit;

            // Add to the total sum
            totalSum += calibrationValue;
        }
    }

    return totalSum;
}

export default sumCalibrationValues;
```

Now, let's write the Jest test class:

```typescript
import sumCalibrationValues from './path/to/sumCalibrationValues'; // Adjust the import path as needed

describe('TestSumCalibrationValues', () => {
    describe('test_basic_calculations', () => {
        it('should correctly calculate the sum with basic input', () => {
            const document = [
                "Reading 1234 calibration",
                "Measure 5678 complete",
                "End of data 91011"
            ];
            expect(sumCalibrationValues(document)).toBe(163);
        });
    });

    describe('test_no_digits', () => {
        it('should return 0 when no digits are present', () => {
            const document = [
                "No numbers here",
                "Still no numbers"
            ];
            expect(sumCalibrationValues(document)).toBe(0);
        });
    });

    describe('test_empty_lines', () => {
        it('should return 0 for empty or whitespace-only lines', () => {
            const document = [
                "",
                "   "
            ];
            expect(sumCalibrationValues(document)).toBe(0);
        });
    });

    describe('test_mixed_content', () => {
        it('should correctly calculate the sum with mixed content', () => {
            const document = [
                "Good line 1524 end",
                "Bad line",
                "Another good line 7681"
            ];
            expect(sumCalibrationValues(document)).toBe(85);
        });
    });
});
```

### Explanation:
1. **Import Function**:
   - Import the `sumCalibrationValues` function from the appropriate module.

2. **Describe Blocks**:
   - Use `describe` blocks to group related tests together.

3. **It Blocks**:
   - Use `it` blocks to define individual test cases.
   - Each `it` block contains an assertion using `expect` to verify the expected behavior.

4. **Test Cases**:
   - `test_basic_calculations`: Tests with a simple input where lines contain at least two digits.
   - `test_no_digits`: Tests lines with no digits.
   - `test_empty_lines`: Tests with empty lines or lines with spaces.
   - `test_mixed_content`: Tests with a mixture of valid and invalid lines.

5. **Assertions**:
   - Use `expect` with `toBe` to check the equality of the results.

This setup ensures that the tests are structured similarly to the Python `unittest` framework and uses Jest’s assertion methods to validate the behavior of the `sumCalibrationValues` function.