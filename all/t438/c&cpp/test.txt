To convert the given Python function into a C++ equivalent and write tests for it using Catch2, we need to follow these steps:

1. **Implement the `read_csv_to_dataframe` function in C++**.
2. **Write tests for this function using Catch2**.

### Step 1: Implement the Function

First, let's implement the function in C++. For simplicity, we'll use the `fstream` library to read the CSV file and store the data in a simple structure like a `std::vector<std::vector<std::string>>`.

```cpp
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

// Represents a row in the CSV file.
using Row = std::vector<std::string>;
// Represents the entire CSV file.
using DataFrame = std::vector<Row>;

// Reads a CSV file and converts it to a vector of vectors.
DataFrame read_csv_to_dataframe(const std::string& file_path) {
    DataFrame data;
    std::ifstream file(file_path);
    if (!file.is_open()) {
        throw std::runtime_error("Failed to open file: " + file_path);
    }

    std::string line;
    while (std::getline(file, line)) {
        std::istringstream ss(line);
        Row row;
        std::string cell;
        while (std::getline(ss, cell, ',')) {
            row.push_back(cell);
        }
        data.push_back(row);
    }

    file.close();
    return data;
}
```

### Step 2: Write Tests Using Catch2

Now, let's write tests for the `read_csv_to_dataframe` function using Catch2. We'll assume that you have already set up the Catch2 environment in your project.

Here is the test suite using Catch2:

```cpp
#include "catch2/catch_test_macros.hpp"

// Include the implementation of the function.
#include "path/to/your/implementation.h" // Replace with actual path

TEST_CASE("read_csv_to_dataframe reads the CSV file correctly", "[read_csv]") {
    const std::string test_file_path = "path/to/test.csv"; // Replace with actual path

    SECTION("Reads a valid CSV file") {
        DataFrame expected_data = {
            {"header1", "header2"},
            {"value1", "value2"},
            {"value3", "value4"}
        };

        DataFrame actual_data = read_csv_to_dataframe(test_file_path);

        REQUIRE(actual_data.size() == expected_data.size());
        for (size_t i = 0; i < actual_data.size(); ++i) {
            REQUIRE(actual_data[i].size() == expected_data[i].size());
            for (size_t j = 0; j < actual_data[i].size(); ++j) {
                REQUIRE(actual_data[i][j] == expected_data[i][j]);
            }
        }
    }

    SECTION("Throws an error when the file does not exist") {
        const std::string non_existent_file_path = "nonexistent.csv";
        REQUIRE_THROWS_AS(read_csv_to_dataframe(non_existent_file_path), std::runtime_error);
    }
}
```

### Explanation

- **Implementation**: The `read_csv_to_dataframe` function reads the CSV file and stores the data in a `std::vector<std::vector<std::string>>`.
- **Test Suite**: 
  - The `SECTION` blocks are used to separate different scenarios or cases within the test.
  - The first section checks if the function correctly reads a valid CSV file and compares the output with the expected data.
  - The second section verifies that the function throws a `std::runtime_error` when the specified file does not exist.

Make sure to replace `"path/to/test.csv"` and `"path/to/your/implementation.h"` with the actual paths in your project. This setup ensures that the functionality and logic of the tests are preserved and appropriately translated from Python's unittest to C++'s Catch2.