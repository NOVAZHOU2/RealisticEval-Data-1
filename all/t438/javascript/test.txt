Sure, let's convert the given Python unittest test class into a Jest test suite. Since you haven't provided the actual unittest class, I'll assume you want to create a Jest test suite for the `read_csv_to_dataframe` function.

Hereâ€™s the equivalent Jest test suite:

```javascript
const fs = require('fs');
const path = require('path');
const { parse } = require('papaparse');

// Mock the dependencies
jest.mock('fs', () => ({
  ...jest.requireActual('fs'),
  readFile: jest.fn(),
}));

jest.mock('papaparse', () => ({
  parse: jest.fn(),
}));

function readCsvToDataFrame(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, 'utf8', (err, data) => {
      if (err) {
        reject(err);
      } else {
        const parsedData = parse(data, { header: true });
        resolve(parsedData.data);
      }
    });
  });
}

describe('readCsvToDataFrame', () => {
  beforeEach(() => {
    fs.readFile.mockClear();
    parse.mockClear();
  });

  it('should correctly read and parse the CSV file', async () => {
    const mockFileContent = 'Name,Age\nAlice,30\nBob,25';
    const mockParsedData = [
      { Name: 'Alice', Age: '30' },
      { Name: 'Bob', Age: '25' },
    ];

    // Mock the file reading and parsing
    fs.readFile.mockImplementationOnce((_, callback) => {
      callback(null, mockFileContent);
    });

    parse.mockReturnValue({ data: mockParsedData });

    const filePath = path.join(__dirname, 'test.csv');
    try {
      const result = await readCsvToDataFrame(filePath);
      expect(result).toEqual(mockParsedData);
    } catch (error) {
      fail(`An error occurred: ${error.message}`);
    }

    expect(fs.readFile).toHaveBeenCalledTimes(1);
    expect(parse).toHaveBeenCalledTimes(1);
  });

  it('should handle errors when reading the CSV file', async () => {
    const mockError = new Error('Failed to read file');
    fs.readFile.mockImplementationOnce((_, callback) => {
      callback(mockError);
    });

    const filePath = path.join(__dirname, 'test.csv');
    try {
      await readCsvToDataFrame(filePath);
    } catch (error) {
      expect(error).toBe(mockError);
    }

    expect(fs.readFile).toHaveBeenCalledTimes(1);
    expect(parse).not.toHaveBeenCalled();
  });

  it('should handle errors when parsing the CSV content', async () => {
    const mockFileContent = 'Name,Age\nAlice,30\nBob,25';
    const mockParseError = new Error('Failed to parse CSV');
    parse.mockImplementationOnce(() => {
      throw mockParseError;
    });

    fs.readFile.mockImplementationOnce((_, callback) => {
      callback(null, mockFileContent);
    });

    const filePath = path.join(__dirname, 'test.csv');
    try {
      await readCsvToDataFrame(filePath);
    } catch (error) {
      expect(error).toBe(mockParseError);
    }

    expect(fs.readFile).toHaveBeenCalledTimes(1);
    expect(parse).toHaveBeenCalledTimes(1);
  });
});
```

### Explanation:
1. **Importing Dependencies**: We import `fs`, `path`, and `papaparse` which are necessary for reading and parsing CSV files.
2. **Mocking Dependencies**: We use `jest.mock` to mock `fs.readFile` and `papaparse.parse` functions to control their behavior during tests.
3. **Function Definition**: We define the `readCsvToDataFrame` function which reads a CSV file and parses it into an array of objects.
4. **Test Cases**:
   - **Correct Parsing**: Tests that the function correctly reads and parses the CSV file.
   - **Handling Read Errors**: Tests that the function handles errors when reading the CSV file.
   - **Handling Parse Errors**: Tests that the function handles errors when parsing the CSV content.
5. **Before Each Hook**: Clears the mocks before each test to avoid side effects from previous tests.

This setup ensures that the functionality and logic of the tests are maintained while adapting to the Jest testing framework.