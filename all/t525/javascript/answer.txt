Certainly! Below is the equivalent JavaScript code that mirrors the functionality, logic, and structure of the provided Python code:

```javascript
function flipPointCloud(pointCloud, axis) {
    /**
     * Flip the point cloud across a specified axis.
     *
     * Parameters:
     * - pointCloud: A N x 3 array representing the 3D point cloud.
     * - axis: An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).
     *
     * Returns:
     * - A N x 3 array of the flipped point cloud.
     */

    // Validate the axis input
    if (axis !== 0 && axis !== 1 && axis !== 2) {
        throw new Error("Axis must be 0 (x-axis), 1 (y-axis), or 2 (z-axis).");
    }

    // Create a scaling factor array with -1 for the specified axis and 1 for others
    const flipFactors = [1, 1, 1];
    flipFactors[axis] = -1;

    // Flip the point cloud by multiplying with the scaling factor array
    const flippedPointCloud = pointCloud.map(row => {
        return row.map((value, index) => value * flipFactors[index]);
    });

    return flippedPointCloud;
}

// Example usage:
const pointCloud = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];

const axis = 1; // Flip along the y-axis

try {
    const flippedPointCloud = flipPointCloud(pointCloud, axis);
    console.log(flippedPointCloud);
} catch (error) {
    console.error(error.message);
}
```

### Explanation:
1. **Validation**: The function checks if the `axis` parameter is valid (0, 1, or 2).
2. **Scaling Factors**: It creates an array `flipFactors` where the element at the specified `axis` is set to `-1`, and all other elements are set to `1`.
3. **Flipping**: It maps over each row in the `pointCloud` and multiplies each element by the corresponding value in `flipFactors`.

This ensures that the point cloud is flipped correctly along the specified axis.