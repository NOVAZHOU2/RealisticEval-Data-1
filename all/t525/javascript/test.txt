Certainly! Below is the equivalent Jest test suite for the given Python unittest class. The goal is to maintain the functionality and logic of the tests while adapting them to Jest's syntax and conventions.

### Python Code:
```python
import unittest
import numpy as np

class TestFlipPointCloud(unittest.TestCase):

    def test_flip_x_axis(self):
        """Test flipping the point cloud across the x-axis."""
        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
        expected_output = np.array([[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]])
        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=1), expected_output)

    def test_flip_y_axis(self):
        """Test flipping the point cloud across the y-axis."""
        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
        expected_output = np.array([[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]])
        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)

    def test_flip_z_axis(self):
        """Test flipping the point cloud across the z-axis."""
        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
        expected_output = np.array([[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]])
        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=2), expected_output)

    def test_invalid_axis(self):
        """Test handling of an invalid axis."""
        point_cloud = np.array([[1.0, 2.0, 3.0]])
        self.assertRaises(Exception, lambda: flip_point_cloud(point_cloud, axis=3))

    def test_empty_point_cloud(self):
        """Test flipping an empty point cloud."""
        point_cloud = np.array([]).reshape(0, 3)  # Empty point cloud with shape (0, 3)
        expected_output = np.array([]).reshape(0, 3)  # Expect the output to be the same
        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)
```

### Equivalent Jest Test Suite:
```javascript
const { flipPointCloud } = require('./flipPointCloud'); // Import the flipPointCloud function

describe('TestFlipPointCloud', () => {
    describe('test_flip_x_axis', () => {
        it('should flip the point cloud across the x-axis', () => {
            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];
            const expectedOutput = [[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]];
            expect(flipPointCloud(pointCloud, 1)).toEqual(expectedOutput);
        });
    });

    describe('test_flip_y_axis', () => {
        it('should flip the point cloud across the y-axis', () => {
            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];
            const expectedOutput = [[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]];
            expect(flipPointCloud(pointCloud, 0)).toEqual(expectedOutput);
        });
    });

    describe('test_flip_z_axis', () => {
        it('should flip the point cloud across the z-axis', () => {
            const pointCloud = [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];
            const expectedOutput = [[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]];
            expect(flipPointCloud(pointCloud, 2)).toEqual(expectedOutput);
        });
    });

    describe('test_invalid_axis', () => {
        it('should throw an error when an invalid axis is provided', () => {
            const pointCloud = [[1.0, 2.0, 3.0]];
            expect(() => flipPointCloud(pointCloud, 3)).toThrow('Axis must be 0 (x-axis), 1 (y-axis), or 2 (z-axis).');
        });
    });

    describe('test_empty_point_cloud', () => {
        it('should handle an empty point cloud correctly', () => {
            const pointCloud = [];
            const expectedOutput = [];
            expect(flipPointCloud(pointCloud, 0)).toEqual(expectedOutput);
        });
    });
});

// Example implementation of flipPointCloud function for testing
function flipPointCloud(pointCloud, axis) {
    if (axis !== 0 && axis !== 1 && axis !== 2) {
        throw new Error("Axis must be 0 (x-axis), 1 (y-axis), or 2 (z-axis).");
    }

    const flipFactors = [1, 1, 1];
    flipFactors[axis] = -1;

    const flippedPointCloud = pointCloud.map(row => {
        return row.map((value, index) => value * flipFactors[index]);
    });

    return flippedPointCloud;
}

module.exports = { flipPointCloud };
```

### Explanation:
1. **Importing the Function**:
   - The `flipPointCloud` function is imported from the file `flipPointCloud.js`.

2. **Describe Blocks**:
   - Each test case is wrapped in a `describe` block to provide context.
   - Each test case is defined using `it` blocks with descriptive messages.

3. **Assertions**:
   - `expect` is used to assert the expected behavior of the function.
   - `toEqual` is used to check if the arrays are equal.
   - `toThrow` is used to check if the function throws the expected error message.

4. **Handling Invalid Axis**:
   - The `test_invalid_axis` test checks if the function throws an error when an invalid axis is provided.

5. **Empty Point Cloud**:
   - The `test_empty_point_cloud` test checks if the function handles an empty point cloud correctly.

This ensures that the Jest test suite maintains the functionality and logic of the original Python unittest class while adhering to Jest's syntax and conventions.