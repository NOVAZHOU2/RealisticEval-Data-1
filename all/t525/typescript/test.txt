Sure! Here's how you can convert your Python unittest test class to a TypeScript Jest test case:

```typescript
import { expect } from '@jest/globals';
import * as np from 'numpy';

describe('flipPointCloud', () => {
    it('should flip the point cloud across the x-axis', () => {
        const pointCloud = np.array([
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ]);
        const flippedPointCloud = flipPointCloud(pointCloud, 0);
        expect(flippedPointCloud).toEqual(np.array([
            [-1, 2, 3],
            [-4, 5, 6],
            [-7, 8, 9]
        ]));
    });

    it('should flip the point cloud across the y-axis', () => {
        const pointCloud = np.array([
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ]);
        const flippedPointCloud = flipPointCloud(pointCloud, 1);
        expect(flippedPointCloud).toEqual(np.array([
            [1, -2, 3],
            [4, -5, 6],
            [7, -8, 9]
        ]));
    });

    it('should flip the point cloud across the z-axis', () => {
        const pointCloud = np.array([
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ]);
        const flippedPointCloud = flipPointCloud(pointCloud, 2);
        expect(flippedPointCloud).toEqual(np.array([
            [1, 2, -3],
            [4, 5, -6],
            [7, 8, -9]
        ]));
    });
});
```

Please note that TypeScript does not have a direct equivalent to NumPy, so you might need to find or create a suitable library for handling arrays and mathematical operations in TypeScript. One popular choice is `mathjs`, which provides a comprehensive math library including support for matrices and arrays.

Here's an example using `mathjs`:

```typescript
import { expect } from '@jest/globals';
import { matrix, multiply, subtract } from 'mathjs';

function flipPointCloud(pointCloud: number[][], axis: number): number[][] {
    const m = matrix(pointCloud);
    const identityMatrix = matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]);
    const reflectionMatrix = identityMatrix.clone();
    reflectionMatrix.set([axis, axis], -1);

    return multiply(reflectionMatrix, m).toArray();
}

describe('flipPointCloud', () => {
    it('should flip the point cloud across the x-axis', () => {
        const pointCloud = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ];
        const flippedPointCloud = flipPointCloud(pointCloud, 0);
        expect(flippedPointCloud).toEqual([
            [-1, 2, 3],
            [-4, 5, 6],
            [-7, 8, 9]
        ]);
    });

    it('should flip the point cloud across the y-axis', () => {
        const pointCloud = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ];
        const flippedPointCloud = flipPointCloud(pointCloud, 1);
        expect(flippedPointCloud).toEqual([
            [1, -2, 3],
            [4, -5, 6],
            [7, -8, 9]
        ]);
    });

    it('should flip the point cloud across the z-axis', () => {
        const pointCloud = [
            [1, 2, 3],
            [4, 5, 6],
            [7, 8, 9]
        ];
        const flippedPointCloud = flipPointCloud(pointCloud, 2);
        expect(flippedPointCloud).toEqual([
            [1, 2, -3],
            [4, 5, -6],
            [7, 8, -9]
        ]);
    });
});
```

In this example, we use `mathjs` to handle the matrix operations, making the code more robust and easier to understand.