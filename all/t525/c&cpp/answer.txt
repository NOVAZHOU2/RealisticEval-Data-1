Sure! Below is the equivalent C++ code for the given Python function. This code uses the `Eigen` library for handling matrices, which is a popular choice for matrix operations in C++ similar to NumPy in Python.

First, you need to include the Eigen library in your project. You can download it from [here](http://eigen.tuxfamily.org/index.php?title=Main_Page) or use package managers like `vcpkg`.

Here's the C++ code:

```cpp
#include <iostream>
#include <Eigen/Dense>

using Eigen::MatrixXd;

// Function to flip the point cloud across a specified axis
MatrixXd flipPointCloud(const MatrixXd& pointCloud, int axis) {
    // Validate the axis input
    if (axis < 0 || axis > 2) {
        throw std::invalid_argument("Axis must be 0 (x-axis), 1 (y-axis), or 2 (z-axis).");
    }

    // Create a scaling factor vector with -1 for the specified axis and 1 for others
    VectorXd flipFactors(3);
    flipFactors << (axis != 0 ? 1 : -1), (axis != 1 ? 1 : -1), (axis != 2 ? 1 : -1);

    // Flip the point cloud by multiplying with the scaling factor vector
    MatrixXd flippedPointCloud = pointCloud.unaryExpr([flipFactors](double val, int row, int col) {
        return val * flipFactors(col);
    });

    return flippedPointCloud;
}

int main() {
    try {
        // Example usage
        MatrixXd pointCloud(4, 3); // 4 points, each with 3 coordinates
        pointCloud << 1, 2, 3,
                      4, 5, 6,
                      7, 8, 9,
                      10, 11, 12;

        int axis = 1; // Flip along the y-axis

        MatrixXd flippedPointCloud = flipPointCloud(pointCloud, axis);

        std::cout << "Flipped Point Cloud:\n" << flippedPointCloud << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Include Eigen Library**: The `#include <Eigen/Dense>` line includes the necessary Eigen headers.
2. **Function Definition**: The `flipPointCloud` function takes a `MatrixXd` (similar to a NumPy array) and an integer `axis`.
3. **Validation**: The function checks if the `axis` is within the valid range `[0, 1, 2]`.
4. **Scaling Factor Vector**: A `VectorXd` is created with `-1` for the specified axis and `1` for the other axes.
5. **Matrix Multiplication**: The point cloud is flipped by multiplying each column with the corresponding scaling factor using `unaryExpr`.
6. **Example Usage**: In the `main` function, an example point cloud is created and flipped along the y-axis (`axis = 1`).

This code should provide the same functionality as the original Python code but adapted to C++ using the Eigen library.