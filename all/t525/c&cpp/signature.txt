Certainly! Below is the equivalent C++ code for the given Python function, including the translation of the function signature, comments, and documentation into C++ standards. We will use the `Eigen` library for handling matrices, as it provides similar functionality to NumPy arrays.

### C++ Code

```cpp
#include <iostream>
#include <Eigen/Dense>
#include <stdexcept>

using Eigen::MatrixXd;

/**
 * Flip the point cloud across a specified axis.
 *
 * @param pointCloud A N x 3 matrix representing the 3D point cloud.
 * @param axis An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).
 * @return A N x 3 matrix of the flipped point cloud.
 */
MatrixXd flipPointCloud(const MatrixXd& pointCloud, int axis) {
    // Validate the axis input
    if (axis < 0 || axis > 2) {
        throw std::invalid_argument("Axis must be 0 (x-axis), 1 (y-axis), or 2 (z-axis).");
    }

    // Create a scaling factor vector with -1 for the specified axis and 1 for others
    VectorXd flipFactors(3);
    flipFactors << (axis != 0 ? 1 : -1), (axis != 1 ? 1 : -1), (axis != 2 ? 1 : -1);

    // Flip the point cloud by multiplying with the scaling factor vector
    MatrixXd flippedPointCloud = pointCloud.unaryExpr([flipFactors](double val, int row, int col) {
        return val * flipFactors(col);
    });

    return flippedPointCloud;
}

int main() {
    try {
        // Example usage
        MatrixXd pointCloud(4, 3); // 4 points, each with 3 coordinates
        pointCloud << 1, 2, 3,
                      4, 5, 6,
                      7, 8, 9,
                      10, 11, 12;

        int axis = 1; // Flip along the y-axis

        MatrixXd flippedPointCloud = flipPointCloud(pointCloud, axis);

        std::cout << "Flipped Point Cloud:\n" << flippedPointCloud << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Include Eigen Library**: The `#include <Eigen/Dense>` line includes the necessary Eigen headers.
2. **Using Eigen Types**: The `using Eigen::MatrixXd` line defines a shorthand for `MatrixXd`.
3. **Function Documentation**: The `/** ... */` block provides detailed documentation for the function, including parameters and return values.
4. **Function Definition**: The `flipPointCloud` function takes a `MatrixXd` and an integer `axis`.
5. **Validation**: The function checks if the `axis` is within the valid range `[0, 1, 2]`.
6. **Scaling Factor Vector**: A `VectorXd` is created with `-1` for the specified axis and `1` for the other axes.
7. **Matrix Multiplication**: The point cloud is flipped by multiplying each column with the corresponding scaling factor using `unaryExpr`.
8. **Example Usage**: In the `main` function, an example point cloud is created and flipped along the y-axis (`axis = 1`).

This code preserves the original functionality and structure of the Python code while adapting it to C++ standards and using the Eigen library for matrix operations.