Sure, here's how you can convert your Python unittest test class to a C++ Catch2 test case:

Firstly, let's assume that `translate_point_cloud` function is implemented in C++ and available for use in your C++ tests.

```cpp
#include <catch2/catch.hpp>
#include "your_translation_function.h" // Include the header where your function is declared

// Define the fixture if necessary
struct TranslationTest : Catch::TestSpec {
    TranslationTest() {
        // Setup any common resources here
    }

    ~TranslationTest() {
        // Cleanup any common resources here
    }
};

TEST_CASE_METHOD(TranslationTest, "Translate Point Cloud", "[translation]") {
    // Test data
    Eigen::MatrixXd pointCloud(3, 3);
    pointCloud << 1, 2, 3,
                   4, 5, 6,
                   7, 8, 9;

    Eigen::Vector3d translationVector(10, 11, 12);

    // Call the function
    Eigen::MatrixXd result = translatePointCloud(pointCloud, translationVector);

    // Expected result
    Eigen::MatrixXd expected(3, 3);
    expected << 11, 13, 15,
                 14, 16, 18,
                 17, 19, 21;

    // Check the result
    REQUIRE(result.isApprox(expected));
}

```

In this example, we're using Catch2's `TEST_CASE_METHOD` macro to create a test case within a fixture. We're also assuming that the `Eigen` library is used for matrix operations because it is commonly used with C++ when dealing with numerical computations like point clouds.

Make sure to replace `"your_translation_function.h"` with the actual path to your header file containing the implementation of `translatePointCloud`. Also, ensure that the `Eigen` library is included in your project.