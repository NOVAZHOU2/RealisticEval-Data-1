Here's how you could write your Python unittest test class in TypeScript using Jest:

```typescript
import { expect } from '@jest/globals';
import * as tf from '@tensorflow/tfjs-node';

function translatePointCloud(pointCloud: tf.Tensor2D, translationVector: tf.Tensor1D): tf.Tensor2D {
    return pointCloud.add(translationVector);
}

describe('translatePointCloud', () => {
    it('should translate a point cloud correctly', async () => {
        const pointCloud = tf.tensor2d([
            [0, 0, 0],
            [1, 1, 1]
        ]);

        const translationVector = tf.tensor1d([1, 2, 3]);

        const result = await translatePointCloud(pointCloud, translationVector).data();

        expect(result).toEqual([
            [1, 2, 3],
            [2, 3, 4]
        ]);
    });
});
```

Please note that in this example we're using TensorFlow.js (tfjs-node), which is an implementation of TensorFlow for Node.js. This allows us to use tensors and operations on them, similar to what you would do with NumPy arrays in Python. 

The `translatePointCloud` function takes two arguments, both of type `tf.Tensor`, performs element-wise addition, and returns the resulting tensor. The test case checks if the function correctly translates a point cloud by a given vector. It uses Jest's `expect` function to compare the expected output with the actual output. 

Also, keep in mind that the `await` keyword is used before calling `translatePointCloud` because it returns a promise due to the asynchronous nature of tensor computations in TensorFlow.js.