Here's how you can implement similar functionality in C++ using the standard library:

```cpp
#include <iostream>
#include <string>

enum class LogLevel {
    Debug,
    Info,
    Warning,
    Error
};

class Logger {
public:
    explicit Logger(const std::string& name, LogLevel level = LogLevel::Debug)
        : name(name), level(level) {}

    void log(LogLevel level, const std::string& message) {
        if (this->level <= level) {
            switch (level) {
                case LogLevel::Debug:
                    std::cout << "[DEBUG] " << name << ": " << message << std::endl;
                    break;
                case LogLevel::Info:
                    std::cout << "[INFO] " << name << ": " << message << std::endl;
                    break;
                case LogLevel::Warning:
                    std::cout << "[WARNING] " << name << ": " << message << std::endl;
                    break;
                case LogLevel::Error:
                    std::cerr << "[ERROR] " << name << ": " << message << std::endl;
                    break;
            }
        }
    }

private:
    std::string name;
    LogLevel level;
};
```

This C++ implementation defines an `enum` for different log levels and a `Logger` class that behaves similarly to your Python class. The `log` method checks if the current log level allows for the message to be logged before printing it to either `std::cout` or `std::cerr`. Note that error messages are sent to `std::cerr` by convention.