Certainly! Below is the equivalent C++ test class using the Catch2 testing framework. I will ensure that the functionality and logic of the tests are preserved, making any necessary adjustments for language differences between Python and C++, and using appropriate assertions in Catch2.

### C++ Code with Catch2 Testing Framework

First, ensure you have Catch2 installed. You can install it via your package manager or add it to your project manually.

For Ubuntu/Debian:
```sh
sudo apt-get install catch2
```

For macOS (using Homebrew):
```sh
brew install catch2
```

Here's the C++ code:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <iostream>
#include <memory>
#include <spdlog/spdlog.h>
#include <spdlog/sinks/stdout_color_sinks.h>

// Define logging levels for convenience
#define SPDLOG_LEVEL_DEBUG spdlog::level::debug
#define SPDLOG_LEVEL_INFO spdlog::level::info
#define SPDLOG_LEVEL_WARNING spdlog::level::warn
#define SPDLOG_LEVEL_ERROR spdlog::level::err
#define SPDLOG_LEVEL_CRITICAL spdlog::level::critical

/**
 * Logger class for logging messages.
 */
class Logger {
public:
    /**
     * Initializes a new logger instance.
     *
     * @param name Name of the logger, typically __name__ to reference the module name.
     * @param level Logging level, default is DEBUG.
     */
    Logger(const std::string& name, int level = SPDLOG_LEVEL_DEBUG) {
        // Create logger
        auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
        console_sink->set_pattern("[%H:%M:%S] [%n] [%^%l%$] [file: %s line: %#] - %v");

        // Set level
        switch (level) {
            case SPDLOG_LEVEL_DEBUG:
                console_sink->set_level(spdlog::level::debug);
                break;
            case SPDLOG_LEVEL_INFO:
                console_sink->set_level(spdlog::level::info);
                break;
            case SPDLOG_LEVEL_WARNING:
                console_sink->set_level(spdlog::level::warn);
                break;
            case SPDLOG_LEVEL_ERROR:
                console_sink->set_level(spdlog::level::err);
                break;
            case SPDLOG_LEVEL_CRITICAL:
                console_sink->set_level(spdlog::level::critical);
                break;
            default:
                console_sink->set_level(spdlog::level::debug); // Default to debug
                break;
        }

        // Initialize logger with the sink
        logger_ = std::make_shared<spdlog::logger>(name, console_sink);
        spdlog::register_logger(logger_);
        logger_->flush_on(spdlog::level::trace);
    }

    void log(int level, const std::string& message) {
        switch (level) {
            case SPDLOG_LEVEL_DEBUG:
                logger_->debug(message);
                break;
            case SPDLOG_LEVEL_INFO:
                logger_->info(message);
                break;
            case SPDLOG_LEVEL_WARNING:
                logger_->warn(message);
                break;
            case SPDLOG_LEVEL_ERROR:
                logger_->error(message);
                break;
            case SPDLOG_LEVEL_CRITICAL:
                logger_->critical(message);
                break;
            default:
                logger_->debug(message); // Default to debug
                break;
        }
    }

private:
    std::shared_ptr<spdlog::logger> logger_;
};

TEST_CASE("TestLogger", "[Logger]") {
    SECTION("Initialization") {
        const std::string logger_name = "TestLogger";
        Logger logger(logger_name);

        REQUIRE(logger.logger_->name() == logger_name);
        REQUIRE(logger.logger_->level() == spdlog::level::debug);
    }

    SECTION("Default Logging Level") {
        const std::string logger_name = "DefaultLogger";
        Logger logger(logger_name);

        REQUIRE(logger.logger_->level() == spdlog::level::debug);
    }

    SECTION("Console Handler Added") {
        const std::string logger_name = "TestLogger";
        Logger logger(logger_name);

        auto handlers = logger.logger_->sinks();
        REQUIRE(handlers.size() > 0);
        REQUIRE(std::dynamic_pointer_cast<spdlog::sinks::stdout_color_sink_mt>(handlers[0]) != nullptr);
    }
}

int main(int argc, char* argv[]) {
    // Run Catch2 tests
    int result = Catch::Session().run(argc, argv);
    return result;
}
```

### Explanation:
1. **Header Files**: The necessary header files are included at the beginning.
2. **Logger Class**: The `Logger` class is defined with a constructor and a `log` method.
3. **Catch2 Test Class**:
   - `TEST_CASE` macro defines the test suite.
   - `SECTION` macros define individual test cases.
4. **Initialization Test**:
   - Verifies that the logger is initialized with the correct name and level.
5. **Default Logging Level Test**:
   - Verifies that the logger defaults to DEBUG level if not specified.
6. **Console Handler Added Test**:
   - Verifies that the console handler is added to the logger.
7. **Main Function**: Runs the Catch2 tests.

### Compilation and Running Tests
To compile and run the tests, make sure to link against the `spdlog` and `Catch2` libraries:

```sh
g++ -o my_tests my_tests.cpp -lspdlog -lcatch2
./my_tests
```

This ensures that the `spdlog` and `Catch2` libraries are linked properly, allowing the program to use their functionalities and run the tests.