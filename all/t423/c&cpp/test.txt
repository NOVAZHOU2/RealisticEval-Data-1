To create an equivalent test class in C++ using Catch2, you'll need to define a fixture class that sets up the environment for your tests, such as creating temporary files. Below is the C++ code using Catch2 for the given Python function `write_unique_line_to_file`. Note that I've included the necessary setup for temporary files using the standard library facilities:

```cpp
#include <catch2/catch.hpp>
#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;

// Fixture class for setting up the test environment
class UniqueLineWriterTestFixture {
public:
    // Constructor creates a temporary file for testing
    UniqueLineWriterTestFixture() : tempFile("temp_test.txt") {
        // Clear the file if it exists before starting the test
        std::ofstream ofs(tempFile);
        ofs.close();
    }

    // Destructor removes the temporary file after the test
    ~UniqueLineWriterTestFixture() {
        fs::remove(tempFile);
    }

    const std::string& getTempFilename() const { return tempFile; }

private:
    std::string tempFile;
};

// Function to write a unique line to a file
void write_unique_line_to_file(const std::string& filename, const std::string& lineContent) {
    std::ifstream ifs(filename);
    std::string line;
    bool lineExists = false;

    while (std::getline(ifs, line)) {
        if (line == lineContent) {
            lineExists = true;
            break;
        }
    }
    ifs.close();

    if (!lineExists) {
        std::ofstream ofs(filename, std::ios_base::app);
        ofs << lineContent << '\n';
        ofs.close();
    }
}

TEST_CASE_METHOD(UniqueLineWriterTestFixture, "Test writing unique lines to a file", "[unique_line_writer]") {
    // Given a new file
    const std::string line1 = "First line";
    const std::string line2 = "Second line";

    // When writing the first line
    write_unique_line_to_file(getTempFilename(), line1);

    // Then the first line should be written
    REQUIRE(fs::exists(getTempFilename()));
    std::ifstream ifs(getTempFilename());
    std::string fileContent((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
    REQUIRE(fileContent.find(line1) != std::string::npos);

    // When writing the second line
    write_unique_line_to_file(getTempFilename(), line2);

    // Then both lines should be written
    ifs.clear(); // Clear EOF flag
    ifs.seekg(0); // Reset file position
    std::string updatedFileContent((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
    REQUIRE(updatedFileContent.find(line2) != std::string::npos);

    // When trying to write the first line again
    write_unique_line_to_file(getTempFilename(), line1);

    // Then the first line should still appear only once
    ifs.clear(); // Clear EOF flag
    ifs.seekg(0); // Reset file position
    std::string finalFileContent((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
    REQUIRE(std::count(finalFileContent.begin(), finalFileContent.end(), '\n') == 2);
}
```

In this example:
- A fixture class `UniqueLineWriterTestFixture` is used to set up and tear down the test environment.
- The `write_unique_line_to_file` function checks if the line already exists in the file before appending it.
- The test case verifies that the function behaves correctly by checking the file contents after each write operation.