Certainly! Below is the equivalent C++ code for the provided Python function `flatten`. This code will flatten a nested list into a single list, maintaining the same functionality and logic:

```cpp
#include <iostream>
#include <vector>

// Function to flatten a nested vector into a single vector
std::vector<int> flatten(const std::vector<std::vector<int>>& nested_list) {
    std::vector<int> flattened;  // Vector to hold the flattened elements

    // Helper function to recursively flatten the nested list
    void flattenHelper(const std::vector<std::vector<int>>& list, std::vector<int>& result) {
        for (const auto& element : list) {
            if (!element.empty()) {  // Check if the element is a non-empty sub-vector
                flattenHelper(element, result);  // Recursively flatten the nested list
            } else if (!list.empty()) {
                // If the element is not a sub-vector, append it directly
                for (const auto& item : list) {
                    result.push_back(item);
                }
            }
        }
    }

    flattenHelper(nested_list, flattened);
    return flattened;
}

int main() {
    // Example usage
    std::vector<std::vector<int>> nested_list = {{1, 2, {3}}, 4, {{5, 6}, 7}};
    std::vector<int> result = flatten(nested_list);

    // Output the flattened list
    for (int num : result) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Explanation:
1. **Function Definition**: The `flatten` function takes a nested list (represented as a vector of vectors) and returns a flattened version of it.
2. **Helper Function**: The `flattenHelper` function is a recursive helper function that processes each element of the nested list. If the element is another list (sub-vector), it calls itself recursively to flatten that sublist. Otherwise, it appends the element to the `flattened` vector.
3. **Main Function**: Demonstrates how to use the `flatten` function with an example nested list and prints the flattened result.

Note: In this example, the innermost elements are assumed to be integers (`int`). If you need to handle other types, you can modify the types accordingly.