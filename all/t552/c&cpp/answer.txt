Here is how you can implement the function in C++ using the STL library:

```cpp
#include <vector>
#include <algorithm>

bool areSetsEqual(std::vector<double> set1, std::vector<double> set2, double rtol = 1e-5, double atol = 1e-6) {
    // Sort both vectors
    sort(set1.begin(), set1.end());
    sort(set2.begin(), set2.end());

    // Check if sizes match
    if (set1.size() != set2.size()) return false;

    // Compare elements one by one
    for (size_t i = 0; i < set1.size(); ++i) {
        if (std::abs(set1[i] - set2[i]) > atol + rtol * std::max(std::abs(set1[i]), std::abs(set2[i]))) return false;
    }

    return true;
}
```

And here is an equivalent implementation in C:

```c
#include <stdlib.h>
#include <math.h>

int compare(const void* a, const void* b) {
    return (*(double*)a - *(double*)b);
}

int areSetsEqual(double* set1, int size1, double* set2, int size2, double rtol, double atol) {
    // Sort both arrays
    qsort(set1, size1, sizeof(double), compare);
    qsort(set2, size2, sizeof(double), compare);

    // Check if sizes match
    if (size1 != size2) return 0;

    // Compare elements one by one
    for (int i = 0; i < size1; ++i) {
        if (fabs(set1[i] - set2[i]) > atol + rtol * fmax(fabs(set1[i]), fabs(set2[i]))) return 0;
    }

    return 1;
}
```
Please note that the C version assumes that the input arrays `set1` and `set2` are already allocated with the correct size. If not, you need to allocate memory before calling these functions.