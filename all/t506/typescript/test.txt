Certainly! Here’s the equivalent TypeScript test class using Jest, ensuring that the functionality and logic of the tests are preserved. We will use Jest’s assertion methods to match the behavior of Python’s `unittest` framework.

First, let's define the `snakeToCamel` function in TypeScript:

```typescript
function snakeToCamel(snakeStr: string): string {
    // Split the snake_case string into words
    const words = snakeStr.split('_');
    // Capitalize the first letter of each word and join them
    const camelCaseStr = words.map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
    return camelCaseStr;
}
```

Now, let's write the Jest test class:

```typescript
import { describe, it, expect } from '@jest/globals';

describe('Test snakeToCamel', () => {
    it('test basic conversion', () => {
        // Test basic snake_case to CamelCase conversion
        expect(snakeToCamel("hello_world")).toBe("HelloWorld");
    });

    it('test conversion of a snake_case string with multiple words', () => {
        // Test conversion of a snake_case string with multiple words
        expect(snakeToCamel("this_is_a_test")).toBe("ThisIsATest");
    });

    it('test conversion with numbers in the string', () => {
        // Test conversion with numbers in the string
        expect(snakeToCamel("convert_this_123_string")).toBe("ConvertThis123String");
    });

    it('test conversion with leading and trailing underscores', () => {
        // Test conversion with leading and trailing underscores
        expect(snakeToCamel("_leading_and_trailing_")).toBe("LeadingAndTrailing");
        expect(snakeToCamel("___multiple___underscores___")).toBe("MultipleUnderscores");
    });

    it('test conversion of an empty string', () => {
        // Test conversion of an empty string
        expect(snakeToCamel("")).toBe("");
    });
});
```

### Explanation:
1. **Import Jest Testing Utilities**: Import `describe`, `it`, and `expect` from `@jest/globals`.
2. **Describe Block**: Use `describe` to group the tests under a descriptive name.
3. **It Block**: Use `it` to define individual test cases.
4. **Expect Assertions**: Use `expect` with various assertion methods like `toBe` to check the expected outcomes.

### Running the Tests:
To run these tests, you need to have Jest installed and configured in your project. Here’s how you can set up Jest if you haven’t already:

1. **Install Jest**:
   ```sh
   npm install --save-dev jest @types/jest ts-jest
   ```

2. **Configure Jest**:
   Add the following configuration to your `tsconfig.json` file:
   ```json
   {
     "compilerOptions": {
       "module": "commonjs",
       "esModuleInterop": true,
       "target": "es6",
       "moduleResolution": "node",
       "sourceMap": true,
       "outDir": "./dist",
       "baseUrl": "./src",
       "incremental": true,
       "strict": true,
       "jsx": "react"
     },
     "include": ["src/**/*"],
     "exclude": ["node_modules"]
   }
   ```

3. **Add Jest Configuration to `package.json`**:
   ```json
   {
     "scripts": {
       "test": "jest"
     },
     "jest": {
       "preset": "ts-jest",
       "testEnvironment": "node"
     }
   }
   ```

4. **Run the Tests**:
   ```sh
   npm test
   ```

This setup ensures that the tests are executed correctly and that the TypeScript code is properly transpiled and tested using Jest.