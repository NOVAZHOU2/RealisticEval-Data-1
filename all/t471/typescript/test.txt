Sure, here is how you can convert your Python `unittest` test class to a TypeScript test case using Jest:

```typescript
import { describe, it, expect } from '@jest/globals';
import { getRotation } from './path-to-your-function'; // Adjust the path accordingly
import * as np from 'numpy'; // Assuming you have a compatible npm package for numpy

describe('getRotation', () => {
  it('should correctly extract the rotation angle from a 2D affine transformation matrix', () => {
    const matrix = np.array([
      [1, 0, 0],
      [0, 1, 0],
      [0, 0, 1]
    ]);

    const result = getRotation(matrix);
    expect(result).toBeCloseTo(0); // Assuming the rotation should be 0 radians for the given identity matrix
  });

  it('should handle other matrices with known rotation angles', () => {
    const matrix = np.array([
      [Math.cos(Math.PI / 4), -Math.sin(Math.PI / 4), 0],
      [Math.sin(Math.PI / 4), Math.cos(Math.PI / 4), 0],
      [0, 0, 1]
    ]);

    const result = getRotation(matrix);
    expect(result).toBeCloseTo(Math.PI / 4); // Assuming the rotation should be Ï€/4 radians for the given matrix
  });
});
```

### Explanation:
1. **Importing Dependencies**: 
   - We use `@jest/globals` to access Jest's testing functions (`describe`, `it`, `expect`).
   - We import the function `getRotation` from your module.
   - We import `np` from a compatible npm package that provides functionalities similar to NumPy in JavaScript.

2. **Describe and It Blocks**:
   - `describe` block groups related tests together.
   - `it` blocks define individual test cases.

3. **Expectations**:
   - `expect(result).toBeCloseTo(expectedValue)` checks if the result is close enough to the expected value, considering floating-point precision issues.

Make sure you adjust the import paths according to where your function and dependencies are located. Also, ensure you have a compatible npm package for NumPy or implement equivalent functionality in TypeScript.