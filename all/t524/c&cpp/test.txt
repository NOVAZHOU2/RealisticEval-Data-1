Certainly! Below is the equivalent C++ test class using the Catch2 testing framework. The provided Python unittest class will be converted into a Catch2 test suite, ensuring that the functionality and logic of the tests are preserved.

### C++ Code with Catch2

First, make sure you have Catch2 installed. You can include Catch2 in your project by adding the header files and following the instructions from the [Catch2 GitHub repository](https://github.com/catchorg/Catch2).

Hereâ€™s the C++ code:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <Eigen/Dense>
#include <stdexcept>

// Function to scale a point cloud by a given factor
Eigen::MatrixXd scalePointCloud(const Eigen::MatrixXd& pointCloud, double scaleFactor) {
    // Validate input shape
    if (pointCloud.cols() != 3) {
        throw std::invalid_argument("pointCloud must be a 2D array with shape (N, 3)");
    }

    // Scale the point cloud by the given factor
    Eigen::MatrixXd scaledPointCloud = pointCloud * scaleFactor;

    return scaledPointCloud;
}

TEST_CASE("Test scaling of point clouds", "[scalePointCloud]") {
    SECTION("Test simple scaling") {
        Eigen::MatrixXd pointCloud(1, 3);
        pointCloud << 1.0, 2.0, 3.0;
        double scale_factor = 2.0;
        Eigen::MatrixXd expected_output(1, 3);
        expected_output << 2.0, 4.0, 6.0;

        REQUIRE((scalePointCloud(pointCloud, scale_factor)).isApprox(expected_output));
    }

    SECTION("Test multiple points scaling") {
        Eigen::MatrixXd pointCloud(2, 3);
        pointCloud << 1.0, 2.0, 3.0,
                      4.0, 5.0, 6.0;
        double scale_factor = 0.5;
        Eigen::MatrixXd expected_output(2, 3);
        expected_output << 0.5, 1.0, 1.5,
                           2.0, 2.5, 3.0;

        REQUIRE((scalePointCloud(pointCloud, scale_factor)).isApprox(expected_output));
    }

    SECTION("Test zero scaling") {
        Eigen::MatrixXd pointCloud(2, 3);
        pointCloud << 1.0, 2.0, 3.0,
                      4.0, 5.0, 6.0;
        double scale_factor = 0.0;
        Eigen::MatrixXd expected_output(2, 3);
        expected_output << 0.0, 0.0, 0.0,
                           0.0, 0.0, 0.0;

        REQUIRE((scalePointCloud(pointCloud, scale_factor)).isApprox(expected_output));
    }

    SECTION("Test negative scaling") {
        Eigen::MatrixXd pointCloud(1, 3);
        pointCloud << 1.0, 2.0, 3.0;
        double scale_factor = -2.0;
        Eigen::MatrixXd expected_output(1, 3);
        expected_output << -2.0, -4.0, -6.0;

        REQUIRE((scalePointCloud(pointCloud, scale_factor)).isApprox(expected_output));
    }
}
```

### Explanation:
1. **Header Files**:
   - `<catch2/catch_test_macros.hpp>`: For using Catch2 test macros.
   - `<Eigen/Dense>`: For using Eigen's dense matrix operations.
   - `<stdexcept>`: For throwing exceptions.

2. **Function Definition**:
   - `scalePointCloud`: This function takes a `Eigen::MatrixXd` (representing the point cloud) and a `double` (scaling factor) as inputs.
   - It checks if the point cloud has the correct shape (i.e., 2D array with 3 columns).
   - If the shape is incorrect, it throws a `std::invalid_argument`.
   - Otherwise, it scales the point cloud by the given factor and returns the result.

3. **Test Suite**:
   - `TEST_CASE`: Defines a test case named "Test scaling of point clouds".
   - Each `SECTION` within the test case represents a specific test scenario.
   - The `REQUIRE` macro is used to assert that the output of `scalePointCloud` matches the expected output using `isApprox` for floating-point comparisons.

4. **Assertions**:
   - `REQUIRE((scalePointCloud(pointCloud, scale_factor)).isApprox(expected_output))`: Checks if the scaled point cloud is approximately equal to the expected output.

This code ensures that the functionality and logic of the tests are preserved while adhering to C++ and Catch2 standards.