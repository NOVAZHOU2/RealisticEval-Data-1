Sure, here is how you can translate the provided Python unittest test class into a C++ Catch2 test case:

```cpp
#include <catch2/catch.hpp>
#include <vector>
#include <tuple>

// Function signature remains the same
std::vector<std::tuple<int, int>> bresenham_line(int x1, int y1, int x2, int y2);

TEST_CASE("Bresenham Line Algorithm", "[bresenham]")
{
    // Test Case 1
    SECTION("Line from (0, 0) to (3, 3)")
    {
        auto result = bresenham_line(0, 0, 3, 3);
        REQUIRE(result.size() == 4); // Should generate 4 points
        CHECK(result[0] == std::make_tuple(0, 0));
        CHECK(result[1] == std::make_tuple(1, 1));
        CHECK(result[2] == std::make_tuple(2, 2));
        CHECK(result[3] == std::make_tuple(3, 3));
    }

    // Test Case 2
    SECTION("Line from (0, 0) to (3, -3)")
    {
        auto result = bresenham_line(0, 0, 3, -3);
        REQUIRE(result.size() == 4); // Should generate 4 points
        CHECK(result[0] == std::make_tuple(0, 0));
        CHECK(result[1] == std::make_tuple(1, -1));
        CHECK(result[2] == std::make_tuple(2, -2));
        CHECK(result[3] == std::make_tuple(3, -3));
    }

    // Add more test cases as needed...
}
```

In this C++ code snippet:
- We include the `Catch2` header file.
- We define the `bresenham_line` function with the same signature as in your Python code.
- We create a `TEST_CASE` block named "Bresenham Line Algorithm" that groups multiple test sections together.
- Each `SECTION` represents a specific test case, such as drawing a line from `(0, 0)` to `(3, 3)` or `(3, -3)`.
- We use `REQUIRE` to ensure the number of points generated matches the expected count.
- We use `CHECK` to verify individual points in the generated line.

Make sure to compile your C++ code with Catch2 included. For example, if you're using g++, you might compile it like this:

```sh
g++ -std=c++17 -o test_bresenham test_bresenham.cpp -lc++abi
./test_bresenham
```

This will run your tests and provide output indicating whether they passed or failed.