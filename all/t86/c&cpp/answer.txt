Here is how you can convert the Python code into C++:

```C++
#include <vector>
#include <utility>

std::vector<std::pair<int, int>> bresenhamLine(int x1, int y1, int x2, int y2) {
    std::vector<std::pair<int, int>> line;
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;

    while(true){
        line.push_back(std::make_pair(x1, y1));
        if ((x1 == x2) && (y1 == y2)) break;
        int e2 = 2 * err;
        if (e2 > -dy){err -= dy; x1 += sx;}
        if (e2 < dx){err += dx; y1 += sy;}
    }
    
    return line;
}
```

And here is how it would look in C:

```C
#include <stdlib.h>
#include <stdbool.h>

typedef struct{
    int x;
    int y;
} Point;

Point* bresenhamLine(int x1, int y1, int x2, int y2, int *lineSize){
    int dx = abs(x2 - x1), dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;
    *lineSize = 0;

    // Calculate size of line array
    while(true){
        (*lineSize)++;
        if ((x1 == x2) && (y1 == y2)) break;
        int e2 = 2 * err;
        if (e2 > -dy){err -= dy; x1 += sx;}
        if (e2 < dx){err += dx; y1 += sy;}
    }

    Point *line = malloc(*lineSize * sizeof(Point));
    if (!line)
        return NULL;

    // Populate line array
    x1 = x2;
    y1 = y2;
    err = dx - dy;
    int i = 0;
    while(true){
        line[i].x = x1;
        line[i].y = y1;
        i++;
        if ((x1 == x2) && (y1 == y2)) break;
        int e2 = 2 * err;
        if (e2 > -dy){err -= dy; x1 += sx;}
        if (e2 < dx){err += dx; y1 += sy;}
    }

    return line;
}
```
The C version returns a dynamically allocated array of `Point` structures, so remember to free the memory when you're done with it. The `bresenhamLine` function also takes a pointer to an integer that will hold the size of the returned array.