Sure! Here's the JavaScript code converted to TypeScript:

```typescript
/**
 * Modify the ABC string by inserting the specified clef (e.g., "clef=bass") after the tone line (K: ),
 * or "bass" if no clef is specified.
 *
 * @param {string} abc - The ABC notation string.
 * @param {string} [clef="bass"] - The clef to set (default is "bass").
 * @returns {string} - The updated ABC notation string with the new clef.
 */
function changedClef(abc: string, clef: string = "bass"): string {
    const clefIndex = abc.indexOf("\nK:");

    // If the key signature is found
    if (clefIndex !== -1) {
        // Find the next newline character after the key signature line, or if none exists, use the end of the string
        const nextNewline = abc.indexOf("\n", clefIndex + 1);
        const endIndex = nextNewline === -1 ? abc.length : nextNewline;

        // Create the string to inject, which includes the clef
        const injection = ` clef=${clef}`;

        // Construct the new ABC string with the injected clef
        return `${abc.substring(0, endIndex)}${injection}${abc.substring(endIndex)}`;
    }

    // If the key signature is not found, return the original string
    return abc;
}
```

In this TypeScript version:
- Function parameters and return types are annotated with types.
- Variable types are inferred from their initial values, but explicit types can be added if needed.
- The logic remains the same as in the original JavaScript code.