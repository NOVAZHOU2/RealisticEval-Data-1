Certainly! Below is the equivalent Jest test suite for the given Python unittest class. The goal is to maintain the same functionality and logic while adapting to Jest's syntax and conventions.

### Python Code:
```python
import unittest
from typing import Tuple

def calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:
    if not (isinstance(point1, tuple) and isinstance(point2, tuple)):
        raise TypeError("Both points must be tuples")

    if not (len(point1) == 2 and len(point2) == 2):
        raise TypeError("Both points must be tuples of two elements")

    if not (all(isinstance(coord, (int, float)) for coord in point1) and
            all(isinstance(coord, (int, float)) for coord in point2)):
        raise TypeError("All coordinates must be integers or floats")

    x1, y1 = point1
    x2, y2 = point2

    dx = x2 - x1
    dy = y2 - y1

    return (dx ** 2 + dy ** 2) ** 0.5

class TestCalculateEuclideanDistance(unittest.TestCase):

    def test_basic_functionality(self):
        point1 = (0, 0)
        point2 = (3, 4)
        expected_distance = 5.0
        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, "Should calculate the distance correctly")

    def test_negative_coordinates(self):
        point1 = (-1, -1)
        point2 = (-4, -5)
        expected_distance = 5.0
        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, "Should handle negative coordinates correctly")

    def test_zero_distance(self):
        point1 = (2, 3)
        point2 = (2, 3)
        expected_distance = 0.0
        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, "Should return 0 when both points are the same")

    def test_large_coordinates(self):
        point1 = (1e6, 1e6)
        point2 = (1e6 + 3, 1e6 + 4)
        expected_distance = 5.0
        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, "Should handle large coordinates correctly")

    def test_invalid_input(self):
        with self.assertRaises(TypeError):
            calculate_euclidean_distance("invalid", (0, 0))

if __name__ == "__main__":
    unittest.main()
```

### Equivalent Jest Test Suite:

```javascript
// Import the function to be tested
const calculateEuclideanDistance = require('./calculateEuclideanDistance');

describe('TestCalculateEuclideanDistance', () => {
    it('should calculate the distance correctly', () => {
        const point1 = [0, 0];
        const point2 = [3, 4];
        const expectedDistance = 5.0;
        expect(calculateEuclideanDistance(point1, point2)).toBe(expectedDistance);
    });

    it('should handle negative coordinates correctly', () => {
        const point1 = [-1, -1];
        const point2 = [-4, -5];
        const expectedDistance = 5.0;
        expect(calculateEuclideanDistance(point1, point2)).toBe(expectedDistance);
    });

    it('should return 0 when both points are the same', () => {
        const point1 = [2, 3];
        const point2 = [2, 3];
        const expectedDistance = 0.0;
        expect(calculateEuclideanDistance(point1, point2)).toBe(expectedDistance);
    });

    it('should handle large coordinates correctly', () => {
        const point1 = [1e6, 1e6];
        const point2 = [1e6 + 3, 1e6 + 4];
        const expectedDistance = 5.0;
        expect(calculateEuclideanDistance(point1, point2)).toBe(expectedDistance);
    });

    it('should throw a TypeError for invalid input', () => {
        expect(() => calculateEuclideanDistance("invalid", [0, 0])).toThrow(TypeError);
    });
});

// calculateEuclideanDistance.js
module.exports = function calculateEuclideanDistance(point1, point2) {
    // Check if both points are arrays
    if (!Array.isArray(point1) || !Array.isArray(point2)) {
        throw new TypeError("Both points must be arrays");
    }

    // Check if both points have exactly two elements
    if (point1.length !== 2 || point2.length !== 2) {
        throw new TypeError("Both points must be arrays of two elements");
    }

    // Check if all coordinates are numbers
    if (!point1.every(coord => typeof coord === 'number') ||
        !point2.every(coord => typeof coord === 'number')) {
        throw new TypeError("All coordinates must be numbers");
    }

    // Extract coordinates from the input arrays
    const [x1, y1] = point1;
    const [x2, y2] = point2;

    // Compute differences and Euclidean distance using the Pythagorean theorem
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx ** 2 + dy ** 2);
};
```

### Explanation:
1. **Import Function**: The `calculateEuclideanDistance` function is imported from a separate file (`calculateEuclideanDistance.js`).
2. **Describe Block**: The `describe` block groups the tests together under a descriptive name.
3. **It Blocks**: Each `it` block represents a specific test case.
4. **Assertions**:
   - `expect(calculateEuclideanDistance(point1, point2)).toBe(expectedDistance)` is used to check if the calculated distance matches the expected distance.
   - `expect(() => calculateEuclideanDistance("invalid", [0, 0])).toThrow(TypeError)` is used to check if the function throws a `TypeError` for invalid input.
5. **Function Implementation**: The `calculateEuclideanDistance` function is implemented in a separate file (`calculateEuclideanDistance.js`) to keep the test file clean and focused on testing.

This conversion ensures that the functionality and logic of the tests are preserved while adapting to Jest's syntax and conventions.