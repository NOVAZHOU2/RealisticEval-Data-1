Below is the Python equivalent of the provided C++ code for a priority queue using a max-heap. In Python, we can utilize a list to maintain the heap, and the methods and structure will be adapted accordingly.
Python Code
python
class PriorityQueue:
    def __init__(self):
        self.heap = []  # This will store the elements of the heap

    # Helper function to get the index of the parent
    def parent(self, index):
        return (index - 1) // 2

    # Helper function to get the index of the left child
    def left_child(self, index):
        return 2 * index + 1

    # Helper function to get the index of the right child
    def right_child(self, index):
        return 2 * index + 2

    # Helper function to swap two elements in the heap
    def swap(self, a_index, b_index):
        self.heap[a_index], self.heap[b_index] = self.heap[b_index], self.heap[a_index]

    # Heapify up to maintain the max-heap property after insertion
    def heapify_up(self, index):
        while index > 0 and self.heap[self.parent(index)] < self.heap[index]:
            self.swap(self.parent(index), index)
            index = self.parent(index)

    # Heapify down to maintain the max-heap property after deletion
    def heapify_down(self, index):
        size = len(self.heap)
        largest = index
        left = self.left_child(index)
        right = self.right_child(index)

        if left < size and self.heap[left] > self.heap[largest]:
            largest = left
        if right < size and self.heap[right] > self.heap[largest]:
            largest = right
        if largest != index:
            self.swap(index, largest)
            self.heapify_down(largest)

    # Insert an element into the priority queue
    def push(self, value):
        self.heap.append(value)
        self.heapify_up(len(self.heap) - 1)

    # Remove the maximum element from the priority queue
    def pop(self):
        if self.is_empty():
            raise RuntimeError("Priority queue is empty")
        self.heap[0] = self.heap[-1]
        self.heap.pop()
        if not self.is_empty():
            self.heapify_down(0)

    # Get the maximum element without removing it
    def top(self):
        if self.is_empty():
            raise RuntimeError("Priority queue is empty")
        return self.heap[0]

    # Check if the priority queue is empty
    def is_empty(self):
        return len(self.heap) == 0

    # Get the size of the priority queue
    def size(self):
        return len(self.heap)

# Example usage:
if __name__ == "__main__":
    pq = PriorityQueue()
    pq.push(10)
    pq.push(5)
    pq.push(20)

    print("Top element:", pq.top())  # Should print 20
    pq.pop()
    print("Top element after pop:", pq.top())  # Should print 10
    print("Size of the queue:", pq.size())  # Should print 2
Explanation
Class Definition: The PriorityQueue class is defined, and its constructor initializes an empty list for the heap.
Helper Methods:
parent, left_child, and right_child methods compute the indices of the parent and child nodes in the heap.
The swap method swaps two elements in the heap based on their indices.
Heap Operations:
heapify_up: Maintains the max-heap property after inserting a new element.
heapify_down: Maintains the max-heap property after removing the top element.
Main Methods:
push: Inserts a new element into the heap and ensures the max-heap property is maintained.
pop: Removes the maximum element (the root) and maintains the heap structure.
top: Returns the maximum element without removing it.
is_empty and size: Utility methods to check if the queue is empty and to get the number of elements in the queue.
Example Usage: The example at the bottom shows how to use the PriorityQueue class.
This code faithfully replicates the behavior of the C++ version while adhering to Python conventions and practices.