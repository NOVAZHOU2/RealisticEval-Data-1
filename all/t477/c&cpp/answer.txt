Here is an example of how you could translate your Python function into C++:

```c++
#include <iostream>
#include <map>

// Define a template class that checks if a type can be treated as a map
template<typename T>
class CanClassToDict {
public:
    static bool value() {
        return false;
    }
};

// Specialize the template for std::map and std::unordered_map
template<typename K, typename V>
class CanClassToDict<std::map<K,V>> {
public:
    static bool value() {
        return true;
    }
};

template<typename K, typename V>
class CanClassToDict<std::unordered_map<K,V>> {
public:
    static bool value() {
        return true;
    }
};

int main() {
    // Test the function with different types
    std::cout << std::boolalpha; // Print boolean values as true/false instead of 1/0
    std::cout << "Can int to dict: " << CanClassToDict<int>::value() << std::endl;
    std::cout << "Can std::map<int,int> to dict: " << CanClassToDict<std::map<int,int>>::value() << std::endl;
    std::cout << "Can std::unordered_map<int,int> to dict: " << CanClassToDict<std::unordered_map<int,int>>::value() << std::endl;

    return 0;
}
```

This C++ code defines a template class `CanClassToDict` which has a static method `value()` returning a boolean indicating whether the given type can be treated as a dictionary. We then specialize this template for `std::map` and `std::unordered_map`, both of which can be considered dictionaries in C++. The `main()` function tests these specializations with different types.