Certainly! Below is the equivalent C++ test class using the Catch2 testing framework. This test class will ensure that the functionality and logic of the `prepare_query` function are preserved and tested appropriately.

First, make sure you have Catch2 installed and included in your project. You can include Catch2 via a header-only library or use a package manager like vcpkg.

Hereâ€™s the complete C++ code with the test class using Catch2:

### C++ Code with Catch2 Test Class

#### 1. Include Catch2 Header

Make sure to include the Catch2 header at the beginning of your file.

```cpp
#define CATCH_CONFIG_MAIN  // This tells Catch2 to provide a main() - only do this in one cpp file
#include <catch2/catch_test_macros.hpp>
#include <string>
#include <vector>
#include <map>
#include <regex>

// Function to prepare a SQL query string for libraries like asyncpg
std::pair<std::string, std::vector<std::string>> prepare_query(const std::string& sql, const std::map<std::string, std::string>& params) {
    // Find all occurrences of named parameters in the SQL string
    std::regex named_param_pattern("\\$(\\w+)");
    std::sregex_iterator begin(sql.begin(), sql.end(), named_param_pattern);
    std::sregex_iterator end;

    // Extract matches and remove duplicates while preserving order
    std::map<std::string, bool> unique_params_map;
    std::vector<std::string> unique_params;
    for (std::sregex_iterator i = begin; i != end; ++i) {
        std::smatch match = *i;
        std::string param = match.str(1);
        if (unique_params_map.find(param) == unique_params_map.end()) {
            unique_params_map[param] = true;
            unique_params.push_back(param);
        }
    }

    // Substitute each named parameter with its corresponding positional parameter
    for (size_t index = 1; index <= unique_params.size(); ++index) {
        std::string param = unique_params[index - 1];
        std::string pattern = "\\$" + param;
        sql = std::regex_replace(sql, std::regex(pattern), std::to_string(index));
    }

    // Prepare the vector of values corresponding to the order of the positional parameters
    std::vector<std::string> values;
    for (const auto& param : unique_params) {
        auto it = params.find(param);
        if (it != params.end()) {
            values.push_back(it->second);
        }
    }

    return {sql, values};
}

// Test class using Catch2
TEST_CASE("Test prepare_query function") {
    SECTION("Basic usage") {
        std::string sql = "SELECT * FROM users WHERE id = $user_id AND status = $status";
        std::map<std::string, std::string> params = {{"user_id", "42"}, {"status", "active"}};

        auto result = prepare_query(sql, params);

        REQUIRE(result.first == "SELECT * FROM users WHERE id = $1 AND status = $2");
        REQUIRE_THAT(result.second, Catch::Matchers::Equals(std::vector<std::string>{"42", "active"}));
    }

    SECTION("Missing parameters") {
        std::string sql = "SELECT * FROM users WHERE id = $user_id AND status = $status";
        std::map<std::string, std::string> params = {{"user_id", "42"}};

        auto result = prepare_query(sql, params);

        REQUIRE(result.first == "SELECT * FROM users WHERE id = $1 AND status = $2");
        REQUIRE_THAT(result.second, Catch::Matchers::Equals(std::vector<std::string>{"42"}));
    }

    SECTION("Duplicate parameters") {
        std::string sql = "SELECT * FROM users WHERE id = $user_id AND status = $status AND id = $user_id";
        std::map<std::string, std::string> params = {{"user_id", "42"}, {"status", "active"}};

        auto result = prepare_query(sql, params);

        REQUIRE(result.first == "SELECT * FROM users WHERE id = $1 AND status = $2 AND id = $1");
        REQUIRE_THAT(result.second, Catch::Matchers::Equals(std::vector<std::string>{"42", "active"}));
    }
}
```

### Explanation:
1. **Include Catch2**: The Catch2 header is included at the beginning of the file.
2. **Function Definition**: The `prepare_query` function is defined with the same logic as the Python version.
3. **Test Class**: The `TEST_CASE` macro is used to define a test case for the `prepare_query` function.
4. **Sections**: Each `SECTION` within the test case represents a different scenario or test case.
5. **Assertions**:
   - `REQUIRE`: Used to check that the modified SQL string is correct.
   - `REQUIRE_THAT`: Used with a matcher to check that the vector of parameter values is correct.

This setup ensures that the functionality and logic of the `prepare_query` function are thoroughly tested using the Catch2 testing framework.