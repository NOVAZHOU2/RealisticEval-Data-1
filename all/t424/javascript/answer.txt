Sure! Below is the equivalent JavaScript code that implements Dijkstra's algorithm with the same functionality, logic, and structure as the provided Python code:

```javascript
function dijkstra(graph, start) {
    /**
     * Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.
     *
     * Parameters:
     * - graph (object): An object representing the adjacency list of the graph. Each key is a node, and the value is an array of objects {neighbor, weight}.
     * - start: The starting node for the shortest path search.
     *
     * Returns:
     * - object: An object with the shortest distance from the start node to each node.
     */

    // Priority queue for the minimum distance nodes
    const queue = [];
    // Object to store the shortest path to each node
    const shortestPaths = {};
    for (const node in graph) {
        shortestPaths[node] = Infinity;
    }
    shortestPaths[start] = 0;

    // Push the starting node with distance 0 into the queue
    queue.push({ dist: 0, node: start });
    queue.sort((a, b) => a.dist - b.dist);

    while (queue.length > 0) {
        // Extract the node with the smallest distance
        const { dist, node } = queue.shift();

        // If the distance is greater than the recorded shortest path, skip processing
        if (dist > shortestPaths[node]) {
            continue;
        }

        // Explore neighbors
        for (const { neighbor, weight } of graph[node]) {
            const newDist = dist + weight;

            // Only consider this new path if it's better
            if (newDist < shortestPaths[neighbor]) {
                shortestPaths[neighbor] = newDist;
                // Add the new node to the queue and sort it
                queue.push({ dist: newDist, node: neighbor });
                queue.sort((a, b) => a.dist - b.dist);
            }
        }
    }

    return shortestPaths;
}

// Example usage:
const graph = {
    'A': [{ neighbor: 'B', weight: 1 }, { neighbor: 'C', weight: 4 }],
    'B': [{ neighbor: 'A', weight: 1 }, { neighbor: 'C', weight: 2 }, { neighbor: 'D', weight: 5 }],
    'C': [{ neighbor: 'A', weight: 4 }, { neighbor: 'B', weight: 2 }, { neighbor: 'D', weight: 1 }],
    'D': [{ neighbor: 'B', weight: 5 }, { neighbor: 'C', weight: 1 }]
};

console.log(dijkstra(graph, 'A'));
```

### Explanation:
- **Priority Queue**: In JavaScript, we use an array and keep it sorted to maintain the priority queue behavior.
- **Graph Representation**: The graph is represented as an object where each key is a node and the value is an array of objects containing `neighbor` and `weight`.
- **Sorting**: The queue is sorted after each insertion to ensure the node with the smallest distance is always at the front.
- **Shortest Paths**: We initialize the shortest paths object with `Infinity` for all nodes except the start node, which is set to `0`.

This JavaScript implementation maintains the same functionality, logic, and structure as the provided Python code.