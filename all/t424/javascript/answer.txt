Here is the equivalent JavaScript code:

```javascript
function dijkstra(graph, start) {
    let distances = {};
    Object.keys(graph).forEach(node => {
        distances[node] = Infinity;
    });
    distances[start] = 0;

    let priorityQueue = [[start, 0]];

    while (priorityQueue.length > 0) {
        let [currentNode, currentDistance] = priorityQueue.shift();
        
        if (currentDistance > distances[currentNode]) continue;

        graph[currentNode].forEach(neighbor => {
            let [nextNode, weight] = neighbor;
            let distance = currentDistance + weight;

            if (distance < distances[nextNode]) {
                distances[nextNode] = distance;
                priorityQueue.push([nextNode, distance]);
            }
        });

        // Sort the queue based on the distance
        priorityQueue.sort((a, b) => a[1] - b[1]);
    }

    return distances;
}
```

In this JavaScript function, we use an object `distances` to store the shortest distance from the start node to each node. We initialize it with `Infinity` for every node except for the start node which is initialized with `0`. 

Then we use a priority queue implemented using an array `priorityQueue` to keep track of the nodes that need to be processed. Initially, only the start node is added to the priority queue with its distance set to `0`.

Inside the loop, we take out the node with the smallest distance from the front of the priority queue. If its distance is greater than what we have stored for it, then we skip it. Otherwise, we check its neighbors and update their distances if a shorter path is found. Then we add them to the priority queue.

Finally, we sort the priority queue based on the distance before continuing with the next iteration. This ensures that the node with the smallest distance is always processed first.