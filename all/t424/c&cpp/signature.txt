```cpp
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <queue>
#include <utility> // For std::pair

/**
 * Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.
 * 
 * @param graph An unordered_map representing the adjacency list of the graph. Each key is a node, and the value is a vector of pairs (neighbor, weight).
 * @param start The starting node for the shortest path search.
 * 
 * @return An unordered_map with the shortest distance from the start node to each node.
 */
std::unordered_map<std::string, int> dijkstra(const std::unordered_map<std::string, std::vector<std::pair<std::string, int>>>& graph, const std::string& start) {
    // Initialize distances map with infinite distances for all nodes except the start node
    std::unordered_map<std::string, int> distances;
    for (const auto& node : graph) {
        distances[node.first] = INT_MAX; // Use INT_MAX to represent infinity
    }
    distances[start] = 0;

    // Priority queue to store nodes sorted by their current distance from the start node
    std::priority_queue<std::pair<int, std::string>, std::vector<std::pair<int, std::string>>, std::greater<>> pq;
    pq.push({0, start});

    while (!pq.empty()) {
        std::string current = pq.top().second;
        pq.pop();

        // Explore neighbors of the current node
        for (const auto& neighbor_pair : graph.at(current)) {
            std::string neighbor = neighbor_pair.first;
            int weight = neighbor_pair.second;

            // Calculate tentative distance through the current node
            int new_distance = distances[current] + weight;

            // If this path is shorter, update the distance and push it to the priority queue
            if (new_distance < distances[neighbor]) {
                distances[neighbor] = new_distance;
                pq.push({new_distance, neighbor});
            }
        }
    }

    return distances;
}
```

This C++ version preserves the original purpose and structure of the Python function, including the use of a priority queue for Dijkstra's algorithm. The Python type annotations and comments have been converted to C++ comments and types, ensuring clarity and correctness.