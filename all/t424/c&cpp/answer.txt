Here is the equivalent C++ code for your Python function using priority queue:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

typedef pair<int, string> pii;
typedef unordered_map<string, vector<pii>> Graph;

unordered_map<string, int> dijkstra(Graph &graph, string start) {
    unordered_map<string, int> dist;
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    
    // Initialize distances to infinity
    for(auto it = graph.begin(); it != graph.end(); ++it)
        dist[it->first] = INT_MAX;
        
    dist[start] = 0;
    pq.push({0, start});
    
    while(!pq.empty()) {
        auto curr = pq.top();
        pq.pop();
        
        for(auto neighbor : graph[curr.second]) {
            if(dist[neighbor.first] > dist[curr.second] + neighbor.second) {
                dist[neighbor.first] = dist[curr.second] + neighbor.second;
                pq.push({dist[neighbor.first], neighbor.first});
            }
        }
    }
    
    return dist;
}

int main() {
    Graph g;
    g["A"] = {{ "B", 1 }, { "C", 4 }};
    g["B"] = {{ "A", 1 }, { "C", 2 }, { "D", 5 }};
    g["C"] = {{ "A", 4 }, { "B", 2 }, { "D", 1 }};
    g["D"] = {{ "B", 5 }, { "C", 1 }};
    
    unordered_map<string, int> result = dijkstra(g, "A");
    
    for(auto it = result.begin(); it != result.end(); ++it)
        cout << "Distance from 'A' to '" << it->first << "' is " << it->second << endl;
    
    return 0;
}
```

This C++ code uses an unordered map to represent the graph, where each key-value pair represents a node and its neighbors respectively. The neighbors are represented as pairs of strings (representing the neighboring node) and integers (representing the edge weights).

The `dijkstra` function then calculates the shortest paths from the start node to all other nodes using Dijkstra's algorithm, and returns these shortest distances in another unordered map.

Note that unlike Python, C++ does not have built-in support for dictionaries or priority queues. Therefore, we use standard library containers like `std::unordered_map` and `std::priority_queue`.