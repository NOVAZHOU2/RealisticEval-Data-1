Here is the equivalent Java code:

```java
import java.util.*;

public class Answer {
    public static Map<String, Integer> dijkstra(Map<String, List<Map.Entry<String, Integer>>> graph, String start) {
        Set<String> visited = new HashSet<>();
        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(Comparator.comparingInt(Map.Entry::getValue));
        Map<String, Integer> dist = new HashMap<>();

        for (String s : graph.keySet()) {
            if (s.equals(start)) {
                dist.put(s, 0);
                pq.offer(new AbstractMap.SimpleEntry<>(s, 0));
            } else {
                dist.put(s, Integer.MAX_VALUE);
                pq.offer(new AbstractMap.SimpleEntry<>(s, Integer.MAX_VALUE));
            }
        }

        while (!pq.isEmpty()) {
            Map.Entry<String, Integer> entry = pq.poll();
            String u = entry.getKey();
            int d = entry.getValue();

            if (visited.contains(u)) continue;

            visited.add(u);

            for (Map.Entry<String, Integer> neighbor : graph.get(u)) {
                String v = neighbor.getKey();
                int w = neighbor.getValue();

                if (!visited.contains(v) && dist.get(u) + w < dist.get(v)) {
                    dist.put(v, dist.get(u) + w);
                    pq.removeIf(e -> e.getKey().equals(v));
                    pq.offer(new AbstractMap.SimpleEntry<>(v, dist.get(v)));
                }
            }
        }

        return dist;
    }
}
```

This Java code does the same thing as your Python code. It uses a priority queue to implement Dijkstra's algorithm. Please note that Java doesn't support negative weights on edges because it would break the correctness of Dijkstra's algorithm.