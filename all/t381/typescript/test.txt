Sure, here's how you can convert your Python unittest test class into a TypeScript Jest test case:

```typescript
// Assuming the function is defined in a file named utils.ts
import { extractEmailDetails } from './utils';

describe('extractEmailDetails', () => {
  it('should extract username and domain from valid email', () => {
    const result = extractEmailDetails("xxx@gmail.com");
    expect(result).toEqual(['xxx', 'gmail.com']);
  });

  it('should handle different domain formats', () => {
    const result1 = extractEmailDetails("user@domain.co.uk");
    const result2 = extractEmailDetails("another_user@sub.domain.net");

    expect(result1).toEqual(['user', 'domain.co.uk']);
    expect(result2).toEqual(['another_user', 'sub.domain.net']);
  });

  it('should throw error for invalid email format', () => {
    expect(() => extractEmailDetails("invalid-email")).toThrowError();
    expect(() => extractEmailDetails("noatsign.com")).toThrowError();
    expect(() => extractEmailDetails("@nodomain.com")).toThrowError();
  });
});
```

In this example, I've assumed that the `extractEmailDetails` function is exported from a file named `utils.ts`. The Jest `describe` block groups related tests together, while the `it` blocks define individual test cases.

The `expect` function is used to assert that the output of the `extractEmailDetails` function matches the expected result. If the assertion fails, Jest will provide a detailed error message indicating what went wrong.

Note that TypeScript does not have built-in support for regular expressions like Python, so you may need to implement additional validation logic if your function requires it.