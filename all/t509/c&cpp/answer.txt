Certainly! Below is the equivalent C++ code for the given Python function, ensuring that the functionality, logic, and structure remain consistent:

```cpp
#include <iostream>
#include <stdexcept>

// Function to perform modular exponentiation: (base^exponent) % modulus efficiently.
long long mod_exp(long long base, long long exponent, long long modulus) {
    if (modulus <= 0) {
        throw std::invalid_argument("Modulus must be a positive integer.");
    }

    long long result = 1;
    base = base % modulus;  // Ensure base is within the modulus

    while (exponent > 0) {
        // If exponent is odd, multiply the base with the result
        if (exponent % 2 == 1) {
            result = (result * base) % modulus;
        }

        // Right shift the exponent by 1 (equivalent to exponent //= 2)
        exponent >>= 1;
        // Square the base
        base = (base * base) % modulus;
    }

    return result;
}

// Function to test the mod_exp function
void test_mod_exp() {
    try {
        std::cout << "Testing mod_exp(2, 3, 5): " << mod_exp(2, 3, 5) << std::endl;  // Should output 3
        std::cout << "Testing mod_exp(7, 4, 13): " << mod_exp(7, 4, 13) << std::endl;  // Should output 9
        std::cout << "Testing mod_exp(5, 0, 17): " << mod_exp(5, 0, 17) << std::endl;  // Should output 1
        std::cout << "Testing mod_exp(3, 5, -1): ";
        mod_exp(3, 5, -1);  // Should throw an exception
    } catch (const std::invalid_argument& e) {
        std::cout << "Caught exception: " << e.what() << std::endl;
    }
}

int main() {
    test_mod_exp();
    return 0;
}
```

### Explanation:
1. **Function Definition**: The `mod_exp` function is defined to perform modular exponentiation.
2. **Error Handling**: The function throws a `std::invalid_argument` if the modulus is not positive.
3. **Loop Logic**: The loop logic remains the same, including the checks for odd exponents and right-shifting the exponent.
4. **Type Declarations**: The types `long long` are used for `base`, `exponent`, and `modulus` to handle large numbers.
5. **Testing**: A `test_mod_exp` function is included to verify the correctness of the implementation with some test cases.