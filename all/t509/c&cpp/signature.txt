Sure, here is the equivalent C++ function signature with comments:

```cpp
/**
 * Perform modular exponentiation: (base^exponent) % modulus efficiently.
 *
 * @param base The base value.
 * @param exponent The exponent value (should be non-negative).
 * @param modulus The modulus value (should be positive).
 * @return The result of (base^exponent) % modulus.
 */
int mod_exp(int base, int exponent, int modulus);
```

This C++ function signature maintains the same purpose and parameters as your original Python function. It uses `int` for all parameter types and return type, which should work well for typical use cases where the values do not exceed the limits of a standard integer in C++. If you expect very large numbers that might exceed the range of `int`, you would need to use a larger data type or implement arbitrary-precision arithmetic.