Certainly! Below is the equivalent C++ code for the given Python function, including the translation of comments and docstrings into C++ style comments:

```cpp
#include <iostream>
#include <stdexcept>

/**
 * Perform modular exponentiation: (base^exponent) % modulus efficiently.
 *
 * @param base The base value.
 * @param exponent The exponent value (should be non-negative).
 * @param modulus The modulus value (should be positive).
 * @return The result of (base^exponent) % modulus.
 * @throws std::invalid_argument If modulus is less than or equal to zero.
 */
long long mod_exp(long long base, long long exponent, long long modulus) {
    if (modulus <= 0) {
        throw std::invalid_argument("Modulus must be a positive integer.");
    }

    long long result = 1;
    base = base % modulus;  // Ensure base is within the modulus

    while (exponent > 0) {
        // If exponent is odd, multiply the base with the result
        if (exponent % 2 == 1) {
            result = (result * base) % modulus;
        }

        // Right shift the exponent by 1 (equivalent to exponent //= 2)
        exponent >>= 1;
        // Square the base
        base = (base * base) % modulus;
    }

    return result;
}

// Function to test the mod_exp function
void test_mod_exp() {
    try {
        std::cout << "Testing mod_exp(2, 3, 5): " << mod_exp(2, 3, 5) << std::endl;  // Should output 3
        std::cout << "Testing mod_exp(7, 4, 13): " << mod_exp(7, 4, 13) << std::endl;  // Should output 9
        std::cout << "Testing mod_exp(5, 0, 17): " << mod_exp(5, 0, 17) << std::endl;  // Should output 1
        std::cout << "Testing mod_exp(3, 5, -1): ";
        mod_exp(3, 5, -1);  // Should throw an exception
    } catch (const std::invalid_argument& e) {
        std::cout << "Caught exception: " << e.what() << std::endl;
    }
}

int main() {
    test_mod_exp();
    return 0;
}
```

### Explanation:
1. **Function Definition**: The `mod_exp` function is defined to perform modular exponentiation.
2. **Docstring Comments**: The Python docstring is converted into a C++ multi-line comment using `/** */`.
3. **Single-Line Comments**: Single-line comments are preserved using `//`.
4. **Type Annotations**: The Python type annotations (`int`) are translated into C++ types (`long long` for handling larger integers).
5. **Error Handling**: The function throws a `std::invalid_argument` if the modulus is not positive.
6. **Testing**: A `test_mod_exp` function is included to verify the correctness of the implementation with some test cases.

This ensures that the functionality, logic, and structure of the original Python code are preserved in the C++ version.