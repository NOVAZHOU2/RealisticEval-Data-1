To convert the given Python unittest test class to a C++ Catch2 test case, we first need to implement the `is_point_on_line` function in C++. Then, we can write the corresponding test cases using Catch2.

Here's how you can do it:

1. **Implement the `is_point_on_line` function in C++**:

```cpp
#include <vector>
#include <cmath>

bool is_point_on_line(const std::vector<int>& A, const std::vector<int>& B, const std::vector<int>& C) {
    // Calculate the area of the triangle formed by points A, B, and C
    int area = 0.5 * std::abs(A[0]*(B[1] - C[1]) + B[0]*(C[1] - A[1]) + C[0]*(A[1] - B[1]));
    
    // If the area is zero, then the points are collinear
    return area == 0;
}
```

2. **Write the Catch2 test cases**:

```cpp
#define CATCH_CONFIG_MAIN
#include "catch.hpp"

TEST_CASE("Check if point is on line", "[point-on-line]") {
    REQUIRE(is_point_on_line({0, 0}, {1, 1}, {2, 2}) == true);  // Points are collinear
    REQUIRE(is_point_on_line({0, 0}, {1, 1}, {3, 4}) == false); // Points are not collinear
    REQUIRE(is_point_on_line({-1, 0}, {1, 0}, {0, 0}) == true); // Points are collinear
    REQUIRE(is_point_on_line({-1, 0}, {1, 0}, {-1, 1}) == false); // Points are not collinear
    REQUIRE(is_point_on_line({0, 0}, {0, 0}, {0, 0}) == true);   // Same point considered as collinear
}

int main() {
    return Catch::Session().run();
}
```

### Explanation:

1. **Function Implementation**:
   - The `is_point_on_line` function calculates the area of the triangle formed by the three points.
   - If the area is zero, the points are collinear, meaning point `C` lies on the line formed by points `A` and `B`.

2. **Catch2 Test Cases**:
   - We define a test case named "Check if point is on line" with several sub-tests.
   - Each `REQUIRE` statement checks if the function returns the expected result for different sets of input points.
   - The `main` function runs the Catch2 tests.

This setup ensures that your C++ code has a similar testing structure to your original Python unittest code.