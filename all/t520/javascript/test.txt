Certainly! Below is the equivalent Jest test suite for the given Python unittest class. The goal is to maintain the same functionality and logic while adapting to Jest's syntax and conventions.

### Python Code:
```python
import unittest

class TestComputeOutputIndex(unittest.TestCase):

    def test_standard_case(self):
        """Test with two standard positive integers."""
        idx_1 = 3  # binary: 11
        idx_2 = 5  # binary: 101
        expected = 6  # 3 XOR 5 = 6
        result = compute_output_index(idx_1, idx_2)
        self.assertEqual(result, expected)

    def test_identical_indices(self):
        """Test with identical indices (should return 0)."""
        idx_1 = 7  # binary: 111
        idx_2 = 7  # binary: 111
        expected = 0  # 7 XOR 7 = 0
        result = compute_output_index(idx_1, idx_2)
        self.assertEqual(result, expected)

    def test_zero_index(self):
        """Test with one index as zero."""
        idx_1 = 0  # binary: 0
        idx_2 = 5  # binary: 101
        expected = 5  # 0 XOR 5 = 5
        result = compute_output_index(idx_1, idx_2)
        self.assertEqual(result, expected)

    def test_large_numbers(self):
        """Test with large integer values."""
        idx_1 = 1024  # binary: 10000000000
        idx_2 = 2048  # binary: 100000000000
        expected = 3072  # 1024 XOR 2048 = 3072
        result = compute_output_index(idx_1, idx_2)
        self.assertEqual(result, expected)
```

### JavaScript Code (Using Jest):

```javascript
// Import the computeOutputIndex function
const computeOutputIndex = require('./computeOutputIndex');

describe('TestComputeOutputIndex', () => {
    it('test_standard_case', () => {
        // Test with two standard positive integers
        const idx_1 = 3;  // binary: 11
        const idx_2 = 5;  // binary: 101
        const expected = 6;  // 3 XOR 5 = 6
        const result = computeOutputIndex(idx_1, idx_2);
        expect(result).toEqual(expected);
    });

    it('test_identical_indices', () => {
        // Test with identical indices (should return 0)
        const idx_1 = 7;  // binary: 111
        const idx_2 = 7;  // binary: 111
        const expected = 0;  // 7 XOR 7 = 0
        const result = computeOutputIndex(idx_1, idx_2);
        expect(result).toEqual(expected);
    });

    it('test_zero_index', () => {
        // Test with one index as zero
        const idx_1 = 0;  // binary: 0
        const idx_2 = 5;  // binary: 101
        const expected = 5;  // 0 XOR 5 = 5
        const result = computeOutputIndex(idx_1, idx_2);
        expect(result).toEqual(expected);
    });

    it('test_large_numbers', () => {
        // Test with large integer values
        const idx_1 = 1024;  // binary: 10000000000
        const idx_2 = 2048;  // binary: 100000000000
        const expected = 3072;  // 1024 XOR 2048 = 3072
        const result = computeOutputIndex(idx_1, idx_2);
        expect(result).toEqual(expected);
    });
});
```

### Explanation:
1. **Import the Function**:
   - The `computeOutputIndex` function is imported using `require` (or `import` if using ES modules).

2. **Describe Block**:
   - The `describe` block is used to group the tests under a single test suite named `TestComputeOutputIndex`.

3. **It Blocks**:
   - Each `it` block represents a specific test case.
   - The descriptions within the `it` blocks are similar to the docstrings in the Python unittest class.

4. **Assertions**:
   - The `expect` function is used to make assertions.
   - `toEqual` is used to check equality, which is equivalent to `assertEqual` in Python's `unittest`.

This Jest test suite maintains the same functionality and logic as the original Python unittest class, ensuring that all assertions are properly mapped to Jest equivalents.