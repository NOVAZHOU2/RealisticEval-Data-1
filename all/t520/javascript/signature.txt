Certainly! Below is the equivalent JavaScript code with the function signature and comments rewritten to conform to JSDoc standards:

```javascript
/**
 * Computes the output index from two given indices in the MultiVector's representation
 * of the G_n orthonormal basis.
 *
 * This function interprets the integers as little-endian bitstrings, takes their XOR,
 * and interprets the result as an integer in little-endian.
 *
 * @param {number} idx1 - Input index 1.
 * @param {number} idx2 - Input index 2.
 * @returns {number} The computed output index.
 */
function computeOutputIndex(idx1, idx2) {
    // Perform bitwise XOR between the two indices
    let result = idx1 ^ idx2;

    // Convert result to little-endian byte representation
    let resultBytes = new Uint8Array((result.toString(2).length + 7) / 8);
    for (let i = 0; i < resultBytes.length; i++) {
        resultBytes[i] = result & 0xff;
        result >>= 8;
    }

    // Convert little-endian bytes back to an integer
    let resultInt = 0;
    for (let byte of resultBytes) {
        resultInt = (resultInt << 8) | byte;
    }

    return resultInt;
}
```

### Explanation:
1. **JSDoc Comments**:
   - The Python docstring is converted to JSDoc comments.
   - The `@param` tags specify the parameters and their types.
   - The `@returns` tag specifies the return type and description.

2. **Function Signature**:
   - The Python function `def compute_output_index(idx_1: int, idx_2: int) -> int:` is translated to `function computeOutputIndex(idx1, idx2)` in JavaScript.

3. **Implementation**:
   - The bitwise XOR operation `idx1 ^ idx2` remains the same.
   - The conversion to little-endian byte representation uses a `Uint8Array`.
   - The conversion back to an integer is done by iterating over the `Uint8Array`.

This JavaScript code preserves the functionality, logic, and structure of the original Python code while adhering to JSDoc standards for documentation.