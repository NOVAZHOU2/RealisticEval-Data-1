Sure! Below is the equivalent C++ code for the provided Python function `bits_to_bytes`.

```cpp
#include <vector>
#include <iostream>

std::vector<unsigned char> bits_to_bytes(const std::vector<int>& bits) {
    std::vector<unsigned char> bytes;
    size_t num_bits = bits.size();
    
    // Calculate the number of full bytes we can form
    size_t num_full_bytes = num_bits / 8;
    
    for (size_t i = 0; i < num_full_bytes; ++i) {
        unsigned char byte = 0;
        
        // Compose the byte from the bits
        for (int j = 0; j < 8; ++j) {
            byte |= static_cast<unsigned char>(bits[i * 8 + j] << (7 - j));
        }
        
        bytes.push_back(byte);
    }
    
    return bytes;
}

int main() {
    std::vector<int> bits = {1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0};
    std::vector<unsigned char> bytes = bits_to_bytes(bits);
    
    for (unsigned char byte : bytes) {
        std::cout << static_cast<int>(byte) << " ";
    }
    
    return 0;
}
```

### Explanation:

1. **Function Definition**:
   - The function `bits_to_bytes` takes a vector of integers (`bits`) as input and returns a vector of unsigned characters (`bytes`).

2. **Calculate Number of Full Bytes**:
   - We calculate the number of full bytes that can be formed from the input bits using integer division (`num_bits / 8`).

3. **Form Full Bytes**:
   - For each full byte, we initialize an unsigned character `byte` to 0.
   - We then iterate over the 8 bits for each byte, shifting them into place and OR-ing them with the `byte`.
   - Each fully composed byte is added to the `bytes` vector.

4. **Main Function**:
   - A sample `main` function demonstrates how to use the `bits_to_bytes` function.
   - It prints the resulting bytes to the console.

This C++ code achieves the same functionality as the provided Python function, converting an array of binary bits to an array of bytes while discarding any incomplete byte at the end if the total number of bits is not a multiple of 8.