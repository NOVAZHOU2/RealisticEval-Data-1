Sure! Here is the equivalent C++ code for your Python function:

```cpp
#include <iostream>
#include <string>
#include <unordered_map>

std::string minWindow(std::string s, std::string t) {
    // Count frequency of each character in t
    std::unordered_map<char, int> targetCount;
    for (char c : t) {
        targetCount[c]++;
    }

    // Initialize variables
    int required = targetCount.size();
    int formed = 0;
    std::unordered_map<char, int> windowCounts;

    int left = 0, right = 0;
    int ansLen = INT_MAX, ansLeft = -1;

    while (right < s.length()) {
        char c = s[right];
        windowCounts[c]++;

        if (targetCount.find(c) != targetCount.end() && windowCounts[c] == targetCount[c]) {
            formed++;
        }

        // Try and contract the window till the point where it ceases to be 'desirable'
        while (left <= right && formed == required) {
            char d = s[left];

            // Save the smallest window until now
            if (ansLen > right - left + 1) {
                ansLen = right - left + 1;
                ansLeft = left;
            }

            windowCounts[d]--;
            if (targetCount.find(d) != targetCount.end() && windowCounts[d] < targetCount[d]) {
                formed--;
            }

            left++;
        }
        right++;
    }

    return ansLen == INT_MAX ? "" : s.substr(ansLeft, ansLen);
}

int main() {
    std::string s = "ADOBECODEBANC";
    std::string t = "ABC";
    std::cout << minWindow(s, t) << std::endl;  // Output should be "BANC"
    return 0;
}
```

### Explanation:
- **targetCount**: This map keeps track of the count of each character in the string `t`.
- **required**: This variable counts how many unique characters need to be matched.
- **formed**: This variable counts how many unique characters have been matched so far.
- **windowCounts**: This map keeps track of the count of each character in the current window of `s`.
- **left** and **right**: These pointers represent the sliding window on the string `s`.
- **ansLen** and **ansLeft**: These store the length and starting index of the minimum window found.

The function iterates through the string `s`, expanding the window to include characters from `t` and contracting the window when possible to find the smallest valid window. Finally, it returns the minimum window substring or an empty string if no such substring exists.