Certainly! Below is the equivalent Jest test suite for the given Python unittest class. The goal is to maintain the same functionality and logic while adapting to Jest's syntax and assertion methods.

### Python Code:
```python
import unittest
import numpy as np

def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:
    """
    Calculates the Euclidean distance between two agents based on their coordinates in the observations.

    :param agent1: String representation of agent1's identifier.
    :param agent2: String representation of agent2's identifier.
    :param observations: Dictionary containing observation question with agent identifiers as keys.
                         Each value is a dictionary with 'x' and 'y' keys representing coordinates.
    :return: Euclidean distance between the two agents.
    """
    # Extract coordinates of both agents
    x1, y1 = observations[agent1]['x'], observations[agent1]['y']
    x2, y2 = observations[agent2]['x'], observations[agent2]['y']

    # Calculate the Euclidean distance
    distance = np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)

    return distance

class TestCalculateDistance(unittest.TestCase):

    def test_same_point(self):
        # Both agents are at the same point
        observations = {
            "agent1": {"x": 0, "y": 0},
            "agent2": {"x": 0, "y": 0}
        }
        self.assertAlmostEqual(calculate_distance("agent1", "agent2", observations), 0.0)

    def test_horizontal_distance(self):
        # Agents are horizontally apart
        observations = {
            "agent1": {"x": 0, "y": 0},
            "agent2": {"x": 3, "y": 0}
        }
        self.assertAlmostEqual(calculate_distance("agent1", "agent2", observations), 3.0)

    def test_vertical_distance(self):
        # Agents are vertically apart
        observations = {
            "agent1": {"x": 0, "y": 0},
            "agent2": {"x": 0, "y": 4}
        }
        self.assertAlmostEqual(calculate_distance("agent1", "agent2", observations), 4.0)

    def test_diagonal_distance(self):
        # Agents are diagonally apart
        observations = {
            "agent1": {"x": 1, "y": 2},
            "agent2": {"x": 4, "y": 6}
        }
        expected_distance = np.sqrt((4 - 1) ** 2 + (6 - 2) ** 2)
        self.assertAlmostEqual(calculate_distance("agent1", "agent2", observations), expected_distance)

    def test_negative_coordinates(self):
        # Agents have negative coordinates
        observations = {
            "agent1": {"x": -1, "y": -1},
            "agent2": {"x": -4, "y": -5}
        }
        expected_distance = np.sqrt((-4 + 1) ** 2 + (-5 + 1) ** 2)
        self.assertAlmostEqual(calculate_distance("agent1", "agent2", observations), expected_distance)
```

### Equivalent Jest Test Suite:

```javascript
const { calculateDistance } = require('./path/to/calculateDistance');

describe('TestCalculateDistance', () => {
    it('should calculate the distance when both agents are at the same point', () => {
        const observations = {
            "agent1": { x: 0, y: 0 },
            "agent2": { x: 0, y: 0 }
        };
        expect(calculateDistance("agent1", "agent2", observations)).toBeCloseTo(0.0);
    });

    it('should calculate the horizontal distance', () => {
        const observations = {
            "agent1": { x: 0, y: 0 },
            "agent2": { x: 3, y: 0 }
        };
        expect(calculateDistance("agent1", "agent2", observations)).toBeCloseTo(3.0);
    });

    it('should calculate the vertical distance', () => {
        const observations = {
            "agent1": { x: 0, y: 0 },
            "agent2": { x: 0, y: 4 }
        };
        expect(calculateDistance("agent1", "agent2", observations)).toBeCloseTo(4.0);
    });

    it('should calculate the diagonal distance', () => {
        const observations = {
            "agent1": { x: 1, y: 2 },
            "agent2": { x: 4, y: 6 }
        };
        const expectedDistance = Math.sqrt(Math.pow(4 - 1, 2) + Math.pow(6 - 2, 2));
        expect(calculateDistance("agent1", "agent2", observations)).toBeCloseTo(expectedDistance);
    });

    it('should calculate the distance with negative coordinates', () => {
        const observations = {
            "agent1": { x: -1, y: -1 },
            "agent2": { x: -4, y: -5 }
        };
        const expectedDistance = Math.sqrt(Math.pow(-4 + 1, 2) + Math.pow(-5 + 1, 2));
        expect(calculateDistance("agent1", "agent2", observations)).toBeCloseTo(expectedDistance);
    });
});
```

### Explanation:
1. **Importing the Function**:
   - The `calculateDistance` function is imported from the appropriate module.

2. **Describe Block**:
   - The `describe` block groups the tests under a descriptive name (`TestCalculateDistance`).

3. **It Blocks**:
   - Each `it` block represents a specific test case.
   - The descriptions within each `it` block match the purpose of the corresponding Python test method.

4. **Assertions**:
   - The `expect` function is used to make assertions.
   - `toBeCloseTo` is used instead of `assertAlmostEqual` to handle floating-point comparisons.

5. **Test Data**:
   - The test data and expected results are structured similarly to the Python tests.

This Jest test suite maintains the same functionality and logic as the original Python unittest class, ensuring that all assertions are appropriately mapped to Jest equivalents.