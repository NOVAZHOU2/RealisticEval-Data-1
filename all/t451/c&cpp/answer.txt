Sure! Hereâ€™s the equivalent C++ code for converting an image to a binary representation using the C++ Imaging Library (CImg). If you don't have CImg installed, you can install it or use another library like OpenCV, but for this example, we'll stick with CImg.

First, make sure you have CImg installed. You can download it from [here](http://cimg.eu/).

Here's the translated C++ code:

```cpp
#include <iostream>
#include <vector>
#include <CImg.h>

using namespace std;
using namespace cimg_library;

vector<int> convert_image_to_bits(const char* image_path) {
    /**
     * Converts an image to a binary representation.
     *
     * Args:
     *     image_path (const char*): The file path of the image to convert.
     *
     * Returns:
     *     vector<int>: A vector of bits representing the image, where 1 is for white pixels
     *                  and 0 is for black pixels.
     */
    CImg<unsigned char> image(image_path);
    image.resize(image.width(), image.height(), 1, 1, 1); // Convert to grayscale
    image.normalize(0, 255); // Normalize the image values between 0 and 255

    vector<int> bits_array;

    int w = image.width();
    int h = image.height();

    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            unsigned char pixel = image(x, y);
            int bit = (pixel == 255) ? 1 : 0;
            bits_array.push_back(bit);
        }
    }

    return bits_array;
}

int main() {
    const char* image_path = "path/to/your/image.jpg";
    vector<int> bits = convert_image_to_bits(image_path);

    // Print the bits for demonstration
    for (int bit : bits) {
        cout << bit << " ";
    }

    return 0;
}
```

### Explanation:
1. **Header Files**: 
   - We include `iostream` for input/output operations.
   - We include `vector` for using vectors.
   - We include `CImg.h` from the CImg library for image processing.

2. **Using Directives**:
   - We use `using namespace std;` for standard C++ libraries.
   - We use `using namespace cimg_library;` for the CImg library.

3. **Function Definition**:
   - The function `convert_image_to_bits` takes the path of the image as a `const char*` argument.
   - It loads the image using `CImg<unsigned char> image(image_path);`.
   - It converts the image to grayscale and normalizes the pixel values to be between 0 and 255.
   - It iterates over each pixel and appends the binary value (1 for white, 0 for black) to the `bits_array`.

4. **Main Function**:
   - The `main` function demonstrates how to call the `convert_image_to_bits` function and prints the resulting bits.

This should give you a working C++ equivalent of the provided Python code.