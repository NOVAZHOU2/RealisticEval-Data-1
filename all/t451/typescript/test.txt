Certainly! Here is the equivalent TypeScript code for the provided Python function along with a Jest test suite to verify its correctness.

### TypeScript Function

First, let's define the TypeScript function `convertImageToBits`:

```typescript
import Jimp from 'jimp';

/**
 * Converts an image to a binary representation.
 * Convert the image to black and white mode, that is, each pixel is represented by only 1 bit,
 * with a white pixel value of 255 and a black pixel value of 0.
 *
 * @param {string} imagePath - The file path of the image to convert.
 * @returns {Promise<number[]>} A promise that resolves to a list of bits representing the image,
 *                              where 1 is for white pixels and 0 is for black pixels.
 */
async function convertImageToBits(imagePath: string): Promise<number[]> {
  const image = await Jimp.read(imagePath);
  image.grayscale();
  image.threshold(128);

  const width = image.bitmap.width;
  const height = image.bitmap.height;

  const bitsArray: number[] = [];

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const pixel = image.getPixelColor(x, y);
      const bit = Jimp.intToRGBA(pixel).r === 255 ? 1 : 0;
      bitsArray.push(bit);
    }
  }

  return bitsArray;
}

export default convertImageToBits;
```

### Jest Test Suite

Next, let's create a Jest test suite to verify the correctness of the `convertImageToBits` function. We will assume that you have a sample image file named `sample-image.jpg` for testing purposes.

```typescript
import convertImageToBits from './convertImageToBits'; // Import the function from the previous file

describe('convertImageToBits', () => {
  it('should convert an image to a binary representation', async () => {
    const imagePath = 'path/to/sample-image.jpg';
    const expectedBits = [1, 1, 1, 1, 1, 1, 1, 1]; // Example expected bits array

    const bits = await convertImageToBits(imagePath);

    expect(bits).toEqual(expectedBits); // Use Jest's toEqual assertion to compare arrays
  });

  it('should handle invalid image paths', async () => {
    const invalidImagePath = 'path/to/nonexistent-image.jpg';

    await expect(convertImageToBits(invalidImagePath)).rejects.toThrow();
  });
});

// Example usage
(async () => {
  try {
    const bits = await convertImageToBits('path/to/sample-image.jpg');
    console.log(bits);
  } catch (error) {
    console.error('Error converting image:', error);
  }
})();
```

### Explanation:

1. **Importing Jimp**: We import the `Jimp` library to handle image processing.
2. **Function Definition**: The `convertImageToBits` function is defined with the appropriate type signatures and JSDoc comments.
3. **Loading the Image**: We use `Jimp.read` to load the image asynchronously.
4. **Converting to Grayscale and Thresholding**: We convert the image to grayscale and then apply a threshold to get a binary image.
5. **Iterating Over Pixels**: We iterate over each pixel and extract the red channel value (which is the same for all channels in a grayscale image).
6. **Appending Bits**: We append either 1 or 0 based on the pixel value.
7. **Jest Test Suite**: We define a Jest test suite with two test cases:
   - The first test case verifies that the function correctly converts an image to a binary representation.
   - The second test case checks that the function handles invalid image paths gracefully by throwing an error.
8. **Example Usage**: An example usage is provided at the end to demonstrate how to call the function asynchronously.

This setup ensures that the functionality and logic of the tests are preserved, and the necessary type annotations and Jest assertions are included.