#include <stdio.h>
#include <stdlib.h>

struct Node {
    int val;
    struct Node* next;
} typedef Node;

struct Queue {
    Node* head;
    Node* tail;
} typedef Queue;

typedef enum {true = 1, false = 0} bool;

void enqueue(Queue* queue, int val);
bool contains(Queue* queue, int val);
int dequeue(Queue* queue);
void print(Queue* queue);
void freeAll(Queue* queue);

/// Enqueues an element to the back of the `Queue`.
/// This is operation takes `O(1)` time
void enqueue(Queue* queue, int val) {
    Node* node = malloc(sizeof(Node));
    node->val = val;
    node->next = NULL;
    
    if (queue->head == NULL) {
        queue->head = node;
        queue->tail = node;
    } else {
        queue->tail->next = node;
        queue->tail = node;
    }
}

/// Checks if the queue contains a certain value.
/// This is an `O(n)` operation
///
/// # Params
/// 
/// - `queue` a `Queue` pointer of the queue to check
/// - `val` an `int` representing the value to check
/// 
/// # Returns
/// `1` if the value is found
/// `0` if the queue is empty or the value is not found
bool contains(Queue* queue, int val) {
    if (queue->head == NULL) {
        return false;
    }
    Node* cursor = queue->head;
    while (cursor != NULL) {
        if (cursor->val == val) {
            return true;
        } else {
            cursor = cursor->next;
        }
    }
    return false;
}

/// Removes an element from the front of the `Queue` and returns its value.
/// This operation takes `O(1)` time
int dequeue(Queue* queue) {
    // the q is empty
    if (queue->head == NULL) {
        return 0;
    }
    int val = queue->head->val;
    queue->head = queue->head->next;

    return val;
}

/// Peeks into the front of a `Queue` and return it's value without dequeuing it
/// This operation takes `O(1)` time
int peek(Queue* queue) {
    // the q is empty
    if (queue->head == NULL) {
        return 0;
    }
    
    return queue->head->val;
}

/// prints the queue in `O(n) time
void print(Queue* queue) {
    // this way i create a pointer that is pointing to the same value as head
    Node* cursor = queue->head; 
    int idx = 0;
    while (cursor != NULL) {
        printf("queue[%d] = %d\n", idx, cursor->val);
        cursor = cursor->next;
        idx++;
    }
}

/// frees all the memory allocated by the queue
void freeAll(Queue* queue) {
    Node* current = queue->head;
    while (current != NULL) {
        Node* next = current->next;
        free(current);
        current = next;
    }
}

// some random testing generated by chatGPT
int main() {
    Queue *queue = (Queue *)malloc(sizeof(Queue));
    queue->head = NULL;
    queue->tail = NULL;

    enqueue(queue, 10);
    enqueue(queue, 20);
    enqueue(queue, 30);

    printf("Queue after enqueue:\n");
    print(queue);

    printf("Value peeked: %d\n", peek(queue));

    printf("Queue after peek:\n");
    print(queue);

    printf("Dequeue: %d\n", dequeue(queue));
    printf("Queue after dequeue:\n");
    print(queue);

    printf("Is 20 in the queue? %s\n", contains(queue, 20) ? "Yes" : "No");
    printf("Is 40 in the queue? %s\n", contains(queue, 40) ? "Yes" : "No");

    freeAll(queue);
    free(queue);

    return 0;
}