Here is the equivalent C++ code for your Python function:

```cpp
#include <vector>
#include <utility>

bool isPointInPolygon(const std::pair<double, double>& point, const std::vector<std::pair<double, double>>& polygon)
{
    int n = polygon.size();
    bool result = false;
    
    for(int i = 0, j = n-1; i < n; j = i++)
    {
        if(((polygon[i].second > point.second) != (polygon[j].second > point.second)) &&
           (point.first < (polygon[j].first - polygon[i].first) * (point.second - polygon[i].second) / (polygon[j].second - polygon[i].second) + polygon[i].first))
            result = !result;
    }
    return result;
}
```

And here is the equivalent C code for your Python function:

```c
#include <stdbool.h>

bool is_point_in_polygon(double x, double y, double* poly_x, double* poly_y, int num_points) {
    int i, j;
    bool result = false;

    for(i = 0, j = num_points-1; i < num_points; j = i++) {
        if((poly_y[i] > y) != (poly_y[j] > y) && 
           (x < (poly_x[j]-poly_x[i])*(y-poly_y[i])/(poly_y[j]-poly_y[i])+poly_x[i])) 
            result = !result;
    }

    return result;
}
```
Note that in C and C++, you need to pass an array or pointer to the x and y coordinates of the polygon's vertices, along with the number of points in the polygon. In Python, these details are handled automatically by the function definition. Also note that the C/C++ versions use `double` instead of `float` for the coordinate values, because `float` may not provide enough precision for some calculations.