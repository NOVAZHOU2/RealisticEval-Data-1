Certainly! Below is the TypeScript version of your JavaScript function with type annotations:

```typescript
/**
 * Sorts an array of objects alphabetically based on a specified field.
 *
 * @param {Array<T>} array - The array of objects to sort.
 * @param {keyof T} field - The field of the objects to sort by.
 * @param {boolean} [ascending=true] - If true, sort in ascending order; if false, sort in descending order.
 * @returns {Array<T>} - The sorted array of objects.
 */
function sortByField<T>(array: T[], field: keyof T, ascending: boolean = true): T[] {
    return array.sort((a, b) => {
        const aValue = a[field];
        const bValue = b[field];

        if (typeof aValue === 'string' && typeof bValue === 'string') {
            return ascending ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
        }

        // Handle other data types or provide appropriate sorting logic for those types
        return 0;
    });
}
```

### Explanation:
1. **Type Parameters**: 
   - `T` is used to represent the generic type of the objects in the array.

2. **Type Annotations**:
   - `array: T[]`: Indicates that the input array should be an array of objects of type `T`.
   - `field: keyof T`: Ensures that the `field` parameter must be a key of the object type `T`.
   - `ascending: boolean = true`: Specifies that the `ascending` parameter is optional and defaults to `true`.

3. **Sorting Logic**:
   - The `sort` method is used to sort the array. Inside the comparator function, it checks if both values (`aValue` and `bValue`) are strings and uses `localeCompare` for string comparison. For other types, you may need to add additional logic depending on how you want to handle them.

This TypeScript function now includes type safety and will help catch errors at compile time if there are mismatches between the provided parameters and their expected types.