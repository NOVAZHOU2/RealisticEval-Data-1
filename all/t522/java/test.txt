Here's how you can convert your Python unittest test class to a Java JUnit test case:

```java
import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class Tester {

    @Test
    public void testRotatePointCloud() {
        // Assuming we have a method to generate random point clouds and calculate the expected result
        double[][] pointCloud = generateRandomPointCloud();
        double rotationAngle = Math.PI / 4; // 45 degrees in radians

        // Call the method to be tested
        double[][] rotatedPointCloud = rotatePointCloud(pointCloud, rotationAngle);

        // Check if the results are as expected
        for (int i = 0; i < pointCloud.length; i++) {
            assertEquals("Mismatch at index " + i, expectedValueX[i], rotatedPointCloud[i][0], 0.001);
            assertEquals("Mismatch at index " + i, expectedValueY[i], rotatedPointCloud[i][1], 0.001);
            assertEquals("Mismatch at index " + i, expectedValueZ[i], rotatedPointCloud[i][2], 0.001);
        }
    }

    private double[][] generateRandomPointCloud() {
        // Implement this method to generate a random point cloud
        return new double[10][3]; // Replace with actual implementation
    }

    private double[][] rotatePointCloud(double[][] pointCloud, double rotationAngle) {
        // Implement this method to rotate the point cloud
        return new double[pointCloud.length][3]; // Replace with actual implementation
    }

    private double[] expectedValueX = { /* Expected values */ };
    private double[] expectedValueY = { /* Expected values */ };
    private double[] expectedValueZ = { /* Expected values */ };
}
```

Please note that you need to replace `generateRandomPointCloud`, `rotatePointCloud`, and the `expectedValueX`, `expectedValueY`, and `expectedValueZ` arrays with the actual implementations from your Python code. Also, ensure that the `rotation_angle` parameter is correctly converted to radians before passing it to the `rotatePointCloud` method.