Hereâ€™s how you can convert the provided TypeScript formatBytes function to Python:
TypeScript Code
typescript
function formatBytes(
    bytes: number,
    options: { decimals?: number; sizeType?: "accurate" | "normal" } = {}
): string {
    const { decimals = 0, sizeType = "normal" } = options;

    const sizeUnits = sizeType === "accurate"
        ? ["Bytes", "KiB", "MiB", "GiB", "TiB"]
        : ["Bytes", "KB", "MB", "GB", "TB"];

    if (bytes === 0) return "0 Byte";
    const unitIndex = Math.floor(Math.log(bytes) / Math.log(1024));
    const formattedSize = (bytes / Math.pow(1024, unitIndex)).toFixed(decimals);

    return `${formattedSize} ${sizeUnits[unitIndex] || "Bytes"}`;
}
Python Code
python
import math
from typing import Optional, Dict

def format_bytes(bytes: int, options: Optional[Dict[str, Optional[int]]] = None) -> str:
    if options is None:
        options = {}

    decimals = options.get('decimals', 0)
    size_type = options.get('sizeType', 'normal')

    size_units = ["Bytes", "KiB", "MiB", "GiB", "TiB"] if size_type == "accurate" else ["Bytes", "KB", "MB", "GB", "TB"]

    if bytes == 0:
        return "0 Byte"

    unit_index = math.floor(math.log(bytes, 1024)) if bytes > 0 else 0
    formatted_size = f"{bytes / (1024 ** unit_index):.{decimals}f}"

    return f"{formatted_size} {size_units[unit_index] if unit_index < len(size_units) else 'Bytes'}"
Explanation of Changes
Imports:
The math module is imported to use the logarithm and floor functions.
Optional and Dict from typing are imported for type hinting.
Function Signature:
The function is defined as format_bytes, matching Python's naming convention (snake_case).
The bytes parameter is typed as int, and the options parameter is typed as an optional dictionary that can include decimals and sizeType.
Default Values:
Default values for decimals and sizeType are handled using options.get(...) which provides a fallback if the keys are not present.
Size Units Selection:
The selection of size units is done using a conditional expression similar to TypeScript.
Zero Handling:
If bytes is zero, the function returns "0 Byte".
Unit Index Calculation:
The unit index is calculated using math.log(bytes, 1024), which is a more direct way to compute logarithm with a specific base.
Formatted Size:
The formatted size is created using formatted string literals (f-strings), allowing for easy control over the number of decimal places.
Return Statement:
The return statement constructs the final output string using an f-string, ensuring proper handling of unit indexing.
This Python function replicates the functionality of the original TypeScript function while adhering to Python conventions and best practices. You can use this function directly in your Python code!