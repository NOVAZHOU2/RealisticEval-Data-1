Sure, here's the equivalent C++ code for the provided Python function:

```cpp
#include <vector>
#include <iostream>

std::vector<int> perform_polynomial_decryption(int degree, int modulus, const std::vector<int>& key, const std::vector<int>& encrypted_data) {
    // Assuming the implementation of the decryption logic here.
    // For demonstration purposes, we'll just return an empty vector.
    std::vector<int> decrypted_question;
    
    // Replace the following with actual decryption logic.
    for (size_t i = 0; i < encrypted_data.size(); ++i) {
        int decrypted_value = (encrypted_data[i] * key[i]) % modulus;
        decrypted_question.push_back(decrypted_value);
    }
    
    return decrypted_question;
}

int main() {
    int degree = 2; // Example degree
    int modulus = 13; // Example modulus
    std::vector<int> key = {5, 7}; // Example key
    std::vector<int> encrypted_data = {8, 10}; // Example encrypted data
    
    std::vector<int> decrypted_question = perform_polynomial_decryption(degree, modulus, key, encrypted_data);
    
    std::cout << "Decrypted Question: ";
    for (int value : decrypted_question) {
        std::cout << value << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

This C++ code defines a function `perform_polynomial_decryption` that takes the same parameters as your Python function and returns a vector of integers representing the decrypted question.

In the `main` function, we demonstrate how to call `perform_polynomial_decryption` with example values and print the result.

Please note that you need to replace the placeholder decryption logic inside the function with the actual algorithm you intend to implement. This example simply multiplies corresponding elements of the key and encrypted data vectors and then applies the modulus operation.