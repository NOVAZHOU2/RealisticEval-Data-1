Certainly! Here’s the equivalent Jest test suite in TypeScript, ensuring that the functionality and logic of the tests are preserved. We will use Jest’s assertion methods to match the behavior of Python’s `unittest` framework.

First, let's define the `squaredEuclideanDistance` function in TypeScript:

```typescript
/**
 * Computes the squared Euclidean distance between two vectors.
 *
 * @param vec1 - The first vector.
 * @param vec2 - The second vector.
 * @returns The squared Euclidean distance between vec1 and vec2.
 * @throws {Error} If the vectors are of different lengths.
 */
function squaredEuclideanDistance(vec1: number[], vec2: number[]): number {
    if (vec1.length !== vec2.length) {
        throw new Error("Vectors must be of the same length");
    }

    const distanceSquared = vec1.reduce((acc, curr, index) => {
        const diff = curr - vec2[index];
        return acc + diff * diff;
    }, 0);

    return distanceSquared;
}
```

Next, we’ll write the Jest test suite:

```typescript
import { squaredEuclideanDistance } from './path-to-squared-euclidean-distance';

describe('SquaredEuclideanDistance', () => {
    describe('test_standard_vectors', () => {
        it('should calculate the squared distance correctly for typical vectors', () => {
            const vec1 = [1, 2, 3];
            const vec2 = [4, 5, 6];
            const expectedResult = 27; // (3^2 + 3^2 + 3^2)
            const result = squaredEuclideanDistance(vec1, vec2);
            expect(result).toBe(expectedResult);
        });
    });

    describe('test_vectors_with_zeros', () => {
        it('should handle vectors that include zero values', () => {
            const vec1 = [0, 0, 0];
            const vec2 = [0, 0, 0];
            const expectedResult = 0;
            const result = squaredEuclideanDistance(vec1, vec2);
            expect(result).toBe(expectedResult);
        });
    });

    describe('test_vectors_with_negative_values', () => {
        it('should handle vectors that include negative values', () => {
            const vec1 = [-1, -2, -3];
            const vec2 = [-4, -5, -6];
            const expectedResult = 27; // (3^2 + 3^2 + 3^2)
            const result = squaredEuclideanDistance(vec1, vec2);
            expect(result).toBe(expectedResult);
        });
    });

    describe('test_single_element_vectors', () => {
        it('should handle single element vectors', () => {
            const vec1 = [5];
            const vec2 = [-5];
            const expectedResult = 100; // (10^2)
            const result = squaredEuclideanDistance(vec1, vec2);
            expect(result).toBe(expectedResult);
        });
    });
});
```

### Explanation:
1. **Import Statement**:
   - Import the `squaredEuclideanDistance` function from the appropriate module.

2. **Describe Blocks**:
   - Use `describe` blocks to group related tests together.
   - Each `it` block represents a specific test case.

3. **Assertion Methods**:
   - Use Jest’s `expect` and `toBe` methods to assert the expected results.

4. **Test Cases**:
   - Each test case is structured similarly to the Python `unittest` test cases, ensuring that the functionality and logic are preserved.

### Running the Tests:
To run the tests, you can use the following command in your project directory:

```sh
npm test
```

This setup ensures that the tests are written in TypeScript and use Jest’s assertion methods to validate the correctness of the `squaredEuclideanDistance` function.