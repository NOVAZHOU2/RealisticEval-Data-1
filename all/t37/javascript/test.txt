Certainly! Below is the equivalent Jest test suite for the given Python unittest class. The goal is to maintain the functionality and logic of the tests while adapting them to Jest's syntax and conventions.

### Python Code:
```python
import unittest
import numpy as np


class QuadratureRule:
    def __init__(self, x, w):
        self.x = np.array(x)
        self.w = np.array(w)


class TestOrthogonalPolynomial(unittest.TestCase):
    def test_lanczos_basic(self):
        x = [0.0, 0.5, 1.0]
        w = [0.333, 0.333, 0.334]
        quadrature_rule = QuadratureRule(x, w)
        n = 2
        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)

        self.assertEqual(len(alpha), n)
        self.assertEqual(len(beta), n - 1)
        self.assertEqual(len(gamma), n)

    def test_lanczos_n_greater_than_length(self):
        x = [0.0, 0.5, 1.0]
        w = [0.333, 0.333, 0.334]
        quadrature_rule = QuadratureRule(x, w)
        n = 4

        with self.assertRaises(ValueError):
            lanczos(n, quadrature_rule)

    def test_lanczos_n_zero(self):
        x = [0.0, 0.5, 1.0]
        w = [0.333, 0.333, 0.334]
        quadrature_rule = QuadratureRule(x, w)
        n = 0

        with self.assertRaises(ValueError):
            lanczos(n, quadrature_rule)

    def test_lanczos_weights_nonuniform(self):
        x = [0.0, 0.5, 1.0]
        w = [0.1, 0.4, 0.5]
        quadrature_rule = QuadratureRule(x, w)
        n = 3
        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)

        self.assertEqual(len(alpha), n)
        self.assertEqual(len(beta), n - 1)
        self.assertEqual(len(gamma), n)
        self.assertTrue(np.all(gamma > 0))

    def test_lanczos_single_node(self):
        x = [0.5]
        w = [1.0]
        quadrature_rule = QuadratureRule(x, w)
        n = 1
        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)

        self.assertEqual(len(alpha), n)
        self.assertEqual(len(beta), n - 1)
        self.assertEqual(len(gamma), n)
        self.assertTrue(np.all(gamma > 0))
```

### Equivalent Jest Test Suite:

```javascript
// Import necessary packages
const { lanczos } = require('./lanczos'); // Assuming lanczos is defined in a separate file
const QuadratureRule = require('./quadratureRule');

describe('TestOrthogonalPolynomial', () => {
    describe('test_lanczos_basic', () => {
        it('should correctly compute the basic Lanczos coefficients', () => {
            const x = [0.0, 0.5, 1.0];
            const w = [0.333, 0.333, 0.334];
            const quadratureRule = new QuadratureRule(x, w);
            const n = 2;
            const [alpha, beta, gamma, _] = lanczos(n, quadratureRule);

            expect(alpha.length).toBe(n);
            expect(beta.length).toBe(n - 1);
            expect(gamma.length).toBe(n);
        });
    });

    describe('test_lanczos_n_greater_than_length', () => {
        it('should throw an error when n is greater than the length of x', () => {
            const x = [0.0, 0.5, 1.0];
            const w = [0.333, 0.333, 0.334];
            const quadratureRule = new QuadratureRule(x, w);
            const n = 4;

            expect(() => lanczos(n, quadratureRule)).toThrow('n must be between 1 and len(x).');
        });
    });

    describe('test_lanczos_n_zero', () => {
        it('should throw an error when n is zero', () => {
            const x = [0.0, 0.5, 1.0];
            const w = [0.333, 0.333, 0.334];
            const quadratureRule = new QuadratureRule(x, w);
            const n = 0;

            expect(() => lanczos(n, quadratureRule)).toThrow('n must be between 1 and len(x).');
        });
    });

    describe('test_lanczos_weights_nonuniform', () => {
        it('should correctly compute the Lanczos coefficients with non-uniform weights', () => {
            const x = [0.0, 0.5, 1.0];
            const w = [0.1, 0.4, 0.5];
            const quadratureRule = new QuadratureRule(x, w);
            const n = 3;
            const [alpha, beta, gamma, _] = lanczos(n, quadratureRule);

            expect(alpha.length).toBe(n);
            expect(beta.length).toBe(n - 1);
            expect(gamma.length).toBe(n);
            expect(gamma.every(val => val > 0)).toBe(true);
        });
    });

    describe('test_lanczos_single_node', () => {
        it('should correctly compute the Lanczos coefficients with a single node', () => {
            const x = [0.5];
            const w = [1.0];
            const quadratureRule = new QuadratureRule(x, w);
            const n = 1;
            const [alpha, beta, gamma, _] = lanczos(n, quadratureRule);

            expect(alpha.length).toBe(n);
            expect(beta.length).toBe(n - 1);
            expect(gamma.length).toBe(n);
            expect(gamma.every(val => val > 0)).toBe(true);
        });
    });
});

// Utility functions
function dotProduct(...arrays) {
    if (arrays.length < 2) {
        throw new Error('At least two arrays are required for dot product.');
    }

    return arrays.reduce((acc, curr, idx, arr) => {
        if (idx === 0) return curr;
        return acc.map((a, i) => a * curr[i]);
    }, arrays[0]).reduce((sum, val) => sum + val, 0);
}

// Example usage
const QuadratureRule = class {
    constructor(x, w) {
        this.x = x;
        this.w = w;
    }
};

const lanczos = (n, quadratureRule) => {
    if (n <= 0 || n > quadratureRule.x.length) {
        throw new Error('n must be between 1 and len(x).');
    }

    const x = quadratureRule.x;
    const w = quadratureRule.w;
    const alpha = new Array(n).fill(0);
    const beta = n > 1 ? new Array(n - 1).fill(0) : [];
    const gamma = new Array(n).fill(0);

    // Initial polynomial p_0(x) = 1, p_-1(x) = 0 (non-existent, thus ignored in calculations)
    const p0 = new Array(x.length).fill(1);
    const p1 = new Array(x.length).fill(0);

    for (let i = 0; i < n; i++) {
        // Compute new polynomial p_i
        let pi;
        if (i > 0) {
            pi = x.map((xi, index) => (xi - alpha[i - 1]) * p0[index]);
        } else {
            pi = p0;
        }

        if (i > 1) {
            pi = x.map((xi, index) => (xi - alpha[i - 1]) * p0[index] - beta[i - 2] * p1[index]);
        }

        gamma[i] = dotProduct(w, pi, pi);
        alpha[i] = dotProduct(w, x, pi, pi) / gamma[i];

        if (i < n - 1) {
            beta[i] = dotProduct(w, pi, pi, pi) / gamma[i];
            [p1, p0] = [p0, pi]; // Update polynomials for next iteration
        }
    }

    return [alpha, beta, gamma, quadratureRule];
};
```

### Explanation:
1. **Class Definition**: The `QuadratureRule` class is defined similarly to the Python class.
2. **Function Definition**: The `lanczos` function is defined with the same parameters and logic.
3. **Jest Test Suite**: The test cases are structured using `describe` and `it` blocks to group and describe each test case.
4. **Assertions**: Jest's `expect` function is used to perform assertions similar to Python's `unittest.TestCase` methods.
5. **Error Handling**: Jest's `toThrow` matcher is used to check for thrown errors.
6. **Utility Functions**: The `dotProduct` function is included to handle the dot product calculations.

This Jest test suite preserves the functionality and logic of the original Python unittest class while adapting to Jest's syntax and conventions.