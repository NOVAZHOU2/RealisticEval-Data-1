Certainly! Below is the equivalent JavaScript code with the function and class signatures converted, along with JSDoc comments to maintain the purpose and structure of the code:

```javascript
// Import necessary packages
const { dotProduct } = require('./utils'); // Assuming dotProduct is defined in a utility file

/**
 * Represents a quadrature rule with nodes and weights.
 */
class QuadratureRule {
    /**
     * Constructs a QuadratureRule object.
     * @param {number[]} x - The nodes for the quadrature.
     * @param {number[]} w - The weights for the quadrature.
     */
    constructor(x, w) {
        this.x = x;
        this.w = w;
    }
}

/**
 * Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials.
 * @param {number} n - The number of orthogonal polynomials to generate.
 * @param {QuadratureRule} quadratureRule - An object containing x (nodes) and w (weights) for the quadrature.
 * @returns {[number[], number[], number[], QuadratureRule]} - The computed coefficients and the quadrature rule.
 */
function lanczos(n, quadratureRule) {
    if (n <= 0 || n > quadratureRule.x.length) {
        throw new Error('n must be between 1 and len(x).');
    }

    const x = quadratureRule.x;
    const w = quadratureRule.w;
    const alpha = new Array(n).fill(0);
    const beta = n > 1 ? new Array(n - 1).fill(0) : [];
    const gamma = new Array(n).fill(0);

    // Initial polynomial p_0(x) = 1, p_-1(x) = 0 (non-existent, thus ignored in calculations)
    const p0 = new Array(x.length).fill(1);
    const p1 = new Array(x.length).fill(0);

    for (let i = 0; i < n; i++) {
        // Compute new polynomial p_i
        let pi;
        if (i > 0) {
            pi = x.map((xi, index) => (xi - alpha[i - 1]) * p0[index]);
        } else {
            pi = p0;
        }

        if (i > 1) {
            pi = x.map((xi, index) => (xi - alpha[i - 1]) * p0[index] - beta[i - 2] * p1[index]);
        }

        gamma[i] = dotProduct(w, pi, pi);
        alpha[i] = dotProduct(w, x, pi, pi) / gamma[i];

        if (i < n - 1) {
            beta[i] = dotProduct(w, pi, pi, pi) / gamma[i];
            [p1, p0] = [p0, pi]; // Update polynomials for next iteration
        }
    }

    return [alpha, beta, gamma, quadratureRule];
}

// Helper function for dot product
function dotProduct(...arrays) {
    if (arrays.length < 2) {
        throw new Error('At least two arrays are required for dot product.');
    }

    return arrays.reduce((acc, curr, idx, arr) => {
        if (idx === 0) return curr;
        return acc.map((a, i) => a * curr[i]);
    }, arrays[0]).reduce((sum, val) => sum + val, 0);
}

// Example usage
const quadratureRule = new QuadratureRule([0, 1, 2], [0.5, 0.5, 0.5]);
const result = lanczos(3, quadratureRule);
console.log(result);
```

### Explanation:
1. **Class Definition**: The `QuadratureRule` class is defined with JSDoc comments to describe its purpose and constructor parameters.
2. **Function Definition**: The `lanczos` function is defined with JSDoc comments to describe its purpose, arguments, and return value.
3. **Array Initialization**: Arrays are initialized using `new Array(length).fill(0)` to mimic the behavior of `np.zeros`.
4. **Dot Product Function**: A helper function `dotProduct` is defined to compute the dot product of arrays, which is used in the main function.
5. **Polynomial Calculation**: The polynomial calculation logic is implemented using array mapping and multiplication.
6. **Example Usage**: An example usage of the `QuadratureRule` and `lanczos` function is provided at the end.

This JavaScript code preserves the functionality, logic, and structure of the original Python code while adhering to JSDoc documentation standards.