Certainly! Below is the equivalent Java test class using JUnit for the provided Python unittest class. The Java test class will be placed in the package `org.real.temp` and named `Tester`. It includes appropriate JUnit annotations and assertion methods to ensure the functionality and logic of the tests are preserved.

### Java Code

```java
package org.real.temp;

import org.junit.Test;
import static org.junit.Assert.*;

/**
 * Test class for the Lanczos algorithm.
 */
public class Tester {

    @Test
    public void testLanczosBasic() {
        double[] x = {0.0, 0.5, 1.0};
        double[] w = {0.333, 0.333, 0.334};
        QuadratureRule quadratureRule = new QuadratureRule(x, w);
        int n = 2;
        OrthogonalPolynomialResult result = lanczos(n, quadratureRule);

        assertEquals(n, result.getAlpha().length);
        assertEquals(n - 1, result.getBeta().length);
        assertEquals(n, result.getGamma().length);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testLanczosNGreaterThanLength() {
        double[] x = {0.0, 0.5, 1.0};
        double[] w = {0.333, 0.333, 0.334};
        QuadratureRule quadratureRule = new QuadratureRule(x, w);
        int n = 4;
        lanczos(n, quadratureRule);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testLanczosNZero() {
        double[] x = {0.0, 0.5, 1.0};
        double[] w = {0.333, 0.333, 0.334};
        QuadratureRule quadratureRule = new QuadratureRule(x, w);
        int n = 0;
        lanczos(n, quadratureRule);
    }

    @Test
    public void testLanczosWeightsNonUniform() {
        double[] x = {0.0, 0.5, 1.0};
        double[] w = {0.1, 0.4, 0.5};
        QuadratureRule quadratureRule = new QuadratureRule(x, w);
        int n = 3;
        OrthogonalPolynomialResult result = lanczos(n, quadratureRule);

        assertEquals(n, result.getAlpha().length);
        assertEquals(n - 1, result.getBeta().length);
        assertEquals(n, result.getGamma().length);
        assertTrue(Arrays.stream(result.getGamma()).allMatch(g -> g > 0));
    }

    @Test
    public void testLanczosSingleNode() {
        double[] x = {0.5};
        double[] w = {1.0};
        QuadratureRule quadratureRule = new QuadratureRule(x, w);
        int n = 1;
        OrthogonalPolynomialResult result = lanczos(n, quadratureRule);

        assertEquals(n, result.getAlpha().length);
        assertEquals(n - 1, result.getBeta().length);
        assertEquals(n, result.getGamma().length);
        assertTrue(Arrays.stream(result.getGamma()).allMatch(g -> g > 0));
    }

    private OrthogonalPolynomialResult lanczos(int n, QuadratureRule quadratureRule) {
        if (n <= 0 || n > quadratureRule.getX().length) {
            throw new IllegalArgumentException("n must be between 1 and " + quadratureRule.getX().length + ".");
        }

        double[] x = quadratureRule.getX();
        double[] w = quadratureRule.getW();
        double[] alpha = new double[n];
        double[] beta = new double[Math.max(0, n - 1)];
        double[] gamma = new double[n];

        // Initial polynomial p_0(x) = 1, p_-1(x) = 0 (non-existent, thus ignored in calculations)
        double[] p0 = new double[x.length];
        Arrays.fill(p0, 1);
        double[] p1 = new double[x.length];

        for (int i = 0; i < n; i++) {
            // Compute new polynomial p_i
            double[] pi;
            if (i > 0) {
                pi = new double[x.length];
                for (int j = 0; j < x.length; j++) {
                    pi[j] = (x[j] - alpha[i - 1]) * p0[j];
                }
            } else {
                pi = p0;
            }

            if (i > 1) {
                for (int j = 0; j < x.length; j++) {
                    pi[j] -= beta[i - 2] * p1[j];
                }
            }

            gamma[i] = dotProduct(w, pi, pi);
            alpha[i] = dotProduct(w, x, pi, pi) / gamma[i];

            if (i < n - 1) {
                beta[i] = dotProduct(w, pi, pi) / gamma[i];
                double[] temp = p0;
                p0 = pi;
                p1 = temp;  // Update polynomials for next iteration
            }
        }

        return new OrthogonalPolynomialResult(alpha, beta, gamma, quadratureRule);
    }

    private double dotProduct(double[] w, double[]... arrays) {
        double result = 0.0;
        for (int i = 0; i < w.length; i++) {
            double product = 1.0;
            for (double[] array : arrays) {
                product *= array[i];
            }
            result += w[i] * product;
        }
        return result;
    }

    private static class QuadratureRule {
        private final double[] x;
        private final double[] w;

        public QuadratureRule(double[] x, double[] w) {
            this.x = x;
            this.w = w;
        }

        public double[] getX() {
            return x;
        }

        public double[] getW() {
            return w;
        }
    }

    private static class OrthogonalPolynomialResult {
        private final double[] alpha;
        private final double[] beta;
        private final double[] gamma;
        private final QuadratureRule quadratureRule;

        public OrthogonalPolynomialResult(double[] alpha, double[] beta, double[] gamma, QuadratureRule quadratureRule) {
            this.alpha = alpha;
            this.beta = beta;
            this.gamma = gamma;
            this.quadratureRule = quadratureRule;
        }

        public double[] getAlpha() {
            return alpha;
        }

        public double[] getBeta() {
            return beta;
        }

        public double[] getGamma() {
            return gamma;
        }

        public QuadratureRule getQuadratureRule() {
            return quadratureRule;
        }
    }
}
```

### Explanation:
1. **JUnit Annotations**:
   - `@Test`: Marks methods as test cases.
   - `@Test(expected = IllegalArgumentException.class)`: Used for expected exceptions.

2. **Assertions**:
   - `assertEquals`: Checks equality of values.
   - `assertTrue`: Checks boolean conditions.

3. **Test Methods**:
   - `testLanczosBasic`: Tests basic functionality.
   - `testLanczosNGreaterThanLength`: Tests when `n` is greater than the length of `x`.
   - `testLanczosNZero`: Tests when `n` is zero.
   - `testLanczosWeightsNonUniform`: Tests non-uniform weights.
   - `testLanczosSingleNode`: Tests a single node case.

4. **Helper Methods**:
   - `lanczos`: Computes the Lanczos coefficients.
   - `dotProduct`: Computes the dot product of multiple arrays weighted by `w`.

5. **Inner Classes**:
   - `QuadratureRule`: Represents the quadrature rule with nodes (`x`) and weights (`w`).
   - `OrthogonalPolynomialResult`: Represents the result of the Lanczos algorithm.

6. **Error Handling**:
   - Throws an `IllegalArgumentException` if `n` is out of bounds.

7. **Array Initialization and Manipulation**:
   - Uses loops and array operations to compute the polynomials and dot products.

This Java code preserves the functionality and structure of the original Python unittest class while adhering to JUnit conventions and best practices.