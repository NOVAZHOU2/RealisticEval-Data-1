Certainly! Below is the equivalent Java code for the provided Python code, including the class and function signatures, along with appropriate Javadoc comments and type conversions:

```java
package org.real.temp;

import java.util.Arrays;

/**
 * Represents a quadrature rule with nodes and weights.
 */
public class QuadratureRule {
    private final double[] x;
    private final double[] w;

    /**
     * Constructs a QuadratureRule object with specified nodes and weights.
     *
     * @param x the nodes for the quadrature
     * @param w the weights for the quadrature
     */
    public QuadratureRule(double[] x, double[] w) {
        this.x = x;
        this.w = w;
    }

    public double[] getX() {
        return x;
    }

    public double[] getW() {
        return w;
    }
}

/**
 * Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials.
 */
public class LanczosAlgorithm {

    /**
     * Computes the Lanczos coefficients for generating orthogonal polynomials.
     *
     * @param n the number of orthogonal polynomials to generate
     * @param quadratureRule an object containing nodes (x) and weights (w) for the quadrature
     * @return a tuple containing the alpha, beta, gamma coefficients, and the original quadrature rule
     */
    public static OrthogonalPolynomialResult lanczos(int n, QuadratureRule quadratureRule) {
        if (n <= 0 || n > quadratureRule.getX().length) {
            throw new IllegalArgumentException("n must be between 1 and " + quadratureRule.getX().length + ".");
        }

        double[] x = quadratureRule.getX();
        double[] w = quadratureRule.getW();
        double[] alpha = new double[n];
        double[] beta = new double[Math.max(0, n - 1)];
        double[] gamma = new double[n];

        // Initial polynomial p_0(x) = 1, p_-1(x) = 0 (non-existent, thus ignored in calculations)
        double[] p0 = new double[x.length];
        Arrays.fill(p0, 1);
        double[] p1 = new double[x.length];

        for (int i = 0; i < n; i++) {
            // Compute new polynomial p_i
            double[] pi;
            if (i > 0) {
                pi = new double[x.length];
                for (int j = 0; j < x.length; j++) {
                    pi[j] = (x[j] - alpha[i - 1]) * p0[j];
                }
            } else {
                pi = p0;
            }

            if (i > 1) {
                for (int j = 0; j < x.length; j++) {
                    pi[j] -= beta[i - 2] * p1[j];
                }
            }

            gamma[i] = dotProduct(w, pi, pi);
            alpha[i] = dotProduct(w, x, pi, pi) / gamma[i];

            if (i < n - 1) {
                beta[i] = dotProduct(w, pi, pi) / gamma[i];
                double[] temp = p0;
                p0 = pi;
                p1 = temp;  // Update polynomials for next iteration
            }
        }

        return new OrthogonalPolynomialResult(alpha, beta, gamma, quadratureRule);
    }

    private static double dotProduct(double[] w, double[]... arrays) {
        double result = 0.0;
        for (int i = 0; i < w.length; i++) {
            double product = 1.0;
            for (double[] array : arrays) {
                product *= array[i];
            }
            result += w[i] * product;
        }
        return result;
    }

    /**
     * Represents the result of the Lanczos algorithm.
     */
    public static class OrthogonalPolynomialResult {
        private final double[] alpha;
        private final double[] beta;
        private final double[] gamma;
        private final QuadratureRule quadratureRule;

        public OrthogonalPolynomialResult(double[] alpha, double[] beta, double[] gamma, QuadratureRule quadratureRule) {
            this.alpha = alpha;
            this.beta = beta;
            this.gamma = gamma;
            this.quadratureRule = quadratureRule;
        }

        public double[] getAlpha() {
            return alpha;
        }

        public double[] getBeta() {
            return beta;
        }

        public double[] getGamma() {
            return gamma;
        }

        public QuadratureRule getQuadratureRule() {
            return quadratureRule;
        }
    }

    public static void main(String[] args) {
        double[] x = {1.0, 2.0, 3.0};
        double[] w = {0.5, 0.3, 0.2};
        QuadratureRule quadratureRule = new QuadratureRule(x, w);

        OrthogonalPolynomialResult result = lanczos(2, quadratureRule);
        System.out.println("Alpha: " + Arrays.toString(result.getAlpha()));
        System.out.println("Beta: " + Arrays.toString(result.getBeta()));
        System.out.println("Gamma: " + Arrays.toString(result.getGamma()));
    }
}
```

### Explanation:
1. **Class Definitions**:
   - `QuadratureRule`: Represents the quadrature rule with nodes (`x`) and weights (`w`).
   - `LanczosAlgorithm`: Contains the `lanczos` method and the `OrthogonalPolynomialResult` inner class.

2. **Method Signatures**:
   - `lanczos`: Computes the Lanczos coefficients and returns an `OrthogonalPolynomialResult` object.
   - `dotProduct`: Computes the dot product of multiple arrays weighted by `w`.

3. **Javadoc Comments**:
   - Detailed Javadoc comments are provided for each class and method, explaining their purpose and parameters.

4. **Type Conversions**:
   - Python `np.ndarray` is converted to Java `double[]`.
   - Python `Tuple` is converted to a custom `OrthogonalPolynomialResult` class.

5. **Error Handling**:
   - Throws an `IllegalArgumentException` if `n` is out of bounds.

6. **Array Initialization and Manipulation**:
   - Uses loops and array operations to compute the polynomials and dot products.

This Java code preserves the functionality and structure of the original Python code while adhering to Java's conventions and best practices.