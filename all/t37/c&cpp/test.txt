Certainly! Let's convert the provided Python unittest test class into an equivalent test class using Catch2 in C++. We will ensure that the functionality and logic of the tests are preserved, and we will use appropriate assertions in Catch2.

Here is the equivalent C++ code using Catch2:

### C++ Code with Catch2 Testing Framework

```cpp
#include <catch2/catch_test_macros.hpp>
#include <vector>
#include <stdexcept>
#include <cmath>

// QuadratureRule class definition
class QuadratureRule {
public:
    std::vector<double> x;
    std::vector<double> w;

    // Constructor
    QuadratureRule(const std::vector<double>& x, const std::vector<double>& w) : x(x), w(w) {}
};

// Function to compute the dot product of two vectors
double dot_product(const std::vector<double>& v1, const std::vector<double>& v2) {
    double result = 0.0;
    for (size_t i = 0; i < v1.size(); ++i) {
        result += v1[i] * v2[i];
    }
    return result;
}

// Lanczos function implementation
std::tuple<std::vector<double>, std::vector<double>, std::vector<double>, QuadratureRule>
lanczos(int n, const QuadratureRule& quadrature_rule) {
    if (n <= 0 || n > quadrature_rule.x.size()) {
        throw std::invalid_argument("n must be between 1 and len(x).");
    }

    const auto& x = quadrature_rule.x;
    const auto& w = quadrature_rule.w;
    std::vector<double> alpha(n);
    std::vector<double> beta(n - 1);
    std::vector<double> gamma(n);

    // Initial polynomial p_0(x) = 1, p_-1(x) = 0 (non-existent, thus ignored in calculations)
    std::vector<double> p0(x.size(), 1.0);
    std::vector<double> p1(x.size(), 0.0);

    for (int i = 0; i < n; ++i) {
        // Compute new polynomial p_i
        std::vector<double> pi(x.size());
        if (i > 0) {
            for (size_t j = 0; j < x.size(); ++j) {
                pi[j] = (x[j] - alpha[i - 1]) * p0[j];
            }
        } else {
            pi = p0;
        }

        if (i > 1) {
            for (size_t j = 0; j < x.size(); ++j) {
                pi[j] -= beta[i - 1] * p1[j];
            }
        }

        gamma[i] = dot_product(w, pi);
        alpha[i] = dot_product(w, x) / gamma[i];

        if (i < n - 1) {
            beta[i] = dot_product(w, pi) / gamma[i];
            p1 = p0;
            p0 = pi;
        }
    }

    return std::make_tuple(alpha, beta, gamma, quadrature_rule);
}

TEST_CASE("Test Orthogonal Polynomial", "[orthogonal_polynomial]") {
    SECTION("Basic Lanczos Test") {
        std::vector<double> x = {0.0, 0.5, 1.0};
        std::vector<double> w = {0.333, 0.333, 0.334};
        QuadratureRule quadrature_rule(x, w);
        int n = 2;

        auto [alpha, beta, gamma, _] = lanczos(n, quadrature_rule);

        REQUIRE(alpha.size() == n);
        REQUIRE(beta.size() == n - 1);
        REQUIRE(gamma.size() == n);
    }

    SECTION("N Greater Than Length Test") {
        std::vector<double> x = {0.0, 0.5, 1.0};
        std::vector<double> w = {0.333, 0.333, 0.334};
        QuadratureRule quadrature_rule(x, w);
        int n = 4;

        REQUIRE_THROWS_AS(lanczos(n, quadrature_rule), std::invalid_argument);
    }

    SECTION("N Zero Test") {
        std::vector<double> x = {0.0, 0.5, 1.0};
        std::vector<double> w = {0.333, 0.333, 0.334};
        QuadratureRule quadrature_rule(x, w);
        int n = 0;

        REQUIRE_THROWS_AS(lanczos(n, quadrature_rule), std::invalid_argument);
    }

    SECTION("Non-uniform Weights Test") {
        std::vector<double> x = {0.0, 0.5, 1.0};
        std::vector<double> w = {0.1, 0.4, 0.5};
        QuadratureRule quadrature_rule(x, w);
        int n = 3;

        auto [alpha, beta, gamma, _] = lanczos(n, quadrature_rule);

        REQUIRE(alpha.size() == n);
        REQUIRE(beta.size() == n - 1);
        REQUIRE(gamma.size() == n);
        REQUIRE(std::all_of(gamma.begin(), gamma.end(), [](double val) { return val > 0; }));
    }

    SECTION("Single Node Test") {
        std::vector<double> x = {0.5};
        std::vector<double> w = {1.0};
        QuadratureRule quadrature_rule(x, w);
        int n = 1;

        auto [alpha, beta, gamma, _] = lanczos(n, quadrature_rule);

        REQUIRE(alpha.size() == n);
        REQUIRE(beta.size() == n - 1);
        REQUIRE(gamma.size() == n);
        REQUIRE(std::all_of(gamma.begin(), gamma.end(), [](double val) { return val > 0; }));
    }
}
```

### Explanation:
1. **QuadratureRule Class**:
   - The `QuadratureRule` class is defined with member variables `x` and `w`.
   - The constructor initializes these member variables.

2. **Dot Product Function**:
   - A helper function `dot_product` is defined to compute the dot product of two vectors.

3. **Lanczos Function**:
   - The `lanczos` function is implemented with appropriate error checking and computation logic.

4. **Catch2 Test Cases**:
   - Each test case is defined within a `SECTION` block inside the `TEST_CASE`.
   - Assertions are used to verify the correctness of the function outputs.
   - `REQUIRE` is used for basic assertions.
   - `REQUIRE_THROWS_AS` is used to check for specific exception types.

This C++ code preserves the functionality and logic of the original Python unittest test cases while adhering to the Catch2 testing framework.