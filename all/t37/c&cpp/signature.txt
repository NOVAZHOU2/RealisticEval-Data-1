Certainly! Let's convert the given Python code into its equivalent C++ version, ensuring that the function and class signatures, as well as the comments and documentation, are appropriately translated.

Here is the converted C++ code:

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>
#include <tuple>

// QuadratureRule class definition
class QuadratureRule {
public:
    std::vector<double> x;
    std::vector<double> w;

    // Constructor
    QuadratureRule(const std::vector<double>& x, const std::vector<double>& w) : x(x), w(w) {}
};

// Function to compute the dot product of two vectors
double dot_product(const std::vector<double>& v1, const std::vector<double>& v2) {
    double result = 0.0;
    for (size_t i = 0; i < v1.size(); ++i) {
        result += v1[i] * v2[i];
    }
    return result;
}

// Lanczos function implementation
std::tuple<std::vector<double>, std::vector<double>, std::vector<double>, QuadratureRule>
lanczos(int n, const QuadratureRule& quadrature_rule) {
    // Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials
    // Args:
    //     n (int): the number of orthogonal polynomials to generate
    //     quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.
    // Returns:
    //     Tuple<std::vector<double>, std::vector<double>, std::vector<double>, QuadratureRule>

    if (n <= 0 || n > quadrature_rule.x.size()) {
        throw std::invalid_argument("n must be between 1 and len(x).");
    }

    const auto& x = quadrature_rule.x;
    const auto& w = quadrature_rule.w;
    std::vector<double> alpha(n);
    std::vector<double> beta(n - 1);
    std::vector<double> gamma(n);

    // Initial polynomial p_0(x) = 1, p_-1(x) = 0 (non-existent, thus ignored in calculations)
    std::vector<double> p0(x.size(), 1.0);
    std::vector<double> p1(x.size(), 0.0);

    for (int i = 0; i < n; ++i) {
        // Compute new polynomial p_i
        std::vector<double> pi(x.size());
        if (i > 0) {
            for (size_t j = 0; j < x.size(); ++j) {
                pi[j] = (x[j] - alpha[i - 1]) * p0[j];
            }
        } else {
            pi = p0;
        }

        if (i > 1) {
            for (size_t j = 0; j < x.size(); ++j) {
                pi[j] -= beta[i - 1] * p1[j];
            }
        }

        gamma[i] = dot_product(w, pi);
        alpha[i] = dot_product(w, x) / gamma[i];

        if (i < n - 1) {
            beta[i] = dot_product(w, pi) / gamma[i];
            p1 = p0;
            p0 = pi;
        }
    }

    return std::make_tuple(alpha, beta, gamma, quadrature_rule);
}

int main() {
    // Example usage
    QuadratureRule rule = {{1.0, 2.0, 3.0}, {0.5, 0.5, 0.5}};
    int n = 2;

    try {
        auto [alpha, beta, gamma, qr] = lanczos(n, rule);
        std::cout << "Alpha: ";
        for (auto a : alpha) {
            std::cout << a << " ";
        }
        std::cout << "\nBeta: ";
        for (auto b : beta) {
            std::cout << b << " ";
        }
        std::cout << "\nGamma: ";
        for (auto g : gamma) {
            std::cout << g << " ";
        }
        std::cout << "\n";
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **QuadratureRule Class**:
   - The `QuadratureRule` class is defined with member variables `x` and `w`.
   - The constructor initializes these member variables.

2. **Dot Product Function**:
   - A helper function `dot_product` is defined to compute the dot product of two vectors.

3. **Lanczos Function**:
   - The `lanczos` function is implemented with appropriate comments and documentation.
   - It checks the validity of the input parameter `n`.
   - The main loop computes the orthogonal polynomials and returns the results.

4. **Main Function**:
   - An example usage of the `lanczos` function is provided in the `main` function.
   - Error handling is included to catch and report exceptions.

This C++ code preserves the original functionality and structure of the Python code while adhering to C++ syntax and documentation standards.