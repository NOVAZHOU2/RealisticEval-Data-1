To convert the given Python code into C++, we need to handle several aspects such as class definitions, function definitions, array handling, and error checking. Below is the equivalent C++ code:

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>

// QuadratureRule struct to mimic the Python quadrature_rule object
struct QuadratureRule {
    std::vector<double> x;
    std::vector<double> w;
};

// OrthogonalPolynomial class definition
class OrthogonalPolynomial {
public:
    double alpha;
    double beta;
    double gamma;
    QuadratureRule quadrature_rule;

    OrthogonalPolynomial(double alpha, double beta, double gamma, const QuadratureRule& quadrature_rule)
        : alpha(alpha), beta(beta), gamma(gamma), quadrature_rule(quadrature_rule) {}
};

// Function to compute dot product
double dot_product(const std::vector<double>& v1, const std::vector<double>& v2) {
    double result = 0.0;
    for (size_t i = 0; i < v1.size(); ++i) {
        result += v1[i] * v2[i];
    }
    return result;
}

// Lanczos function implementation
std::tuple<std::vector<double>, std::vector<double>, std::vector<double>, QuadratureRule>
lanczos(int n, const QuadratureRule& quadrature_rule) {
    if (n <= 0 || n > quadrature_rule.x.size()) {
        throw std::invalid_argument("n must be between 1 and len(x).");
    }

    const auto& x = quadrature_rule.x;
    const auto& w = quadrature_rule.w;
    std::vector<double> alpha(n);
    std::vector<double> beta(n - 1);
    std::vector<double> gamma(n);

    // Initial polynomial p_0(x) = 1, p_-1(x) = 0 (non-existent, thus ignored in calculations)
    std::vector<double> p0(x.size(), 1.0);
    std::vector<double> p1(x.size(), 0.0);

    for (int i = 0; i < n; ++i) {
        // Compute new polynomial p_i
        std::vector<double> pi(x.size());
        if (i > 0) {
            for (size_t j = 0; j < x.size(); ++j) {
                pi[j] = (x[j] - alpha[i - 1]) * p0[j];
            }
        } else {
            pi = p0;
        }

        if (i > 1) {
            for (size_t j = 0; j < x.size(); ++j) {
                pi[j] -= beta[i - 1] * p1[j];
            }
        }

        gamma[i] = dot_product(w, pi);
        alpha[i] = dot_product(w, x) / gamma[i];

        if (i < n - 1) {
            beta[i] = dot_product(w, pi) / gamma[i];
            p1 = p0;
            p0 = pi;
        }
    }

    return std::make_tuple(alpha, beta, gamma, quadrature_rule);
}

int main() {
    // Example usage
    QuadratureRule rule = {{1.0, 2.0, 3.0}, {0.5, 0.5, 0.5}};
    int n = 2;

    try {
        auto [alpha, beta, gamma, qr] = lanczos(n, rule);
        std::cout << "Alpha: ";
        for (auto a : alpha) {
            std::cout << a << " ";
        }
        std::cout << "\nBeta: ";
        for (auto b : beta) {
            std::cout << b << " ";
        }
        std::cout << "\nGamma: ";
        for (auto g : gamma) {
            std::cout << g << " ";
        }
        std::cout << "\n";
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **QuadratureRule Struct**: This struct mimics the Python `quadrature_rule` object.
2. **OrthogonalPolynomial Class**: This class is defined with member variables and a constructor.
3. **Dot Product Function**: A helper function to compute the dot product of two vectors.
4. **Lanczos Function**: The main function that computes the Lanczos algorithm. It handles the initialization of arrays and the main loop for computing the polynomials.
5. **Main Function**: An example usage of the `lanczos` function.

This C++ code maintains the functionality and logic of the original Python code while adapting to C++ syntax and features.