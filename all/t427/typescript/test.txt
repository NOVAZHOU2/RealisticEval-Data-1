Sure, let's convert the given Python unittest test class into a Jest test suite in TypeScript. Since you haven't provided the actual unittest test class, I'll create a hypothetical example and then provide the equivalent Jest test suite.

### Hypothetical Python Unittest Test Class
```python
import unittest
from typing import Dict

def check_sequences(filename: str) -> Dict:
    # Implementation of check_sequences function
    pass

class TestCheckSequences(unittest.TestCase):
    def test_check_sequences(self):
        # Test cases for check_sequences function
        test_data = [
            ('test1.txt', {'sequence': [2, 1], 'is_munodi': True}),
            ('test2.txt', {'sequence': [3, 10, 5, 16, 8, 4, 2, 1], 'is_munodi': True}),
            ('test3.txt', {'sequence': [5, 16, 8, 4, 2, 1], 'is_munodi': True}),
            ('test4.txt', {'sequence': [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 'is_munodi': True}),
            ('test5.txt', {'sequence': [1], 'is_munodi': True}),
            ('test6.txt', {'sequence': [2, 3, 4], 'is_munodi': False}),
        ]

        for filename, expected in test_data:
            result = check_sequences(filename)
            self.assertEqual(result['sequence'], expected['sequence'])
            self.assertEqual(result['is_munodi'], expected['is_munodi'])

if __name__ == '__main__':
    unittest.main()
```

### Equivalent Jest Test Suite in TypeScript
First, define the `check_sequences` function in TypeScript:

```typescript
import { readFileSync } from 'fs';

interface SequenceResult {
    sequence: number[];
    isMunodi: boolean;
}

function check_sequences(filename: string): SequenceResult {
    // Placeholder implementation for demonstration purposes
    const sequence = [2, 1]; // Example sequence
    const isMunodi = true; // Placeholder flag
    return { sequence, isMunodi };
}

// Example utility function to read file content (for demonstration)
function readSequenceFromFile(filename: string): number[] {
    const fileContent = readFileSync(filename, 'utf-8');
    return fileContent.split(',').map(Number);
}
```

Next, write the Jest test suite:

```typescript
import { check_sequences } from './path/to/check_sequences'; // Import the function

describe('check_sequences', () => {
    const test_data = [
        { filename: 'test1.txt', expected: { sequence: [2, 1], isMunodi: true } },
        { filename: 'test2.txt', expected: { sequence: [3, 10, 5, 16, 8, 4, 2, 1], isMunodi: true } },
        { filename: 'test3.txt', expected: { sequence: [5, 16, 8, 4, 2, 1], isMunodi: true } },
        { filename: 'test4.txt', expected: { sequence: [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], isMunodi: true } },
        { filename: 'test5.txt', expected: { sequence: [1], isMunodi: true } },
        { filename: 'test6.txt', expected: { sequence: [2, 3, 4], isMunodi: false } },
    ];

    test_data.forEach(({ filename, expected }) => {
        test(`checks ${filename} correctly`, () => {
            const result = check_sequences(filename);
            expect(result.sequence).toEqual(expected.sequence);
            expect(result.isMunodi).toBe(expected.isMunodi);
        });
    });
});
```

### Notes:
1. **Type Annotations**: The TypeScript code includes type annotations for the `SequenceResult` interface.
2. **Jest Assertions**: The `expect` function is used with Jest matchers like `toEqual` and `toBe`.
3. **File Reading**: A placeholder function `readSequenceFromFile` is included for reading the file content. In a real scenario, you would implement this function to read the file and parse the sequence data.

This conversion preserves the functionality and logic of the original Python unittest test class while adapting it to TypeScript and Jest.