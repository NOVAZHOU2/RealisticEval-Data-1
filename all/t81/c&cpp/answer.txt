Here's the equivalent C++ code for the provided Python function. This code includes necessary type definitions, exception handling, and the logic to find the closest element to a target value within a list:

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#include <stdexcept>
#include <limits>

// Function to find the closest element to the target value in a vector of doubles
double find_closest_element(double target, const std::vector<double>& elements) {
    if (elements.empty()) {
        throw std::invalid_argument("The list of elements cannot be empty.");
    }

    // Initialize the closest element with the first element of the vector
    double closest = elements[0];

    // Iterate through the elements to find the closest one
    for (const auto& element : elements) {
        if (std::abs(element - target) < std::abs(closest - target)) {
            closest = element;
        }
    }

    return closest;
}

int main() {
    try {
        std::vector<double> elements = {1.0, 2.5, 3.7, 4.1};
        double target = 3.0;
        double closest = find_closest_element(target, elements);
        std::cout << "The closest element to " << target << " is " << closest << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **Type Definitions**: In C++, we use `double` to represent both integers and floating-point numbers since C++ does not have a direct equivalent to Python's `Union[int, float]`.
2. **Exception Handling**: We use `std::invalid_argument` to throw an exception when the input list is empty.
3. **Finding the Closest Element**: The function iterates over the elements and uses the `std::abs` function to calculate the absolute difference between each element and the target. It updates the closest element accordingly.
4. **Main Function**: Demonstrates how to call the `find_closest_element` function and handles any exceptions that might occur.