Certainly! Here is the equivalent C++ code for the provided Python function, including proper comments and type conversions:

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <sstream>

/**
 * Formats a string into a commented block with specified maximum line length.
 *
 * @param string The input string to format.
 * @param max_length Maximum length of each line in the output.
 * @return A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.
 */
std::string format_comment(const std::string& string, int max_length = 60) {
    // Split the string into lines
    std::istringstream iss(string);
    std::vector<std::string> lines;
    std::string line;
    while (std::getline(iss, line, '\n')) {
        lines.push_back(line);
    }

    // Initialize a vector to store the formatted lines
    std::vector<std::string> formatted_lines;

    // Iterate through the lines
    for (const auto& current_line : lines) {
        // Split the line into words
        std::istringstream word_stream(current_line);
        std::string word;
        std::string current_formatted_line = "";

        // Iterate through the words
        while (word_stream >> word) {
            // If the current formatted line plus the next word would be too long,
            // append the current formatted line to the list of formatted lines and start a new line
            if (current_formatted_line.length() + word.length() + 2 > max_length) {
                formatted_lines.push_back(current_formatted_line);
                current_formatted_line = "";
            }

            // If the current formatted line is empty, add the word to the line
            // Otherwise, add a space and the word to the line
            if (!current_formatted_line.empty()) {
                current_formatted_line += " " + word;
            } else {
                current_formatted_line = word;
            }
        }

        // Add the remaining line to the list of formatted lines
        formatted_lines.push_back(current_formatted_line);
    }

    // Return the formatted comment
    std::ostringstream oss;
    for (const auto& formatted_line : formatted_lines) {
        oss << "# " << formatted_line << "\n";
    }

    return oss.str();
}

int main() {
    std::string input = "This is a very long string that needs to be split into multiple lines.\n"
                        "Each line should be prefixed with '# ' and should not exceed the specified maximum length.";

    std::string formatted_comment = format_comment(input, 60);
    std::cout << formatted_comment << std::endl;

    return 0;
}
```

### Explanation:
1. **Function Signature**:
   - The function signature is translated to `std::string format_comment(const std::string& string, int max_length = 60);`.
   - The parameter types are explicitly defined (`const std::string&` for the string and `int` for the maximum length).

2. **Docstring**:
   - The Python docstring is converted into a C++ style comment block using `/** ... */`.

3. **Single-Line Comments**:
   - Single-line comments are used to explain steps within the function.

4. **String Manipulation**:
   - The input string is split into lines using `std::istringstream` and `std::getline`.
   - Words are extracted from each line using another `std::istringstream`.
   - The formatted lines are constructed and stored in a `std::vector<std::string>`.

5. **Output Construction**:
   - The formatted lines are concatenated and prefixed with `# ` using `std::ostringstream`.

6. **Main Function**:
   - A sample input string is provided, and the `format_comment` function is called to demonstrate its usage.

This conversion preserves the original functionality and structure while adhering to C++ standards and conventions.