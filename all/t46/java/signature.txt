Certainly! Below is the equivalent Java code for the provided Python code, including appropriate Javadoc comments and method signatures. The Java code preserves the original functionality and structure while adhering to Java conventions.

```java
package org.real.temp;

/**
 * Represents a binary tree node.
 */
public class TreeNode {
    private int value;
    private TreeNode left;
    private TreeNode right;

    /**
     * Constructs a new TreeNode with the specified value and optional children.
     *
     * @param value the value of the node
     * @param left  the left child of the node
     * @param right the right child of the node
     */
    public TreeNode(int value, TreeNode left, TreeNode right) {
        this.value = value;
        this.left = left;
        this.right = right;
    }

    /**
     * Constructs a new TreeNode with the specified value and no children.
     *
     * @param value the value of the node
     */
    public TreeNode(int value) {
        this(value, null, null);
    }

    // Getters and setters for the fields
    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    public TreeNode getLeft() {
        return left;
    }

    public void setLeft(TreeNode left) {
        this.left = left;
    }

    public TreeNode getRight() {
        return right;
    }

    public void setRight(TreeNode right) {
        this.right = right;
    }
}

/**
 * Represents a binary tree.
 */
public class BinaryTree {
    private TreeNode root;

    /**
     * Constructs a new BinaryTree with the specified root node.
     *
     * @param root the root node of the tree
     */
    public BinaryTree(TreeNode root) {
        this.root = root;
    }

    /**
     * Constructs a new BinaryTree with no root node.
     */
    public BinaryTree() {
        this(null);
    }

    /**
     * Performs a preorder traversal of the binary tree.
     *
     * @param node   the current node being visited
     * @param result the list to store the traversal results
     * @return the list containing the preorder traversal results
     */
    public List<Integer> preorderTraversal(TreeNode node, List<Integer> result) {
        if (result == null) {
            result = new ArrayList<>();
        }
        if (node != null) {
            result.add(node.getValue());
            preorderTraversal(node.getLeft(), result);
            preorderTraversal(node.getRight(), result);
        }
        return result;
    }

    /**
     * Performs an inorder traversal of the binary tree.
     *
     * @param node   the current node being visited
     * @param result the list to store the traversal results
     * @return the list containing the inorder traversal results
     */
    public List<Integer> inorderTraversal(TreeNode node, List<Integer> result) {
        if (result == null) {
            result = new ArrayList<>();
        }
        if (node != null) {
            inorderTraversal(node.getLeft(), result);
            result.add(node.getValue());
            inorderTraversal(node.getRight(), result);
        }
        return result;
    }

    /**
     * Performs a postorder traversal of the binary tree.
     *
     * @param node   the current node being visited
     * @param result the list to store the traversal results
     * @return the list containing the postorder traversal results
     */
    public List<Integer> postorderTraversal(TreeNode node, List<Integer> result) {
        if (result == null) {
            result = new ArrayList<>();
        }
        if (node != null) {
            postorderTraversal(node.getLeft(), result);
            postorderTraversal(node.getRight(), result);
            result.add(node.getValue());
        }
        return result;
    }
}

// Example usage
public class Main {
    public static void main(String[] args) {
        // Create a sample binary tree
        TreeNode root = new TreeNode(1,
                new TreeNode(2, new TreeNode(4), new TreeNode(5)),
                new TreeNode(3));

        BinaryTree tree = new BinaryTree(root);

        // Perform and print traversals
        System.out.println("Preorder Traversal: " + tree.preorderTraversal(root, null));
        System.out.println("Inorder Traversal: " + tree.inorderTraversal(root, null));
        System.out.println("Postorder Traversal: " + tree.postorderTraversal(root, null));
    }
}
```

### Explanation:
1. **TreeNode Class**:
   - The `TreeNode` class represents a node in the binary tree.
   - It includes fields for the node's value, left child, and right child.
   - Constructors are provided to initialize nodes with or without children.
   - Getter and setter methods are included for accessing and modifying the node's fields.

2. **BinaryTree Class**:
   - The `BinaryTree` class represents the binary tree itself.
   - It includes methods for performing preorder, inorder, and postorder traversals.
   - Each traversal method initializes a list to store the traversal results and performs the traversal recursively.

3. **Javadoc Comments**:
   - Javadoc comments are used to document the purpose and parameters of each method and class.

4. **Example Usage**:
   - The `Main` class provides an example of creating a binary tree and performing the traversals.

This Java code closely mirrors the functionality and structure of the original Python code while adhering to Java's syntax and conventions.