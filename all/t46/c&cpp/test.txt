Certainly! Below is the equivalent C++ test class using the Catch2 testing framework. This includes the setup of the tree structure and the corresponding test cases for preorder, inorder, and postorder traversals.

First, make sure you have Catch2 installed and included in your project. You can include Catch2 by adding the header file and using the `CATCH_TEST_CASE` macro for defining test cases.

Hereâ€™s the complete C++ code:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <vector>

// TreeNode class definition
class TreeNode {
public:
    int value;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int val = 0, TreeNode* l = nullptr, TreeNode* r = nullptr)
        : value(val), left(l), right(r) {}
};

// BinaryTree class definition
class BinaryTree {
public:
    TreeNode* root;

    BinaryTree(TreeNode* r = nullptr) : root(r) {}

    // Recursive Preorder Traversal
    std::vector<int> preorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {
        if (result == nullptr) {
            result = new std::vector<int>();
        }
        if (node != nullptr) {
            result->push_back(node->value);
            preorder_traversal(node->left, result);
            preorder_traversal(node->right, result);
        }
        return *result;
    }

    // Recursive Inorder Traversal
    std::vector<int> inorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {
        if (result == nullptr) {
            result = new std::vector<int>();
        }
        if (node != nullptr) {
            inorder_traversal(node->left, result);
            result->push_back(node->value);
            inorder_traversal(node->right, result);
        }
        return *result;
    }

    // Recursive Postorder Traversal
    std::vector<int> postorder_traversal(TreeNode* node, std::vector<int>* result = nullptr) {
        if (result == nullptr) {
            result = new std::vector<int>();
        }
        if (node != nullptr) {
            postorder_traversal(node->left, result);
            postorder_traversal(node->right, result);
            result->push_back(node->value);
        }
        return *result;
    }
};

// Test fixture for BinaryTree
struct TestBinaryTree {
    void setup() {
        // Tree structure:
        //      1
        //     / \
        //    2   3
        //   / \
        //  4   5
        tree = BinaryTree(new TreeNode(1));
        tree.root->left = new TreeNode(2, new TreeNode(4), new TreeNode(5));
        tree.root->right = new TreeNode(3);
    }

    void teardown() {
        delete tree.root->left->left; // Delete node 4
        delete tree.root->left->right; // Delete node 5
        delete tree.root->left; // Delete node 2
        delete tree.root->right; // Delete node 3
        delete tree.root; // Delete root node 1
    }

    BinaryTree tree;
};

TEST_CASE("TestBinaryTree", "[BinaryTree]") {
    TestBinaryTree test;

    SECTION("Test preorder traversal") {
        test.setup();
        std::vector<int> result = test.tree.preorder_traversal(test.tree.root);
        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({1, 2, 4, 5, 3})));
        test.teardown();
    }

    SECTION("Test inorder traversal") {
        test.setup();
        std::vector<int> result = test.tree.inorder_traversal(test.tree.root);
        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({4, 2, 5, 1, 3})));
        test.teardown();
    }

    SECTION("Test postorder traversal") {
        test.setup();
        std::vector<int> result = test.tree.postorder_traversal(test.tree.root);
        REQUIRE_THAT(result, Catch::Matchers::Equals(std::vector<int>({4, 5, 2, 3, 1})));
        test.teardown();
    }

    SECTION("Test empty tree") {
        BinaryTree empty_tree;
        REQUIRE_THAT(empty_tree.preorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));
        REQUIRE_THAT(empty_tree.inorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));
        REQUIRE_THAT(empty_tree.postorder_traversal(empty_tree.root), Catch::Matchers::Equals(std::vector<int>({})));
    }

    SECTION("Test single node tree") {
        BinaryTree single_node_tree(new TreeNode(10));
        REQUIRE_THAT(single_node_tree.preorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));
        REQUIRE_THAT(single_node_tree.inorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));
        REQUIRE_THAT(single_node_tree.postorder_traversal(single_node_tree.root), Catch::Matchers::Equals(std::vector<int>({10})));
    }
}
```

### Explanation:
1. **TreeNode Class**:
   - The `TreeNode` class has three members: `value`, `left`, and `right`.
   - The constructor initializes these members with default values.

2. **BinaryTree Class**:
   - The `BinaryTree` class has a single member `root`.
   - The constructor initializes the `root` with a given `TreeNode` or `nullptr`.

3. **Traversal Methods**:
   - **Recursive Traversals** (`preorder_traversal`, `inorder_traversal`, `postorder_traversal`):
     - These methods use recursion to traverse the tree and store the node values in a vector.
     - They handle the case where `result` is `nullptr` by creating a new vector.

4. **Test Fixture**:
   - The `TestBinaryTree` struct sets up and tears down the tree structure for testing.
   - It includes methods to set up and tear down the tree structure.

5. **Catch2 Test Cases**:
   - Each test section uses the `setup` and `teardown` methods to create and destroy the tree structure.
   - Assertions are made using `REQUIRE_THAT` with `Catch::Matchers::Equals` to verify the correctness of the traversals.

This C++ code preserves the original purpose and structure of the Python unittest code, translating it appropriately into C++ syntax and conventions using the Catch2 testing framework.