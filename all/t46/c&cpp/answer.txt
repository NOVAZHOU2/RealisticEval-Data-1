Sure! Below is the equivalent C++ code for your Python classes `TreeNode` and `BinaryTree`. This includes implementations for the `preorder_traversal`, `inorder_traversal`, and `postorder_traversal` methods.

```cpp
#include <iostream>
#include <vector>

// Define the TreeNode structure
struct TreeNode {
    int value;
    TreeNode* left;
    TreeNode* right;

    // Constructor
    TreeNode(int val = 0) : value(val), left(nullptr), right(nullptr) {}
};

// Define the BinaryTree class
class BinaryTree {
private:
    TreeNode* root;

public:
    // Constructor
    BinaryTree(TreeNode* root = nullptr) : root(root) {}

    // Preorder traversal
    void preorderTraversal(TreeNode* node, std::vector<int>& result) const {
        if (node != nullptr) {
            result.push_back(node->value);
            preorderTraversal(node->left, result);
            preorderTraversal(node->right, result);
        }
    }

    // Inorder traversal
    void inorderTraversal(TreeNode* node, std::vector<int>& result) const {
        if (node != nullptr) {
            inorderTraversal(node->left, result);
            result.push_back(node->value);
            inorderTraversal(node->right, result);
        }
    }

    // Postorder traversal
    void postorderTraversal(TreeNode* node, std::vector<int>& result) const {
        if (node != nullptr) {
            postorderTraversal(node->left, result);
            postorderTraversal(node->right, result);
            result.push_back(node->value);
        }
    }

    // Helper functions to start traversals from the root
    std::vector<int> getPreorderTraversal() const {
        std::vector<int> result;
        preorderTraversal(root, result);
        return result;
    }

    std::vector<int> getInorderTraversal() const {
        std::vector<int> result;
        inorderTraversal(root, result);
        return result;
    }

    std::vector<int> getPostorderTraversal() const {
        std::vector<int> result;
        postorderTraversal(root, result);
        return result;
    }
};

int main() {
    // Example usage
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    BinaryTree bt(root);

    std::cout << "Preorder Traversal: ";
    for (int val : bt.getPreorderTraversal()) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    std::cout << "Inorder Traversal: ";
    for (int val : bt.getInorderTraversal()) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    std::cout << "Postorder Traversal: ";
    for (int val : bt.getPostorderTraversal()) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    // Clean up memory
    delete root->left->right;
    delete root->left->left;
    delete root->left;
    delete root->right;
    delete root;

    return 0;
}
```

This C++ code defines the same structures and methods as your Python code. The `main` function demonstrates how to use the `BinaryTree` class with an example binary tree and prints the results of the different traversals. Make sure to clean up dynamically allocated memory to avoid leaks.