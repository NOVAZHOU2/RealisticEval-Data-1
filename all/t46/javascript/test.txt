Here's how you could write the same test cases in JavaScript using Jest:

```javascript
const { describe, it, expect } = require('@jest/globals');

// Mocking TreeNode and BinaryTree classes for testing
class TreeNode {
  constructor(value = 0, left = null, right = null) {}
}

class BinaryTree {
  constructor(root = null) {}

  preorderTraversal(node, result = []) {
    return result;
  }

  inorderTraversal(node, result = []) {
    return result;
  }

  postorderTraversal(node, result = []) {
    return result;
  }
}

describe('BinaryTree', () => {
  let binaryTree;

  beforeEach(() => {
    binaryTree = new BinaryTree();
  });

  describe('#preorderTraversal', () => {
    it('should return an empty array when called with no node', () => {
      const result = binaryTree.preorderTraversal(null);
      expect(result).toEqual([]);
    });
  });

  describe('#inorderTraversal', () => {
    it('should return an empty array when called with no node', () => {
      const result = binaryTree.inorderTraversal(null);
      expect(result).toEqual([]);
    });
  });

  describe('#postorderTraversal', () => {
    it('should return an empty array when called with no node', () => {
      const result = binaryTree.postorderTraversal(null);
      expect(result).toEqual([]);
    });
  });
});
```

In this code, we're using Jest's `describe` function to group related tests together, and the `it` function to define individual test cases. We're also using Jest's `expect` function to assert that our methods behave as expected.

Please note that in real-world scenario, you would probably want to mock the behavior of your `TreeNode` and `BinaryTree` classes, but I've kept them simple here for illustrative purposes. Also, these tests assume that your `preorderTraversal`, `inorderTraversal`, and `postorderTraversal` methods all accept a `node` parameter and a `result` parameter, which they do not in your provided Python code. If your actual implementation differs, please adjust the tests accordingly.