Sure, here's how you can translate your Python function `dict_of_lists_to_list_of_dicts` to C and C++:

### C Code

```c
#include <stdio.h>
#include <stdlib.h>

// Define a structure for a dictionary entry
typedef struct {
    char* key;
    int* values;
    size_t length;
} DictEntry;

// Function to convert a dictionary of lists to a list of dictionaries
void dictOfListsToListOfDicts(DictEntry** dictOfLists, size_t numEntries, DictEntry** result) {
    *result = malloc(numEntries * sizeof(DictEntry));
    
    for (size_t i = 0; i < numEntries; ++i) {
        (*result)[i].key = strdup(dictOfLists[i]->key);
        (*result)[i].values = malloc(dictOfLists[i]->length * sizeof(int));
        
        for (size_t j = 0; j < dictOfLists[i]->length; ++j) {
            (*result)[i].values[j] = dictOfLists[i]->values[j];
        }
        
        (*result)[i].length = dictOfLists[i]->length;
    }
}

int main() {
    // Example usage
    DictEntry dict1 = {"one", (int[]){1, 2}, 2};
    DictEntry dict2 = {"two", (int[]){3, 4}, 2};
    
    DictEntry* dictOfLists[] = {&dict1, &dict2};
    size_t numEntries = sizeof(dictOfLists) / sizeof(dictOfLists[0]);
    
    DictEntry* result;
    dictOfListsToListOfDicts(dictOfLists, numEntries, &result);
    
    // Print the result
    for (size_t i = 0; i < numEntries; ++i) {
        printf("Key: %s\n", result[i].key);
        printf("Values: ");
        for (size_t j = 0; j < result[i].length; ++j) {
            printf("%d ", result[i].values[j]);
        }
        printf("\n");
        
        free(result[i].key);
        free(result[i].values);
    }
    
    free(result);
    
    return 0;
}
```

### C++ Code

```cpp
#include <iostream>
#include <vector>
#include <string>

struct DictEntry {
    std::string key;
    std::vector<int> values;
};

std::vector<DictEntry> dictOfListsToListOfDicts(const std::vector<DictEntry>& dictOfLists) {
    std::vector<DictEntry> result;
    
    for (const auto& entry : dictOfLists) {
        DictEntry newEntry;
        newEntry.key = entry.key;
        newEntry.values = entry.values;
        
        result.push_back(newEntry);
    }
    
    return result;
}

int main() {
    // Example usage
    DictEntry dict1 = {"one", {1, 2}};
    DictEntry dict2 = {"two", {3, 4}};
    
    std::vector<DictEntry> dictOfLists = {dict1, dict2};
    
    std::vector<DictEntry> result = dictOfListsToListOfDicts(dictOfLists);
    
    // Print the result
    for (const auto& entry : result) {
        std::cout << "Key: " << entry.key << "\n";
        std::cout << "Values: ";
        for (const auto& val : entry.values) {
            std::cout << val << " ";
        }
        std::cout << "\n";
    }
    
    return 0;
}
```

### Explanation

- **C Code**: 
  - Defines a `DictEntry` structure to represent an entry in the dictionary.
  - The `dictOfListsToListOfDicts` function takes an array of `DictEntry` pointers and converts it into a dynamically allocated array of `DictEntry`.
  
- **C++ Code**:
  - Uses `std::vector` instead of dynamic arrays for better memory management and convenience.
  - The `dictOfListsToListOfDicts` function takes a vector of `DictEntry` objects and returns a vector of `DictEntry` objects.

Both versions maintain the functionality of converting a dictionary of lists into a list of dictionaries.