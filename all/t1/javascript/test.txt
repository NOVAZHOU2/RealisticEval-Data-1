Certainly! Below is the equivalent Jest test suite for the given Python unittest class. I will convert each test case and ensure that the functionality and logic are preserved.

### Python Unittest Code

```python
import unittest

class TestSmartConvert(unittest.TestCase):
    def test_convert_integer(self):
        self.assertEqual(numerical_str_convert("123"), 123, "Should convert to integer")

    def test_convert_float(self):
        self.assertEqual(numerical_str_convert("123.45"), 123.45, "Should convert to float")

    def test_convert_non_numeric_string(self):
        self.assertEqual(numerical_str_convert("abc"), "abc", "Should remain a string")

    def test_convert_negative_integer(self):
        self.assertEqual(numerical_str_convert("-456"), -456, "Should convert to negative integer")

    def test_convert_negative_float(self):
        self.assertEqual(numerical_str_convert("-456.78"), -456.78, "Should convert to negative float")
```

### Equivalent Jest Test Suite

First, let's define the `numericalStrConvert` function in JavaScript:

```javascript
function numericalStrConvert(value) {
    // Attempt to parse the string as an integer
    const intValue = parseInt(value, 10);
    if (!isNaN(intValue) && intValue.toString() === value) {
        return intValue;
    }

    // If not an integer, attempt to parse the string as a floating-point number
    const floatValue = parseFloat(value);
    if (!isNaN(floatValue) && floatValue.toString() === value) {
        return floatValue;
    }

    // If not an integer or a floating-point number, return the original string
    return value;
}
```

Now, let's write the Jest test suite:

```javascript
const numericalStrConvert = require('./numericalStrConvert'); // Assuming the function is in a separate file

describe('TestSmartConvert', () => {
    it('should convert to integer', () => {
        expect(numericalStrConvert("123")).toBe(123);
    });

    it('should convert to float', () => {
        expect(numericalStrConvert("123.45")).toBe(123.45);
    });

    it('should remain a string for non-numeric input', () => {
        expect(numericalStrConvert("abc")).toBe("abc");
    });

    it('should convert to negative integer', () => {
        expect(numericalStrConvert("-456")).toBe(-456);
    });

    it('should convert to negative float', () => {
        expect(numericalStrConvert("-456.78")).toBe(-456.78);
    });
});
```

### Explanation:
1. **Importing the Function**:
   - The `numericalStrConvert` function is imported from a separate file using `require`. You can adjust this based on your project setup.

2. **Describe Block**:
   - The `describe` block groups the test cases together under a descriptive name (`TestSmartConvert`).

3. **Test Cases**:
   - Each test case is defined using the `it` function.
   - The `expect` function is used to assert the expected behavior of the `numericalStrConvert` function.
   - `toBe` is used to check for strict equality.

### Notes:
- **Floating-Point Precision**:
  - In JavaScript, floating-point comparisons can sometimes have precision issues. If you need more precise floating-point comparisons, you can use `expect(value).toBeCloseTo(expectedValue)` instead of `toBe`.

Hereâ€™s an example with `toBeCloseTo` for floating-point comparisons:

```javascript
describe('TestSmartConvert', () => {
    it('should convert to integer', () => {
        expect(numericalStrConvert("123")).toBe(123);
    });

    it('should convert to float', () => {
        expect(numericalStrConvert("123.45")).toBeCloseTo(123.45);
    });

    it('should remain a string for non-numeric input', () => {
        expect(numericalStrConvert("abc")).toBe("abc");
    });

    it('should convert to negative integer', () => {
        expect(numericalStrConvert("-456")).toBe(-456);
    });

    it('should convert to negative float', () => {
        expect(numericalStrConvert("-456.78")).toBeCloseTo(-456.78);
    });
});
```

This conversion ensures that the functionality and logic of the tests are preserved while adapting to Jest's syntax and best practices.