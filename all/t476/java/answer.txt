Below is the equivalent Java code for the provided Python code. The Java code is organized within the package `org.real.temp` and the class `Answer`. It includes the necessary imports, type declarations, method signatures, and object-oriented principles.

```java
package org.real.temp;

import java.util.*;

public class Answer {
    /**
     * Achieve topological sorting based on depth-first search.
     *
     * @param vertices A list of vertices in the graph. Each vertex should be a unique integer.
     * @param edges A list of tuples where each tuple represents a directed edge in the graph and is formed as (start_vertex, end_vertex).
     * @return A list of vertices in topological order. If the graph contains a cycle, and thus cannot have a valid topological ordering, an empty list is returned.
     */
    public static List<Integer> topologicalSortDFS(List<Integer> vertices, List<int[]> edges) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();
        Deque<Integer> result = new ArrayDeque<>();

        // Build the graph
        for (int[] edge : edges) {
            int start = edge[0];
            int end = edge[1];
            graph.computeIfAbsent(start, k -> new ArrayList<>()).add(end);
        }

        // Recursive depth-first search function
        class DFSHelper {
            void dfs(int node) {
                if (visited.contains(node)) {
                    return;
                }
                visited.add(node);
                List<Integer> neighbors = graph.getOrDefault(node, Collections.emptyList());
                for (int neighbor : neighbors) {
                    if (!visited.contains(neighbor)) {
                        dfs(neighbor);
                    }
                }
                result.addFirst(node);  // Add the node to the front of the result
            }
        }

        DFSHelper helper = new DFSHelper();

        // Traverse all nodes
        for (Integer vertex : vertices) {
            if (!visited.contains(vertex)) {
                helper.dfs(vertex);
            }
        }

        return new ArrayList<>(result);
    }

    public static void main(String[] args) {
        List<Integer> vertices = Arrays.asList(1, 2, 3, 4, 5);
        List<int[]> edges = Arrays.asList(new int[]{1, 2}, new int[]{1, 3}, new int[]{2, 4}, new int[]{3, 4}, new int[]{4, 5});

        List<Integer> sortedVertices = topologicalSortDFS(vertices, edges);
        System.out.println(sortedVertices);
    }
}
```

### Explanation:
1. **Imports**: Added necessary imports for `Map`, `HashMap`, `Set`, `HashSet`, `Deque`, `ArrayDeque`, and `List`.
2. **Method Signature**: The method `topologicalSortDFS` is defined to match the functionality of the Python code.
3. **Graph Representation**: Used a `Map<Integer, List<Integer>>` to represent the graph, where the key is a vertex and the value is a list of its neighbors.
4. **Visited Set**: Used a `Set<Integer>` to keep track of visited vertices.
5. **Result**: Used an `ArrayDeque<Integer>` to store the result, which allows efficient operations at both ends.
6. **Inner Class**: Created an inner class `DFSHelper` to encapsulate the recursive depth-first search functionality.
7. **Traversal**: Iterated over all vertices and performed DFS if they have not been visited yet.
8. **Main Method**: Added a simple `main` method to demonstrate how to call the `topologicalSortDFS` method and print the result.

This Java code maintains the same functionality and logic as the provided Python code while adhering to Java's syntax and best practices.