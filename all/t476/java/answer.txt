Here's how you can translate the Python code into Java:

```java
import java.util.*;

public class Answer {
    public static List<Integer> topologicalSortDFS(List<Integer> vertices, List<List<Integer>> edges) {
        Map<Integer, List<Integer>> adjacencyList = new HashMap<>();
        for(int v : vertices){
            adjacencyList.put(v, new ArrayList<>());
        }
        for(List<Integer> e : edges){
            adjacencyList.get(e.get(0)).add(e.get(1));
        }

        Stack<Integer> stack = new Stack<>();
        boolean[] visited = new boolean[vertices.size()];
        for(int i=0; i<visited.length; i++){
            if(!visited[i]){
                dfs(adjacencyList, visited, i, stack);
            }
        }

        List<Integer> result = new ArrayList<>();
        while (!stack.isEmpty()){
            result.add(stack.pop());
        }
        
        return result;
    }

    private static void dfs(Map<Integer, List<Integer>> adjacencyList, boolean[] visited, int current, Stack<Integer> stack){
        visited[current] = true;
        for(int neighbor : adjacencyList.get(current)){
            if(!visited[neighbor]){
                dfs(adjacencyList, visited, neighbor, stack);
            }
        }
        stack.push(current);
    }
}
```
This Java code does essentially the same thing as your original Python function. It creates an adjacency list using a `HashMap` to represent the graph, then performs a DFS on every unvisited node to populate a `Stack`. Finally, it pops all elements from the stack to get the topologically sorted list.

Please note that this implementation assumes that the input vertices are 0-indexed. If they're not, you'll need to adjust the code accordingly. Also, it doesn't check for cycles in the graph, so if there's a cycle, it will still attempt to perform a topological sort which may lead to incorrect results or even a `StackOverflowError` due to infinite recursion.