Here's how you can write the above Python function in TypeScript:

```typescript
type Edge = [number, number];
type Graph = Map<number, number[]>;

function topologicalSortDfs(vertices: number[], edges: Edge[]): number[] {
    let adjList: Graph = new Map();
    let visited: boolean[] = Array(vertices.length).fill(false);
    let stack: number[] = [];

    // Build adjacency list representation of the graph
    for(let i=0; i<vertices.length; i++) {
        adjList.set(vertices[i], []);
    }

    for(let edge of edges) {
        adjList.get(edge[0])?.push(edge[1]);
    }

    // Depth first search
    for(let v of vertices) {
        if(!visited[v]) {
            dfs(v);
        }
    }

    // Function to perform DFS
    function dfs(v: number) {
        visited[v] = true;

        for(let neighbor of adjList.get(v)!) {
            if(!visited[neighbor]) {
                dfs(neighbor);
            }
        }

        stack.push(v);
    }

    return stack.reverse();
}
```

This code creates a directed acyclic graph using an adjacency list, then performs a depth-first search to find all nodes reachable from each node. It pushes each visited node onto a stack and finally returns the contents of the stack reversed, which gives us the topological sort of the graph. 

Note that it assumes the input vertices are 0-indexed and are consecutive integers starting from 0. If your vertices are not 0-indexed or are not consecutive, you'll need to adjust the code accordingly.