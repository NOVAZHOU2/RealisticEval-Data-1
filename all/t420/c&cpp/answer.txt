Certainly! Below is the equivalent C++ code for the provided Python functions, ensuring that the functionality, logic, and structure remain consistent:

```cpp
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <limits>
#include <sstream>

// Function to read the file and convert each line into a vector of strings
std::vector<std::vector<std::string>> read_file_as_sequences(const std::string& file_path) {
    std::ifstream file(file_path);
    std::vector<std::vector<std::string>> sequences;
    std::string line;

    if (!file.is_open()) {
        std::cerr << "Error opening file: " << file_path << std::endl;
        return sequences;
    }

    while (std::getline(file, line)) {
        std::istringstream iss(line);
        std::vector<std::string> words;
        std::string word;
        while (iss >> word) {
            words.push_back(word);
        }
        sequences.push_back(words);
    }

    file.close();
    return sequences;
}

// Function to find the indices of two words in a sequence and calculate their closest distances
int find_closest_word_indices(const std::vector<std::string>& sequence, const std::string& word1, const std::string& word2) {
    std::vector<int> word1_indices;
    std::vector<int> word2_indices;
    int min_distance = std::numeric_limits<int>::max();

    for (size_t index = 0; index < sequence.size(); ++index) {
        if (sequence[index] == word1) {
            word1_indices.push_back(static_cast<int>(index));
        } else if (sequence[index] == word2) {
            word2_indices.push_back(static_cast<int>(index));
        }
    }

    for (int index1 : word1_indices) {
        for (int index2 : word2_indices) {
            int distance = std::abs(index1 - index2);
            if (distance < min_distance) {
                min_distance = distance;
            }
        }
    }

    return min_distance;
}

// Function to determine the minimum distance between two words in any line of a file
std::pair<int, int> get_min_distance(const std::string& file_path, const std::string& word1, const std::string& word2) {
    std::vector<std::vector<std::string>> sequences = read_file_as_sequences(file_path);
    int min_distance = std::numeric_limits<int>::max();
    int min_seq_num = -1;

    for (size_t i = 0; i < sequences.size(); ++i) {
        int distance = find_closest_word_indices(sequences[i], word1, word2);
        if (distance < min_distance) {
            min_distance = distance;
            min_seq_num = static_cast<int>(i);
        }
    }

    if (min_distance == std::numeric_limits<int>::max()) {
        return std::make_pair(-1, -1); // Equivalent to (None, None) in Python
    }

    return std::make_pair(min_seq_num, min_distance);
}

int main() {
    // Example usage
    std::string file_path = "example.txt";
    std::string word1 = "word1";
    std::string word2 = "word2";
    auto result = get_min_distance(file_path, word1, word2);

    if (result.first != -1) {
        std::cout << "Minimum distance: " << result.second << " at line " << result.first << std::endl;
    } else {
        std::cout << "Words not found." << std::endl;
    }

    return 0;
}
```

### Explanation:
1. **File Reading**: The `read_file_as_sequences` function reads the file and converts each line into a vector of strings.
2. **Index Finding**: The `find_closest_word_indices` function finds the indices of two words in a sequence and calculates their closest distances.
3. **Distance Calculation**: The `get_min_distance` function determines the minimum distance between two words in any line of a file.

The code uses standard C++ libraries and handles file operations, string manipulations, and vector operations efficiently. It also includes error handling for file opening and returns appropriate values when words are not found.