Here is the C++ version of your Python function:

```cpp
#include <vector>
#include <algorithm>

using namespace std;

vector<vector<float>> floydWarshall(vector<vector<float>>& adjMatrix) {
    int n = adjMatrix.size();
    for(int k=0; k<n; ++k)
        for(int i=0; i<n; ++i)
            for(int j=0; j<n; ++j)
                if(adjMatrix[i][k] != numeric_limits<float>::infinity() && adjMatrix[k][j] != numeric_limits<float>::infinity())
                    adjMatrix[i][j] = min(adjMatrix[i][j], adjMatrix[i][k] + adjMatrix[k][j]);
    return adjMatrix;
}
```

This C++ function takes a 2D vector `adjMatrix` as input and returns a new 2D vector which contains the shortest path distances between all pairs of vertices. It uses nested loops to iterate over all possible intermediate vertices (`k`) and updates the shortest path distances accordingly. Note that we use `numeric_limits<float>::infinity()` to represent infinity in C++.