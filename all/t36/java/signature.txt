Certainly! Below is the equivalent Java code for the given Python function, including appropriate Java method signatures, type conversions, and Javadoc comments:

```java
package org.real.temp;

import java.util.ArrayList;
import java.util.List;

/**
 * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices
 * in a graph represented by an adjacency matrix.
 */
public class Answer {

    /**
     * Implements the Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices
     * in a graph represented by an adjacency matrix.
     *
     * @param adjacencyMatrix The adjacency matrix representing the graph,
     *                        where adjacencyMatrix[i][j] is the weight of the edge from vertex i to vertex j.
     *                        If there is no edge, the weight should be represented as Double.POSITIVE_INFINITY.
     * @return The matrix representing the shortest paths between all pairs of vertices.
     *         shortestPaths[i][j] will hold the shortest distance from vertex i to vertex j.
     */
    public static List<List<Double>> floydWarshallShortestPaths(List<List<Double>> adjacencyMatrix) {
        int numVertices = adjacencyMatrix.size();

        return _recursiveFloydWarshall(adjacencyMatrix, numVertices, 0);
    }

    /**
     * Recursive helper function for the Floyd-Warshall algorithm.
     *
     * @param adjacencyMatrix The current adjacency matrix.
     * @param numVertices     The number of vertices in the graph.
     * @param k               The current intermediate vertex being considered.
     * @return The updated adjacency matrix after considering the current intermediate vertex.
     */
    private static List<List<Double>> _recursiveFloydWarshall(List<List<Double>> adjacencyMatrix, int numVertices, int k) {
        if (k == numVertices) {
            return adjacencyMatrix;
        }
        for (int i = 0; i < numVertices; i++) {
            for (int j = 0; j < numVertices; j++) {
                double viaK = adjacencyMatrix.get(i).get(k) + adjacencyMatrix.get(k).get(j);
                double currentDistance = adjacencyMatrix.get(i).get(j);

                if (currentDistance > viaK) {
                    adjacencyMatrix.get(i).set(j, viaK);
                }
            }
        }
        return _recursiveFloydWarshall(adjacencyMatrix, numVertices, k + 1);
    }

    public static void main(String[] args) {
        // Example usage
        List<List<Double>> adjacencyMatrix = new ArrayList<>();
        adjacencyMatrix.add(new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, 3.0, Double.POSITIVE_INFINITY, 7.0)));
        adjacencyMatrix.add(new ArrayList<>(Arrays.asList(2.0, Double.POSITIVE_INFINITY, 5.0, 1.0)));
        adjacencyMatrix.add(new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)));
        adjacencyMatrix.add(new ArrayList<>(Arrays.asList(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 2.0, Double.POSITIVE_INFINITY)));

        List<List<Double>> shortestPaths = floydWarshallShortestPaths(adjacencyMatrix);
        System.out.println(shortestPaths);
    }
}
```

### Explanation:
1. **Package and Class Definition**: The Java code starts with the package declaration `package org.real.temp;` and defines the class `Answer`.

2. **Javadoc Comments**: The Javadoc comments provide detailed documentation for the methods, including the parameters and return values.

3. **Method Definitions**:
   - `floydWarshallShortestPaths`: This method is the entry point for the Floyd-Warshall algorithm. It initializes the process and calls the recursive helper method `_recursiveFloydWarshall`.
   - `_recursiveFloydWarshall`: This is a private helper method that implements the recursive part of the Floyd-Warshall algorithm. It updates the distances based on the intermediate vertex `k`.

4. **Type Handling**: In Java, we use `List<List<Double>>` to represent the adjacency matrix. `Double.POSITIVE_INFINITY` is used to represent infinity.

5. **Recursive Logic**: The recursive logic is implemented using nested loops to update the distances between vertices.

6. **Example Usage**: The `main` method provides an example of how to use the `floydWarshallShortestPaths` method and prints the resulting shortest paths matrix.

This Java code preserves the functionality and structure of the original Python code while adhering to Java's syntax and best practices.