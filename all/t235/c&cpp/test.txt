Here is how you can write the equivalent C++ Catch2 test case for your Python unittest test class:

```cpp
#include <catch2/catch.hpp>
#include <cmath>

// Function to convert degrees to radians
double deg_to_rad(double degree)
{
    return degree * M_PI / 180;
}

// Function to calculate bearing
double calculate_bearing(double lat1, double lon1, double lat2, double lon2)
{
    // Convert latitudes and longitudes from degrees to radians
    lat1 = deg_to_rad(lat1);
    lon1 = deg_to_rad(lon1);
    lat2 = deg_to_rad(lat2);
    lon2 = deg_to_rad(lon2);

    // Calculate the difference in longitudes
    double dLon = lon2 - lon1;

    // Use the formula to calculate the bearing
    double y = sin(dLon) * cos(lat2);
    double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);
    double initialBearing = atan2(y, x);

    // Normalize the bearing to be between 0 and 360 degrees
    double bearing = (initialBearing * 180 / M_PI + 360) % 360;

    return bearing;
}

TEST_CASE("Calculate bearing", "[calculate_bearing]")
{
    REQUIRE(calculate_bearing(52.2296756, 21.0122287, 41.8919300, 12.5113300) == Approx(158.0));
    REQUIRE(calculate_bearing(-33.8688200, 151.2092960, 37.7749296, -122.4194180) == Approx(135.0));
}
```

This C++ code uses the Catch2 testing framework to define a test case that tests the `calculate_bearing` function with the same parameters as your Python unittest test class. The `Approx` matcher is used to compare floating-point numbers with a specified tolerance.