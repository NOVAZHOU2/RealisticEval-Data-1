Certainly! Here is the equivalent C++ test class using the Catch2 testing framework. I will ensure that the functionality and logic of the tests are preserved, and use appropriate assertions in Catch2.

First, make sure you have Catch2 installed and included in your project. You can include Catch2 by adding the header file and ensuring it is properly set up in your build system.

### C++ Code with Catch2 Testing Framework

```cpp
#include <catch2/catch_test_macros.hpp>
#include <cmath>

// Function to calculate the azimuth between two points on the earth
/**
 * Calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as parameters and returns the azimuth from the first point to the second point in degrees.
 *
 * @param lat1 Latitude of the starting point in decimal degrees.
 * @param lon1 Longitude of the starting point in decimal degrees.
 * @param lat2 Latitude of the ending point in decimal degrees.
 * @param lon2 Longitude of the ending point in decimal degrees.
 *
 * @return Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.
 */
double calculateBearing(double lat1, double lon1, double lat2, double lon2) {
    // Convert latitude and longitude from degrees to radians
    double lat1_rad = lat1 * M_PI / 180.0;
    double lon1_rad = lon1 * M_PI / 180.0;
    double lat2_rad = lat2 * M_PI / 180.0;
    double lon2_rad = lon2 * M_PI / 180.0;

    // Difference in longitude
    double delta_lon_rad = lon2_rad - lon1_rad;

    // Calculate the bearing components
    double x = std::sin(delta_lon_rad) * std::cos(lat2_rad);
    double y = std::cos(lat1_rad) * std::sin(lat2_rad) - (std::sin(lat1_rad) * std::cos(lat2_rad) * std::cos(delta_lon_rad));

    // Calculate the initial bearing in radians
    double initial_bearing_rad = std::atan2(x, y);

    // Convert the initial bearing from radians to degrees
    double initial_bearing_deg = initial_bearing_rad * 180.0 / M_PI;

    // Normalize the bearing to 0-360 degrees
    double compass_bearing = fmod((initial_bearing_deg + 360.0), 360.0);

    return compass_bearing;
}

TEST_CASE("Test Calculate Bearing") {
    SECTION("North Bearing") {
        // From equator directly north
        REQUIRE_THAT(calculate_bearing(0, 0, 10, 0), Catch::Approx(0));
    }

    SECTION("East Bearing") {
        // From prime meridian directly east
        REQUIRE_THAT(calculate_bearing(0, 0, 0, 10), Catch::Approx(90));
    }

    SECTION("South Bearing") {
        // From a point directly south
        REQUIRE_THAT(calculate_bearing(10, 0, 0, 0), Catch::Approx(180));
    }

    SECTION("West Bearing") {
        // From a point directly west
        REQUIRE_THAT(calculate_bearing(0, 10, 0, 0), Catch::Approx(270));
    }

    SECTION("Across Prime Meridian") {
        // From a point west of the prime meridian to a point east
        REQUIRE_THAT(calculate_bearing(0, -1, 0, 1), Catch::Approx(90));
    }
}

int main(int argc, char* argv[]) {
    int result = Catch::Session().run(argc, argv);
    return result;
}
```

### Explanation:
1. **Header Files**: Include the necessary header files (`<catch2/catch_test_macros.hpp>` and `<cmath>`).
2. **Function Definition**: The `calculateBearing` function is defined with the same logic and structure as the Python version.
3. **Test Class**: The test cases are defined using Catch2's `TEST_CASE` and `SECTION` macros.
4. **Assertions**: Use `REQUIRE_THAT` with `Catch::Approx` to perform floating-point comparisons, which is equivalent to `assertAlmostEqual` in Python.
5. **Main Function**: The `main` function initializes and runs the Catch2 test session.

This C++ code preserves the functionality and logic of the original Python tests, ensuring that the tests are performed accurately and consistently.