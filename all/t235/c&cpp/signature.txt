Certainly! Here is the equivalent C++ code for the provided Python function, including the function signature, comments, and documentation:

```cpp
#include <cmath>
#include <iostream>

// Function to calculate the azimuth between two points on the earth
/**
 * Calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as parameters and returns the azimuth from the first point to the second point in degrees.
 *
 * @param lat1 Latitude of the starting point in decimal degrees.
 * @param lon1 Longitude of the starting point in decimal degrees.
 * @param lat2 Latitude of the ending point in decimal degrees.
 * @param lon2 Longitude of the ending point in decimal degrees.
 *
 * @return Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.
 */
double calculateBearing(double lat1, double lon1, double lat2, double lon2) {
    // Convert latitude and longitude from degrees to radians
    double lat1_rad = lat1 * M_PI / 180.0;
    double lon1_rad = lon1 * M_PI / 180.0;
    double lat2_rad = lat2 * M_PI / 180.0;
    double lon2_rad = lon2 * M_PI / 180.0;

    // Difference in longitude
    double delta_lon_rad = lon2_rad - lon1_rad;

    // Calculate the bearing components
    double x = std::sin(delta_lon_rad) * std::cos(lat2_rad);
    double y = std::cos(lat1_rad) * std::sin(lat2_rad) - (std::sin(lat1_rad) * std::cos(lat2_rad) * std::cos(delta_lon_rad));

    // Calculate the initial bearing in radians
    double initial_bearing_rad = std::atan2(x, y);

    // Convert the initial bearing from radians to degrees
    double initial_bearing_deg = initial_bearing_rad * 180.0 / M_PI;

    // Normalize the bearing to 0-360 degrees
    double compass_bearing = fmod((initial_bearing_deg + 360.0), 360.0);

    return compass_bearing;
}

int main() {
    // Example usage
    double lat1 = 52.2296756;
    double lon1 = 21.0122287;
    double lat2 = 41.8919300;
    double lon2 = 12.5113300;

    double bearing = calculateBearing(lat1, lon1, lat2, lon2);
    std::cout << "Bearing: " << bearing << " degrees" << std::endl;

    return 0;
}
```

### Explanation:
1. **Header Files**: The necessary header files (`<cmath>` and `<iostream>`) are included.
2. **Function Documentation**: The function `calculateBearing` is documented using C++ style comments (`/* ... */`).
3. **Function Signature**: The function signature is defined with the appropriate types (`double` for floating-point values).
4. **Radians Conversion**: The conversion from degrees to radians uses the constant `M_PI` from `<cmath>`.
5. **Bearing Calculation**: The calculations for the bearing components and normalization are performed using standard C++ math functions (`std::sin`, `std::cos`, `std::atan2`, `fmod`).
6. **Main Function**: An example usage of the `calculateBearing` function is provided in the `main` function.

This C++ code preserves the original functionality and structure of the Python code, including the documentation and type annotations.