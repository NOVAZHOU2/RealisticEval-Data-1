Certainly! Below is the equivalent Jest test suite for the given Python unittest class. The goal is to maintain the functionality and logic of the tests while adapting them to Jest's syntax and conventions.

### Python Code:
```python
import unittest

k_B_over_keV = 8.617333262145e-5  # eV/K to keV/K

class TestConvertLog10KToKeV(unittest.TestCase):

    def test_scalar_input(self):
        """Test conversion of a single scalar log10(K) value."""
        T_log10_K = 3.0
        expected_result = 10 ** T_log10_K * k_B_over_keV
        result = convert_log10_K_to_keV(T_log10_K)
        self.assertAlmostEqual(result, expected_result, places=6)

    def test_tuple_input(self):
        """Test conversion of a tuple of log10(K) values."""
        T_log10_K = (2.0, 3.0, 4.0)
        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)
        result = convert_log10_K_to_keV(T_log10_K)
        self.assertEqual(result, expected_results)

    def test_zero_input(self):
        """Test conversion of log10(K) = 0."""
        T_log10_K = 0.0
        expected_result = 10 ** T_log10_K * k_B_over_keV
        result = convert_log10_K_to_keV(T_log10_K)
        self.assertAlmostEqual(result, expected_result, places=6)

    def test_negative_input(self):
        """Test conversion of a negative log10(K) value."""
        T_log10_K = -1.0
        expected_result = 10 ** T_log10_K * k_B_over_keV
        result = convert_log10_K_to_keV(T_log10_K)
        self.assertAlmostEqual(result, expected_result, places=6)

    def test_large_tuple_input(self):
        """Test conversion of a large tuple of log10(K) values."""
        T_log10_K = (1.0, 2.0, 3.0, 4.0, 5.0)
        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)
        result = convert_log10_K_to_keV(T_log10_K)
        self.assertEqual(result, expected_results)

    def test_single_large_value(self):
        """Test conversion of a large log10(K) value."""
        T_log10_K = 10.0
        expected_result = 10 ** T_log10_K * k_B_over_keV
        result = convert_log10_K_to_keV(T_log10_K)
        self.assertAlmostEqual(result, expected_result, places=6)

    def test_invalid_input(self):
        """Test conversion with invalid input (string)."""
        T_log10_K = "invalid"
        with self.assertRaises(ValueError):
            convert_log10_K_to_keV(T_log10_K)
```

### Equivalent Jest Test Suite:

```javascript
const { convertLog10KToKeV } = require('./path/to/convertLog10KToKeV'); // Import the function to test

describe('TestConvertLog10KToKeV', () => {
    const k_B_over_keV = 8.617333262145e-5; // eV/K to keV/K

    describe('Scalar Input', () => {
        it('should correctly convert a single scalar log10(K) value', () => {
            const T_log10_K = 3.0;
            const expected_result = Math.pow(10, T_log10_K) * k_B_over_keV;
            const result = convertLog10KToKeV(T_log10_K);
            expect(result).toBeCloseTo(expected_result, 6);
        });
    });

    describe('Tuple Input', () => {
        it('should correctly convert a tuple of log10(K) values', () => {
            const T_log10_K = [2.0, 3.0, 4.0];
            const expected_results = T_log10_K.map(t => Math.pow(10, t) * k_B_over_keV);
            const result = convertLog10KToKeV(T_log10_K);
            expect(result).toEqual(expected_results);
        });
    });

    describe('Zero Input', () => {
        it('should correctly convert log10(K) = 0', () => {
            const T_log10_K = 0.0;
            const expected_result = Math.pow(10, T_log10_K) * k_B_over_keV;
            const result = convertLog10KToKeV(T_log10_K);
            expect(result).toBeCloseTo(expected_result, 6);
        });
    });

    describe('Negative Input', () => {
        it('should correctly convert a negative log10(K) value', () => {
            const T_log10_K = -1.0;
            const expected_result = Math.pow(10, T_log10_K) * k_B_over_keV;
            const result = convertLog10KToKeV(T_log10_K);
            expect(result).toBeCloseTo(expected_result, 6);
        });
    });

    describe('Large Tuple Input', () => {
        it('should correctly convert a large tuple of log10(K) values', () => {
            const T_log10_K = [1.0, 2.0, 3.0, 4.0, 5.0];
            const expected_results = T_log10_K.map(t => Math.pow(10, t) * k_B_over_keV);
            const result = convertLog10KToKeV(T_log10_K);
            expect(result).toEqual(expected_results);
        });
    });

    describe('Single Large Value', () => {
        it('should correctly convert a large log10(K) value', () => {
            const T_log10_K = 10.0;
            const expected_result = Math.pow(10, T_log10_K) * k_B_over_keV;
            const result = convertLog10KToKeV(T_log10_K);
            expect(result).toBeCloseTo(expected_result, 6);
        });
    });

    describe('Invalid Input', () => {
        it('should throw an error when input is invalid', () => {
            const T_log10_K = "invalid";
            expect(() => convertLog10KToKeV(T_log10_K)).toThrow("Input must be a scalar (number) or an array of temperatures.");
        });
    });
});
```

### Explanation:
1. **Import Function**: The `convertLog10KToKeV` function is imported at the beginning.
2. **Describe Blocks**: Each test case is wrapped in a `describe` block to group related tests.
3. **It Blocks**: Each test case is defined using `it` blocks, which contain the actual assertions.
4. **Assertions**:
   - `toBeCloseTo`: Used for floating-point comparisons, similar to `assertAlmostEqual` in Python.
   - `toEqual`: Used for comparing arrays or objects, similar to `assertEqual` in Python.
   - `toThrow`: Used to check if a function throws an error, similar to `assertRaises` in Python.
5. **Mathematical Operations**: `Math.pow(10, T_log10_K)` is used to compute powers of 10, similar to `10 ** T_log10_K` in Python.

This Jest test suite ensures that the functionality and logic of the original Python unittest class are preserved while adapting to Jest's syntax and conventions.