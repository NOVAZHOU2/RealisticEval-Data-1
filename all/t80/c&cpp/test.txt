Certainly! Below is the equivalent C++ test class using the Catch2 testing framework. The provided Python unittest class will be converted into a set of Catch2 test cases, ensuring that the functionality and logic of the tests are preserved.

### C++ Code Using Catch2

First, make sure you have Catch2 installed and included in your project. You can include Catch2 using the following headers:

```cpp
#include <catch2/catch_test_macros.hpp>
#include <string>
#include <regex>

// Function to remove illegal characters from Windows file path string
std::string sanitize_filename(const std::string& filename) {
    // Define the illegal characters for Windows filenames
    std::regex illegal_chars_pattern("[<>:\"/\\\\|?*\\x00-\\x1F]");

    // Replace illegal characters with an underscore
    std::string sanitized = std::regex_replace(filename, illegal_chars_pattern, "_");

    // Optionally, limit the length of the filename
    // Windows has a maximum path length of 260 characters
    const size_t max_length = 255;
    if (sanitized.length() > max_length) {
        sanitized = sanitized.substr(0, max_length);
    }

    return sanitized;
}

TEST_CASE("TestSanitizeFilename", "[sanitize_filename]") {
    SECTION("test_valid_filename") {
        REQUIRE(sanitize_filename("valid_filename.txt") == "valid_filename.txt");
    }

    SECTION("test_illegal_characters") {
        REQUIRE(sanitize_filename("invalid<filename>.txt") == "invalid_filename_.txt");
        REQUIRE(sanitize_filename("file/name:with*illegal|chars?.txt") == "file_name_with_illegal_chars_.txt");
    }

    SECTION("test_long_filename") {
        std::string long_filename = std::string(300, 'a') + ".txt";
        std::string sanitized_filename = sanitize_filename(long_filename);
        REQUIRE(sanitized_filename.length() == 255);
        REQUIRE(sanitized_filename == std::string(255, 'a'));
    }

    SECTION("test_empty_filename") {
        REQUIRE(sanitize_filename("") == "");
    }
}
```

### Explanation:
1. **Headers**:
   - `#include <catch2/catch_test_macros.hpp>` for Catch2 test macros.
   - `#include <string>` for string manipulation.
   - `#include <regex>` for regular expression handling.

2. **Function Definition**:
   - The `sanitize_filename` function remains the same as before.

3. **Test Class**:
   - The `TEST_CASE` macro is used to define a test case named `TestSanitizeFilename`.
   - Each `SECTION` within the test case corresponds to a specific test method in the Python unittest class.

4. **Assertions**:
   - `REQUIRE` is used for assertions in Catch2. It behaves similarly to `assertEqual` in Python's `unittest`.

5. **Test Cases**:
   - `test_valid_filename`: Checks that a valid filename remains unchanged.
   - `test_illegal_characters`: Checks that filenames with illegal characters are sanitized correctly.
   - `test_long_filename`: Checks that a long filename is truncated to 255 characters.
   - `test_empty_filename`: Checks that an empty filename remains empty after sanitization.

### Running the Tests
To run the tests, you need to link against Catch2 and execute the test binary. Hereâ€™s an example of how to do this:

#### CMake Example:
If you are using CMake, you can add the following to your `CMakeLists.txt`:

```cmake
cmake_minimum_required(VERSION 3.10)
project(SanitizeFilenameTests)

# Find Catch2
find_package(Catch2 REQUIRED)

# Add executable
add_executable(sanitize_filename_tests main.cpp sanitize_filename.cpp)

# Link against Catch2
target_link_libraries(sanitize_filename_tests PRIVATE Catch2::Catch2)
```

#### Main File:
You can create a `main.cpp` file to run the tests:

```cpp
#include <catch2/catch_runners.hpp>

int main(int argc, char* argv[]) {
    return Catch::Session().run(argc, argv);
}
```

This setup ensures that the tests are executed when you build and run the project.