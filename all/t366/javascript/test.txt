First, let's define the equivalent JavaScript function for `extract_text_from_word`. We will use the `docx` library for Node.js, which needs to be installed first:

```bash
npm install docx
```

Now, let's create the JavaScript function and the Jest test class.

### JavaScript Function

Create a file named `extractTextFromWord.js`:

```javascript
const { Document } = require('docx');

function extractTextFromWord(docxFilePath) {
    /**
     * Extracts text content from a given Word file (.docx).
     *
     * @param {string} docxFilePath - The path to the Word file.
     * @returns {Promise<string>} - A promise that resolves to the extracted text content.
     */
    return new Promise((resolve, reject) => {
        const document = new Document({ filePath: docxFilePath });
        document.getText().then(text => {
            resolve(text);
        }).catch(error => {
            reject(error);
        });
    });
}

module.exports = extractTextFromWord;
```

### Jest Test Class

Create a file named `extractTextFromWord.test.js`:

```javascript
const extractTextFromWord = require('./extractTextFromWord');
const fs = require('fs');
const path = require('path');

describe('extractTextFromWord', () => {
    it('should correctly extract text from a valid Word document', async () => {
        const docxFilePath = path.join(__dirname, 'test.docx');
        const expectedText = 'This is a test document.';

        // Mock the document to simulate the expected behavior
        jest.mock('docx', () => ({
            Document: jest.fn(() => ({
                getText: jest.fn(() => Promise.resolve(expectedText)),
            })),
        }), { virtual: true });

        const result = await extractTextFromWord(docxFilePath);
        expect(result).toBe(expectedText);
    });

    it('should handle errors when the Word document cannot be read', async () => {
        const docxFilePath = path.join(__dirname, 'nonexistent.docx');
        const errorMessage = 'File not found';

        // Mock the document to simulate an error
        jest.mock('docx', () => ({
            Document: jest.fn(() => ({
                getText: jest.fn(() => Promise.reject(new Error(errorMessage))),
            })),
        }), { virtual: true });

        await expect(extractTextFromWord(docxFilePath)).rejects.toThrow(errorMessage);
    });

    it('should handle errors when the Word document is invalid', async () => {
        const docxFilePath = path.join(__dirname, 'invalid.docx');
        const errorMessage = 'Invalid document format';

        // Mock the document to simulate an error
        jest.mock('docx', () => ({
            Document: jest.fn(() => ({
                getText: jest.fn(() => Promise.reject(new Error(errorMessage))),
            })),
        }), { virtual: true });

        await expect(extractTextFromWord(docxFilePath)).rejects.toThrow(errorMessage);
    });
});
```

### Explanation

1. **Function Definition**: The JavaScript function `extractTextFromWord` uses promises to handle asynchronous operations. It returns a promise that resolves with the extracted text or rejects with an error if something goes wrong.

2. **Test Cases**:
   - The first test case checks if the function correctly extracts text from a valid Word document.
   - The second test case checks if the function handles errors properly when the Word document cannot be read.
   - The third test case checks if the function handles errors properly when the Word document is invalid.

3. **Mocking**: We use Jest's mocking capabilities to simulate the behavior of the `Document` class and its `getText` method. This allows us to control the output and test various scenarios without needing actual Word documents.

4. **Error Handling**: We use `await expect(...).rejects.toThrow(...)` to handle rejected promises and verify that the correct error message is thrown.

This conversion maintains the functionality and logic of the original Python unittest class while adapting it to work with Jest in JavaScript.