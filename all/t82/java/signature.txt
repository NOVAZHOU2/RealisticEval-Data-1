```java
import java.util.*;
import org.jgrapht.graph.*;

public class Graph {
    private DirectedGraph<String, DefaultEdge> graph;

    public Graph(List<Edge<String>> edges) {
        graph = new DefaultDirectedGraph<>(DefaultEdge.class);
        for (Edge<String> edge : edges) {
            graph.addVertex(edge.getSource());
            graph.addVertex(edge.getTarget());
            graph.addEdge(edge.getSource(), edge.getTarget());
        }
    }

    /**
     * Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.
     *
     * @param filterRepeatNodes If true, filters out cycles where any node appears more than once.
     * @return Map<Integer, List<DirectedGraph<String, DefaultEdge>>> - A map where keys represent cycle sizes and values are lists of directed graph objects representing each unique cycle of that size.
     */
    public Map<Integer, List<DirectedGraph<String, DefaultEdge>>> cyclesBySize(boolean filterRepeatNodes) {
        // Implementation goes here...
        return new HashMap<>();
    }
}

// Helper class for edges
class Edge<T> {
    private T source;
    private T target;

    public Edge(T source, T target) {
        this.source = source;
        this.target = target;
    }

    public T getSource() {
        return source;
    }

    public T getTarget() {
        return target;
    }
}
```

Please note that the `cyclesBySize` method's implementation is not provided here because it would require a specific algorithm to find cycles in a directed graph which isn't covered in the original Python code. This Java version uses JGraphT library for graph operations.