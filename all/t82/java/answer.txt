Here's the equivalent Java code for your Python class `Graph`:

```java
package org.real.temp;

import java.util.*;
import java.util.stream.Collectors;

public class Graph {
    private Map<Integer, Set<List<Integer>>> graph;

    public Graph(List<List<Integer>> edges) {
        this.graph = new HashMap<>();
        for (List<Integer> edge : edges) {
            int u = edge.get(0);
            int v = edge.get(1);
            this.addEdge(u, v);
        }
    }

    private void addEdge(int u, int v) {
        this.graph.computeIfAbsent(u, k -> new HashSet<>()).add(v);
        this.graph.computeIfAbsent(v, k -> new HashSet<>()).put(u, Collections.singleton(u));
    }

    public Map<Integer, List<Set<Integer>>> cyclesBySize(boolean filterRepeatNodes) {
        Map<Integer, List<Set<Integer>>> result = new HashMap<>();
        for (int i = 3; i <= graph.size(); i++) {
            List<Set<Integer>> cycles = findCycles(i, new ArrayList<>(), new HashSet<>());
            if (!cycles.isEmpty()) {
                result.put(i, filterRepeatNodes ? cycles.stream()
                        .filter(this::hasNoRepeatedNodes)
                        .collect(Collectors.toList())
                        : cycles);
            }
        }
        return result;
    }

    private boolean hasNoRepeatedNodes(Set<Integer> cycle) {
        Set<Integer> seen = new HashSet<>();
        for (Integer node : cycle) {
            if (!seen.add(node)) {
                return false;
            }
        }
        return true;
    }

    private List<Set<Integer>> findCycles(int length, List<Integer> currentPath, Set<Integer> visited) {
        int lastNode = currentPath.isEmpty() ? -1 : currentPath.get(currentPath.size() - 1);
        if (currentPath.size() == length && graph.containsKey(lastNode) && graph.get(lastNode).contains(currentPath.get(0))) {
            Set<Integer> cycle = new HashSet<>(currentPath);
            cycle.add(currentPath.get(0)); // Adding back the starting node to complete the cycle
            return Collections.singletonList(cycle);
        }
        List<Set<Integer>> cycles = new ArrayList<>();
        if (lastNode != -1) {
            for (Integer neighbor : graph.get(lastNode)) {
                if (!visited.contains(neighbor)) {
                    currentPath.add(neighbor);
                    visited.add(neighbor);
                    cycles.addAll(findCycles(length, currentPath, visited));
                    visited.remove(neighbor);
                    currentPath.remove(currentPath.size() - 1);
                }
            }
        }
        return cycles;
    }
}
```

This Java code defines a `Graph` class similar to your Python class. It includes methods to add edges and find cycles by size, with an option to filter out cycles with repeated nodes. The `findCycles` method uses recursion to explore all possible paths and identify cycles of the specified length.