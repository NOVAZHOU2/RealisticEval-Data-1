To convert the provided C++ code that generates prime numbers using the Sieve of Eratosthenes algorithm into Python, we'll maintain the logic while adapting it to Python syntax and conventions. Below is the Python equivalent of the given C++ code:
C++ Code
cpp
#include <vector>
#include <stdexcept>

/**
 * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm
 * 
 * @param limit The upper bound (inclusive) for finding prime numbers.
 * @return A vector of integers containing all prime numbers less than or equal to the limit.
 * @throws std::invalid_argument if the limit is less than 2.
 */
std::vector<int> generatePrimes(int limit) {
    if (limit < 2) {
        throw std::invalid_argument("Limit must be greater than or equal to 2.");
    }
    std::vector<bool> isPrime(limit + 1, true);
    isPrime[0] = isPrime[1] = false;  // 0 and 1 are not prime numbers
    for (int i = 2; i * i <= limit; ++i) {
        if (isPrime[i]) {
            for (int j = i * i; j <= limit; j += i) {
                isPrime[j] = false;
            }
        }
    }
    std::vector<int> primes;
    for (int i = 2; i <= limit; ++i) {
        if (isPrime[i]) {
            primes.push_back(i);
        }
    }
    return primes;
}
Python Code
python
from typing import List

def generate_primes(limit: int) -> List[int]:
    """
    Find all prime numbers that are less than or equal to limit using the Sieve of Eratosthenes algorithm.

    :param limit: The upper bound (inclusive) for finding prime numbers.
    :return: A list of integers containing all prime numbers less than or equal to the limit.
    :raises ValueError: If the limit is less than 2.
    """
    if limit < 2:
        raise ValueError("Limit must be greater than or equal to 2.")

    is_prime = [True] * (limit + 1)  # Create a list to track prime status
    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers

    # Sieve of Eratosthenes algorithm
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, limit + 1, i):
                is_prime[j] = False

    # Collecting all prime numbers
    primes = [i for i in range(2, limit + 1) if is_prime[i]]
    
    return primes
Key Changes Made:
Imports:
Imported List from the typing module for type hints.
Function Definition:
Converted the C++ function signature to a Python function using def and added type hints.
Error Handling:
Changed the C++ std::invalid_argument exception to Python's ValueError.
List Initialization:
Used a list comprehension to initialize the is_prime list, maintaining the same logic as the C++ vector.
Sieve Logic:
Translated the nested loop structure and index handling from C++ to Python syntax.
Collecting Primes:
Used a list comprehension to create the final list of primes.
This Python code maintains the same functionality as the original C++ code and adheres to Python conventions. If you have any further modifications or questions, feel free to ask!