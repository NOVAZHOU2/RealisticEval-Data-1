Sure, here's how you can translate the Python function signature to C++:

```cpp
#include <string>
#include <vector>

// Assuming we have a class to represent DataFrame
class DataFrame {
public:
    // Method to add data to DataFrame
    void addData(const std::string& column, const std::string& value);
};

/**
 * Convert the XML file into a DataFrame, where each <sequence> tag is treated as a row record in the XML,
 * and the tag and text content of each sub-element are treated as columns and values of the DataFrame.
 *
 * @param xml_file The path to the XML file.
 * @return DataFrame A DataFrame containing the data from the XML file.
 */
DataFrame xmlToDataFrame(const std::string& xmlFile);

```

### Explanation:
1. **Include Necessary Headers**: We include `<string>` for handling string operations and `<vector>` if needed for dynamic arrays.
2. **Define DataFrame Class**: A simple `DataFrame` class is defined with a method `addData` to store data. This is a placeholder for the actual implementation of a DataFrame in C++.
3. **Function Signature**:
   - `xmlToDataFrame`: This function takes a single argument `xmlFile` which is a string representing the path to the XML file.
   - It returns an instance of `DataFrame`.

This C++ code snippet keeps the structure and purpose of the original Python function while translating it to C++. Note that the actual implementation of the `DataFrame` class and the logic to parse the XML file will need additional code.