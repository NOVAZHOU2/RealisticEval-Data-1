To convert the given Python code to C++/C, we need to use libraries that can handle XML parsing and data manipulation. For XML parsing, we can use the `pugixml` library, which is a lightweight and fast XML parser for C++. For data manipulation, we can use the `Eigen` library for matrices and arrays.

Here's a possible implementation in C++:

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <pugixml.hpp>
#include <Eigen/Dense>

// Function to parse XML file and return a map of column names and their corresponding values
std::map<std::string, std::vector<std::string>> parseXML(const std::string& xmlFile) {
    pugi::xml_document doc;
    if (!doc.load_file(xmlFile.c_str())) {
        throw std::runtime_error("Failed to load XML file");
    }

    std::map<std::string, std::vector<std::string>> result;

    for (auto sequence = doc.child("sequences").child("sequence"); sequence; sequence = sequence.next_sibling("sequence")) {
        for (auto child = sequence.first_child(); child; child = child.next_sibling()) {
            const auto& tagName = child.name();
            const auto& tagText = child.text().as_string();

            if (result.find(tagName) == result.end()) {
                result[tagName] = {};
            }
            result[tagName].push_back(tagText);
        }
    }

    return result;
}

// Function to create an Eigen matrix from the parsed data
Eigen::MatrixXd createDataFrame(const std::map<std::string, std::vector<std::string>>& data) {
    size_t numRows = 0;
    for (const auto& pair : data) {
        numRows = std::max(numRows, pair.second.size());
    }

    Eigen::MatrixXd df(data.size(), numRows);

    int colIndex = 0;
    for (const auto& pair : data) {
        for (size_t rowIndex = 0; rowIndex < numRows; ++rowIndex) {
            if (rowIndex < pair.second.size()) {
                df(colIndex, rowIndex) = std::stod(pair.second[rowIndex]);
            } else {
                df(colIndex, rowIndex) = 0.0; // Default value for missing data
            }
        }
        ++colIndex;
    }

    return df;
}

int main() {
    try {
        std::string xmlFile = "path/to/your/xmlfile.xml";
        auto data = parseXML(xmlFile);
        auto df = createDataFrame(data);

        // Print the DataFrame
        std::cout << df << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
```

### Explanation:
1. **XML Parsing**: The `parseXML` function uses `pugixml` to load and parse the XML file. It extracts the tag names and their corresponding text content, storing them in a `std::map`.
2. **Data Manipulation**: The `createDataFrame` function converts the parsed data into an `Eigen::MatrixXd`. Each key in the map corresponds to a column in the DataFrame, and the values are stored in rows.
3. **Main Function**: The `main` function calls these functions and prints the resulting DataFrame.

Make sure to install the required libraries (`pugixml` and `Eigen`) before compiling the code. You can download `pugixml` from its [GitHub repository](https://github.com/zeux/pugixml), and `Eigen` is typically available via package managers like `vcpkg` or `conan`.