Certainly! Below is the equivalent C++ test case using Catch2 for the `reorderData` function:

1. **Include Catch2 Headers**
2. **Define the `reorderData` Function**
3. **Write Test Cases**

Here's the complete code:

### C++ Code with Catch2 Test Cases

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
#include <catch2/catch_test_macros.hpp>

// Define a structure to hold image data
struct ImageData {
    int score;
    std::string name;
    std::string id;
};

// Function to reorder the data based on scores
std::map<std::string, std::vector<std::string>> reorderData(
    const std::vector<int>& imageScores,
    const std::vector<std::string>& imageNames,
    const std::vector<std::string>& imageIDs)
{
    // Combine the scores, names, and IDs into a vector of ImageData structs
    std::vector<ImageData> imageData;
    for (size_t i = 0; i < imageScores.size(); ++i) {
        imageData.emplace_back(imageScores[i], imageNames[i], imageIDs[i]);
    }

    // Sort the vector of ImageData structs by score in ascending order
    std::sort(imageData.begin(), imageData.end(), [](const ImageData& a, const ImageData& b) {
        return a.score < b.score;
    });

    // Extract sorted scores, names, and IDs into separate vectors
    std::vector<int> resultScores;
    std::vector<std::string> resultNames;
    std::vector<std::string> resultIDs;

    for (const auto& data : imageData) {
        resultScores.push_back(data.score);
        resultNames.push_back(data.name);
        resultIDs.push_back(data.id);
    }

    // Create a map to return the sorted arrays
    std::map<std::string, std::vector<std::string>> result;
    result["resultScores"] = vector_to_string(resultScores);
    result["resultNames"] = resultNames;
    result["resultIDs"] = resultIDs;

    // Helper function to convert vector<int> to vector<string>
    std::vector<std::string> vector_to_string(const std::vector<int>& vec) {
        std::vector<std::string> strVec;
        for (int num : vec) {
            strVec.push_back(std::to_string(num));
        }
        return strVec;
    }

    // Return the sorted arrays
    return result;
}

TEST_CASE("reorderData", "[reorderData]") {
    SECTION("should reorder the question based on scores in ascending order") {
        const std::vector<int> imageScores = {90, 85, 95};
        const std::vector<std::string> imageNames = {"image1.png", "image2.png", "image3.png"};
        const std::vector<std::string> imageIDs = {"id1", "id2", "id3"};

        auto result = reorderData(imageScores, imageNames, imageIDs);

        REQUIRE_THAT(result["resultScores"], Catch::Matchers::Equals<std::vector<std::string>>({"85", "90", "95"}));
        REQUIRE_THAT(result["resultNames"], Catch::Matchers::Equals<std::vector<std::string>>({"image2.png", "image1.png", "image3.png"}));
        REQUIRE_THAT(result["resultIDs"], Catch::Matchers::Equals<std::vector<std::string>>({"id2", "id1", "id3"}));
    }

    SECTION("should return the same order if scores are already in ascending order") {
        const std::vector<int> imageScores = {70, 75, 80};
        const std::vector<std::string> imageNames = {"imageA.png", "imageB.png", "imageC.png"};
        const std::vector<std::string> imageIDs = {"idA", "idB", "idC"};

        auto result = reorderData(imageScores, imageNames, imageIDs);

        REQUIRE_THAT(result["resultScores"], Catch::Matchers::Equals<std::vector<std::string>>({"70", "75", "80"}));
        REQUIRE_THAT(result["resultNames"], Catch::Matchers::Equals<std::vector<std::string>>({"imageA.png", "imageB.png", "imageC.png"}));
        REQUIRE_THAT(result["resultIDs"], Catch::Matchers::Equals<std::vector<std::string>>({"idA", "idB", "idC"}));
    }

    SECTION("should handle an array with only one element") {
        const std::vector<int> imageScores = {50};
        const std::vector<std::string> imageNames = {"imageSingle.png"};
        const std::vector<std::string> imageIDs = {"idSingle"};

        auto result = reorderData(imageScores, imageNames, imageIDs);

        REQUIRE_THAT(result["resultScores"], Catch::Matchers::Equals<std::vector<std::string>>({"50"}));
        REQUIRE_THAT(result["resultNames"], Catch::Matchers::Equals<std::vector<std::string>>({"imageSingle.png"}));
        REQUIRE_THAT(result["resultIDs"], Catch::Matchers::Equals<std::vector<std::string>>({"idSingle"}));
    }

    SECTION("should handle an empty array") {
        const std::vector<int> imageScores = {};
        const std::vector<std::string> imageNames = {};
        const std::vector<std::string> imageIDs = {};

        auto result = reorderData(imageScores, imageNames, imageIDs);

        REQUIRE_THAT(result["resultScores"], Catch::Matchers::Equals<std::vector<std::string>>({}));
        REQUIRE_THAT(result["resultNames"], Catch::Matchers::Equals<std::vector<std::string>>({}));
        REQUIRE_THAT(result["resultIDs"], Catch::Matchers::Equals<std::vector<std::string>>({}));
    }

    SECTION("should reorder correctly when there are duplicate scores") {
        const std::vector<int> imageScores = {88, 88, 92};
        const std::vector<std::string> imageNames = {"image1.png", "image2.png", "image3.png"};
        const std::vector<std::string> imageIDs = {"id1", "id2", "id3"};

        auto result = reorderData(imageScores, imageNames, imageIDs);

        REQUIRE_THAT(result["resultScores"], Catch::Matchers::Equals<std::vector<std::string>>({"88", "88", "92"}));
        REQUIRE_THAT(result["resultNames"], Catch::Matchers::Equals<std::vector<std::string>>({"image1.png", "image2.png", "image3.png"}));
        REQUIRE_THAT(result["resultIDs"], Catch::Matchers::Equals<std::vector<std::string>>({"id1", "id2", "id3"}));
    }
}

int main(int argc, char* argv[]) {
    return Catch::Session().run(argc, argv);
}
```

### Explanation:
1. **Catch2 Headers**: Include the necessary headers for Catch2.
2. **ImageData Struct**: Define a struct `ImageData` to hold the score, name, and ID of each image.
3. **reorderData Function**: Implement the `reorderData` function to sort the images based on their scores.
4. **Test Cases**: Use Catch2's `TEST_CASE` and `SECTION` macros to define test cases.
   - Each test case uses `REQUIRE_THAT` with `Catch::Matchers::Equals` to verify the correctness of the function's output.

This setup ensures that the test cases are comprehensive and cover various scenarios, including sorting in ascending order, handling duplicates, and edge cases like empty arrays and single-element arrays.