Certainly! Here is the equivalent TypeScript code for the provided Python function:

```typescript
function handleNestedData(data: any): any {
    if (typeof data === 'object' && data !== null) {
        if (Array.isArray(data)) {
            // If it's an array, apply the function recursively to each item
            return data.map(item => handleNestedData(item));
        } else {
            // If it's an object (dictionary), apply the function recursively to each value
            const result: { [key: string]: any } = {};
            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    result[key] = handleNestedData(data[key]);
                }
            }
            return result;
        }
    } else if (typeof data === 'string') {
        // Try to convert strings that represent integers or floats to their numeric forms
        const num = Number(data);
        if (!isNaN(num)) {
            return num;
        }
        return data;  // Return the original string if it's not a number
    } else if (typeof data === 'number') {
        // If it's a number, return as is
        return data;
    } else if (typeof data === 'bigint') {
        // If it's a bigint, return as is
        return data;
    } else if (typeof data === 'boolean') {
        // If it's a boolean, return as is
        return data;
    } else if (data instanceof ArrayBuffer) {
        // If it's an ArrayBuffer (similar to bytes in Python), decode to a UTF-8 string
        const decoder = new TextDecoder('utf-8');
        return decoder.decode(data);
    }
    return data;  // Return the input as is for any other type
}
```

### Explanation:
1. **Type Checking**:
   - `typeof data` checks the type of the variable.
   - `Array.isArray(data)` checks if the variable is an array.

2. **Dictionary Handling**:
   - For objects, we iterate over the keys using a `for...in` loop and apply the function recursively.

3. **Array Handling**:
   - For arrays, we use the `.map()` method to apply the function recursively to each element.

4. **String Conversion**:
   - We attempt to convert strings to numbers using `Number(data)` and check if the conversion is valid with `!isNaN(num)`.

5. **Number and Boolean Handling**:
   - We directly return numbers and booleans as they are.

6. **Buffer Handling**:
   - For `ArrayBuffer` (similar to `bytes` in Python), we use `TextDecoder` to decode it to a UTF-8 string.

This TypeScript function mirrors the functionality of the Python function, ensuring consistent behavior across both languages.