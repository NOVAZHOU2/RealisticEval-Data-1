Sure! Below is the equivalent TypeScript code using Jest for testing the `handle_nested_data` function. I'll include the function definition as well as the Jest test cases.

First, let's define the function and its expected behavior:

```typescript
import { deepStrictEqual } from 'assert';

type Question = {
  [key: string]: any;
};

function handleNestedData(data: Question): Question {
  if (typeof data === 'object' && data !== null) {
    if (Array.isArray(data)) {
      return data.map((item) => handleNestedData(item));
    }
    const result: Question = {};
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        result[key] = handleNestedData(data[key]);
      }
    }
    return result;
  } else if (typeof data === 'string' && data.startsWith('b\'') && data.endsWith('\'')) {
    // Decode bytes to UTF8-string
    return data.slice(2, -1);
  } else if (typeof data === 'number') {
    // Convert number to integer or floating point number
    return Math.floor(data) === data ? Math.floor(data) : data;
  }
  return data;
}

// Example usage
const exampleData: Question = {
  key1: "value1",
  key2: [1, 2, "b'bytes'", { key3: "value3", key4: 3.14 }],
  key5: { key6: "b'another bytes'" },
};

console.log(handleNestedData(exampleData));
```

Now, let's write the Jest test cases:

```typescript
import { deepStrictEqual } from 'assert';

describe('handleNestedData', () => {
  it('should correctly handle nested data', () => {
    const input: Question = {
      key1: "value1",
      key2: [1, 2, "b'bytes'", { key3: "value3", key4: 3.14 }],
      key5: { key6: "b'another bytes'" },
    };

    const expectedOutput: Question = {
      key1: "value1",
      key2: [1, 2, "bytes", { key3: "value3", key4: 3.14 }],
      key5: { key6: "another bytes" },
    };

    const output = handleNestedData(input);
    expect(output).toEqual(expectedOutput);
  });

  it('should correctly handle simple data types', () => {
    const input: Question = {
      key1: "value1",
      key2: 3.14,
      key3: "b'bytes'",
    };

    const expectedOutput: Question = {
      key1: "value1",
      key2: 3.14,
      key3: "bytes",
    };

    const output = handleNestedData(input);
    expect(output).toEqual(expectedOutput);
  });

  it('should correctly handle arrays', () => {
    const input: Question[] = [
      "value1",
      3.14,
      "b'bytes'",
      ["b'inner bytes'", 2],
    ];

    const expectedOutput: Question[] = [
      "value1",
      3.14,
      "bytes",
      ["inner bytes", 2],
    ];

    const output = handleNestedData(input);
    expect(output).toEqual(expectedOutput);
  });
});
```

In this conversion:
- The `handleNestedData` function is defined with the expected behavior.
- The Jest test cases use `expect` and `toEqual` to verify the correctness of the function.
- The test cases cover handling nested data, simple data types, and arrays.

This should provide a complete and equivalent conversion from the Python unittest to Jest in TypeScript.