Certainly! Here is the equivalent Java test class using JUnit, placed in the package `org.real.temp` and named `Tester`. The functionality and logic of the tests are preserved, and appropriate JUnit annotations and assertion methods are used.

```java
package org.real.temp;

import org.junit.Test;
import org.junit.Assert;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Tester {

    @Test
    public void testSimpleDictionary() {
        Map<String, Object> data = new HashMap<>();
        data.put("name", "Alice".getBytes());
        data.put("age", "30");

        Map<String, Object> expected = new HashMap<>();
        expected.put("name", "Alice");
        expected.put("age", 30);

        Assert.assertEquals(expected, handleNestedData(data));
    }

    @Test
    public void testNestedDictionary() {
        Map<String, Object> nestedDetails = new HashMap<>();
        nestedDetails.put("age", "25");
        nestedDetails.put("height", "175.5");

        Map<String, Object> nestedUser = new HashMap<>();
        nestedUser.put("name", "Bob".getBytes());
        nestedUser.put("details", nestedDetails);

        Map<String, Object> data = new HashMap<>();
        data.put("user", nestedUser);

        Map<String, Object> expectedDetails = new HashMap<>();
        expectedDetails.put("age", 25);
        expectedDetails.put("height", 175.5);

        Map<String, Object> expectedUser = new HashMap<>();
        expectedUser.put("name", "Bob");
        expectedUser.put("details", expectedDetails);

        Map<String, Object> expected = new HashMap<>();
        expected.put("user", expectedUser);

        Assert.assertEquals(expected, handleNestedData(data));
    }

    @Test
    public void testListOfMixedDataTypes() {
        List<Object> data = Arrays.asList("100", "200".getBytes(), 300.0, "400.5");

        List<Object> expected = Arrays.asList(100, "200", 300.0, 400.5);

        Assert.assertEquals(expected, handleNestedData(data));
    }

    @Test(expected = UnicodeDecodeError.class)
    public void testIncorrectByteDecoding() {
        Map<String, Object> data = new HashMap<>();
        data.put("invalid_bytes", new byte[]{(byte) 0xff, (byte) 0xfe, (byte) 0xfd, (byte) 0xfc});

        handleNestedData(data);
    }

    @Test
    public void testComplexNestedStructure() {
        Map<String, Object> charlieScores = new HashMap<>();
        charlieScores.put("name", "Charlie".getBytes());
        charlieScores.put("scores", Arrays.asList("1000", "2000.2"));

        Map<String, Object> daisySkills = new HashMap<>();
        daisySkills.put("name", "Daisy".getBytes());
        daisySkills.put("skills", Arrays.asList("Coding".getBytes(), "Design".getBytes()));
        daisySkills.put("age", "22");

        List<Object> team = Arrays.asList(charlieScores, daisySkills);

        Map<String, Object> data = new HashMap<>();
        data.put("team", team);

        Map<String, Object> expectedCharlieScores = new HashMap<>();
        expectedCharlieScores.put("name", "Charlie");
        expectedCharlieScores.put("scores", Arrays.asList(1000, 2000.2));

        Map<String, Object> expectedDaisySkills = new HashMap<>();
        expectedDaisySkills.put("name", "Daisy");
        expectedDaisySkills.put("skills", Arrays.asList("Coding", "Design"));
        expectedDaisySkills.put("age", 22);

        List<Object> expectedTeam = Arrays.asList(expectedCharlieScores, expectedDaisySkills);

        Map<String, Object> expected = new HashMap<>();
        expected.put("team", expectedTeam);

        Assert.assertEquals(expected, handleNestedData(data));
    }

    private Object handleNestedData(Object data) {
        if (data instanceof Map) {
            // If it's a Map, apply the function recursively to each value
            Map<?, ?> map = (Map<?, ?>) data;
            Map<Object, Object> newMap = new HashMap<>();
            for (Map.Entry<?, ?> entry : map.entrySet()) {
                newMap.put(entry.getKey(), handleNestedData(entry.getValue()));
            }
            return newMap;
        } else if (data instanceof List) {
            // If it's a List, apply the function recursively to each item
            List<?> list = (List<?>) data;
            List<Object> newList = new ArrayList<>();
            for (Object item : list) {
                newList.add(handleNestedData(item));
            }
            return newList;
        } else if (data instanceof byte[]) {
            // If it's bytes, decode to a UTF-8 string
            byte[] bytes = (byte[]) data;
            return new String(bytes, java.nio.charset.StandardCharsets.UTF_8);
        } else if (data instanceof Integer || data instanceof Float || data instanceof Double) {
            // If it's already a number, return as is
            return data;
        } else if (data instanceof String) {
            // Try to convert strings that represent integers or floats to their numeric forms
            String str = (String) data;
            try {
                return Integer.parseInt(str);
            } catch (NumberFormatException e) {
                try {
                    return Double.parseDouble(str);
                } catch (NumberFormatException ex) {
                    return str;  // Return the original string if it's not a number
                }
            }
        }
        return data;  // Return the input as is for any other type
    }
}
```

### Explanation:
1. **JUnit Annotations**: Each test method is annotated with `@Test`.
2. **Assertions**: Assertions are performed using `Assert.assertEquals`.
3. **Byte Handling**: Byte arrays are created using `new byte[]{...}` and decoded using `new String(bytes, StandardCharsets.UTF_8)`.
4. **Test Data**: Test data is constructed using `HashMap` and `ArrayList` to match the Python dictionary and list structures.
5. **Exception Handling**: The `testIncorrectByteDecoding` method uses `@Test(expected = UnicodeDecodeError.class)` to handle the expected exception. Note that `UnicodeDecodeError` is not a standard Java exception, so you may need to define a custom exception or use a different approach (e.g., `assertThrows`).

This Java code preserves the functionality and structure of the original Python unittests while adhering to JUnit conventions and syntax.