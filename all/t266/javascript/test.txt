Since you provided a function definition instead of a Python unittest test class, I will assume that you want to create a test class for this function using Jest. Below is the equivalent test class using Jest in JavaScript:

```javascript
const handleNestedData = require('./handleNestedData'); // Adjust the path as needed

describe('handleNestedData', () => {
  it('should correctly handle nested data', () => {
    const testData = {
      key1: 'value1',
      key2: {
        nestedKey1: Buffer.from('nestedValue1'), // Simulating byte string
        nestedKey2: 100,
        nestedKey3: 3.14,
        nestedKey4: [Buffer.from('item1'), Buffer.from('item2')]
      },
      key3: [Buffer.from('listItem1'), 50, 6.28]
    };

    const expectedResult = {
      key1: 'value1',
      key2: {
        nestedKey1: 'nestedValue1',
        nestedKey2: 100,
        nestedKey3: 3.14,
        nestedKey4: ['item1', 'item2']
      },
      key3: ['listItem1', 50, 6.28]
    };

    expect(handleNestedData(testData)).toEqual(expectedResult);
  });

  it('should handle empty input', () => {
    const testData = {};

    const expectedResult = {};

    expect(handleNestedData(testData)).toEqual(expectedResult);
  });

  it('should handle simple input', () => {
    const testData = {
      key1: Buffer.from('value1'),
      key2: 200,
      key3: 4.56
    };

    const expectedResult = {
      key1: 'value1',
      key2: 200,
      key3: 4.56
    };

    expect(handleNestedData(testData)).toEqual(expectedResult);
  });
});

// Note: In the above tests, we use Buffer.from() to simulate byte strings (which are represented as Buffers in Node.js).
```

### Explanation:
1. **Imports and Setup**:
   - `const handleNestedData = require('./handleNestedData');` is used to import the `handleNestedData` function from another file.
   - The `describe` block is used to group related tests together.

2. **Test Cases**:
   - Each `it` block represents a specific test case.
   - We define `testData` which is the input to the `handleNestedData` function.
   - We define `expectedResult` which is the expected output of the function.
   - We use `expect` with `toEqual` to check if the actual result matches the expected result.

3. **Handling Byte Strings**:
   - In JavaScript, byte strings can be simulated using `Buffer` objects. We use `Buffer.from()` to create these byte strings.
   - The function `handleNestedData` should convert these Buffers to strings when necessary.

### Notes on Conversion:
- **Buffer Objects**: In Python, byte strings are represented as `bytes` objects, whereas in JavaScript, they are represented as `Buffer` objects (in Node.js). This is why we use `Buffer.from()` to simulate byte strings.
- **Assertions**: `unittest` uses various assertion methods like `assertEqual`, `assertTrue`, etc. Jest uses `expect` with various matchers like `toEqual`, `toBe`, etc. In this example, we primarily use `toEqual` for deep equality checks.

This setup ensures that the functionality and logic of the tests are maintained while adapting to JavaScript and Jest conventions.