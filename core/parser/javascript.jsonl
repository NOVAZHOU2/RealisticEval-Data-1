{"task_id": 87, "code_type": "method", "code_language": "javascript", "code_signature": "describe('timestampToReadableDate', () => {\n    test('converts Unix timestamp for New Year\\'s Day', () => {\n        // January 1, 2023 00:00 GMT\n        expect(timestampToReadableDate(1672531200)).toBe('Jan 1, 8:00');\n    });\n\n    test('converts Unix timestamp for a leap day', () => {\n        // February 29, 2024 12:00 GMT (leap year)\n        expect(timestampToReadableDate(1709227200)).toBe('Mar 1, 1:20');\n    });\n\n    test('converts Unix timestamp for a summer day', () => {\n        // June 21, 2023 15:45 GMT\n        expect(timestampToReadableDate(1687362300)).toBe('Jun 21, 23:45');\n    });\n\n    test('handles minutes with leading zero', () => {\n        // October 3, 2023 02:05 GMT\n        expect(timestampToReadableDate(1696377900)).toBe('Oct 4, 8:05');\n    });\n\n    test('handles end of the year', () => {\n        // December 31, 2023 23:59 GMT\n        expect(timestampToReadableDate(1704067140)).toBe('Jan 1, 7:59');\n    });\n});", "test_code": "/**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00', for example, 1709227200 is converted to get the string' Mar1, 1:20'\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n"}
{"task_id": 88, "code_type": "method", "code_language": "javascript", "code_signature": "describe('isCronBetween2And4AM', () => {\n    test('should return true for specific hours 2, 3, and 4', () => {\n        expect(isCronBetween2And4AM('0 2,3,4 * * *')).toBe(true);\n    });\n\n    test('should return true for range that includes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 1-5 * * *')).toBe(true);\n    });\n\n    test('should return false for range that excludes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 0-1,5-23 * * *')).toBe(false);\n    });\n\n    test('should return true for wildcard in hour field', () => {\n        expect(isCronBetween2And4AM('0 * * * *')).toBe(true);\n    });\n\n    test('should throw an error for invalid cron expressions', () => {\n        expect(() => {\n            isCronBetween2And4AM('invalid input');\n        }).toThrow('Invalid cron expression');\n    });\n});", "test_code": "/**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}"}
{"task_id": 94, "code_type": "method", "code_language": "javascript", "code_signature": "describe('createCircleOfFifths', () => {\n    test('should return 12 notes in the circle', () => {\n        const result = createCircleOfFifths('C');\n        expect(result).toHaveLength(12);\n    });\n\n    test('should start with the given starting note', () => {\n        const startingNote = 'G';\n        const result = createCircleOfFifths(startingNote);\n        expect(result[0]).toBe(startingNote);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from C', () => {\n        const result = createCircleOfFifths('C');\n        const expectedCircle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from G', () => {\n        const result = createCircleOfFifths('G');\n        const expectedCircle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from F', () => {\n        const result = createCircleOfFifths('F');\n        const expectedCircle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];\n        expect(result).toEqual(expectedCircle);\n    });\n});", "test_code": "/**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}"}
{"task_id": 95, "code_type": "method", "code_language": "javascript", "code_signature": "describe('getIndexValues', () => {\n    test('should return the index of the minimum value in an array', () => {\n        const inputArray = [3, 1, 4, 1, 5, 9, 2];\n        const result = getIndexValues(inputArray, compareMin);\n        expect(result).toEqual([[1, 1], [3, 1]]);\n    });\n\n    test('should return the index of the maximum value in an array', () => {\n        const inputArray = [3, 1, 4, 1, 5, 9, 2];\n        const result = getIndexValues(inputArray, compareMax);\n        expect(result).toEqual([[5, 9]]);\n    });\n\n    test('should return multiple indices if there are multiple minimum values', () => {\n        const inputArray = [7, 5, 2, 2, 8];\n        const result = getMinIndex(inputArray);\n        expect(result).toEqual([[2, 2], [3, 2]]);\n    });\n\n    test('should return multiple indices if there are multiple maximum values', () => {\n        const inputArray = [10, 4, 10, 1];\n        const result = getMaxIndex(inputArray);\n        expect(result).toEqual([[0, 10], [2, 10]]);\n    });\n\n    test('should return the index of the minimum value when array contains negative numbers', () => {\n        const inputArray = [-3, -1, -7, -1, -5];\n        const result = getMinIndex(inputArray);\n        expect(result).toEqual([[2, -7]]);\n    });\n});", "test_code": "/**\n * finds the matching elements and their indices in the input array according to the specified comparison function\n *\n * @param {Array} inputArray - The array to search through.\n * @param {Function} comparatorFn - The comparator function to determine the condition.\n * @returns {Array} - An array of [index, value] pairs that meet the comparator condition.\n */\nfunction getIndexValues(inputArray, comparatorFn) {\n\n}"}
{"task_id": 96, "code_type": "method", "code_language": "javascript", "code_signature": "describe('changedClef', () => {\n    test('should insert the clef at the correct position when the clef is not specified (default to \"bass\")', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc);\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should insert the clef at the correct position when a specific clef is provided', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"treble\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should handle cases where there is no newline after the key signature', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\";\n        const result = changedClef(abc, \"alto\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        expect(result).toBe(expected);\n    });\n\n    test('should not alter the ABC notation if the key signature is not found', () => {\n        const abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"tenor\");\n        expect(result).toBe(abc); // Expect the original string to be returned unchanged\n    });\n\n    test('should correctly handle ABC notation with multiple key signatures', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        const result = changedClef(abc, \"baritone\");\n        const expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        expect(result).toBe(expected);\n    });\n});", "test_code": "/**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}"}
{"task_id": 97, "code_type": "class", "code_language": "javascript", "code_signature": "describe('Queue', () => {\n    let queue;\n\n    beforeEach(() => {\n        queue = new Queue();\n    });\n\n    test('should add elements to the queue using enqueue', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        expect(queue.printQueue()).toBe('10 20 30');\n    });\n\n    test('should remove elements from the front of the queue using dequeue', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        const removedElement = queue.dequeue();\n        expect(removedElement).toBe(10);\n        expect(queue.printQueue()).toBe('20 30');\n    });\n\n    test('should return \"Underflow\" when dequeue is called on an empty queue', () => {\n        const result = queue.dequeue();\n        expect(result).toBe('Underflow');\n    });\n\n    test('should return the front element using front without removing it', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        const frontElement = queue.front();\n        expect(frontElement).toBe(10);\n        expect(queue.printQueue()).toBe('10 20'); // Ensure the element is not removed\n    });\n\n    test('should return true when isEmpty is called on an empty queue', () => {\n        expect(queue.isEmpty()).toBe(true);\n        queue.enqueue(10);\n        expect(queue.isEmpty()).toBe(false);\n    });\n});", "test_code": "/**\n * realize the basic functions of the data structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n\n}"}
{"task_id": 99, "code_type": "method", "code_language": "javascript", "code_signature": "describe('Sum Function Tests', () => {\n    test('should return the sum of a normal array of positive numbers', () => {\n        expect(sum([1, 2, 3, 4, 5])).toBe(15);\n    });\n\n    test('should return the sum of an array containing negative numbers', () => {\n        expect(sum([-1, -2, -3, -4, -5])).toBe(-15);\n    });\n\n    test('should return 0 for an empty array', () => {\n        expect(sum([])).toBe(0);\n    });\n\n    test('should return the sum of an array containing both positive and negative numbers', () => {\n        expect(sum([10, -10, 5, -5, 15])).toBe(15);\n    });\n\n    test('should return the sum of an array with floating point numbers', () => {\n        expect(sum([1.5, 2.5, 3.5])).toBe(7.5);\n    });\n});", "test_code": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n"}
{"task_id": 100, "code_type": "method", "code_language": "javascript", "code_signature": "describe('ConvertTime Function Tests', () => {\n    test('should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds', () => {\n        expect(convertTime('PT1H23M45.678S')).toBe('1h23m45s678ms');\n    });\n\n    test('should correctly convert duration with only minutes and seconds including milliseconds', () => {\n        expect(convertTime('PT0M30.123S')).toBe('30s123ms');\n    });\n\n    test('should correctly convert duration with only seconds and milliseconds', () => {\n        expect(convertTime('PT45.5S')).toBe('45s500ms');\n    });\n\n    test('should correctly convert duration with hours and minutes, but no seconds', () => {\n        expect(convertTime('PT2H5M')).toBe('2h5m');\n    });\n\n    test('should correctly convert duration with only seconds, no milliseconds', () => {\n        expect(convertTime('PT20S')).toBe('20s');\n    });\n});", "test_code": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n"}
{"task_id": 101, "code_type": "method", "code_language": "javascript", "code_signature": "describe('isBreakTime Function Tests', () => {\n    test('should return true when current time is exactly at the start time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:00\")).toBe(true);\n    });\n\n    test('should return true when current time is within the break time range', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:30\")).toBe(true);\n    });\n\n    test('should return true when current time is exactly at the end time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:00\")).toBe(true);\n    });\n\n    test('should return false when current time is before the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"08:59\")).toBe(false);\n    });\n\n    test('should return false when current time is after the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:01\")).toBe(false);\n    });\n});", "test_code": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n"}
{"task_id": 103, "code_type": "method", "code_language": "javascript", "code_signature": "describe('sliceString Function Tests', () => {\n    test('should return a truncated string with \"...\" if it is longer than the specified limit, containing <p> tags', () => {\n        expect(sliceString(\"<p>Hello, World!</p>\", 5)).toBe(\"He...\");\n    });\n\n    test('should return the original string if it is exactly at the specified limit', () => {\n        expect(sliceString(\"Hello\", 5)).toBe(\"Hello\");\n    });\n\n    test('should return the original string if it is shorter than the specified limit', () => {\n        expect(sliceString(\"Hi\", 5)).toBe(\"Hi\");\n    });\n\n    test('should return a truncated string with \"...\" if it is longer than the specified limit, without <p> tags', () => {\n        expect(sliceString(\"Hello, World!\", 8)).toBe(\"Hello, W...\");\n    });\n\n    test('should return a truncated string with \"...\" if it has multiple <p> tags and is longer than the specified limit', () => {\n        expect(sliceString(\"<p>Hello, <p>World!</p></p>\", 7)).toBe(\"Hello, ...\");\n    });\n});", "test_code": "/**\n * Truncate the string to the specified length and add an ellipsis (...) if necessary. . In addition, any <p> and </p> tags are removed from the truncated string.\n * \n * @param {string} str - The string to be truncated.\n * @param {number} num - The maximum number of characters allowed. */\nfunction sliceString(str, num) {\n    \n}\n"}
{"task_id": 104, "code_type": "method", "code_language": "javascript", "code_signature": "describe('convertThreadToJSONFile Function Tests', () => {\n    test('should return a Blob object for a basic thread object', () => {\n        const thread1 = { id: 1, title: \"First Thread\", content: \"This is the first thread.\" };\n        const blob1 = convertThreadToJSONFile(thread1);\n        expect(blob1 instanceof Blob).toBe(true);\n        expect(blob1.type).toBe(\"application/json\");\n    });\n\n    test('should return a Blob object for an empty thread object', () => {\n        const thread2 = {};\n        const blob2 = convertThreadToJSONFile(thread2);\n        expect(blob2 instanceof Blob).toBe(true);\n        expect(blob2.size).toBe(2); // \"{}\" has a size of 2 bytes\n    });\n\n    test('should return a Blob object for a thread object with nested objects', () => {\n        const thread3 = { id: 2, title: \"Second Thread\", comments: [{ user: \"Alice\", comment: \"Great post!\" }] };\n        const blob3 = convertThreadToJSONFile(thread3);\n        expect(blob3 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with special characters', () => {\n        const thread4 = { id: 3, title: \"Thread & Special <Characters>\", content: 'This is a thread with special characters: <, >, &, \".' };\n        const blob4 = convertThreadToJSONFile(thread4);\n        expect(blob4 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with arrays', () => {\n        const thread5 = { id: 4, title: \"Thread with Array\", tags: [\"JavaScript\", \"JSON\", \"Blob\"] };\n        const blob5 = convertThreadToJSONFile(thread5);\n        expect(blob5 instanceof Blob).toBe(true);\n    });\n});", "test_code": "/**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n"}
{"task_id": 87, "code_type": "method", "code_language": "javascript", "code_signature": "describe('timestampToReadableDate', () => {\n    test('converts Unix timestamp for New Year\\'s Day', () => {\n        // January 1, 2023 00:00 GMT\n        expect(timestampToReadableDate(1672531200)).toBe('Jan 1, 8:00');\n    });\n\n    test('converts Unix timestamp for a leap day', () => {\n        // February 29, 2024 12:00 GMT (leap year)\n        expect(timestampToReadableDate(1709227200)).toBe('Mar 1, 1:20');\n    });\n\n    test('converts Unix timestamp for a summer day', () => {\n        // June 21, 2023 15:45 GMT\n        expect(timestampToReadableDate(1687362300)).toBe('Jun 21, 23:45');\n    });\n\n    test('handles minutes with leading zero', () => {\n        // October 3, 2023 02:05 GMT\n        expect(timestampToReadableDate(1696377900)).toBe('Oct 4, 8:05');\n    });\n\n    test('handles end of the year', () => {\n        // December 31, 2023 23:59 GMT\n        expect(timestampToReadableDate(1704067140)).toBe('Jan 1, 7:59');\n    });\n});", "test_code": "/**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00', for example, 1709227200 is converted to get the string' Mar1, 1:20'\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n"}
{"task_id": 88, "code_type": "method", "code_language": "javascript", "code_signature": "describe('isCronBetween2And4AM', () => {\n    test('should return true for specific hours 2, 3, and 4', () => {\n        expect(isCronBetween2And4AM('0 2,3,4 * * *')).toBe(true);\n    });\n\n    test('should return true for range that includes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 1-5 * * *')).toBe(true);\n    });\n\n    test('should return false for range that excludes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 0-1,5-23 * * *')).toBe(false);\n    });\n\n    test('should return true for wildcard in hour field', () => {\n        expect(isCronBetween2And4AM('0 * * * *')).toBe(true);\n    });\n\n    test('should throw an error for invalid cron expressions', () => {\n        expect(() => {\n            isCronBetween2And4AM('invalid input');\n        }).toThrow('Invalid cron expression');\n    });\n});", "test_code": "/**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}"}
{"task_id": 94, "code_type": "method", "code_language": "javascript", "code_signature": "describe('createCircleOfFifths', () => {\n    test('should return 12 notes in the circle', () => {\n        const result = createCircleOfFifths('C');\n        expect(result).toHaveLength(12);\n    });\n\n    test('should start with the given starting note', () => {\n        const startingNote = 'G';\n        const result = createCircleOfFifths(startingNote);\n        expect(result[0]).toBe(startingNote);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from C', () => {\n        const result = createCircleOfFifths('C');\n        const expectedCircle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from G', () => {\n        const result = createCircleOfFifths('G');\n        const expectedCircle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from F', () => {\n        const result = createCircleOfFifths('F');\n        const expectedCircle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];\n        expect(result).toEqual(expectedCircle);\n    });\n});", "test_code": "/**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}"}
{"task_id": 95, "code_type": "method", "code_language": "javascript", "code_signature": "describe('getIndexValues', () => {\n    test('should return the index of the minimum value in an array', () => {\n        const inputArray = [3, 1, 4, 1, 5, 9, 2];\n        const result = getIndexValues(inputArray, compareMin);\n        expect(result).toEqual([[1, 1], [3, 1]]);\n    });\n\n    test('should return the index of the maximum value in an array', () => {\n        const inputArray = [3, 1, 4, 1, 5, 9, 2];\n        const result = getIndexValues(inputArray, compareMax);\n        expect(result).toEqual([[5, 9]]);\n    });\n\n    test('should return multiple indices if there are multiple minimum values', () => {\n        const inputArray = [7, 5, 2, 2, 8];\n        const result = getMinIndex(inputArray);\n        expect(result).toEqual([[2, 2], [3, 2]]);\n    });\n\n    test('should return multiple indices if there are multiple maximum values', () => {\n        const inputArray = [10, 4, 10, 1];\n        const result = getMaxIndex(inputArray);\n        expect(result).toEqual([[0, 10], [2, 10]]);\n    });\n\n    test('should return the index of the minimum value when array contains negative numbers', () => {\n        const inputArray = [-3, -1, -7, -1, -5];\n        const result = getMinIndex(inputArray);\n        expect(result).toEqual([[2, -7]]);\n    });\n});", "test_code": "/**\n * finds the matching elements and their indices in the input array according to the specified comparison function\n *\n * @param {Array} inputArray - The array to search through.\n * @param {Function} comparatorFn - The comparator function to determine the condition.\n * @returns {Array} - An array of [index, value] pairs that meet the comparator condition.\n */\nfunction getIndexValues(inputArray, comparatorFn) {\n\n}"}
{"task_id": 96, "code_type": "method", "code_language": "javascript", "code_signature": "describe('changedClef', () => {\n    test('should insert the clef at the correct position when the clef is not specified (default to \"bass\")', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc);\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should insert the clef at the correct position when a specific clef is provided', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"treble\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should handle cases where there is no newline after the key signature', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\";\n        const result = changedClef(abc, \"alto\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        expect(result).toBe(expected);\n    });\n\n    test('should not alter the ABC notation if the key signature is not found', () => {\n        const abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"tenor\");\n        expect(result).toBe(abc); // Expect the original string to be returned unchanged\n    });\n\n    test('should correctly handle ABC notation with multiple key signatures', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        const result = changedClef(abc, \"baritone\");\n        const expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        expect(result).toBe(expected);\n    });\n});", "test_code": "/**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}"}
{"task_id": 97, "code_type": "class", "code_language": "javascript", "code_signature": "describe('Queue', () => {\n    let queue;\n\n    beforeEach(() => {\n        queue = new Queue();\n    });\n\n    test('should add elements to the queue using enqueue', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        expect(queue.printQueue()).toBe('10 20 30');\n    });\n\n    test('should remove elements from the front of the queue using dequeue', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        const removedElement = queue.dequeue();\n        expect(removedElement).toBe(10);\n        expect(queue.printQueue()).toBe('20 30');\n    });\n\n    test('should return \"Underflow\" when dequeue is called on an empty queue', () => {\n        const result = queue.dequeue();\n        expect(result).toBe('Underflow');\n    });\n\n    test('should return the front element using front without removing it', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        const frontElement = queue.front();\n        expect(frontElement).toBe(10);\n        expect(queue.printQueue()).toBe('10 20'); // Ensure the element is not removed\n    });\n\n    test('should return true when isEmpty is called on an empty queue', () => {\n        expect(queue.isEmpty()).toBe(true);\n        queue.enqueue(10);\n        expect(queue.isEmpty()).toBe(false);\n    });\n});", "test_code": "/**\n * realize the basic functions of the data structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n\n}"}
{"task_id": 99, "code_type": "method", "code_language": "javascript", "code_signature": "describe('Sum Function Tests', () => {\n    test('should return the sum of a normal array of positive numbers', () => {\n        expect(sum([1, 2, 3, 4, 5])).toBe(15);\n    });\n\n    test('should return the sum of an array containing negative numbers', () => {\n        expect(sum([-1, -2, -3, -4, -5])).toBe(-15);\n    });\n\n    test('should return 0 for an empty array', () => {\n        expect(sum([])).toBe(0);\n    });\n\n    test('should return the sum of an array containing both positive and negative numbers', () => {\n        expect(sum([10, -10, 5, -5, 15])).toBe(15);\n    });\n\n    test('should return the sum of an array with floating point numbers', () => {\n        expect(sum([1.5, 2.5, 3.5])).toBe(7.5);\n    });\n});", "test_code": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n"}
{"task_id": 100, "code_type": "method", "code_language": "javascript", "code_signature": "describe('ConvertTime Function Tests', () => {\n    test('should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds', () => {\n        expect(convertTime('PT1H23M45.678S')).toBe('1h23m45s678ms');\n    });\n\n    test('should correctly convert duration with only minutes and seconds including milliseconds', () => {\n        expect(convertTime('PT0M30.123S')).toBe('30s123ms');\n    });\n\n    test('should correctly convert duration with only seconds and milliseconds', () => {\n        expect(convertTime('PT45.5S')).toBe('45s500ms');\n    });\n\n    test('should correctly convert duration with hours and minutes, but no seconds', () => {\n        expect(convertTime('PT2H5M')).toBe('2h5m');\n    });\n\n    test('should correctly convert duration with only seconds, no milliseconds', () => {\n        expect(convertTime('PT20S')).toBe('20s');\n    });\n});", "test_code": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n"}
{"task_id": 101, "code_type": "method", "code_language": "javascript", "code_signature": "describe('isBreakTime Function Tests', () => {\n    test('should return true when current time is exactly at the start time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:00\")).toBe(true);\n    });\n\n    test('should return true when current time is within the break time range', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:30\")).toBe(true);\n    });\n\n    test('should return true when current time is exactly at the end time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:00\")).toBe(true);\n    });\n\n    test('should return false when current time is before the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"08:59\")).toBe(false);\n    });\n\n    test('should return false when current time is after the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:01\")).toBe(false);\n    });\n});", "test_code": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n"}
{"task_id": 103, "code_type": "method", "code_language": "javascript", "code_signature": "describe('sliceString Function Tests', () => {\n    test('should return a truncated string with \"...\" if it is longer than the specified limit, containing <p> tags', () => {\n        expect(sliceString(\"<p>Hello, World!</p>\", 5)).toBe(\"He...\");\n    });\n\n    test('should return the original string if it is exactly at the specified limit', () => {\n        expect(sliceString(\"Hello\", 5)).toBe(\"Hello\");\n    });\n\n    test('should return the original string if it is shorter than the specified limit', () => {\n        expect(sliceString(\"Hi\", 5)).toBe(\"Hi\");\n    });\n\n    test('should return a truncated string with \"...\" if it is longer than the specified limit, without <p> tags', () => {\n        expect(sliceString(\"Hello, World!\", 8)).toBe(\"Hello, W...\");\n    });\n\n    test('should return a truncated string with \"...\" if it has multiple <p> tags and is longer than the specified limit', () => {\n        expect(sliceString(\"<p>Hello, <p>World!</p></p>\", 7)).toBe(\"Hello, ...\");\n    });\n});", "test_code": "/**\n * Truncate the string to the specified length and add an ellipsis (...) if necessary. . In addition, any <p> and </p> tags are removed from the truncated string.\n * \n * @param {string} str - The string to be truncated.\n * @param {number} num - The maximum number of characters allowed. */\nfunction sliceString(str, num) {\n    \n}\n"}
{"task_id": 104, "code_type": "method", "code_language": "javascript", "code_signature": "describe('convertThreadToJSONFile Function Tests', () => {\n    test('should return a Blob object for a basic thread object', () => {\n        const thread1 = { id: 1, title: \"First Thread\", content: \"This is the first thread.\" };\n        const blob1 = convertThreadToJSONFile(thread1);\n        expect(blob1 instanceof Blob).toBe(true);\n        expect(blob1.type).toBe(\"application/json\");\n    });\n\n    test('should return a Blob object for an empty thread object', () => {\n        const thread2 = {};\n        const blob2 = convertThreadToJSONFile(thread2);\n        expect(blob2 instanceof Blob).toBe(true);\n        expect(blob2.size).toBe(2); // \"{}\" has a size of 2 bytes\n    });\n\n    test('should return a Blob object for a thread object with nested objects', () => {\n        const thread3 = { id: 2, title: \"Second Thread\", comments: [{ user: \"Alice\", comment: \"Great post!\" }] };\n        const blob3 = convertThreadToJSONFile(thread3);\n        expect(blob3 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with special characters', () => {\n        const thread4 = { id: 3, title: \"Thread & Special <Characters>\", content: 'This is a thread with special characters: <, >, &, \".' };\n        const blob4 = convertThreadToJSONFile(thread4);\n        expect(blob4 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with arrays', () => {\n        const thread5 = { id: 4, title: \"Thread with Array\", tags: [\"JavaScript\", \"JSON\", \"Blob\"] };\n        const blob5 = convertThreadToJSONFile(thread5);\n        expect(blob5 instanceof Blob).toBe(true);\n    });\n});", "test_code": "/**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n"}
