{"task_id": 149, "code_type": "method", "code_language": "typescript", "code_signature": "describe('hslToRgb', () => {\n\n    // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(0, 100%, 50%) \u8f6c\u6362\u4e3a RGB(255, 0, 0)\n    test('should convert HSL(0, 100%, 50%) to RGB(255, 0, 0)', () => {\n        const hue = 0;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u8fb9\u754c\u503c\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(360, 100%, 50%) \u8f6c\u6362\u4e3a RGB(255, 0, 0)\n    test('should handle hue of 360 degrees correctly as RGB(255, 0, 0)', () => {\n        const hue = 360;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u8fb9\u754c\u503c\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(120, 100%, 50%) \u8f6c\u6362\u4e3a RGB(0, 255, 0)\n    test('should convert HSL(120, 100%, 50%) to RGB(0, 255, 0)', () => {\n        const hue = 120;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 0, g: 255, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u5c06 HSL(-30, 100%, 50%) \u8f6c\u6362\u4e3a\u6b63\u5e38\u8303\u56f4\u5185\u7684 RGB \u503c\n    test('should handle negative hue values correctly and convert HSL(-30, 100%, 50%) to RGB(255, 85, 0)', () => {\n        const hue = -30;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 128 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u5f53\u9971\u548c\u5ea6\u548c\u4eae\u5ea6\u4e3a 0 \u65f6\u5e94\u8f93\u51fa\u7070\u5ea6\u8272 RGB(128, 128, 128)\n    test('should return a grayscale color RGB(128, 128, 128) when saturation and lightness are both 0', () => {\n        const hue = 120;\n        const saturation = 0;\n        const lightness = 50;\n        const expectedOutput = { r: 128, g: 128, b: 128 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n});\n", "test_code": "/**\n * Code implementation for converting HSL color values \u200b\u200bto RGB color values\n */\nexport function hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n\n}"}
{"task_id": 151, "code_type": "method", "code_language": "typescript", "code_signature": "describe('rgbToHsl', () => {\n\n    test('should convert basic RGB values correctly (red)', () => {\n        const rgb = { r: 255, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 100, l: 50 });\n    });\n\n    test('should handle grayscale values (middle gray)', () => {\n        const rgb = { r: 128, g: 128, b: 128 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 50 });\n    });\n\n    test('should handle edge cases (white color)', () => {\n        const rgb = { r: 255, g: 255, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 100 });\n    });\n\n    test('should handle edge cases (black color)', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 0 });\n    });\n\n    test('should throw an error for invalid RGB values (negative values)', () => {\n        const rgb = { r: -50, g: 50, b: 50 };\n        expect(() => rgbToHsl(rgb)).toThrow('Invalid RGB value. Each value must be between 0 and 255.');\n    });\n\n});\n", "test_code": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nexport function rgbToHsl({ r, g, b }: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n"}
{"task_id": 152, "code_type": "method", "code_language": "typescript", "code_signature": "describe('convertToMathematicalSansSerifItalic', () => {\n    test('should return an empty string when input is an empty string', () => {\n        const input = '';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe(''); // Edge case: empty string\n    });\n\n    test('should correctly convert all uppercase and lowercase letters to mathematical sans-serif italic', () => {\n        const input = 'HelloWorld';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc6f\ud835\udc86\ud835\udc8d\ud835\udc8d\ud835\udc90\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8d\ud835\udc85'); // Basic logic: mixed case\n    });\n\n    test('should leave characters unchanged if they have no corresponding mathematical sans-serif italic equivalent', () => {\n        const input = '12345!@#';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udfe3\ud835\udfe4\ud835\udfe5\ud835\udfe6\ud835\udfe7!@#'); // Basic logic: numbers with special characters\n    });\n\n    test('should handle input with a mix of convertible and non-convertible characters', () => {\n        const input = 'Math123!';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc74\ud835\udc82\ud835\udc95\ud835\udc89\ud835\udfe3\ud835\udfe4\ud835\udfe5!'); // Basic logic: mix of letters, numbers, and special characters\n    });\n\n    test('should handle edge case where input is at the boundary of supported characters', () => {\n        const input = 'A0z9';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc68\ud835\udfe2\ud835\udc9b\ud835\udfeb'); // Boundary values: 'A', '0', 'z', '9'\n    });\n});\n\n\n", "test_code": "/**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}"}
{"task_id": 153, "code_type": "method", "code_language": "typescript", "code_signature": "// @ts-ignore\nconst crypto = require('crypto');\n\ndescribe('compressHash', () => {\n\n    test('should return a string of length 5', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result.length).toBe(5);\n    });\n\n    test('should return different strings for different inputs', () => {\n        // @ts-ignore\n        const hash1 = crypto.createHash('sha256').update('test1').digest();\n        // @ts-ignore\n        const hash2 = crypto.createHash('sha256').update('test2').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash1);\n        // @ts-ignore\n        const result2 = compressHash(hash2);\n        expect(result1).not.toBe(result2);\n    });\n\n    test('should return a consistent result for the same input', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash);\n        // @ts-ignore\n        const result2 = compressHash(hash);\n        expect(result1).toBe(result2);\n    });\n\n    test('should handle a hash of all zeros', () => {\n        const hash = Buffer.alloc(32, 0); // 32 bytes of zeros\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n\n    test('should handle a hash of all ones', () => {\n        const hash = Buffer.alloc(32, 255); // 32 bytes of 0xFF (255 in decimal)\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n});\n", "test_code": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}"}
{"task_id": 154, "code_type": "method", "code_language": "typescript", "code_signature": "describe('parseGitDiff', () => {\n\n    test('should parse a simple file addition', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/file.txt`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].newFileMode).toBe('100644');\n    });\n\n    test('should parse a simple file deletion', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\ndeleted file mode 100644\nindex e69de29..0000000\n--- a/file.txt\n+++ /dev/null`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].deletedFileMode).toBe('100644');\n    });\n\n    test('should parse a file modification with changes', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nindex e69de29..d95f3ad 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -0,0 +1 @@\n+Hello World`;\n\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n\n        expect(result).toHaveLength(1); // Ensure only one file diff is parsed\n        expect(result[0].oldPath).toBe('file.txt'); // Validate old file path\n        expect(result[0].newPath).toBe('file.txt'); // Validate new file path\n        expect(result[0].index).toBe('e69de29..d95f3ad'); // Validate index value\n        expect(result[0].changes).toEqual([\n            {code: \"--- a/file.txt\"}, // Validate old file path line\n            {code: \"+++ b/file.txt\"}, // Validate new file path line\n            {diff: '@@ -0,0 +1 @@'},  // Validate diff header\n            {code: '+Hello World'}     // Validate code addition\n        ]); // Validate changes array\n    });\n\n    test('should handle multiple file diffs', () => {\n        const diffText = `diff --git a/file1.txt b/file1.txt\nindex e69de29..d95f3ad 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -0,0 +1 @@\n+Hello World\ndiff --git a/file2.txt b/file2.txt\nindex 0a1b2c3..d4e5f6a 100644\n--- a/file2.txt\n+++ b/file2.txt\n@@ -1 +1 @@\n-Hello\n+Hi`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(2);\n        expect(result[0].oldPath).toBe('file1.txt');\n        expect(result[1].oldPath).toBe('file2.txt');\n    });\n\n    test('should return an empty array for empty diff text', () => {\n        // @ts-ignore\n        const result = parseGitDiff('');\n        expect(result).toEqual([]);\n    });\n\n});", "test_code": "// Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}"}
{"task_id": 155, "code_type": "method", "code_language": "typescript", "code_signature": "describe('getTimestamp', () => {\n    test('should return \"1 second ago\" for a date 1 second ago', () => {\n        const oneSecondAgo = new Date(new Date().getTime() - 1000); // 1 second ago\n        // @ts-ignore\n        expect(getTimestamp(oneSecondAgo)).toBe('1 second ago');\n    });\n\n    test('should return \"5 minutes ago\" for a date 5 minutes ago', () => {\n        const fiveMinutesAgo = new Date(new Date().getTime() - 5 * 60 * 1000); // 5 minutes ago\n        // @ts-ignore\n        expect(getTimestamp(fiveMinutesAgo)).toBe('5 minutes ago');\n    });\n\n    test('should return \"2 hours ago\" for a date 2 hours ago', () => {\n        const twoHoursAgo = new Date(new Date().getTime() - 2 * 60 * 60 * 1000); // 2 hours ago\n        // @ts-ignore\n        expect(getTimestamp(twoHoursAgo)).toBe('2 hours ago');\n    });\n\n    test('should return \"3 days ago\" for a date 3 days ago', () => {\n        const threeDaysAgo = new Date(new Date().getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        // @ts-ignore\n        expect(getTimestamp(threeDaysAgo)).toBe('3 days ago');\n    });\n\n    test('should return \"1 year ago\" for a date 1 year ago', () => {\n        const oneYearAgo = new Date(new Date().getTime() - 365 * 24 * 60 * 60 * 1000); // 1 year ago\n        // @ts-ignore\n        expect(getTimestamp(oneYearAgo)).toBe('1 year ago');\n    });\n});", "test_code": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}"}
{"task_id": 156, "code_type": "method", "code_language": "typescript", "code_signature": "describe('formatNumber', () => {\n    test('should format numbers greater than or equal to 1,000,000 with \"M\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(1500000)).toBe('1.5M');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n\n    test('should format numbers greater than or equal to 1,000 but less than 1,000,000 with \"K\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(2500)).toBe('2.5K');\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n    });\n\n    test('should return the number as a string if it is less than 1,000', () => {\n        // @ts-ignore\n        expect(formatNumber(999)).toBe('999');\n        // @ts-ignore\n        expect(formatNumber(500)).toBe('500');\n    });\n\n    test('should format numbers close to 1,000,000 correctly', () => {\n        // @ts-ignore\n        expect(formatNumber(999999)).toBe('999.9K'); // Corrected to reflect 'K' formatting\n        // @ts-ignore\n        expect(formatNumber(999500)).toBe('999.5K'); // Corrected to reflect 'K' formatting\n    });\n\n    test('should handle edge cases like exactly 1,000 or 1,000,000', () => {\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n});", "test_code": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}"}
{"task_id": 157, "code_type": "method", "code_language": "typescript", "code_signature": "describe('bytesToSize', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        // @ts-ignore\n        expect(bytesToSize(0)).toBe('0 Byte');\n    });\n\n    test('should convert bytes to KB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1024)).toBe('1.00 KB');\n        // @ts-ignore\n        expect(bytesToSize(2048)).toBe('2.00 KB');\n    });\n\n    test('should convert bytes to MB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1048576)).toBe('1.00 MB');\n        // @ts-ignore\n        expect(bytesToSize(2097152)).toBe('2.00 MB');\n    });\n\n    test('should convert bytes to GB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1073741824)).toBe('1.00 GB');\n        // @ts-ignore\n        expect(bytesToSize(2147483648)).toBe('2.00 GB');\n    });\n\n    test('should convert bytes to TB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1099511627776)).toBe('1.00 TB');\n        // @ts-ignore\n        expect(bytesToSize(2199023255552)).toBe('2.00 TB');\n    });\n});\n", "test_code": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\n// @ts-ignore\nexport function bytesToSize(bytes: number): string {\n\n}"}
{"task_id": 158, "code_type": "method", "code_language": "typescript", "code_signature": "describe('getFileExtension', () => {\n    test('should return the file extension for a standard file', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.txt')).toBe('txt');\n    });\n\n    test('should return an empty string for files without an extension', () => {\n        // @ts-ignore\n        expect(getFileExtension('example')).toBe('');\n    });\n\n    test('should handle files with multiple dots', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.with.many.dots.jpg')).toBe('jpg');\n    });\n\n    test('should return an empty string for filenames that end with a dot', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.')).toBe('');\n    });\n\n    test('should correctly handle case sensitivity', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.JPG')).toBe('JPG');\n    });\n});", "test_code": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\n// @ts-ignore\nexport function getFileExtension(file_name: string): string {\n\n}"}
{"task_id": 159, "code_type": "method", "code_language": "typescript", "code_signature": "describe('removeFileExtension', () => {\n    test('should remove the file extension from a standard file', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.txt')).toBe('document');\n    });\n\n    test('should return the original filename for files without an extension', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document')).toBe('document');\n    });\n\n    test('should handle files with multiple dots correctly', () => {\n        // @ts-ignore\n        expect(removeFileExtension('my.file.with.many.extensions.pdf')).toBe('my.file.with.many.extensions');\n    });\n\n    test('should return the original filename if it ends with a dot', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.')).toBe('document');\n    });\n\n    test('should correctly handle filenames with dots in directory names', () => {\n        // @ts-ignore\n        expect(removeFileExtension('path.to/my.file.txt')).toBe('path.to/my.file');\n    });\n});", "test_code": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\n// @ts-ignore\nexport function removeFileExtension(file_name: string): string {\n\n}"}
{"task_id": 149, "code_type": "method", "code_language": "typescript", "code_signature": "describe('hslToRgb', () => {\n\n    // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(0, 100%, 50%) \u8f6c\u6362\u4e3a RGB(255, 0, 0)\n    test('should convert HSL(0, 100%, 50%) to RGB(255, 0, 0)', () => {\n        const hue = 0;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u8fb9\u754c\u503c\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(360, 100%, 50%) \u8f6c\u6362\u4e3a RGB(255, 0, 0)\n    test('should handle hue of 360 degrees correctly as RGB(255, 0, 0)', () => {\n        const hue = 360;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u8fb9\u754c\u503c\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(120, 100%, 50%) \u8f6c\u6362\u4e3a RGB(0, 255, 0)\n    test('should convert HSL(120, 100%, 50%) to RGB(0, 255, 0)', () => {\n        const hue = 120;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 0, g: 255, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u5c06 HSL(-30, 100%, 50%) \u8f6c\u6362\u4e3a\u6b63\u5e38\u8303\u56f4\u5185\u7684 RGB \u503c\n    test('should handle negative hue values correctly and convert HSL(-30, 100%, 50%) to RGB(255, 85, 0)', () => {\n        const hue = -30;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 128 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u5f53\u9971\u548c\u5ea6\u548c\u4eae\u5ea6\u4e3a 0 \u65f6\u5e94\u8f93\u51fa\u7070\u5ea6\u8272 RGB(128, 128, 128)\n    test('should return a grayscale color RGB(128, 128, 128) when saturation and lightness are both 0', () => {\n        const hue = 120;\n        const saturation = 0;\n        const lightness = 50;\n        const expectedOutput = { r: 128, g: 128, b: 128 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n});\n", "test_code": "/**\n * Code implementation for converting HSL color values \u200b\u200bto RGB color values\n */\nexport function hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n\n}"}
{"task_id": 151, "code_type": "method", "code_language": "typescript", "code_signature": "describe('rgbToHsl', () => {\n\n    test('should convert basic RGB values correctly (red)', () => {\n        const rgb = { r: 255, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 100, l: 50 });\n    });\n\n    test('should handle grayscale values (middle gray)', () => {\n        const rgb = { r: 128, g: 128, b: 128 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 50 });\n    });\n\n    test('should handle edge cases (white color)', () => {\n        const rgb = { r: 255, g: 255, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 100 });\n    });\n\n    test('should handle edge cases (black color)', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 0 });\n    });\n\n    test('should throw an error for invalid RGB values (negative values)', () => {\n        const rgb = { r: -50, g: 50, b: 50 };\n        expect(() => rgbToHsl(rgb)).toThrow('Invalid RGB value. Each value must be between 0 and 255.');\n    });\n\n});\n", "test_code": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nexport function rgbToHsl({ r, g, b }: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n"}
{"task_id": 152, "code_type": "method", "code_language": "typescript", "code_signature": "describe('convertToMathematicalSansSerifItalic', () => {\n    test('should return an empty string when input is an empty string', () => {\n        const input = '';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe(''); // Edge case: empty string\n    });\n\n    test('should correctly convert all uppercase and lowercase letters to mathematical sans-serif italic', () => {\n        const input = 'HelloWorld';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc6f\ud835\udc86\ud835\udc8d\ud835\udc8d\ud835\udc90\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8d\ud835\udc85'); // Basic logic: mixed case\n    });\n\n    test('should leave characters unchanged if they have no corresponding mathematical sans-serif italic equivalent', () => {\n        const input = '12345!@#';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udfe3\ud835\udfe4\ud835\udfe5\ud835\udfe6\ud835\udfe7!@#'); // Basic logic: numbers with special characters\n    });\n\n    test('should handle input with a mix of convertible and non-convertible characters', () => {\n        const input = 'Math123!';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc74\ud835\udc82\ud835\udc95\ud835\udc89\ud835\udfe3\ud835\udfe4\ud835\udfe5!'); // Basic logic: mix of letters, numbers, and special characters\n    });\n\n    test('should handle edge case where input is at the boundary of supported characters', () => {\n        const input = 'A0z9';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc68\ud835\udfe2\ud835\udc9b\ud835\udfeb'); // Boundary values: 'A', '0', 'z', '9'\n    });\n});\n\n\n", "test_code": "/**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}"}
{"task_id": 153, "code_type": "method", "code_language": "typescript", "code_signature": "// @ts-ignore\nconst crypto = require('crypto');\n\ndescribe('compressHash', () => {\n\n    test('should return a string of length 5', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result.length).toBe(5);\n    });\n\n    test('should return different strings for different inputs', () => {\n        // @ts-ignore\n        const hash1 = crypto.createHash('sha256').update('test1').digest();\n        // @ts-ignore\n        const hash2 = crypto.createHash('sha256').update('test2').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash1);\n        // @ts-ignore\n        const result2 = compressHash(hash2);\n        expect(result1).not.toBe(result2);\n    });\n\n    test('should return a consistent result for the same input', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash);\n        // @ts-ignore\n        const result2 = compressHash(hash);\n        expect(result1).toBe(result2);\n    });\n\n    test('should handle a hash of all zeros', () => {\n        const hash = Buffer.alloc(32, 0); // 32 bytes of zeros\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n\n    test('should handle a hash of all ones', () => {\n        const hash = Buffer.alloc(32, 255); // 32 bytes of 0xFF (255 in decimal)\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n});\n", "test_code": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}"}
{"task_id": 154, "code_type": "method", "code_language": "typescript", "code_signature": "describe('parseGitDiff', () => {\n\n    test('should parse a simple file addition', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/file.txt`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].newFileMode).toBe('100644');\n    });\n\n    test('should parse a simple file deletion', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\ndeleted file mode 100644\nindex e69de29..0000000\n--- a/file.txt\n+++ /dev/null`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].deletedFileMode).toBe('100644');\n    });\n\n    test('should parse a file modification with changes', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nindex e69de29..d95f3ad 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -0,0 +1 @@\n+Hello World`;\n\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n\n        expect(result).toHaveLength(1); // Ensure only one file diff is parsed\n        expect(result[0].oldPath).toBe('file.txt'); // Validate old file path\n        expect(result[0].newPath).toBe('file.txt'); // Validate new file path\n        expect(result[0].index).toBe('e69de29..d95f3ad'); // Validate index value\n        expect(result[0].changes).toEqual([\n            {code: \"--- a/file.txt\"}, // Validate old file path line\n            {code: \"+++ b/file.txt\"}, // Validate new file path line\n            {diff: '@@ -0,0 +1 @@'},  // Validate diff header\n            {code: '+Hello World'}     // Validate code addition\n        ]); // Validate changes array\n    });\n\n    test('should handle multiple file diffs', () => {\n        const diffText = `diff --git a/file1.txt b/file1.txt\nindex e69de29..d95f3ad 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -0,0 +1 @@\n+Hello World\ndiff --git a/file2.txt b/file2.txt\nindex 0a1b2c3..d4e5f6a 100644\n--- a/file2.txt\n+++ b/file2.txt\n@@ -1 +1 @@\n-Hello\n+Hi`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(2);\n        expect(result[0].oldPath).toBe('file1.txt');\n        expect(result[1].oldPath).toBe('file2.txt');\n    });\n\n    test('should return an empty array for empty diff text', () => {\n        // @ts-ignore\n        const result = parseGitDiff('');\n        expect(result).toEqual([]);\n    });\n\n});", "test_code": "// Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}"}
{"task_id": 155, "code_type": "method", "code_language": "typescript", "code_signature": "describe('getTimestamp', () => {\n    test('should return \"1 second ago\" for a date 1 second ago', () => {\n        const oneSecondAgo = new Date(new Date().getTime() - 1000); // 1 second ago\n        // @ts-ignore\n        expect(getTimestamp(oneSecondAgo)).toBe('1 second ago');\n    });\n\n    test('should return \"5 minutes ago\" for a date 5 minutes ago', () => {\n        const fiveMinutesAgo = new Date(new Date().getTime() - 5 * 60 * 1000); // 5 minutes ago\n        // @ts-ignore\n        expect(getTimestamp(fiveMinutesAgo)).toBe('5 minutes ago');\n    });\n\n    test('should return \"2 hours ago\" for a date 2 hours ago', () => {\n        const twoHoursAgo = new Date(new Date().getTime() - 2 * 60 * 60 * 1000); // 2 hours ago\n        // @ts-ignore\n        expect(getTimestamp(twoHoursAgo)).toBe('2 hours ago');\n    });\n\n    test('should return \"3 days ago\" for a date 3 days ago', () => {\n        const threeDaysAgo = new Date(new Date().getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        // @ts-ignore\n        expect(getTimestamp(threeDaysAgo)).toBe('3 days ago');\n    });\n\n    test('should return \"1 year ago\" for a date 1 year ago', () => {\n        const oneYearAgo = new Date(new Date().getTime() - 365 * 24 * 60 * 60 * 1000); // 1 year ago\n        // @ts-ignore\n        expect(getTimestamp(oneYearAgo)).toBe('1 year ago');\n    });\n});", "test_code": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}"}
{"task_id": 156, "code_type": "method", "code_language": "typescript", "code_signature": "describe('formatNumber', () => {\n    test('should format numbers greater than or equal to 1,000,000 with \"M\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(1500000)).toBe('1.5M');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n\n    test('should format numbers greater than or equal to 1,000 but less than 1,000,000 with \"K\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(2500)).toBe('2.5K');\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n    });\n\n    test('should return the number as a string if it is less than 1,000', () => {\n        // @ts-ignore\n        expect(formatNumber(999)).toBe('999');\n        // @ts-ignore\n        expect(formatNumber(500)).toBe('500');\n    });\n\n    test('should format numbers close to 1,000,000 correctly', () => {\n        // @ts-ignore\n        expect(formatNumber(999999)).toBe('999.9K'); // Corrected to reflect 'K' formatting\n        // @ts-ignore\n        expect(formatNumber(999500)).toBe('999.5K'); // Corrected to reflect 'K' formatting\n    });\n\n    test('should handle edge cases like exactly 1,000 or 1,000,000', () => {\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n});", "test_code": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}"}
{"task_id": 157, "code_type": "method", "code_language": "typescript", "code_signature": "describe('bytesToSize', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        // @ts-ignore\n        expect(bytesToSize(0)).toBe('0 Byte');\n    });\n\n    test('should convert bytes to KB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1024)).toBe('1.00 KB');\n        // @ts-ignore\n        expect(bytesToSize(2048)).toBe('2.00 KB');\n    });\n\n    test('should convert bytes to MB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1048576)).toBe('1.00 MB');\n        // @ts-ignore\n        expect(bytesToSize(2097152)).toBe('2.00 MB');\n    });\n\n    test('should convert bytes to GB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1073741824)).toBe('1.00 GB');\n        // @ts-ignore\n        expect(bytesToSize(2147483648)).toBe('2.00 GB');\n    });\n\n    test('should convert bytes to TB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1099511627776)).toBe('1.00 TB');\n        // @ts-ignore\n        expect(bytesToSize(2199023255552)).toBe('2.00 TB');\n    });\n});\n", "test_code": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\n// @ts-ignore\nexport function bytesToSize(bytes: number): string {\n\n}"}
{"task_id": 158, "code_type": "method", "code_language": "typescript", "code_signature": "describe('getFileExtension', () => {\n    test('should return the file extension for a standard file', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.txt')).toBe('txt');\n    });\n\n    test('should return an empty string for files without an extension', () => {\n        // @ts-ignore\n        expect(getFileExtension('example')).toBe('');\n    });\n\n    test('should handle files with multiple dots', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.with.many.dots.jpg')).toBe('jpg');\n    });\n\n    test('should return an empty string for filenames that end with a dot', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.')).toBe('');\n    });\n\n    test('should correctly handle case sensitivity', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.JPG')).toBe('JPG');\n    });\n});", "test_code": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\n// @ts-ignore\nexport function getFileExtension(file_name: string): string {\n\n}"}
{"task_id": 159, "code_type": "method", "code_language": "typescript", "code_signature": "describe('removeFileExtension', () => {\n    test('should remove the file extension from a standard file', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.txt')).toBe('document');\n    });\n\n    test('should return the original filename for files without an extension', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document')).toBe('document');\n    });\n\n    test('should handle files with multiple dots correctly', () => {\n        // @ts-ignore\n        expect(removeFileExtension('my.file.with.many.extensions.pdf')).toBe('my.file.with.many.extensions');\n    });\n\n    test('should return the original filename if it ends with a dot', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.')).toBe('document');\n    });\n\n    test('should correctly handle filenames with dots in directory names', () => {\n        // @ts-ignore\n        expect(removeFileExtension('path.to/my.file.txt')).toBe('path.to/my.file');\n    });\n});", "test_code": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\n// @ts-ignore\nexport function removeFileExtension(file_name: string): string {\n\n}"}
