{"task_id": 170, "code_type": "method", "code_language": "java", "code_signature": "package com.real.t170;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.real.t170.Adapted.*;\n\npublic class TestClass {\n    @Test\n    public void testSimpleParagraph() {\n        String html = \"<p>This is a test.</p>\";\n        String expected = \"This is a test.\\n\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testComplexNestedTags() {\n        String html = \"<p>This is <strong>bold and <em>italic</em></strong> text.</p>\";\n        String expected = \"This is **bold and *italic*** text.\\n\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testLinks() {\n        String html = \"<p>Check out this <a href='http://example.com'>link</a>.</p>\";\n        String expected = \"Check out this <a href='http://example.com'>link</a>.\\n\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testListItems() {\n        String html = \"<ul><li>Item 1</li><li>Item 2</li></ul>\";\n        String expected = \"* Item 1\\n* Item 2\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testEmptyString() {\n        String html = \"\";\n        String expected = \"\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n}\n", "test_code": "/**\n * convert the HTML string to the corresponding MarkDown formatted text. HTML tags that support conversion include a, strong, code, em, p, br, u, ul, li, ol\n * @param html\n * @return\n */\npublic static String convert(String html) {\n\n}"}
{"task_id": 173, "code_type": "class", "code_language": "java", "code_signature": "package com.real.t173;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\npublic class TestClass {\n\n    @Test\n    public void testCubicBezier_t0() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.0;\n        double[] expected = {0.0, 0.0};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t1() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 1.0;\n        double[] expected = {1.0, 0.0};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t0_5() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {0.5, 0.75};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_midPoint() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {1.0, 1.0};\n        double[] p2 = {2.0, 1.0};\n        double[] p3 = {3.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {1.5, 0.75};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_arbitraryT() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 2.0};\n        double[] p2 = {2.0, 2.0};\n        double[] p3 = {2.0, 0.0};\n        double t = 0.75;\n        double[] expected = {1.6875, 1.125};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n}\n", "test_code": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n"}
{"task_id": 180, "code_type": "method", "code_language": "java", "code_signature": "package com.real.t180;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.real.t180.Adapted.*;\npublic class TestClass {\n    /**\n     * Test when the target is present in the array.\n     */\n    @Test\n    public void testTargetPresent() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 7;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(3, result, \"Target should be found at index 3.\");\n    }\n\n    /**\n     * Test when the target is not present and the closest element is smaller.\n     */\n    @Test\n    public void testClosestElementSmaller() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 6;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(2, result, \"Closest element should be 5 at index 2.\");\n    }\n\n    /**\n     * Test when the target is not present and the closest element is larger.\n     */\n    @Test\n    public void testClosestElementLarger() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 8;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(3, result, \"Closest element should be 7 at index 3.\");\n    }\n\n    /**\n     * Test when the target is smaller than all elements in the array.\n     */\n    @Test\n    public void testTargetSmallerThanAll() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 0;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(0, result, \"Closest element should be 1 at index 0.\");\n    }\n\n    /**\n     * Test when the target is larger than all elements in the array.\n     */\n    @Test\n    public void testTargetLargerThanAll() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 12;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(5, result, \"Closest element should be 11 at index 5.\");\n    }\n}\n", "test_code": "/**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {}"}
{"task_id": 181, "code_type": "method", "code_language": "java", "code_signature": "package com.real.t181;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.real.t181.Adapted.*;\npublic class TestClass {\n\n    private File testFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        testFile = new File(\"testFile.txt\");\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(\"Test content\".getBytes());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    /**\n     * Test reading a file that exists and has content.\n     */\n    @Test\n    public void testReadFileWithContent() throws IOException {\n        byte[] content = Adapted.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"Test content\", new String(content), \"The file content should match the expected string.\");\n    }\n\n    /**\n     * Test reading an empty file.\n     */\n    @Test\n    public void testReadEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n\n        byte[] content = Adapted.readFileToByteArray(emptyFile.getAbsolutePath());\n        assertEquals(0, content.length, \"The content of an empty file should be a byte array of length 0.\");\n\n        emptyFile.delete();\n    }\n\n    /**\n     * Test reading a file that does not exist.\n     */\n    @Test\n    public void testReadNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(IllegalArgumentException.class, () -> {\n            Adapted.readFileToByteArray(nonExistentFilePath);\n        }, \"Reading a non-existent file should throw an IllegalArgumentException.\");\n    }\n\n    /**\n     * Test reading a file with special characters in its content.\n     */\n    @Test\n    public void testReadFileWithSpecialCharacters() throws IOException {\n        String specialContent = \"Special content: !@#$%^&*()_+\";\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(specialContent.getBytes());\n        }\n\n        byte[] content = Adapted.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(specialContent, new String(content), \"The file content should match the special characters string.\");\n    }\n\n    /**\n     * Test reading a large file.\n     */\n    @Test\n    public void testReadLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(largeContent);\n        }\n\n        byte[] content = Adapted.readFileToByteArray(testFile.getAbsolutePath());\n        assertArrayEquals(largeContent, content, \"The content of the large file should match the expected byte array.\");\n    }\n}\n", "test_code": "/**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {}"}
{"task_id": 182, "code_type": "method", "code_language": "java", "code_signature": "package com.real.t182;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.real.t182.Adapted.*;\npublic class TestClass {\n    private File sourceFile;\n    private File destinationFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        sourceFile = new File(\"testSourceFile.txt\");\n        destinationFile = new File(\"testDestinationFile.txt\");\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(\"This is a test file content.\".getBytes());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (sourceFile.exists()) {\n            sourceFile.delete();\n        }\n        if (destinationFile.exists()) {\n            destinationFile.delete();\n        }\n    }\n\n    /**\n     * Test copying a file with content.\n     */\n    @Test\n    public void testCopyFileWithContent() throws IOException {\n        long timeTaken = Adapted.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match.\");\n        assertTrue(timeTaken >= 0, \"Time taken should be non-negative.\");\n    }\n\n    /**\n     * Test copying an empty file.\n     */\n    @Test\n    public void testCopyEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n        File destinationEmptyFile = new File(\"destinationEmptyFile.txt\");\n\n        long timeTaken = Adapted.copyFileWithBufferedStream(emptyFile.getAbsolutePath(), destinationEmptyFile.getAbsolutePath());\n        assertTrue(destinationEmptyFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(0, destinationEmptyFile.length(), \"Empty file should have length 0.\");\n        assertTrue(timeTaken >= 0, \"Time taken should be non-negative.\");\n\n        emptyFile.delete();\n        destinationEmptyFile.delete();\n    }\n\n    /**\n     * Test copying a non-existent source file.\n     */\n    @Test\n    public void testCopyNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(IOException.class, () -> {\n            Adapted.copyFileWithBufferedStream(nonExistentFilePath, destinationFile.getAbsolutePath());\n        }, \"Copying a non-existent file should throw an IOException.\");\n    }\n\n    /**\n     * Test copying a file to an existing destination file (overwriting).\n     */\n    @Test\n    public void testCopyFileOverwrite() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(destinationFile)) {\n            fos.write(\"Old content\".getBytes());\n        }\n\n        long timeTaken = Adapted.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match after overwriting.\");\n        assertTrue(timeTaken > 0, \"Time taken should be greater than 0.\");\n    }\n\n    /**\n     * Test copying a large file.\n     */\n    @Test\n    public void testCopyLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(largeContent);\n        }\n\n        long timeTaken = Adapted.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match.\");\n        assertTrue(timeTaken > 0, \"Time taken should be greater than 0.\");\n    }\n}\n", "test_code": "/**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {}"}
