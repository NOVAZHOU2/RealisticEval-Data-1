{"task_id": 188, "code_type": "method", "code_language": "c&cpp", "code_signature": "\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nTEST_CASE(\"Shell sort - Basic functionality\", \"[shellSort]\") {\n    SECTION(\"Test Case 1: Already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 2: Reverse sorted array\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 3: Array with duplicate elements\") {\n        std::vector<int> arr = {4, 2, 2, 4, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 4: Array with negative numbers\") {\n        std::vector<int> arr = {-3, -1, -4, -2, 0};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 5: Empty array\") {\n        std::vector<int> arr = {};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}", "test_code": "/**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}"}
{"task_id": 189, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"Base64 Encode Tests\") {\n\n    SECTION(\"Empty input should return empty string\") {\n        std::vector<unsigned char> input = {};\n        REQUIRE(base64_encode(input) == \"\");\n    }\n\n    SECTION(\"Encoding 'hello' should return 'aGVsbG8='\") {\n        std::vector<unsigned char> input = {'h', 'e', 'l', 'l', 'o'};\n        REQUIRE(base64_encode(input) == \"aGVsbG8=\");\n    }\n\n    SECTION(\"Encoding 'world' should return 'd29ybGQ='\") {\n        std::vector<unsigned char> input = {'w', 'o', 'r', 'l', 'd'};\n        REQUIRE(base64_encode(input) == \"d29ybGQ=\");\n    }\n\n    SECTION(\"Encoding 'foobar' should return 'Zm9vYmFy'\") {\n        std::vector<unsigned char> input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        REQUIRE(base64_encode(input) == \"Zm9vYmFy\");\n    }\n\n    SECTION(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\") {\n        std::vector<unsigned char> input = {'C', 'a', 't', 'c', 'h', '2'};\n        REQUIRE(base64_encode(input) == \"Q2F0Y2gy\");\n    }\n\n    SECTION(\"Encoding single byte 'A' should return 'QQ=='\") {\n        std::vector<unsigned char> input = {'A'};\n        REQUIRE(base64_encode(input) == \"QQ==\");\n    }\n\n}", "test_code": "/**\n * convert a byte array into a Base64 encoded string.\n * @param data\n * @return\n */\nstd::string base64_encode(const std::vector<unsigned char>& data) {\n\n}"}
{"task_id": 190, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"Hexadecimal String to Float Conversion\", \"[hexStringToFloat]\") {\n\n    SECTION(\"Positive number: 40490FDB\") {\n        std::string hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Negative number: C0490FDB\") {\n        std::string hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Zero: 00000000\") {\n        std::string hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(0.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small positive number: 3F800000\") {\n        std::string hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(1.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small negative number: BF800000\") {\n        std::string hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-1.0f).epsilon(0.00001f));\n    }\n}", "test_code": "/**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}"}
{"task_id": 191, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"floatToHex tests\", \"[floatToHex]\") {\n    SECTION(\"Test with positive float 123.456\") {\n        float input = 123.456f;\n        std::string expected = \"42f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with negative float -123.456\") {\n        float input = -123.456f;\n        std::string expected = \"c2f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with zero\") {\n        float input = 0.0f;\n        std::string expected = \"00000000\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with small positive float 0.0001\") {\n        float input = 0.0001f;\n        std::string expected = \"38d1b717\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with large float 1e30\") {\n        float input = 1e30f;\n        std::string expected = \"7149f2ca\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n}", "test_code": "/**\n * Convert a floating-point number to a hexadecimal string. The process involves interpreting the bit pattern of the floating-point number as an unsigned integer and then formatting this integer value as a hexadecimal string without any prefix (like 0x). The output string should be 8 characters long, with leading zeros added if necessary to meet this length requirement.\n * @param value\n * @return\n */\nstd::string floatToHex(float value) {\n\n}"}
{"task_id": 192, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"hexStringToUnsignedInt converts hex string to unsigned int\", \"[hexStringToUnsignedInt]\") {\n\n    SECTION(\"Valid hex strings\") {\n        REQUIRE(hexStringToUnsignedInt(\"1A3F\") == 6719); // 1A3F in hex is 6719 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"FFFF\") == 65535); // FFFF in hex is 65535 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"0\") == 0); // 0 in hex is 0 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"7F\") == 127); // 7F in hex is 127 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"ABC123\") == 11256099); // ABC123 in hex is 11256099 in decimal\n    }\n\n    SECTION(\"Lowercase hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"abcd\") == 43981); // abcd in hex is 43981 in decimal\n    }\n\n    SECTION(\"Hex string with leading zeroes\") {\n        REQUIRE(hexStringToUnsignedInt(\"0001\") == 1); // 0001 in hex is 1 in decimal\n    }\n\n    SECTION(\"Empty hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"\") == 0); // Empty string should be treated as 0\n    }\n\n    SECTION(\"Mixed case hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"AbCdEf\") == 11259375); // AbCdEf in hex is 11259375 in decimal\n    }\n}", "test_code": "/**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}"}
{"task_id": 193, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"convFlags Test Cases\", \"[convFlags]\") {\n    // Test Case 1: All bits set (0xFFFFFFFF)\n    REQUIRE(convFlags(0xFFFFFFFF) == \"ffffffe0\");\n\n    // Test Case 2: No bits set (0x00000000)\n    REQUIRE(convFlags(0x00000000) == \"1f\");\n\n    // Test Case 3: Inverting first five bits only (0x0000001F)\n    REQUIRE(convFlags(0x0000001F) == \"0\");\n\n    // Test Case 4: Inverting first five bits of a random value (0x00000015)\n    REQUIRE(convFlags(0x00000015) == \"a\");\n\n    // Test Case 5: Inverting first five bits of a large number (0xFFFFFFE0)\n    REQUIRE(convFlags(0xFFFFFFE0) == \"ffffffff\");\n}", "test_code": "/**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}"}
{"task_id": 194, "code_type": "method", "code_language": "c&cpp", "code_signature": "\nTEST_CASE(\"return_string Test Cases\", \"[return_string]\") {\n    // Test Case 1: Copy a non-empty string\n    const char* original1 = \"Hello, World!\";\n    char* copy1 = return_string(original1);\n    REQUIRE(std::strcmp(copy1, original1) == 0);\n    delete[] copy1;\n\n    // Test Case 2: Copy an empty string\n    const char* original2 = \"\";\n    char* copy2 = return_string(original2);\n    REQUIRE(std::strcmp(copy2, original2) == 0);\n    delete[] copy2;\n\n    // Test Case 3: Copy a string with special characters\n    const char* original3 = \"C++ is fun! @#$%^&*()\";\n    char* copy3 = return_string(original3);\n    REQUIRE(std::strcmp(copy3, original3) == 0);\n    delete[] copy3;\n\n    // Test Case 4: Copy a single character string\n    const char* original4 = \"A\";\n    char* copy4 = return_string(original4);\n    REQUIRE(std::strcmp(copy4, original4) == 0);\n    delete[] copy4;\n\n    // Test Case 5: Passing a null pointer (should throw an exception)\n    REQUIRE_THROWS_AS(return_string(nullptr), std::invalid_argument);\n}", "test_code": "/**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}"}
{"task_id": 196, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"Sieve of Eratosthenes Test Cases\", \"[generatePrimes]\") {\n    // Test Case 1: Small limit (10)\n    std::vector<int> expected1 = {2, 3, 5, 7};\n    REQUIRE(generatePrimes(10) == expected1);\n\n    // Test Case 2: Prime limit (29)\n    std::vector<int> expected2 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(29) == expected2);\n\n    // Test Case 3: Non-prime limit (30)\n    std::vector<int> expected3 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(30) == expected3);\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    std::vector<int> expected4 = {2};\n    REQUIRE(generatePrimes(2) == expected4);\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    REQUIRE_THROWS_AS(generatePrimes(1), std::invalid_argument);\n}", "test_code": "/**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}"}
{"task_id": 197, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"FindOrder Test Cases\", \"[findOrder]\") {\n    // Test Case 1: Minimum valid input with 2 players\n    REQUIRE(findOrder(2) == vector<int>{2, 1});\n\n    // Test Case 2: 3 players\n    REQUIRE(findOrder(3) == vector<int>{2, 3, 1});\n\n    // Test Case 3: 5 players\n    REQUIRE(findOrder(5) == vector<int>{2, 5, 4, 1, 3});\n\n    // Test Case 4: 7 players\n    REQUIRE(findOrder(7) == vector<int>{2, 5, 1, 6, 4, 7, 3});\n\n    // Test Case 5: 10 players\n    REQUIRE(findOrder(10) == vector<int>{2, 5, 8, 1, 6, 4, 7, 10, 3, 9});\n}", "test_code": "/**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}"}
{"task_id": 198, "code_type": "method", "code_language": "c&cpp", "code_signature": "TEST_CASE(\"General case\", \"[findMaxDifference]\") {\n    vector<int> l = {2, 3, 10, 6, 4, 8, 1};\n    REQUIRE(findMaxDifference(l) == 8);  // \u6700\u5927\u5dee\u503c\u662f 10 - 2 = 8\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 2: \u9012\u51cf\u5e8f\u5217\nTEST_CASE(\"Decreasing sequence\", \"[findMaxDifference]\") {\n    vector<int> l = {10, 9, 8, 7, 6, 5};\n    REQUIRE(findMaxDifference(l) == -1);  // \u6700\u5927\u5dee\u503c\u662f 9 - 10 = -1\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 3: \u5168\u90e8\u76f8\u540c\u5143\u7d20\nTEST_CASE(\"All elements the same\", \"[findMaxDifference]\") {\n    vector<int> l = {5, 5, 5, 5, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // \u6700\u5927\u5dee\u503c\u662f 5 - 5 = 0\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 4: \u53ea\u6709\u4e24\u4e2a\u5143\u7d20\nTEST_CASE(\"Only two elements\", \"[findMaxDifference]\") {\n    vector<int> l = {3, 8};\n    REQUIRE(findMaxDifference(l) == 5);  // \u6700\u5927\u5dee\u503c\u662f 8 - 3 = 5\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 5: \u53ea\u6709\u4e00\u4e2a\u5143\u7d20\nTEST_CASE(\"Single element\", \"[findMaxDifference]\") {\n    vector<int> l = {4};\n    REQUIRE(findMaxDifference(l) == numeric_limits<int>::min());  // \u53ea\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u65e0\u6cd5\u8ba1\u7b97\u5dee\u503c\n}", "test_code": "/**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}"}
