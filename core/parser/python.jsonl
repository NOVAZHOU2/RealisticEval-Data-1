{"task_id": 1, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestSmartConvert(unittest.TestCase):\n    def test_convert_integer(self):\n        self.assertEqual(numerical_str_convert(\"123\"), 123, \"Should convert to integer\")\n\n    def test_convert_float(self):\n        self.assertEqual(numerical_str_convert(\"123.45\"), 123.45, \"Should convert to float\")\n\n    def test_convert_non_numeric_string(self):\n        self.assertEqual(numerical_str_convert(\"abc\"), \"abc\", \"Should remain a string\")\n\n    def test_convert_negative_integer(self):\n        self.assertEqual(numerical_str_convert(\"-456\"), -456, \"Should convert to negative integer\")\n\n    def test_convert_negative_float(self):\n        self.assertEqual(numerical_str_convert(\"-456.78\"), -456.78, \"Should convert to negative float\")\n", "test_code": "from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n    Args:\n        value (): input value str\n    Returns: convert result\n    \"\"\"\n"}
{"task_id": 2, "code_type": "method", "code_language": "python", "code_signature": "import unittest\nfrom unittest.mock import patch\n\n\ndef get_mock_input(input_values):\n    \"\"\" Generator to return values for each call to input() \"\"\"\n    for value in input_values:\n        yield value\n\n\nclass TestGeneratePowerShellInstallScript(unittest.TestCase):\n    def check_script_contents(self, expected_programs):\n        \"\"\" Helper function to check the contents of the generated PowerShell script \"\"\"\n        script_filename = 'install_programs.ps1'\n        with open(script_filename, 'r') as file:\n            lines = file.readlines()\n\n        # Check installation lines for programs\n        install_lines = [line.strip() for line in lines if line.strip().startswith('choco install')]\n        self.assertEqual(len(install_lines), len(expected_programs))\n        for program in expected_programs:\n            self.assertIn(f\"choco install {program} -y\", install_lines)\n\n    @patch('builtins.input', side_effect=get_mock_input([\"firefox\", \"done\"]))\n    def test_single_program(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"firefox\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"nodejs\", \"python\", \"git\", \"done\"]))\n    def test_multiple_programs(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"nodejs\", \"python\", \"git\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"done\"]))\n    def test_no_programs(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"NodeJS\", \"Python3\", \"done\"]))\n    def test_case_sensitivity(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"NodeJS\", \"Python3\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"sql server\", \"visual studio code\", \"done\"]))\n    def test_special_characters(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"sql server\", \"visual studio code\"])\n", "test_code": "def generate_powershell_install_script() -> str:\n    \"\"\"\n    The name of the program to be installed is obtained by user input, and a PowerShell script is generated, which can be directly run to download these programs\n    Returns: script_file_name\n    \"\"\"\n"}
{"task_id": 4, "code_type": "method", "code_language": "python", "code_signature": "import unittest\nimport math\n\n\nclass TestQuaternionToYaw(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Quaternion for no rotation\n        w, x, y, z = 1, 0, 0, 0\n        expected_yaw = 0\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed zero rotation test\")\n\n    def test_90_degrees_rotation(self):\n        # Quaternion for 90 degrees rotation around z-axis\n        w, x, y, z = math.cos(math.pi / 4), 0, 0, math.sin(math.pi / 4)\n        expected_yaw = math.pi / 2\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 90 degrees rotation test\")\n\n    def test_180_degrees_rotation(self):\n        # Quaternion for 180 degrees rotation around z-axis\n        w, x, y, z = 0, 0, 0, 1\n        expected_yaw = math.pi\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 180 degrees rotation test\")\n\n    def test_270_degrees_rotation(self):\n        # Quaternion for 270 degrees (or -90 degrees) rotation around z-axis\n        w, x, y, z = math.cos(-math.pi / 4), 0, 0, math.sin(-math.pi / 4)\n        expected_yaw = -math.pi / 2\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 270 degrees rotation test\")\n\n    def test_negative_rotation(self):\n        # Quaternion for negative rotation around z-axis\n        w, x, y, z = math.cos(-math.pi / 6), 0, 0, math.sin(-math.pi / 6)\n        expected_yaw = -math.pi / 3\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed negative rotation test\")\n", "test_code": "import math\n\n\ndef quaternion_to_yaw(w: float, x: float, y: float, z: float) -> float:\n    \"\"\"\n    The quaternion is converted to a selected yaw Angle around the z-axis\n    Args:\n        w (float): The scalar component of the quaternion.\n        x (float): The x-component of the quaternion vector part.\n        y (float): The y-component of the quaternion vector part.\n        z (float): The z-component of the quaternion vector part.\n\n    Returns: The yaw angle in radians.\n    \"\"\"\n"}
{"task_id": 5, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestMatrixMultiplication(unittest.TestCase):\n    def test_standard_matrices(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should correctly multiply standard matrices\")\n\n    def test_incompatible_dimensions(self):\n        mat1 = [[1, 2, 3], [4, 5, 6]]\n        mat2 = [[1, 2], [3, 4]]\n        with self.assertRaises(ValueError):\n            matrix_multiply(mat1, mat2)\n\n    def test_empty_matrices(self):\n        mat1 = []\n        mat2 = []\n        expected = []\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should handle empty matrices without error\")\n\n    def test_identity_matrix(self):\n        mat1 = [[1, 0], [0, 1]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[5, 6], [7, 8]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the identity matrix should yield the original.py matrix\")\n", "test_code": "from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n    Args:\n        matrixA (): matrix A\n        matrixB (): matrix B\n\n    Returns: matrixA matrixB multiplication result\n\n    \"\"\""}
{"task_id": 6, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\nclass TestSimplifyWindowsPath(unittest.TestCase):\n    def test_simple_path(self):\n        self.assertEqual(simplify_windows_path(\"C:\\\\Users\\\\User\\\\file.txt\"), \"C_Users_User_file.txt\")\n\n    def test_path_with_spaces(self):\n        self.assertEqual(simplify_windows_path(\"E:\\\\New Folder\\\\my file.docx\"), \"E_New Folder_my file.docx\")\n\n    def test_path_with_drive_only(self):\n        self.assertEqual(simplify_windows_path(\"F:\\\\\"), \"F_\")\n\n    def test_path_with_special_characters(self):\n        self.assertEqual(simplify_windows_path(\"D:\\\\data\\\\new-year@2020\\\\report#1.pdf\"), \"D_data_new-year@2020_report#1.pdf\")\n\n    def test_nested_directories(self):\n        self.assertEqual(simplify_windows_path(\"G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg\"), \"G_folder1_folder2_folder3_file.jpeg\")", "test_code": "def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings, for example, D:\\downlaod\\text.py is simplified to D_download_text.py\n    Args:\n        path (str): windows file path str\n    Returns:\n        simplify path str\n    \"\"\"\n"}
{"task_id": 7, "code_type": "class", "code_language": "python", "code_signature": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogger(unittest.TestCase):\n    def setUp(self):\n        self.logger_name = 'test_logger'\n        self.logger = Logger(self.logger_name)\n\n    @patch('logging.Logger.debug')\n    def test_debug_logging(self, mock_debug):\n        message = \"This is a debug message\"\n        self.logger.log(logging.DEBUG, message)\n        mock_debug.assert_called_once_with(message)\n\n    @patch('logging.Logger.info')\n    def test_info_logging(self, mock_info):\n        message = \"This is an info message\"\n        self.logger.log(logging.INFO, message)\n        mock_info.assert_called_once_with(message)\n\n    @patch('logging.Logger.warning')\n    def test_warning_logging(self, mock_warning):\n        message = \"This is a warning message\"\n        self.logger.log(logging.WARNING, message)\n        mock_warning.assert_called_once_with(message)\n\n    @patch('logging.Logger.error')\n    def test_error_logging(self, mock_error):\n        message = \"This is an error message\"\n        self.logger.log(logging.ERROR, message)\n        mock_error.assert_called_once_with(message)\n\n    @patch('logging.Logger.critical')\n    def test_critical_logging(self, mock_critical):\n        message = \"This is a critical message\"\n        self.logger.log(logging.CRITICAL, message)\n        mock_critical.assert_called_once_with(message)", "test_code": "import logging\n\n\nclass Logger:\n    def __init__(self, name, level=logging.DEBUG):\n        \"\"\"\n        Initializes a new logger instance.\n\n        :param name: Name of the logger, typically __name__ to reference the module name.\n        :param level: Logging level, default is DEBUG.\n        \"\"\"\n\n    def log(self, level, message):\n        \"\"\"\n        Logs a message with the given level.\n\n        :param level: Logging level for the message (e.g., logging.INFO).\n        :param message: Log message.\n        \"\"\"\n"}
{"task_id": 8, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestDecryptFunction(unittest.TestCase):\n    def test_basic_functionality(self):\n        self.assertEqual(perform_polynomial_decryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]), [4, 4, 4, 4])\n\n    def test_zero_secret_key(self):\n        self.assertEqual(perform_polynomial_decryption(3, 7, [0, 0, 0], [6, 13, 20]), [6, 6, 6])\n\n    def test_zero_ciphertext(self):\n        self.assertEqual(perform_polynomial_decryption(3, 9, [1, 2, 3], [0, 0, 0]), [8, 7, 6])\n\n    def test_large_values(self):\n        self.assertEqual(perform_polynomial_decryption(2, 1000, [500, 500], [1000, 1000]), [500, 500])\n\n\ndef perform_polynomial_decryption(degree, modulus, key, encrypted_data):\n    # Decrypts the polynomial based encryption by reversing the encryption steps\n    decrypted_data = [0] * degree\n\n    for index in range(degree):\n        # Reversing encryption: subtract key and take modulo\n        decrypted_data[index] = (encrypted_data[index] - key[index]) % modulus\n\n    return decrypted_data\n", "test_code": "from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting data\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted data\n\n    Returns: decrypted data\n\n    \"\"\""}
{"task_id": 9, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\ndef is_point_on_line(A, B, C):\n    (x_a, y_a), (x_b, y_b), (x_c, y_c) = A, B, C\n    if x_a == x_b:  # Check for vertical line\n        return x_c == x_a\n    return (y_c - y_a) * (x_b - x_a) == (y_b - y_a) * (x_c - x_a)\n\n\nclass TestPointOnLine(unittest.TestCase):\n    def test_point_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 6)\n        self.assertFalse(is_point_on_line(A, B, C))\n\n    def test_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_horizontal_line(self):\n        A = (0, 5)\n        B = (10, 5)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (6, 5)\n        self.assertFalse(is_point_on_line(A, B, C))\n", "test_code": "from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\""}
{"task_id": 11, "code_type": "class", "code_language": "python", "code_signature": "import unittest\n\nfrom total_python.t11.adapted import Trie\n\n\nclass TestTrie(unittest.TestCase):\n    def setUp(self):\n        self.trie = Trie()\n        self.trie.insert(\"apple\")\n        self.trie.insert(\"app\")\n        self.trie.insert(\"apricot\")\n        self.trie.insert(\"banana\")\n        self.trie.insert(\"carrot\")\n        self.trie.insert(\"car\")\n        self.trie.insert(\"care\")\n        self.trie.insert(\"\")\n        self.trie.insert(\"Hello\")\n        self.trie.insert(\"hello\")\n\n    def test_basic_search(self):\n        self.assertTrue(self.trie.search(\"apple\"))\n        self.assertTrue(self.trie.search(\"app\"))\n        self.assertTrue(self.trie.search(\"apricot\"))\n\n    def test_unsuccessful_search(self):\n        self.assertFalse(self.trie.search(\"bandana\"))\n\n    def test_prefix_search(self):\n        self.assertTrue(self.trie.starts_with(\"car\"))\n        self.assertTrue(self.trie.starts_with(\"care\"))\n        self.assertFalse(self.trie.starts_with(\"cat\"))\n\n    def test_empty_string(self):\n        self.assertTrue(self.trie.search(\"\"))\n        self.assertTrue(self.trie.starts_with(\"\"))\n\n    def test_case_sensitivity(self):\n        self.assertTrue(self.trie.search(\"Hello\"))\n        self.assertTrue(self.trie.search(\"hello\"))\n        self.assertFalse(self.trie.search(\"HELLO\"))\n", "test_code": "class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n"}
{"task_id": 13, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestParseMarkdownTable(unittest.TestCase):\n    def test_standard_table(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_inconsistent_columns(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2'),\n            ('Row1', 'Row1Col2', 'ExtraCol'),\n            ('Row2',)\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_empty_cells(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', 'Row1Col2', ''),\n            ('Row2Col1', '', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_all_empty_rows(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', '', ''),\n            ('', '', '')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_excessive_whitespace(self):\n        md_table = \"\"\"\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n\ndef parse_markdown_table(md_table):\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"\n    # Split the input string into lines and strip whitespace\n    lines = md_table.strip().split('\\n')\n\n    # Filter out the separator line for the header (which usually contains \"---\")\n    lines = [line for line in lines if not line.strip().startswith('|---')]\n\n    # Initialize the list to store each row as a tuple\n    table_data = []\n\n    # Process each line\n    for line in lines:\n        # Strip leading and trailing spaces and pipes, then split by \"|\"\n        row = line.strip('| \\n').split('|')\n        # Strip spaces from each cell, handle empty cells, and create a tuple\n        table_data.append(tuple(cell.strip() for cell in row if cell.strip() or cell == ''))\n\n    return table_data\n", "test_code": ""}
{"task_id": 1, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestSmartConvert(unittest.TestCase):\n    def test_convert_integer(self):\n        self.assertEqual(numerical_str_convert(\"123\"), 123, \"Should convert to integer\")\n\n    def test_convert_float(self):\n        self.assertEqual(numerical_str_convert(\"123.45\"), 123.45, \"Should convert to float\")\n\n    def test_convert_non_numeric_string(self):\n        self.assertEqual(numerical_str_convert(\"abc\"), \"abc\", \"Should remain a string\")\n\n    def test_convert_negative_integer(self):\n        self.assertEqual(numerical_str_convert(\"-456\"), -456, \"Should convert to negative integer\")\n\n    def test_convert_negative_float(self):\n        self.assertEqual(numerical_str_convert(\"-456.78\"), -456.78, \"Should convert to negative float\")\n", "test_code": "from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n    Args:\n        value (): input value str\n    Returns: convert result\n    \"\"\"\n"}
{"task_id": 2, "code_type": "method", "code_language": "python", "code_signature": "import unittest\nfrom unittest.mock import patch\n\n\ndef get_mock_input(input_values):\n    \"\"\" Generator to return values for each call to input() \"\"\"\n    for value in input_values:\n        yield value\n\n\nclass TestGeneratePowerShellInstallScript(unittest.TestCase):\n    def check_script_contents(self, expected_programs):\n        \"\"\" Helper function to check the contents of the generated PowerShell script \"\"\"\n        script_filename = 'install_programs.ps1'\n        with open(script_filename, 'r') as file:\n            lines = file.readlines()\n\n        # Check installation lines for programs\n        install_lines = [line.strip() for line in lines if line.strip().startswith('choco install')]\n        self.assertEqual(len(install_lines), len(expected_programs))\n        for program in expected_programs:\n            self.assertIn(f\"choco install {program} -y\", install_lines)\n\n    @patch('builtins.input', side_effect=get_mock_input([\"firefox\", \"done\"]))\n    def test_single_program(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"firefox\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"nodejs\", \"python\", \"git\", \"done\"]))\n    def test_multiple_programs(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"nodejs\", \"python\", \"git\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"done\"]))\n    def test_no_programs(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"NodeJS\", \"Python3\", \"done\"]))\n    def test_case_sensitivity(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"NodeJS\", \"Python3\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"sql server\", \"visual studio code\", \"done\"]))\n    def test_special_characters(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"sql server\", \"visual studio code\"])\n", "test_code": "def generate_powershell_install_script() -> str:\n    \"\"\"\n    The name of the program to be installed is obtained by user input, and a PowerShell script is generated, which can be directly run to download these programs\n    Returns: script_file_name\n    \"\"\"\n"}
{"task_id": 4, "code_type": "method", "code_language": "python", "code_signature": "import unittest\nimport math\n\n\nclass TestQuaternionToYaw(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Quaternion for no rotation\n        w, x, y, z = 1, 0, 0, 0\n        expected_yaw = 0\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed zero rotation test\")\n\n    def test_90_degrees_rotation(self):\n        # Quaternion for 90 degrees rotation around z-axis\n        w, x, y, z = math.cos(math.pi / 4), 0, 0, math.sin(math.pi / 4)\n        expected_yaw = math.pi / 2\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 90 degrees rotation test\")\n\n    def test_180_degrees_rotation(self):\n        # Quaternion for 180 degrees rotation around z-axis\n        w, x, y, z = 0, 0, 0, 1\n        expected_yaw = math.pi\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 180 degrees rotation test\")\n\n    def test_270_degrees_rotation(self):\n        # Quaternion for 270 degrees (or -90 degrees) rotation around z-axis\n        w, x, y, z = math.cos(-math.pi / 4), 0, 0, math.sin(-math.pi / 4)\n        expected_yaw = -math.pi / 2\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 270 degrees rotation test\")\n\n    def test_negative_rotation(self):\n        # Quaternion for negative rotation around z-axis\n        w, x, y, z = math.cos(-math.pi / 6), 0, 0, math.sin(-math.pi / 6)\n        expected_yaw = -math.pi / 3\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed negative rotation test\")\n", "test_code": "import math\n\n\ndef quaternion_to_yaw(w: float, x: float, y: float, z: float) -> float:\n    \"\"\"\n    The quaternion is converted to a selected yaw Angle around the z-axis\n    Args:\n        w (float): The scalar component of the quaternion.\n        x (float): The x-component of the quaternion vector part.\n        y (float): The y-component of the quaternion vector part.\n        z (float): The z-component of the quaternion vector part.\n\n    Returns: The yaw angle in radians.\n    \"\"\"\n"}
{"task_id": 5, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestMatrixMultiplication(unittest.TestCase):\n    def test_standard_matrices(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should correctly multiply standard matrices\")\n\n    def test_incompatible_dimensions(self):\n        mat1 = [[1, 2, 3], [4, 5, 6]]\n        mat2 = [[1, 2], [3, 4]]\n        with self.assertRaises(ValueError):\n            matrix_multiply(mat1, mat2)\n\n    def test_empty_matrices(self):\n        mat1 = []\n        mat2 = []\n        expected = []\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should handle empty matrices without error\")\n\n    def test_identity_matrix(self):\n        mat1 = [[1, 0], [0, 1]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[5, 6], [7, 8]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the identity matrix should yield the original.py matrix\")\n", "test_code": "from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n    Args:\n        matrixA (): matrix A\n        matrixB (): matrix B\n\n    Returns: matrixA matrixB multiplication result\n\n    \"\"\""}
{"task_id": 6, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\nclass TestSimplifyWindowsPath(unittest.TestCase):\n    def test_simple_path(self):\n        self.assertEqual(simplify_windows_path(\"C:\\\\Users\\\\User\\\\file.txt\"), \"C_Users_User_file.txt\")\n\n    def test_path_with_spaces(self):\n        self.assertEqual(simplify_windows_path(\"E:\\\\New Folder\\\\my file.docx\"), \"E_New Folder_my file.docx\")\n\n    def test_path_with_drive_only(self):\n        self.assertEqual(simplify_windows_path(\"F:\\\\\"), \"F_\")\n\n    def test_path_with_special_characters(self):\n        self.assertEqual(simplify_windows_path(\"D:\\\\data\\\\new-year@2020\\\\report#1.pdf\"), \"D_data_new-year@2020_report#1.pdf\")\n\n    def test_nested_directories(self):\n        self.assertEqual(simplify_windows_path(\"G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg\"), \"G_folder1_folder2_folder3_file.jpeg\")", "test_code": "def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings, for example, D:\\downlaod\\text.py is simplified to D_download_text.py\n    Args:\n        path (str): windows file path str\n    Returns:\n        simplify path str\n    \"\"\"\n"}
{"task_id": 7, "code_type": "class", "code_language": "python", "code_signature": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogger(unittest.TestCase):\n    def setUp(self):\n        self.logger_name = 'test_logger'\n        self.logger = Logger(self.logger_name)\n\n    @patch('logging.Logger.debug')\n    def test_debug_logging(self, mock_debug):\n        message = \"This is a debug message\"\n        self.logger.log(logging.DEBUG, message)\n        mock_debug.assert_called_once_with(message)\n\n    @patch('logging.Logger.info')\n    def test_info_logging(self, mock_info):\n        message = \"This is an info message\"\n        self.logger.log(logging.INFO, message)\n        mock_info.assert_called_once_with(message)\n\n    @patch('logging.Logger.warning')\n    def test_warning_logging(self, mock_warning):\n        message = \"This is a warning message\"\n        self.logger.log(logging.WARNING, message)\n        mock_warning.assert_called_once_with(message)\n\n    @patch('logging.Logger.error')\n    def test_error_logging(self, mock_error):\n        message = \"This is an error message\"\n        self.logger.log(logging.ERROR, message)\n        mock_error.assert_called_once_with(message)\n\n    @patch('logging.Logger.critical')\n    def test_critical_logging(self, mock_critical):\n        message = \"This is a critical message\"\n        self.logger.log(logging.CRITICAL, message)\n        mock_critical.assert_called_once_with(message)", "test_code": "import logging\n\n\nclass Logger:\n    def __init__(self, name, level=logging.DEBUG):\n        \"\"\"\n        Initializes a new logger instance.\n\n        :param name: Name of the logger, typically __name__ to reference the module name.\n        :param level: Logging level, default is DEBUG.\n        \"\"\"\n\n    def log(self, level, message):\n        \"\"\"\n        Logs a message with the given level.\n\n        :param level: Logging level for the message (e.g., logging.INFO).\n        :param message: Log message.\n        \"\"\"\n"}
{"task_id": 8, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestDecryptFunction(unittest.TestCase):\n    def test_basic_functionality(self):\n        self.assertEqual(perform_polynomial_decryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]), [4, 4, 4, 4])\n\n    def test_zero_secret_key(self):\n        self.assertEqual(perform_polynomial_decryption(3, 7, [0, 0, 0], [6, 13, 20]), [6, 6, 6])\n\n    def test_zero_ciphertext(self):\n        self.assertEqual(perform_polynomial_decryption(3, 9, [1, 2, 3], [0, 0, 0]), [8, 7, 6])\n\n    def test_large_values(self):\n        self.assertEqual(perform_polynomial_decryption(2, 1000, [500, 500], [1000, 1000]), [500, 500])\n\n\ndef perform_polynomial_decryption(degree, modulus, key, encrypted_data):\n    # Decrypts the polynomial based encryption by reversing the encryption steps\n    decrypted_data = [0] * degree\n\n    for index in range(degree):\n        # Reversing encryption: subtract key and take modulo\n        decrypted_data[index] = (encrypted_data[index] - key[index]) % modulus\n\n    return decrypted_data\n", "test_code": "from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting data\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted data\n\n    Returns: decrypted data\n\n    \"\"\""}
{"task_id": 9, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\ndef is_point_on_line(A, B, C):\n    (x_a, y_a), (x_b, y_b), (x_c, y_c) = A, B, C\n    if x_a == x_b:  # Check for vertical line\n        return x_c == x_a\n    return (y_c - y_a) * (x_b - x_a) == (y_b - y_a) * (x_c - x_a)\n\n\nclass TestPointOnLine(unittest.TestCase):\n    def test_point_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 6)\n        self.assertFalse(is_point_on_line(A, B, C))\n\n    def test_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_horizontal_line(self):\n        A = (0, 5)\n        B = (10, 5)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (6, 5)\n        self.assertFalse(is_point_on_line(A, B, C))\n", "test_code": "from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\""}
{"task_id": 11, "code_type": "class", "code_language": "python", "code_signature": "import unittest\n\nfrom total_python.t11.adapted import Trie\n\n\nclass TestTrie(unittest.TestCase):\n    def setUp(self):\n        self.trie = Trie()\n        self.trie.insert(\"apple\")\n        self.trie.insert(\"app\")\n        self.trie.insert(\"apricot\")\n        self.trie.insert(\"banana\")\n        self.trie.insert(\"carrot\")\n        self.trie.insert(\"car\")\n        self.trie.insert(\"care\")\n        self.trie.insert(\"\")\n        self.trie.insert(\"Hello\")\n        self.trie.insert(\"hello\")\n\n    def test_basic_search(self):\n        self.assertTrue(self.trie.search(\"apple\"))\n        self.assertTrue(self.trie.search(\"app\"))\n        self.assertTrue(self.trie.search(\"apricot\"))\n\n    def test_unsuccessful_search(self):\n        self.assertFalse(self.trie.search(\"bandana\"))\n\n    def test_prefix_search(self):\n        self.assertTrue(self.trie.starts_with(\"car\"))\n        self.assertTrue(self.trie.starts_with(\"care\"))\n        self.assertFalse(self.trie.starts_with(\"cat\"))\n\n    def test_empty_string(self):\n        self.assertTrue(self.trie.search(\"\"))\n        self.assertTrue(self.trie.starts_with(\"\"))\n\n    def test_case_sensitivity(self):\n        self.assertTrue(self.trie.search(\"Hello\"))\n        self.assertTrue(self.trie.search(\"hello\"))\n        self.assertFalse(self.trie.search(\"HELLO\"))\n", "test_code": "class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n"}
{"task_id": 13, "code_type": "method", "code_language": "python", "code_signature": "import unittest\n\n\nclass TestParseMarkdownTable(unittest.TestCase):\n    def test_standard_table(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_inconsistent_columns(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2'),\n            ('Row1', 'Row1Col2', 'ExtraCol'),\n            ('Row2',)\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_empty_cells(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', 'Row1Col2', ''),\n            ('Row2Col1', '', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_all_empty_rows(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', '', ''),\n            ('', '', '')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_excessive_whitespace(self):\n        md_table = \"\"\"\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n\ndef parse_markdown_table(md_table):\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"\n    # Split the input string into lines and strip whitespace\n    lines = md_table.strip().split('\\n')\n\n    # Filter out the separator line for the header (which usually contains \"---\")\n    lines = [line for line in lines if not line.strip().startswith('|---')]\n\n    # Initialize the list to store each row as a tuple\n    table_data = []\n\n    # Process each line\n    for line in lines:\n        # Strip leading and trailing spaces and pipes, then split by \"|\"\n        row = line.strip('| \\n').split('|')\n        # Strip spaces from each cell, handle empty cells, and create a tuple\n        table_data.append(tuple(cell.strip() for cell in row if cell.strip() or cell == ''))\n\n    return table_data\n", "test_code": ""}
