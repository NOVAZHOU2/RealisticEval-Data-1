[
  {
    "task_id": 1,
    "code_type": "method",
    "original_language": "python",
    "file_path": "sd12key.github.io\\8af95a6737f9fa2f7bebe49425e4c59068230b3b\\src\\parser.py",
    "question_type": "Data processing and transformation",
    "summary": "convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n\n    Args:\n        value (str): input value str\n    Returns:\n       Union[int, float, str]: convert model_answer_result\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestSmartConvert(unittest.TestCase):\n    def test_convert_integer(self):\n        self.assertEqual(numerical_str_convert(\"123\"), 123, \"Should convert to integer\")\n\n    def test_convert_float(self):\n        self.assertEqual(numerical_str_convert(\"123.45\"), 123.45, \"Should convert to float\")\n\n    def test_convert_non_numeric_string(self):\n        self.assertEqual(numerical_str_convert(\"abc\"), \"abc\", \"Should remain a string\")\n\n    def test_convert_negative_integer(self):\n        self.assertEqual(numerical_str_convert(\"-456\"), -456, \"Should convert to negative integer\")\n\n    def test_convert_negative_float(self):\n        self.assertEqual(numerical_str_convert(\"-456.78\"), -456.78, \"Should convert to negative float\")\n",
        "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n\n    Args:\n        value (str): input value str\n    Returns:\n       Union[int, float, str]: convert model_answer_result\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 5,
    "code_type": "method",
    "original_language": "python",
    "file_path": "lglsi2-24\\ffe7f23207afeacb1c4e6dab20a013ef91f9051e\\generated-code\\matrix_operations.py",
    "question_type": "Algorithm and data structure",
    "summary": "Implementing matrix multiplication\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n\n    Args:\n        matrixA (List[List[int]]): matrix A\n        matrixB (List[List[int]]): matrix B\n\n    Returns:\n        List[List[int]]: matrixA matrixB multiplication model_answer_result\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestMatrixMultiplication(unittest.TestCase):\n    def test_standard_matrices(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should correctly multiply standard matrices\")\n\n    def test_identity_matrix(self):\n        mat1 = [[1, 0], [0, 1]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[5, 6], [7, 8]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the identity matrix should yield the answer.py matrix\")\n\n    def test_zero_matrix(self):\n        mat1 = [[0, 0], [0, 0]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[0, 0], [0, 0]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the zero matrix should yield a zero matrix\")\n\n    def test_square_matrix_multiplication(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"The multiplication of two square matrices should yield the correct product\")\n\n    def test_large_identity_matrix(self):\n        mat1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n        mat2 = [[5, 6, 7], [8, 9, 10], [11, 12, 13]]\n        expected = [[5, 6, 7], [8, 9, 10], [11, 12, 13]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the larger identity matrix should yield the answer matrix\")\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n\n    Args:\n        matrixA (List[List[int]]): matrix A\n        matrixB (List[List[int]]): matrix B\n\n    Returns:\n        List[List[int]]: matrixA matrixB multiplication model_answer_result\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 6,
    "code_type": "method",
    "original_language": "python",
    "file_path": "brickflow\\49ec3c352b56fed12ee38cf357ee4c10e75cda53\\tools\\modify_schema.py",
    "question_type": "Data processing and transformation",
    "summary": "simplify file paths in windows systems into name strings, for example, D:\\downlaod\\text.py is simplified to D_download_text.py\n",
    "language_version_list": {
      "python": {
        "code_signature": "def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings.\n    For example:\n        input: C:\\\\Users\\\\User\\\\file.txt\n        output: C_Users_User_file.txt\n    Args:\n        path (str): windows file path str\n\n    Returns:\n        str: simplify path str\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestSimplifyWindowsPath(unittest.TestCase):\n    def test_simple_path(self):\n        self.assertEqual(simplify_windows_path(r\"C:\\Users\\User\\file.txt\"), \"C_Users_User_file.txt\")\n\n    def test_simple_path2(self):\n        self.assertEqual(simplify_windows_path(r\"D:\\User\\file.txt\"), \"D_User_file.txt\")\n\n    def test_path_with_spaces(self):\n        self.assertEqual(simplify_windows_path(r\"E:\\New Folder\\my file.docx\"), \"E_New Folder_my file.docx\")\n\n    def test_nested_directories(self):\n        self.assertEqual(simplify_windows_path(r\"G:\\folder1\\folder2\\folder3\\file.jpeg\"),\n                         \"G_folder1_folder2_folder3_file.jpeg\")\n",
        "prompt": "please write a python function , the function signature as below def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings.\n    For example:\n        input: C:\\\\Users\\\\User\\\\file.txt\n        output: C_Users_User_file.txt\n    Args:\n        path (str): windows file path str\n\n    Returns:\n        str: simplify path str\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 8,
    "code_type": "method",
    "original_language": "python",
    "file_path": "PQC_Seminar_S2024\\d29c067dec5571a529bc2d95e1d62f1a6b75b32c\\Kyber_Decrypt.py",
    "question_type": "Algorithm and data structure",
    "summary": "Implement decryption based on polynomials and keys\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting question\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted question\n\n    Returns: decrypted question\n\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestDecryptFunction(unittest.TestCase):\n    def test_basic_functionality(self):\n        self.assertEqual(perform_polynomial_decryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]), [4, 4, 4, 4])\n\n    def test_zero_secret_key(self):\n        self.assertEqual(perform_polynomial_decryption(3, 7, [0, 0, 0], [6, 13, 20]), [6, 6, 6])\n\n    def test_zero_ciphertext(self):\n        self.assertEqual(perform_polynomial_decryption(3, 9, [1, 2, 3], [0, 0, 0]), [8, 7, 6])\n\n    def test_large_values(self):\n        self.assertEqual(perform_polynomial_decryption(2, 1000, [500, 500], [1000, 1000]), [500, 500])\n\n\ndef perform_polynomial_decryption(degree, modulus, key, encrypted_data):\n    # Decrypts the polynomial based encryption by reversing the encryption steps\n    decrypted_data = [0] * degree\n\n    for index in range(degree):\n        # Reversing encryption: subtract key and take modulo\n        decrypted_data[index] = (encrypted_data[index] - key[index]) % modulus\n\n    return decrypted_data\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting question\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted question\n\n    Returns: decrypted question\n\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 9,
    "code_type": "method",
    "original_language": "python",
    "file_path": "polygon_problem\\74813e88e55dcb2b442e127658b714df489b16a4\\Graph.py",
    "question_type": "Data processing and transformation",
    "summary": "Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\"",
        "test_code": "import unittest\n\n\ndef is_point_on_line(A, B, C):\n    (x_a, y_a), (x_b, y_b), (x_c, y_c) = A, B, C\n    if x_a == x_b:  # Check for vertical line\n        return x_c == x_a\n    return (y_c - y_a) * (x_b - x_a) == (y_b - y_a) * (x_c - x_a)\n\n\nclass TestPointOnLine(unittest.TestCase):\n    def test_point_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 6)\n        self.assertFalse(is_point_on_line(A, B, C))\n\n    def test_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_horizontal_line(self):\n        A = (0, 5)\n        B = (10, 5)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (6, 5)\n        self.assertFalse(is_point_on_line(A, B, C))\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 11,
    "code_type": "class",
    "original_language": "python",
    "file_path": "metadata-extraction\\f8a36bb0e7f0ad483a8cef3f4e20d45e623d6db8\\text\\compare.py",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a dictionary tree for fast string retrieval and storage\n",
    "language_version_list": {
      "python": {
        "code_signature": "class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n",
        "test_code": "import unittest\n\n\nclass TestTrie(unittest.TestCase):\n    def setUp(self):\n        self.trie = Trie()\n        self.trie.insert(\"apple\")\n        self.trie.insert(\"app\")\n        self.trie.insert(\"apricot\")\n        self.trie.insert(\"banana\")\n        self.trie.insert(\"carrot\")\n        self.trie.insert(\"car\")\n        self.trie.insert(\"care\")\n        self.trie.insert(\"\")\n        self.trie.insert(\"Hello\")\n        self.trie.insert(\"hello\")\n\n    def test_basic_search(self):\n        self.assertTrue(self.trie.search(\"apple\"))\n        self.assertTrue(self.trie.search(\"app\"))\n        self.assertTrue(self.trie.search(\"apricot\"))\n\n    def test_unsuccessful_search(self):\n        self.assertFalse(self.trie.search(\"bandana\"))\n\n    def test_prefix_search(self):\n        self.assertTrue(self.trie.starts_with(\"car\"))\n        self.assertTrue(self.trie.starts_with(\"care\"))\n        self.assertFalse(self.trie.starts_with(\"cat\"))\n\n    def test_empty_string(self):\n        self.assertTrue(self.trie.search(\"\"))\n        self.assertTrue(self.trie.starts_with(\"\"))\n\n    def test_case_sensitivity(self):\n        self.assertTrue(self.trie.search(\"Hello\"))\n        self.assertTrue(self.trie.search(\"hello\"))\n        self.assertFalse(self.trie.search(\"HELLO\"))\n",
        "prompt": "please write a python class , the class signature as below class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 12,
    "code_type": "method",
    "original_language": "python",
    "file_path": "MARLLPettingZoo\\e519dab2f60ac9ede7f932cc39793e293a249be6\\Custom-Environment\\custom-environment\\marll_v0.1.py",
    "question_type": "Data processing and transformation",
    "summary": "Calculates the Euclidean distance between two agents based on their coordinates in the observations.",
    "language_version_list": {
      "python": {
        "code_signature": "def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation question with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCalculateDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Both agents are at the same point\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 0.0)\n\n    def test_horizontal_distance(self):\n        # Agents are horizontally apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 3, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 3.0)\n\n    def test_vertical_distance(self):\n        # Agents are vertically apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 4}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 4.0)\n\n    def test_diagonal_distance(self):\n        # Agents are diagonally apart\n        observations = {\n            \"agent1\": {\"x\": 1, \"y\": 2},\n            \"agent2\": {\"x\": 4, \"y\": 6}\n        }\n        expected_distance = np.sqrt((4 - 1) ** 2 + (6 - 2) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)\n\n    def test_negative_coordinates(self):\n        # Agents have negative coordinates\n        observations = {\n            \"agent1\": {\"x\": -1, \"y\": -1},\n            \"agent2\": {\"x\": -4, \"y\": -5}\n        }\n        expected_distance = np.sqrt((-4 + 1) ** 2 + (-5 + 1) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)",
        "prompt": "please write a python function , the function signature as below def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation question with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 13,
    "code_type": "method",
    "original_language": "python",
    "file_path": "markpickle\\f29202998c0d5ae3ebc2bd22de57bc1c2c6bacbb\\markpickle\\python_to_tables.py",
    "question_type": "Data processing and transformation",
    "summary": "Parse the string of the table in Markdown format and return a list of tuples, one for each row in the table",
    "language_version_list": {
      "python": {
        "code_signature": "",
        "test_code": "import unittest\n\n\nclass TestParseMarkdownTable(unittest.TestCase):\n    def test_standard_table(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_inconsistent_columns(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2'),\n            ('Row1', 'Row1Col2', 'ExtraCol'),\n            ('Row2',)\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_empty_cells(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', 'Row1Col2', ''),\n            ('Row2Col1', '', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_all_empty_rows(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', '', ''),\n            ('', '', '')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_excessive_whitespace(self):\n        md_table = \"\"\"\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n\ndef parse_markdown_table(md_table):\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"\n    # Split the input string into lines and strip whitespace\n    lines = md_table.strip().split('\\n')\n\n    # Filter out the separator line for the header (which usually contains \"---\")\n    lines = [line for line in lines if not line.strip().startswith('|---')]\n\n    # Initialize the list to store each row as a tuple\n    table_data = []\n\n    # Process each line\n    for line in lines:\n        # Strip leading and trailing spaces and pipes, then split by \"|\"\n        row = line.strip('| \\n').split('|')\n        # Strip spaces from each cell, handle empty cells, and create a tuple\n        table_data.append(tuple(cell.strip() for cell in row if cell.strip() or cell == ''))\n\n    return table_data\n",
        "prompt": "please write a python function , the function signature as below ",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 17,
    "code_type": "method",
    "original_language": "python",
    "file_path": "directional-positioning-error-bachelors-thesis\\4e281251a4a587eb076606817288c31a48536d61\\calculate-distance.py",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "calculate the distance between two points on the earth based on their latitude and longitude\n",
    "language_version_list": {
      "python": {
        "code_signature": "def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\"",
        "test_code": "    import unittest\n\n\n    class TestHaversineDistance(unittest.TestCase):\n\n        def test_same_point(self):\n            # Same point should return a distance of 0\n            lat, lon = 52.2296756, 21.0122287\n            result = haversine_distance(lat, lon, lat, lon)\n            self.assertAlmostEqual(result, 0.0, places=6)\n\n        def test_small_distance(self):\n            # Points that are very close together (few meters apart)\n            lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n            lat2, lon2 = 52.2296756, 21.0122297  # Very close to the previous point\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 0.0001, places=4)  # Expected small distance\n\n        def test_large_distance(self):\n            # Points that are far apart\n            lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n            lat2, lon2 = 41.8919300, 12.5113300  # Rome, Italy\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 1315.514, places=2)  # Approx distance in km\n\n        def test_equator_distance(self):\n            # Points on the equator\n            lat1, lon1 = 0.0, 0.0  # Gulf of Guinea (Equator and Prime Meridian intersection)\n            lat2, lon2 = 0.0, 90.0  # On the Equator, 90 degrees east\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 10007.54, places=2)  # Approx quarter of Earth's circumference\n\n        def test_pole_to_pole(self):\n            # Distance from North Pole to South Pole\n            lat1, lon1 = 90.0, 0.0  # North Pole\n            lat2, lon2 = -90.0, 0.0  # South Pole\n            result = haversine_distance(lat1, lon1, lat2, lon2)\n            self.assertAlmostEqual(result, 20015.09, places=2)  # Approx half of Earth's circumference\n",
        "prompt": "please write a python function , the function signature as below def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 18,
    "code_type": "method",
    "original_language": "python",
    "file_path": "boba-walks\\8449cb77916b4fb07e2d393370699fea7193a0df\\utils.py",
    "question_type": "Data processing and transformation",
    "summary": "Convert a floating point number between 0 and 1 to a color from red to green in the color format RGB",
    "language_version_list": {
      "python": {
        "code_signature": "def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFloatToRGB(unittest.TestCase):\n\n    def test_pure_red(self):\n        # Value at the lower boundary (0.0) should return pure red\n        result = float_to_rgb(0.0)\n        self.assertEqual(result, (255, 0, 0))\n\n    def test_pure_green(self):\n        # Value at the upper boundary (1.0) should return pure green\n        result = float_to_rgb(1.0)\n        self.assertEqual(result, (0, 255, 0))\n\n    def test_midpoint(self):\n        # Value at 0.5 should return an equal mix of red and green, resulting in yellow\n        result = float_to_rgb(0.5)\n        self.assertEqual(result, (127, 127, 0))\n\n    def test_quarter_point(self):\n        # Value at 0.25 should return more red than green\n        result = float_to_rgb(0.25)\n        self.assertEqual(result, (191, 63, 0))\n\n    def test_invalid_value(self):\n        # Value outside the range [0, 1] should raise a ValueError\n        with self.assertRaises(ValueError):\n            float_to_rgb(1.5)",
        "prompt": "please write a python function , the function signature as below def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 19,
    "code_type": "method",
    "original_language": "python",
    "file_path": "athina-sdk\\50646629f89f8e25d0a7b7a8edb69305605fcabb\\magik\\evaluators.py",
    "question_type": "Data processing and transformation",
    "summary": "Determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234",
    "language_version_list": {
      "python": {
        "code_signature": "def contains_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n",
        "test_code": "import re\nimport unittest\n\n\nclass TestPhoneNumberDetection(unittest.TestCase):\n    def test_with_international_prefix(self):\n        self.assertTrue(contains_phone_number(\"+1-800-555-1234\"), \"Should detect international prefix\")\n\n    def test_with_standard_dashes(self):\n        self.assertTrue(contains_phone_number(\"800-555-1234\"), \"Should detect standard format with dashes\")\n\n    def test_with_spaces(self):\n        self.assertTrue(contains_phone_number(\"800 555 1234\"), \"Should detect standard format with spaces\")\n\n    def test_without_phone_number(self):\n        self.assertFalse(contains_phone_number(\"Hello, world!\"), \"Should not detect any phone number\")\n\n    def test_with_text_containing_numbers(self):\n        self.assertTrue(contains_phone_number(\"Call me at 800-555-1234 today!\"), \"Should detect phone number in text\")",
        "prompt": "please write a python function , the function signature as below def contains_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 20,
    "code_type": "method",
    "original_language": "python",
    "file_path": "exa-py\\a3d4c480cb99854656924e83696cfb5546bc7118\\docs\\repair_markdown_docs.py",
    "question_type": "Data processing and transformation",
    "summary": "Match the text with (*... *) The inner asterisks in the part of the format are removed and the outer parts (* and *) are left unchanged. For example,(*he*l*lo*) would be converted to (*hello*)\n",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef transform_parentheses(text: str) -> str:\n    \"\"\"\n    Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n    Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n    For example:\n        input: *he*l*lo*\n        output: *hello*\n\n    Args:\n        text (str): The input text containing patterns to be transformed.\n\n    Returns:\n        str: The transformed text with asterisks inside '(*...*)' patterns removed.\n    \"\"\"\n",
        "test_code": "import unittest\nimport re\n\n\nclass TestTransformParentheses(unittest.TestCase):\n\n    def test_basic_case(self):\n        text = \"Hello (*wo*rld*)!\"\n        expected = \"Hello (*world*)!\"\n        self.assertEqual(transform_parentheses(text), expected)\n\n    def test_multiple_asterisks(self):\n        text = \"(*he*l*lo*)\"\n        expected = \"(*hello*)\"\n        self.assertEqual(transform_parentheses(text), expected)\n\n    def test_no_asterisks_inside(self):\n        text = \"(*hello*)\"\n        expected = \"(*hello*)\"\n        self.assertEqual(transform_parentheses(text), expected)\n\n    def test_multiple_patterns(self):\n        text = \"(*hi*), (*there*), (*world*)!\"\n        expected = \"(*hi*), (*there*), (*world*)!\"\n        self.assertEqual(transform_parentheses(text), expected)\n\n    def test_no_matching_pattern(self):\n        text = \"This is a test without matching parentheses.\"\n        expected = \"This is a test without matching parentheses.\"\n        self.assertEqual(transform_parentheses(text), expected)\n",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef transform_parentheses(text: str) -> str:\n    \"\"\"\n    Transforms the input text by finding and modifying patterns that match the format '(*...*)'.\n    Specifically, it removes any asterisks inside the parentheses while preserving the outer format.\n    For example:\n        input: *he*l*lo*\n        output: *hello*\n\n    Args:\n        text (str): The input text containing patterns to be transformed.\n\n    Returns:\n        str: The transformed text with asterisks inside '(*...*)' patterns removed.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 21,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ecosim-ontology\\44a380ef9b04577b15cbed22110a1691c2a08ae0\\utils\\fortran2params.py",
    "question_type": "Data processing and transformation",
    "summary": " compare the contents of two files and print the differences in unified diff format.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef compare_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n",
        "test_code": "import os\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestCompareFiles(unittest.TestCase):\n\n    def setUp(self):\n        # \u521b\u5efa\u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\n        self.file1_path = 'file1.txt'\n        self.file2_path = 'file2.txt'\n\n    def tearDown(self):\n        # \u5220\u9664\u521b\u5efa\u7684\u6587\u4ef6\n        if os.path.exists(self.file1_path):\n            os.remove(self.file1_path)\n        if os.path.exists(self.file2_path):\n            os.remove(self.file2_path)\n\n    def test_identical_files(self):\n        # Mock question for two identical files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLine2\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = compare_files(self.file1_path, self.file2_path)\n        self.assertEqual(len(result), 0, \"There should be no differences detected\")\n\n    def test_files_with_differences(self):\n        # Mock question for two different files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLineChanged\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = compare_files(self.file1_path, self.file2_path)\n        self.assertNotEqual(len(result), 0, \"There should be differences detected\")\n\n    def test_nonexistent_file(self):\n        # Test when one of the files does not exist\n        with patch('builtins.open', side_effect=FileNotFoundError(\"File not found\")):\n            with self.assertRaises(FileNotFoundError):\n                compare_files('nonexistent.txt', 'file2.txt')\n\n    def test_file_reading_error(self):\n        # Test when there's an error reading the file\n        with patch('builtins.open', side_effect=IOError(\"Error reading file\")):\n            with self.assertRaises(IOError):\n                compare_files('file1.txt', 'file2.txt')\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef compare_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 22,
    "code_type": "method",
    "original_language": "python",
    "file_path": "python-2draycasting-lines\\e848288fd0a6ceb9e53f9092579624ea43effdf0\\utils.py",
    "question_type": "Algorithm and data structure",
    "summary": "calculate the Euclidean distance between two points",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\n\ndef calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    calculate the Euclidean distance between two points in a 2D space.\n\n    Args:\n        point1 (Tuple[float, float]): The first point as a tuple of coordinates (x1, y1).\n        point2 (Tuple[float, float]): The second point as a tuple of coordinates (x2, y2).\n\n    Returns:\n        float: The Euclidean distance between the two points.\n\n    \"\"\"\n",
        "test_code": "import unittest\nfrom typing import Tuple\n\nclass TestCalculateEuclideanDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        # Basic logic functionality test.js\n        point1 = (0, 0)\n        point2 = (3, 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should calculate the distance correctly\")\n\n    def test_negative_coordinates(self):\n        # Test with negative coordinates\n        point1 = (-1, -1)\n        point2 = (-4, -5)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle negative coordinates correctly\")\n\n    def test_zero_distance(self):\n        # Boundary test.js: points are the same\n        point1 = (2, 3)\n        point2 = (2, 3)\n        expected_distance = 0.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should return 0 when both points are the same\")\n\n    def test_large_coordinates(self):\n        # Boundary test.js: large coordinates\n        point1 = (1e6, 1e6)\n        point2 = (1e6 + 3, 1e6 + 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle large coordinates correctly\")\n\n    def test_invalid_input(self):\n        # Exception handling test.js: invalid input (non-tuple)\n        with self.assertRaises(TypeError):\n            calculate_euclidean_distance(\"invalid\", (0, 0))\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    calculate the Euclidean distance between two points in a 2D space.\n\n    Args:\n        point1 (Tuple[float, float]): The first point as a tuple of coordinates (x1, y1).\n        point2 (Tuple[float, float]): The second point as a tuple of coordinates (x2, y2).\n\n    Returns:\n        float: The Euclidean distance between the two points.\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 23,
    "code_type": "method",
    "original_language": "python",
    "file_path": "python-2draycasting-lines\\e848288fd0a6ceb9e53f9092579624ea43effdf0\\utils.py",
    "question_type": "Algorithm and data structure",
    "summary": "calculate the intersection point of two line segments.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Union\n\n\ndef get_line_segment_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestLineSegmentIntersection(unittest.TestCase):\n\n    def test_intersection(self):\n        seg1 = ((1, 1), (4, 4))\n        seg2 = ((1, 4), (4, 1))\n        expected = (2.5, 2.5)\n        result = get_line_segment_intersection(seg1, seg2)\n        self.assertEqual(result, expected, \"The intersection should be at (2.5, 2.5)\")\n\n    def test_no_intersection(self):\n        seg1 = ((1, 1), (2, 2))\n        seg2 = ((3, 3), (4, 4))\n        result = get_line_segment_intersection(seg1, seg2)\n        self.assertIsNone(result, \"There should be no intersection\")\n\n    def test_parallel_segments(self):\n        seg1 = ((1, 1), (2, 2))\n        seg2 = ((1, 2), (2, 3))\n        result = get_line_segment_intersection(seg1, seg2)\n        self.assertIsNone(result, \"Parallel segments should not intersect\")\n\n    def test_no_intersection_due_to_offset(self):\n        seg1 = ((1, 1), (3, 3))\n        seg2 = ((3, 2), (4, 2))\n        result = get_line_segment_intersection(seg1, seg2)\n        self.assertIsNone(result, \"There should be no intersection due to offset between segments\")\n\n    def test_intersection_with_large_coordinates(self):\n        seg1 = ((1000, 1000), (2000, 2000))\n        seg2 = ((1000, 2000), (2000, 1000))\n        expected = (1500.0, 1500.0)\n        result = get_line_segment_intersection(seg1, seg2)\n        self.assertEqual(result, expected, \"The intersection should be at (1500.0, 1500.0)\")\n\n\n",
        "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef get_line_segment_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 24,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Hypothesizer-CLI\\51c51a4562228c44f26e13e24cbe998932fe82c4\\Parsers\\SemgrepConversion.py",
    "question_type": "Data processing and transformation",
    "summary": "convert yaml format files to json format files\n",
    "language_version_list": {
      "python": {
        "code_signature": "def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\nimport os\nimport json\nimport yaml\n\n\nclass TestConvertYamlToJson(unittest.TestCase):\n\n    def setUp(self):\n        # Create temporary YAML files for testing\n        self.simple_yaml = 'simple.yaml'\n        self.nested_yaml = 'nested.yaml'\n        self.empty_yaml = 'empty.yaml'\n        self.list_yaml = 'list.yaml'\n        self.invalid_yaml = 'invalid.yaml'\n\n        with open(self.simple_yaml, 'w') as file:\n            file.write(\"name: John Doe\\nage: 30\\n\")\n\n        with open(self.nested_yaml, 'w') as file:\n            file.write(\"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\")\n\n        with open(self.empty_yaml, 'w') as file:\n            file.write(\"\")\n\n        with open(self.list_yaml, 'w') as file:\n            file.write(\"- item1\\n- item2\\n- item3\\n\")\n\n        with open(self.invalid_yaml, 'w') as file:\n            file.write(\"{ invalid: YAML: structure }\\n\")\n\n    def tearDown(self):\n        # Remove temporary files after testing\n        os.remove(self.simple_yaml)\n        os.remove(self.nested_yaml)\n        os.remove(self.empty_yaml)\n        os.remove(self.list_yaml)\n        os.remove(self.invalid_yaml)\n\n        if os.path.exists('output.json'):\n            os.remove('output.json')\n\n    def test_simple_yaml_conversion(self):\n        convert_yaml_to_json(self.simple_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, {\"name\": \"John Doe\", \"age\": 30})\n\n    def test_nested_yaml_conversion(self):\n        convert_yaml_to_json(self.nested_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        expected_data = {\n            \"person\": {\n                \"name\": \"Jane Doe\",\n                \"age\": 25,\n                \"address\": {\n                    \"city\": \"New York\",\n                    \"zip\": 10001\n                }\n            }\n        }\n        self.assertEqual(data, expected_data)\n\n    def test_empty_yaml_conversion(self):\n        convert_yaml_to_json(self.empty_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, None)  # YAML.safe_load() returns None for empty files\n\n    def test_list_yaml_conversion(self):\n        convert_yaml_to_json(self.list_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, [\"item1\", \"item2\", \"item3\"])\n\n    def test_invalid_yaml_conversion(self):\n        with self.assertRaises(yaml.YAMLError):\n            convert_yaml_to_json(self.invalid_yaml, 'output.json')\n",
        "prompt": "please write a python function , the function signature as below def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 25,
    "code_type": "method",
    "original_language": "python",
    "file_path": "website-2024\\252065dd22d32491fb30866fac26c7125f433d3c\\static\\python-scripts\\poster_filter.py",
    "question_type": "Data processing and transformation",
    "summary": "read the JSON file data based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file question based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\nimport json\nimport tempfile\nimport os\n\nclass TestClassifyJsonObjectsByPid(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.mkdtemp()\n\n        # Create temporary files for testing\n        self.source_file = os.path.join(self.temp_dir, 'source.json')\n        self.match_file = os.path.join(self.temp_dir, 'match.json')\n        self.mismatch_file = os.path.join(self.temp_dir, 'mismatch.json')\n\n        # Example question\n        self.data = [\n            {\"name\": \"Alice\", \"pid\": 1},\n            {\"name\": \"Bob\", \"pid\": 2},\n            {\"name\": \"Charlie\", \"pid\": 3}\n        ]\n        self.pid_list = [1, 3]\n\n        # Write example question to source file\n        with open(self.source_file, 'w') as f:\n            json.dump(self.data, f)\n\n    def test_all_match(self):\n        # Test where all items match\n        classify_json_objects_by_pid(self.source_file, [1, 2, 3], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 3)\n        self.assertEqual(len(mismatches), 0)\n\n    def test_no_match(self):\n        # Test where no items match\n        classify_json_objects_by_pid(self.source_file, [4, 5], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n\n    def test_partial_match(self):\n        # Test where some items match\n        classify_json_objects_by_pid(self.source_file, self.pid_list, self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 2)\n        self.assertEqual(len(mismatches), 1)\n\n    def test_empty_pid_list(self):\n        # Test with an empty PID list\n        classify_json_objects_by_pid(self.source_file, [], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file question based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 26,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Deep-Learning-Project\\993ae1ef77ec317fd8ab7e6686b5e66a3db0fdad\\src\\trainers\\cnn_trainer.py",
    "question_type": "Framework and library",
    "summary": "convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n",
    "language_version_list": {
      "python": {
        "code_signature": "def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestConvertToCommaSeparated(unittest.TestCase):\n    def test_basic_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"apple;banana*orange/mango\"), \"apple,banana,orange,mango\",\n                         \"Failed to convert basic separators.\")\n\n    def test_mixed_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes;lemon/melon*kiwi;litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n    def test_mixed_separators2(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes/lemon/melon*kiwi*litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n\n    def test_no_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"watermelon\"), \"watermelon\",\n                         \"Failed when no separators are present.\")",
        "prompt": "please write a python function , the function signature as below def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 27,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Spotify_Wayback\\956bf4b21beec2ff51750963d4d9c7f81f1b12b0\\combine_json.py",
    "question_type": "Data processing and transformation",
    "summary": "concatenate the root-level array JSON files in the specified directory",
    "language_version_list": {
      "python": {
        "code_signature": "import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged question\n\n    \"\"\"\n",
        "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestConcatenateJsonArrays(unittest.TestCase):\n\n    def setUp(self):\n        # Set up a test.js directory and test.js files\n        self.test_dir = 'test_json'\n        os.makedirs(self.test_dir, exist_ok=True)\n        # Create test.js JSON files\n        self.create_test_file('array1.json', [1, 2, 3])\n        self.create_test_file('array2.json', ['a', 'b', 'c'])\n        self.create_test_file('not_array.json', {'key': 'value'})\n        self.create_test_file('empty.json', [])\n        self.create_test_file('non_json.txt', \"This is not a JSON file.\")\n\n    def tearDown(self):\n        # Clean up: Remove created files and directory\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def create_test_file(self, filename, content):\n        # Helper method to create JSON files\n        with open(os.path.join(self.test_dir, filename), 'w') as f:\n            json.dump(content, f)\n\n    def test_concatenate_valid_json_arrays(self):\n        # Test with valid JSON arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertCountEqual(result, [1, 2, 3, 'a', 'b', 'c'])\n\n    def test_ignore_non_array_json(self):\n        # Test that non-array JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn('key', result)\n\n    def test_ignore_non_json_files(self):\n        # Test that non-JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn(\"This is not a JSON file.\", result)\n\n    def test_handle_empty_arrays(self):\n        # Test concatenation includes empty arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn([], result)\n\n    def test_empty_directory(self):\n        # Test with no JSON files in the directory\n        empty_dir = 'empty_test_json'\n        os.makedirs(empty_dir, exist_ok=True)\n        result = concatenate_json_arrays(empty_dir)\n        self.assertEqual(result, [])\n        os.rmdir(empty_dir)\n",
        "prompt": "please write a python function , the function signature as below import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged question\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 28,
    "code_type": "method",
    "original_language": "python",
    "file_path": "WD65C02_FPGA\\174bb2e32be1f70311bbba6a239ed2a2763c7fa4\\ASM\\GameOfLife\\DumpGameBoardMem.py",
    "question_type": "File operations and I/O operation",
    "summary": "Read a section of memory, printing the status of each bit 0 or 1",
    "language_version_list": {
      "python": {
        "code_signature": "def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.\n    For example:\n        input: 0b10101010\n        output: 10101010\n    If have multiple bytes use \\n split\n    For example:\n        input: [0b11001100, 0b11110000]\n        output: 11001100\\n11110000\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\nfrom io import StringIO\nimport sys\n\n\nclass TestPrintMemoryBits(unittest.TestCase):\n\n    def setUp(self):\n        # Capture the output during each test\n        self.held_stdout = StringIO()\n        sys.stdout = self.held_stdout\n\n    def tearDown(self):\n        # Restore the normal stdout\n        sys.stdout = sys.__stdout__\n\n    def test_single_byte(self):\n        memory_section = bytes([0b10101010])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"10101010\"\n        self.assertEqual(output, expected_output)\n\n    def test_multiple_bytes(self):\n        memory_section = bytes([0b11001100, 0b11110000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"11001100\\n11110000\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_zeros(self):\n        memory_section = bytes([0b00000000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"00000000\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_ones(self):\n        memory_section = bytes([0b11111111])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"11111111\"\n        self.assertEqual(output, expected_output)",
        "prompt": "please write a python function , the function signature as below def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.\n    For example:\n        input: 0b10101010\n        output: 10101010\n    If have multiple bytes use \\n split\n    For example:\n        input: [0b11001100, 0b11110000]\n        output: 11001100\\n11110000\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 31,
    "code_type": "method",
    "original_language": "python",
    "file_path": "PicHooven\\2fac49a8fd58d3605f7b099939e54731b1c33ba7\\helper.py",
    "question_type": "Data processing and transformation",
    "summary": "Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestCalculateRedProportion(unittest.TestCase):\n\n    def test_all_red_pixels(self):\n        # All pixels are fully red\n        pixels = [(255, 0, 0), (255, 0, 0), (255, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 1.0)\n\n    def test_no_red_pixels(self):\n        # No red component in any pixel\n        pixels = [(0, 255, 0), (0, 0, 255), (0, 255, 255)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_empty_pixel_list(self):\n        # Empty list of pixels\n        pixels = []\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_all_black_pixels(self):\n        # All pixels are black\n        pixels = [(0, 0, 0), (0, 0, 0), (0, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n",
        "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 33,
    "code_type": "method",
    "original_language": "python",
    "file_path": "experiments\\d8c3e48eb51b21b8e27e8183cbafbde0954a8c13\\mlx\\lora\\lib\\reference_extraction.py",
    "question_type": "Data processing and transformation",
    "summary": "convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and data of the DataFrame\n",
    "language_version_list": {
      "python": {
        "code_signature": "import pandas as pd\n\n\ndef xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and question of the DataFrame\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the question from the XML file.\n    \"\"\"\n",
        "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\nimport xml.etree.ElementTree as ET\n\nclass TestXmlToDataFrame(unittest.TestCase):\n    def test_single_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>John</name>\n                            <age>30</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'John', 'age': '30'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_multiple_sequences(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Alice</name>\n                            <age>25</age>\n                        </sequence>\n                        <sequence>\n                            <name>Bob</name>\n                            <age>22</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Alice', 'age': '25'}, {'name': 'Bob', 'age': '22'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_empty_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence></sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_mixed_content(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Chris</name>\n                        </sequence>\n                        <sequence>\n                            <age>28</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Chris', 'age': None}, {'name': None, 'age': '28'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_no_sequences(self):\n        xml_data = \"\"\"<root></root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame()\n        pd.testing.assert_frame_equal(df, expected)\n",
        "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and question of the DataFrame\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the question from the XML file.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 35,
    "code_type": "method",
    "original_language": "python",
    "file_path": "scratch-code\\33615a13bfd8b8dc301045581e1ac382fdd3b43f\\point_in_shape.py",
    "question_type": "Data processing and transformation",
    "summary": "calculates whether a point lies within a defined polygon with a series of points\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestPointInPolygon(unittest.TestCase):\n    def setUp(self):\n        # Define some polygons to use in tests\n        self.square = [(0, 0), (0, 10), (10, 10), (10, 0)]\n        self.triangle = [(0, 0), (5, 10), (10, 0)]\n        self.concave = [(0, 0), (5, 5), (10, 0), (5, 10), (0, 10)]\n\n    def test_point_inside_square(self):\n        # Point inside the square\n        self.assertTrue(is_point_in_polygon((5, 5), self.square))\n\n    def test_point_outside_square(self):\n        # Point outside the square\n        self.assertFalse(is_point_in_polygon((15, 5), self.square))\n\n    def test_point_on_edge_of_triangle(self):\n        # Point on the edge of the triangle\n        self.assertFalse(is_point_in_polygon((5, 0), self.triangle))\n\n    def test_point_inside_concave_polygon(self):\n        # Point inside concave polygon\n        self.assertTrue(is_point_in_polygon((5, 9), self.concave))\n\n    def test_point_outside_concave_polygon(self):\n        # Point outside concave polygon\n        self.assertFalse(is_point_in_polygon((5, 1), self.concave))",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 36,
    "code_type": "method",
    "original_language": "python",
    "file_path": "algorithms-assignments\\ddc1c94196634e7686062e3f6b86bf0abd2737c9\\floyd_dijkstra.py",
    "question_type": "Algorithm and data structure",
    "summary": "Implementing Floyd's algorithm",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Union\n\ndef floyd_warshall_shortest_paths(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\"",
        "test_code": "import unittest\n\nclass TestFloydWarshallShortestPaths(unittest.TestCase):\n    def test_basic_functionality(self):\n        # Basic test.js case with a simple graph\n        matrix = [\n            [0, 3, float('inf'), 7],\n            [8, 0, 2, float('inf')],\n            [5, float('inf'), 0, 1],\n            [2, float('inf'), float('inf'), 0]\n        ]\n        expected = [\n            [0, 3, 5, 6],\n            [5, 0, 2, 3],\n            [3, 6, 0, 1],\n            [2, 5, 7, 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Basic functionality test.js failed\")\n\n    def test_single_vertex_graph(self):\n        # Test case with a single vertex graph (1x1 matrix)\n        matrix = [\n            [0]\n        ]\n        expected = [\n            [0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Single vertex graph test.js failed\")\n\n    def test_two_vertices_graph(self):\n        # Test case with two vertices\n        matrix = [\n            [0, 1],\n            [1, 0]\n        ]\n        expected = [\n            [0, 1],\n            [1, 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Two vertices graph test.js failed\")\n\n    def test_large_infinite_weights(self):\n        # Test case with infinite weights\n        matrix = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        expected = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Large infinite weights test.js failed\")\n\n    def test_negative_cycle(self):\n        # Test case with a negative cycle\n        matrix = [\n            [0, 1, float('inf')],\n            [float('inf'), 0, -1],\n            [-1, float('inf'), 0]\n        ]\n        expected = [\n            [-1, 0, -1],\n            [-2, -1, -2],\n            [-2, -1, -2]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Negative cycle test.js failed\")\n\n\n",
        "prompt": "please write a python function , the function signature as below from typing import List, Union\n\ndef floyd_warshall_shortest_paths(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 37,
    "code_type": "method",
    "original_language": "python",
    "file_path": "orthojax\\e8f1b733e8d1a64eefe2e443c2d3909b859d2121\\orthojax\\orthpol.py",
    "question_type": "Algorithm and data structure",
    "summary": "Implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x, w):\n        self.x = np.array(x)\n        self.w = np.array(w)\n\n\nclass TestOrthogonalPolynomial(unittest.TestCase):\n    def test_lanczos_basic(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 2\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n\n    def test_lanczos_n_greater_than_length(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 4\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_n_zero(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 0\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_weights_nonuniform(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.1, 0.4, 0.5]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 3\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))\n\n    def test_lanczos_single_node(self):\n        x = [0.5]\n        w = [1.0]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 1\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 41,
    "code_type": "class",
    "original_language": "python",
    "file_path": "imgt_657_examples\\d3cc758de270f8507d772e46a48d8355d2efe799\\bloom_filters\\bloom_filter.py",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword",
    "language_version_list": {
      "python": {
        "code_signature": "class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n",
        "test_code": "import unittest\n\n\nclass TestBloomFilter(unittest.TestCase):\n\n    def setUp(self):\n        # Initialize BloomFilter with reasonable size and hash count for testing\n        self.bf = BloomFilter(1000, 5)\n\n    def test_add_and_check_presence(self):\n        # Test that added elements are reported as present\n        test_item = \"hello world\"\n        self.bf.add(test_item)\n        self.assertIn(test_item, self.bf)\n\n    def test_check_absence(self):\n        # Test that an unadded element is not present\n        self.assertNotIn(\"random item\", self.bf)\n\n    def test_false_positives(self):\n        # Adding some elements and check for a false positive\n        items_to_add = [\"item1\", \"item2\", \"item3\"]\n        for item in items_to_add:\n            self.bf.add(item)\n        # Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        self.assertNotIn(\"item4\", self.bf)\n\n    def test_collision_handling(self):\n        # Test how the Bloom filter handles hash collisions by adding similar items\n        self.bf.add(\"item123\")\n        self.bf.add(\"item124\")\n        self.assertIn(\"item123\", self.bf)\n        self.assertIn(\"item124\", self.bf)\n\n    def test_empty_bloom_filter(self):\n        # Ensure that an empty Bloom Filter reports no items\n        self.assertNotIn(\"anything\", self.bf)",
        "prompt": "please write a python class , the class signature as below class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 42,
    "code_type": "method",
    "original_language": "python",
    "file_path": "UNR\\463fd47f7c3b018dbe930d48fa9b46e92ca48d8b\\Fall-2023\\482-AI\\project-1-section482-682-ChristopherHowe\\naive_bayes_filter.py",
    "question_type": "Program input code",
    "summary": "replace all phones in the string with the string [PHONE_NUM]",
    "language_version_list": {
      "python": {
        "code_signature": "def replace_phone_numbers(text: str):\n    \"\"\"\n    replace all phones(phone formats in many) in the string with the string [PHONE_NUM]\n    For example:\n        input: Call me at 123-456-7890.\n        output: Call me at [PHONE_NUM].\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestReplacePhoneNumbers(unittest.TestCase):\n    def test_basic_number(self):\n        msg = \"Call me at 123-456-7890.\"\n        expected = \"Call me at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n\n    def test_number_with_parentheses(self):\n        msg = \"Our office number is 123 456-7890.\"\n        expected = \"Our office number is [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_number_with_dots(self):\n        msg = \"Fax us at 123.456.7890.\"\n        expected = \"Fax us at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_no_phone_number(self):\n        msg = \"Hello, please reply to this email.\"\n        expected = \"Hello, please reply to this email.\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n",
        "prompt": "please write a python function , the function signature as below def replace_phone_numbers(text: str):\n    \"\"\"\n    replace all phones(phone formats in many) in the string with the string [PHONE_NUM]\n    For example:\n        input: Call me at 123-456-7890.\n        output: Call me at [PHONE_NUM].\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 43,
    "code_type": "method",
    "original_language": "python",
    "file_path": "OpenTPG\\e26269386fc3ee9c8e47749314b3c89a0c5230f9\\transf\\transformCSVtoJSON.py",
    "question_type": "Data processing and transformation",
    "summary": "Convert RGB color to HSV color\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color.\n    For example:\n        input: 0, 0, 255\n        output: 240, 100, 100\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns:\n       Tuple[int, int, int]: HSV value\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestRGBtoHSV(unittest.TestCase):\n\n    def test_rgb_to_hsv_red(self):\n        # Test conversion of pure red color\n        r, g, b = 255, 0, 0\n        expected_result = (0, 100, 100)  # Hue should be 0, Saturation 1, Value 1 for red\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_green(self):\n        # Test conversion of pure green color\n        r, g, b = 0, 255, 0\n        expected_result = (120, 100, 100)  # Hue should be 120, Saturation 1, Value 1 for green\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_blue(self):\n        # Test conversion of pure blue color\n        r, g, b = 0, 0, 255\n        expected_result = (240, 100, 100)  # Hue should be 240, Saturation 1, Value 1 for blue\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_white(self):\n        # Test conversion of white color\n        r, g, b = 255, 255, 255\n        expected_result = (0, 0, 100)  # Hue is undefined, typically 0; Saturation 0, Value 1 for white\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_black(self):\n        # Test conversion of black color\n        r, g, b = 0, 0, 0\n        expected_result = (0, 0, 0)  # Hue is undefined, typically 0; Saturation 0, Value 0 for black\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color.\n    For example:\n        input: 0, 0, 255\n        output: 240, 100, 100\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns:\n       Tuple[int, int, int]: HSV value\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 44,
    "code_type": "method",
    "original_language": "python",
    "file_path": "search-algorithms\\5ac08e08b690884ec300d257a6d417f9697cd020\\utils\\string_side_by_side.py",
    "question_type": "Data processing and transformation",
    "summary": "Align two lines of string to the left, supplementing with Spaces if the length is not enough",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\n\ndef align_lines_left(str1: str, str2: str) -> Tuple[str, str]:\n    \"\"\"\n    Align two lines of string to the left, supplementing with Spaces if the length is not enough\n\n    Args:\n        str1 (str): str1\n        str2 (str): str2\n\n    Returns:\n        Tuple[str,str]: aligned str1 aligned str2\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestAlignLinesLeft(unittest.TestCase):\n\n    def test_equal_length_strings(self):\n        str1 = \"Hello\"\n        str2 = \"World\"\n        expected_str1 = \"Hello\"\n        expected_str2 = \"World\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_first_string_longer(self):\n        str1 = \"Hello, World!\"\n        str2 = \"Hi\"\n        expected_str1 = \"Hello, World!\"\n        expected_str2 = \"Hi           \"  # 14 spaces after \"Hi\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_second_string_longer(self):\n        str1 = \"Hey\"\n        str2 = \"Goodbye, friend!\"\n        expected_str1 = \"Hey             \"  # 15 spaces after \"Hey\"\n        expected_str2 = \"Goodbye, friend!\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_empty_first_string(self):\n        str1 = \"\"\n        str2 = \"World\"\n        expected_str1 = \"     \"  # 5 spaces\n        expected_str2 = \"World\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_empty_second_string(self):\n        str1 = \"Hello\"\n        str2 = \"\"\n        expected_str1 = \"Hello\"\n        expected_str2 = \"     \"  # 5 spaces\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_both_strings_empty(self):\n        str1 = \"\"\n        str2 = \"\"\n        expected_str1 = \"\"\n        expected_str2 = \"\"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)\n\n    def test_strings_with_spaces(self):\n        str1 = \"Hello \"\n        str2 = \"World  \"\n        expected_str1 = \"Hello  \"\n        expected_str2 = \"World  \"\n        aligned_str1, aligned_str2 = align_lines_left(str1, str2)\n        self.assertEqual(aligned_str1, expected_str1)\n        self.assertEqual(aligned_str2, expected_str2)",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef align_lines_left(str1: str, str2: str) -> Tuple[str, str]:\n    \"\"\"\n    Align two lines of string to the left, supplementing with Spaces if the length is not enough\n\n    Args:\n        str1 (str): str1\n        str2 (str): str2\n\n    Returns:\n        Tuple[str,str]: aligned str1 aligned str2\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 45,
    "code_type": "method",
    "original_language": "python",
    "file_path": "libcolab\\aa179d3014b5e00b3a6d9eff415241c698d812f1\\review_calendar\\today.py",
    "question_type": "Data processing and transformation",
    "summary": "Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }",
    "language_version_list": {
      "python": {
        "code_signature": "import datetime\n\n\ndef get_current_date_info(test_date: datetime.date) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n",
        "test_code": "import unittest\nimport datetime\n\n\nclass TestGetCurrentDateInfo(unittest.TestCase):\n\n    def test_beginning_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 1))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 1,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_middle_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 15))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 3,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_leap_year(self):\n        result = get_current_date_info(datetime.date(2024, 2, 29))\n        expected = {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_change_of_year(self):\n        result = get_current_date_info(datetime.date(2022, 12, 31))\n        expected = {\n            'year': 2022,\n            'month': 'December',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Saturday'\n        }\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below import datetime\n\n\ndef get_current_date_info(test_date: datetime.date) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 46,
    "code_type": "class",
    "original_language": "python",
    "file_path": "python_fiddle\\c54e8adb893ff70d825892aa6715cadb0ad27d73\\psdsa\\chatgpt\\binary_tree.py",
    "question_type": "Algorithm and data structure",
    "summary": "Create a binary tree class, and implement its preorder traversal, inorder traversal, postorder traversal",
    "language_version_list": {
      "python": {
        "code_signature": "class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n",
        "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Setup basic tree structure for testing.\"\"\"\n        # Tree structure:\n        #      1\n        #     / \\\n        #    2   3\n        #   / \\\n        #  4   5\n        self.tree = BinaryTree(TreeNode(1))\n        self.tree.root.left = TreeNode(2, TreeNode(4), TreeNode(5))\n        self.tree.root.right = TreeNode(3)\n\n    def test_preorder_traversal(self):\n        \"\"\"Test preorder traversal.\"\"\"\n        result = self.tree.preorder_traversal(self.tree.root)\n        self.assertEqual(result, [1, 2, 4, 5, 3])\n\n    def test_inorder_traversal(self):\n        \"\"\"Test inorder traversal.\"\"\"\n        result = self.tree.inorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 2, 5, 1, 3])\n\n    def test_postorder_traversal(self):\n        \"\"\"Test postorder traversal.\"\"\"\n        result = self.tree.postorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 5, 2, 3, 1])\n\n    def test_empty_tree(self):\n        \"\"\"Test traversals on an empty tree.\"\"\"\n        empty_tree = BinaryTree()\n        self.assertEqual(empty_tree.preorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.inorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.postorder_traversal(empty_tree.root), [])\n\n    def test_single_node_tree(self):\n        \"\"\"Test all traversals on a tree with only one node.\"\"\"\n        single_node_tree = BinaryTree(TreeNode(10))\n        self.assertEqual(single_node_tree.preorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.inorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.postorder_traversal(single_node_tree.root), [10])\n",
        "prompt": "please write a python class , the class signature as below class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 47,
    "code_type": "method",
    "original_language": "python",
    "file_path": "libcolab\\aa179d3014b5e00b3a6d9eff415241c698d812f1\\review_calendar\\weekday.py",
    "question_type": "Data processing and transformation",
    "summary": "calculate the nth occurrence of a specific working day (k) in a given month (m) and year (y).\nIf there is no nth date in the month, the last date of the month is returned",
    "language_version_list": {
      "python": {
        "code_signature": "import datetime\n\n\ndef find_nth_weekday_of_specific_year(y: int, m: int, n: int, k: int) -> datetime.date:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n",
        "test_code": "import unittest\nimport datetime\n\n\nclass TestFindNthWeekdayOfSpecificYear(unittest.TestCase):\n\n    def test_regular_occurrence(self):\n        # Test for the 2nd Monday of May 2023\n        result = find_nth_weekday_of_specific_year(2023, 5, 2, 0)  # Monday is 0\n        expected = datetime.date(2023, 5, 8)\n        self.assertEqual(result, expected)\n\n    def test_last_occurrence(self):\n        # Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        result = find_nth_weekday_of_specific_year(2023, 5, 5, 0)  # Monday is 0\n        expected = datetime.date(2023, 5, 29)\n        self.assertEqual(result, expected)\n\n    def test_first_day_is_weekday(self):\n        # Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        result = find_nth_weekday_of_specific_year(2023, 8, 1, 1)  # Tuesday is 1\n        expected = datetime.date(2023, 8, 1)\n        self.assertEqual(result, expected)\n\n    def test_edge_year_transition(self):\n        # Test for the 1st Friday of December 2023\n        result = find_nth_weekday_of_specific_year(2023, 12, 1, 4)  # Friday is 4\n        expected = datetime.date(2023, 12, 1)\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below import datetime\n\n\ndef find_nth_weekday_of_specific_year(y: int, m: int, n: int, k: int) -> datetime.date:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 51,
    "code_type": "method",
    "original_language": "python",
    "file_path": "facemocap_dataset\\a44395f9c13cda203ef33c10740605ce6980a276\\seqpc.py",
    "question_type": "Data processing and transformation",
    "summary": "convert a point cloud data from the current coordinate system to coordinates in a coordinate system defined by three reference points\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\nimport numpy as np\n\n\ndef change_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (List): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n",
        "test_code": "import unittest\nimport numpy as np\n\nclass TestChangeReferenceFrame(unittest.TestCase):\n    def setUp(self):\n        # Basic setup for tests, initialize some common point clouds and frames\n        self.point_cloud = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.ref_frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([0, 1, 0])]\n\n    def test_identity_transformation(self):\n        # Test with an identity transformation where the reference frame is the standard basis\n        result = change_reference_frame(self.point_cloud, self.ref_frame_points)\n        np.testing.assert_array_almost_equal(result, self.point_cloud - np.array([0, 0, 0]))\n\n    def test_translation(self):\n        # Only translation no rotation; move the origin\n        frame_points = [np.array([1, 1, 1]), np.array([2, 1, 1]), np.array([1, 2, 1])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[-1. , 0.,  1.], [ 2. , 3.,  4.], [ 5.,  6. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_rotation(self):\n        # Rotation about z-axis by 90 degrees\n        frame_points = [np.array([0, 0, 0]), np.array([0, 1, 0]), np.array([0, 1, 1])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[2. , 3.,  1.], [ 5. , 6.,  4.], [ 8.,  9. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_non_orthonormal_frame(self):\n        # Use non-orthonormal frame to see how function handles it (should normalize internally)\n        frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([1, 1, 0])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        # Manually compute expected model_answer_result\n        u = np.array([1, 0, 0])\n        v = np.array([0, 1, 0])\n        w = np.cross(u, v)\n        rotation_matrix = np.column_stack((u, v, w))\n        expected = np.dot(self.point_cloud, rotation_matrix.T)\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_inverted_frame(self):\n        # Inverting the frame to see if negatives are handled\n        frame_points = [np.array([0, 0, 0]), np.array([-1, 0, 0]), np.array([0, -1, 0])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.dot(self.point_cloud, np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]))\n        np.testing.assert_array_almost_equal(result, expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\nimport numpy as np\n\n\ndef change_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (List): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 52,
    "code_type": "method",
    "original_language": "python",
    "file_path": "scratchScripts\\f2e7f54c168e69f9c48c0935baf5ce28f277e8d0\\renameFiles.py",
    "question_type": "File operations and I/O operation",
    "summary": "rename the windows file path string, replacing the colon: in the file name with the \"_\"",
    "language_version_list": {
      "python": {
        "code_signature": "def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestRenameFilePath(unittest.TestCase):\n    def test_rename_with_colon_in_filename(self):\n        # Test path with colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_without_colon_in_filename(self):\n        # Test path without colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_multiple_colons_in_filename(self):\n        # Test path with multiple colons in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_end_of_filename(self):\n        # Test path with a colon at the end of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\backup:'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\backup_'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_start_of_filename(self):\n        # Test path with a colon at the start of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt'\n        self.assertEqual(rename_file_path(path), expected)\n",
        "prompt": "please write a python function , the function signature as below def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 53,
    "code_type": "method",
    "original_language": "python",
    "file_path": "2D-programmable-waveguide\\bb7c6a3a88ba69769323160c1c0b694e6e09ee22\\tdwg\\lib\\misc_utils.py",
    "question_type": "Data processing and transformation",
    "summary": "computes and returns the size of an object in bytes in memory\n",
    "language_version_list": {
      "python": {
        "code_signature": "def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): question object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n",
        "test_code": "import unittest\nimport sys\n\nclass TestSizeInBytes(unittest.TestCase):\n\n    def test_size_of_integer(self):\n        # Test the size of an integer\n        integer_value = 42\n        expected_size = sys.getsizeof(integer_value)\n        result_size = size_in_bytes(integer_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_string(self):\n        # Test the size of a string\n        string_value = \"Hello, world!\"\n        expected_size = sys.getsizeof(string_value)\n        result_size = size_in_bytes(string_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_list(self):\n        # Test the size of a list\n        list_value = [1, 2, 3, 4, 5]\n        expected_size = sys.getsizeof(list_value)\n        result_size = size_in_bytes(list_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_dictionary(self):\n        # Test the size of a dictionary\n        dict_value = {'key1': 'value1', 'key2': 'value2'}\n        expected_size = sys.getsizeof(dict_value)\n        result_size = size_in_bytes(dict_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_custom_object(self):\n        # Test the size of a custom object\n        class CustomObject:\n            def __init__(self):\n                self.attr1 = 'a'\n                self.attr2 = 123\n        custom_obj = CustomObject()\n        expected_size = sys.getsizeof(custom_obj)  # Note: Does not include size of attributes unless explicitly calculated\n        result_size = size_in_bytes(custom_obj)\n        self.assertEqual(result_size, expected_size)",
        "prompt": "please write a python function , the function signature as below def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): question object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 54,
    "code_type": "method",
    "original_language": "python",
    "file_path": "chatgpt-scripts\\27413237472c6b1228294fed76b3cc46d66bec41\\stratechery-translator\\translator.py",
    "question_type": "Data processing and transformation",
    "summary": "process a list of strings, removing the three consecutive backticks from each string",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestRemoveTripleBackticks(unittest.TestCase):\n\n    def test_remove_triple_backticks_basic(self):\n        # Test basic functionality\n        input_strings = ['Here is ```code``` example', 'Another ```example``` here', 'No backticks here']\n        expected_output = ['Here is code example', 'Another example here', 'No backticks here']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_strings_with_multiple_instances(self):\n        # Test strings containing multiple instances of triple backticks\n        input_strings = ['Multiple ```backticks``` in ```one``` string']\n        expected_output = ['Multiple backticks in one string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_empty_strings(self):\n        # Test with empty strings\n        input_strings = ['']\n        expected_output = ['']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_no_triple_backticks(self):\n        # Test strings that do not contain triple backticks\n        input_strings = ['Just a normal string', 'Another normal string']\n        expected_output = ['Just a normal string', 'Another normal string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_edge_cases(self):\n        # Test edge cases like strings made entirely of triple backticks\n        input_strings = ['```', '```more```', 'text``````']\n        expected_output = ['', 'more', 'text']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 55,
    "code_type": "method",
    "original_language": "python",
    "file_path": "coding-challenges\\62dcf7e64edd4cfebd2c8167f504b6482ea4ce52\\codility\\mindistinct.py",
    "question_type": "Algorithm and data structure",
    "summary": "You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.Return the minimum number of moves to make every value in nums unique.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array, calculate the minimum number of elements to delete so that the elements in the array are not duplicate.\n    For example:\n        input: [3, 3, 1, 2, 2, 1]\n        output: 3\n\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestMinRemovalsToMakeUnique(unittest.TestCase):\n    def test_basic_array(self):\n        \"\"\"Test with a basic array where multiple removals are needed.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([3, 3, 1, 2, 2, 1]), 3)\n\n    def test_all_identical(self):\n        \"\"\"Test an array where all elements are identical.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([4, 4, 4, 4]), 3)\n\n    def test_all_unique(self):\n        \"\"\"Test an array where all elements are already unique.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 3, 4]), 0)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([]), 0)\n\n    def test_complex_case(self):\n        \"\"\"Test a more complex case with a larger array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]), 6)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array, calculate the minimum number of elements to delete so that the elements in the array are not duplicate.\n    For example:\n        input: [3, 3, 1, 2, 2, 1]\n        output: 3\n\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 56,
    "code_type": "method",
    "original_language": "python",
    "file_path": "SoraTranslator\\afbf178ff30c1120d59bc2025e7a38e8b78127cd\\backend\\Integrators\\utils\\encoding_fix.py",
    "question_type": "Data processing and transformation",
    "summary": "find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFindShiftJISNotGBK(unittest.TestCase):\n\n    def setUp(self):\n        # Pre-calculate the list once since it's computationally expensive\n        self.shiftjis_not_gbk = find_shiftjis_not_gbk()\n\n    def test_known_shiftjis_character_not_in_gbk(self):\n        # Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        known_shiftjis_only = '\u30f1'  # An example character, ensure this is correct as per your encodings\n        self.assertNotIn(known_shiftjis_only, self.shiftjis_not_gbk)\n\n    def test_character_in_both_encodings(self):\n        # Test characters known to be in both encodings\n        common_character = '\u6c34'  # Common in both, ensure accuracy\n        self.assertNotIn(common_character, self.shiftjis_not_gbk)\n\n    def test_character_in_neither_encoding(self):\n        # Character not typically found in either encoding\n        neither_encoding_char = '\\U0001F4A9'  # Emoji, not in basic Shift-JIS or GBK\n        self.assertNotIn(neither_encoding_char, self.shiftjis_not_gbk)\n\n    def test_bounds_of_bmp(self):\n        # Characters at the edge of the BMP should be checked\n        edge_of_bmp = '\\uffff'  # Last character in BMP\n        # Since this test.js is situational, we check based on the known state; may not be necessary\n        if edge_of_bmp in self.shiftjis_not_gbk:\n            self.assertIn(edge_of_bmp, self.shiftjis_not_gbk)\n        else:\n            self.assertNotIn(edge_of_bmp, self.shiftjis_not_gbk)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 57,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Q-Tube\\7ad3d430b5eb2ef575c0c544abf1be3d89e07a47\\source\\png_to_icon.py",
    "question_type": "Machine learning and deep learning",
    "summary": "convert png images to ico files\n",
    "language_version_list": {
      "python": {
        "code_signature": "def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestConvertPngToIco(unittest.TestCase):\n    @patch('PIL.Image.open')\n    def test_single_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_multiple_icon_sizes(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(16, 16), (32, 32), (64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(16, 16), (32, 32), (64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_default_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico')\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_file_handling(self, mock_open):\n        mock_image = MagicMock()\n        mock_open.return_value.__enter__.return_value = mock_image\n        convert_png_to_ico('source.png', 'output.ico')\n        # Check if save was called correctly\n        mock_image.save.assert_called_once_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_invalid_image_path(self, mock_open):\n        mock_open.side_effect = FileNotFoundError\n        with self.assertRaises(FileNotFoundError):\n            convert_png_to_ico('invalid.png', 'output.ico')\n",
        "prompt": "please write a python function , the function signature as below def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 58,
    "code_type": "method",
    "original_language": "python",
    "file_path": "python\\1af5d04c65ec5e38496d989b97e7c5833140a04d\\chooseNfromM.py",
    "question_type": "Data processing and transformation",
    "summary": "Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls",
    "language_version_list": {
      "python": {
        "code_signature": "def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom math import isclose\n\n\nclass TestProbabilityOfRedBalls(unittest.TestCase):\n\n    def test_half_red_balls(self):\n        # Scenario where half of the drawn balls are expected to be red\n        result = probability_of_red_balls(7, 10, 10)\n        expected_result = probability_of_red_balls(7, 10, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with half red balls failed\")\n\n    def test_some_red_balls(self):\n        # Scenario with some red balls in the jar, expecting a few red draws\n        result = probability_of_red_balls(5, 5, 10)\n        expected_result = probability_of_red_balls(5, 5, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with some red balls failed\")\n\n    def test_extreme_case(self):\n        # Extreme scenario where the probability is low for the chosen n\n        result = probability_of_red_balls(15, 1, 99)\n        expected_result = probability_of_red_balls(15, 1, 99)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with extreme case failed\")",
        "prompt": "please write a python function , the function signature as below def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 59,
    "code_type": "method",
    "original_language": "python",
    "file_path": "python\\1af5d04c65ec5e38496d989b97e7c5833140a04d\\chooseNfromM.py",
    "question_type": "Data processing and transformation",
    "summary": "calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n",
    "language_version_list": {
      "python": {
        "code_signature": "def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom math import comb\n\n\nclass TestProbabilityRedBalls(unittest.TestCase):\n    def test_all_red(self):\n        # Case where all balls are red\n        self.assertEqual(probability_red_balls(5, 5, 0), 1)\n\n    def test_no_red(self):\n        # Case where no red balls are available\n        self.assertEqual(probability_red_balls(1, 0, 5), 0)\n\n    def test_typical_case(self):\n        # Typical scenario\n        self.assertAlmostEqual(probability_red_balls(2, 10, 5), comb(10, 2) / comb(15, 2))\n\n    def test_impossible_case(self):\n        # More balls requested than available\n        self.assertEqual(probability_red_balls(6, 5, 4), 0)\n\n    def test_high_combinations(self):\n        # Test with higher number of combinations\n        self.assertAlmostEqual(probability_red_balls(3, 20, 30), comb(20, 3) / comb(50, 3))",
        "prompt": "please write a python function , the function signature as below def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 60,
    "code_type": "method",
    "original_language": "python",
    "file_path": "MTIProteinImputation\\cfadc49f01213a64443afa14da99c228a1ad8473\\src\\en\\in_patient\\common_df_cols.py",
    "question_type": "Data processing and transformation",
    "summary": "find the common columns of all csv files in a directory and return these column names as a list\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef find_common_columns(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n",
        "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestCommonColumns(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory\n        self.test_dir = \"test_dir\"\n        os.makedirs(self.test_dir, exist_ok=True)\n\n    def tearDown(self):\n        # Remove created files and directory after each test.js\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def test_all_same_columns(self):\n        # All CSV files have the same columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"A,B,C\\n4,5,6\"\n        data3 = \"A,B,C\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(find_common_columns(self.test_dir)), set(['C', 'B', 'A']))\n\n    def test_no_common_columns(self):\n        # No common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"D,E,F\\n4,5,6\"\n        data3 = \"G,H,I\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(find_common_columns(self.test_dir), [])\n\n    def test_some_common_columns(self):\n        # Some common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"C,D,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(find_common_columns(self.test_dir), ['C'])\n\n    def test_mixed_common_and_unique_columns(self):\n        # Mixed common and unique columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"B,C,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(find_common_columns(self.test_dir)), set(['B', 'C']))\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_common_columns(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 62,
    "code_type": "class",
    "original_language": "python",
    "file_path": "cse-20312-sp24-examples\\310603a99881acc9924cb3b3a7b33e0f198a8e1b\\lecture39\\bst_chatgpt.py",
    "question_type": "Algorithm and data structure",
    "summary": "implement the tree in the data structure and implement its three traversal methods\n",
    "language_version_list": {
      "python": {
        "code_signature": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the question structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n",
        "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n\n    def test_empty_tree(self):\n        bt = BinaryTree()\n        self.assertEqual(bt.inorder_traversal(), [])\n        self.assertEqual(bt.preorder_traversal(), [])\n        self.assertEqual(bt.postorder_traversal(), [])\n\n    def test_single_node_tree(self):\n        bt = BinaryTree()\n        bt.insert(10)\n        self.assertEqual(bt.inorder_traversal(), [10])\n        self.assertEqual(bt.preorder_traversal(), [10])\n        self.assertEqual(bt.postorder_traversal(), [10])\n\n    def test_balanced_tree(self):\n        bt = BinaryTree()\n        elements = [8, 3, 10, 1, 6, 9, 14]\n        for elem in elements:\n            bt.insert(elem)\n        self.assertEqual(bt.inorder_traversal(), [1, 3, 6, 8, 9, 10, 14])\n        self.assertEqual(bt.preorder_traversal(), [8, 3, 1, 6, 10, 9, 14])\n        self.assertEqual(bt.postorder_traversal(), [1, 6, 3, 9, 14, 10, 8])\n\n    def test_left_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(10, 0, -1):  # Inserts 10, 9, ..., 1\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [10-i for i in range(10)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(1, 11)])\n\n    def test_right_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(1, 11):  # Inserts 1, 2, ..., 10\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(10, 0, -1)])",
        "prompt": "please write a python class , the class signature as below class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the question structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 63,
    "code_type": "method",
    "original_language": "python",
    "file_path": "joplen_mlsp2024\\695bde3ec29a7f395715bbad1537c07fe622020f\\joplen\\src\\JOPLEn\\custom_trees.py",
    "question_type": "Algorithm and data structure",
    "summary": "convert a DataFrame object to a table in markdown format",
    "language_version_list": {
      "python": {
        "code_signature": "import pandas as pd\n\n\ndef dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    For example:\n        input: dataframe {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        output: | Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\n\n    Args:\n        df (DataFrame): DataFrame type question\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n",
        "test_code": "import unittest\n=import pandas as pd\n\n\nclass TestDataframeToMarkdown(unittest.TestCase):\n    def setUp(self):\n        # Create a sample DataFrame\n        self.data = {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        self.df = pd.DataFrame(self.data)\n\n    def test_df_to_str(self):\n        # Test that the function writes the correct markdown to a file\n        expected_markdown = \"| Name   |   Age |\\n|:-------|------:|\\n| Alice  |    25 |\\n| Bob    |    30 |\"\n        result = dataframe_to_markdown(self.df, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_empty_dataframe(self):\n        # Test how the function handles an empty DataFrame\n        df_empty = pd.DataFrame()\n        expected_markdown = \"\"\n        result = dataframe_to_markdown(df_empty, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_single_row_dataframe(self):\n        # Test with a DataFrame that contains only one row\n        df_single_row = pd.DataFrame({'Name': ['Alice'], 'Age': [30]})\n        expected_markdown = \"| Name   |   Age |\\n|:-------|------:|\\n| Alice  |    30 |\"\n        result = dataframe_to_markdown(df_single_row, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_non_string_columns(self):\n        # Test with non-string question types in the DataFrame\n        df_non_string = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30], 'Height': [5.5, 6.0]})\n        expected_markdown = ('| Name   |   Age |   Height |\\n'\n                             '|:-------|------:|---------:|\\n'\n                             '| Alice  |    25 |      5.5 |\\n'\n                             '| Bob    |    30 |      6   |')\n        result = dataframe_to_markdown(df_non_string, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_special_characters(self):\n        # Test handling of special characters in DataFrame\n        df_special_chars = pd.DataFrame(\n            {'Name': ['Alice', 'Bob'], 'Comments': ['Good@Work!', 'Excellent & Commendable']})\n        expected_markdown = ('| Name   | Comments                |\\n'\n                             '|:-------|:------------------------|\\n'\n                             '| Alice  | Good@Work!              |\\n'\n                             '| Bob    | Excellent & Commendable |')\n        result = dataframe_to_markdown(df_special_chars, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n",
        "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    For example:\n        input: dataframe {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        output: | Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\n\n    Args:\n        df (DataFrame): DataFrame type question\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 64,
    "code_type": "method",
    "original_language": "python",
    "file_path": "TRGB-BikeComputer\\2537af5d089f764d74269c04410485827529af7b\\Tools\\csv2influx.py",
    "question_type": "Data processing and transformation",
    "summary": "Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed",
    "language_version_list": {
      "python": {
        "code_signature": "import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed.\n\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n",
        "test_code": "import unittest\nimport os\n\n\nclass TestCsvToSqlInsert(unittest.TestCase):\n\n    def setUp(self):\n        # Create sample CSV files for testing\n        self.test_files = {\n            'test1.csv': 'id,name,age\\n1,Alice,30\\n2,Bob,25',\n            'test2.csv': 'product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49',\n            'test3.csv': 'user_id,email\\n3,test@example.com\\n4,user@domain.com',\n            'test4.csv': 'order_id,order_date,total\\n1001,2024-09-01,59.99',\n            'test5.csv': 'quote_id,quote\\n1,\"It\\'s a beautiful day.\"\\n2,\"She said, \"\"Hello!\"\"\"'\n        }\n        # Create the files on disk\n        for filename, content in self.test_files.items():\n            with open(filename, 'w') as f:\n                f.write(content)\n\n    def tearDown(self):\n        # Remove the test files after tests\n        for filename in self.test_files:\n            os.remove(filename)\n\n    def test_simple_csv(self):\n        expected_sql = (\n            \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n            \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n        )\n        result = csv_to_sql_insert('test1.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_product_csv(self):\n        expected_sql = (\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n        )\n        result = csv_to_sql_insert('test2.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_email_csv(self):\n        expected_sql = (\n            \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n            \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n        )\n        result = csv_to_sql_insert('test3.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_date_and_decimal_csv(self):\n        expected_sql = (\n            \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n        )\n        result = csv_to_sql_insert('test4.csv')\n        self.assertEqual(result, expected_sql)",
        "prompt": "please write a python function , the function signature as below import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed.\n\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 65,
    "code_type": "method",
    "original_language": "python",
    "file_path": "infra-config\\6353168dc698d8726ea75570000de7fe1f56674c\\ci\\ip_address_duplicates.py",
    "question_type": "File operations and I/O operation",
    "summary": "Find duplicate IPs in the given IP list and exclude IPs specified to ignore\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef find_duplicate_ips(ip_list: List[str], ignore_list: List[str]) -> List[str]:\n    \"\"\"\n    Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n\n    Args:\n        ip_list (List[str]): List of IP addresses\n        ignore_list (List[str]): List of IP addresses to ignor\n\n    Returns:\n        List[str]: A list of duplicate IPs excluding those in the ignore list.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFindDuplicateIPs(unittest.TestCase):\n\n    def test_basic_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.1\"]\n        ignore_list = []\n        self.assertEqual(find_duplicate_ips(ip_list, ignore_list), [\"192.168.1.1\"])\n\n    def test_ignored_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.2\"]\n        ignore_list = [\"192.168.1.1\"]\n        self.assertEqual(find_duplicate_ips(ip_list, ignore_list), [])\n\n    def test_no_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.2\", \"192.168.1.3\"]\n        ignore_list = []\n        self.assertEqual(find_duplicate_ips(ip_list, ignore_list), [])\n\n    def test_mixed_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"10.0.0.1\", \"192.168.1.2\"]\n        ignore_list = [\"192.168.1.2\"]\n        self.assertEqual(find_duplicate_ips(ip_list, ignore_list), [\"192.168.1.1\"])\n\n    def test_empty_input(self):\n        ip_list = []\n        ignore_list = []\n        self.assertEqual(find_duplicate_ips(ip_list, ignore_list), [])\n\n    def test_only_ignored_ips(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\"]\n        ignore_list = [\"192.168.1.1\"]\n        self.assertEqual(find_duplicate_ips(ip_list, ignore_list), [])\n\n    def test_all_duplicates(self):\n        ip_list = [\"192.168.1.1\", \"192.168.1.1\", \"192.168.1.1\"]\n        ignore_list = []\n        self.assertEqual(find_duplicate_ips(ip_list, ignore_list), [\"192.168.1.1\"])",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_duplicate_ips(ip_list: List[str], ignore_list: List[str]) -> List[str]:\n    \"\"\"\n    Find duplicate IPs in the given IP list excluding specified IPs to ignore.\n\n    Args:\n        ip_list (List[str]): List of IP addresses\n        ignore_list (List[str]): List of IP addresses to ignor\n\n    Returns:\n        List[str]: A list of duplicate IPs excluding those in the ignore list.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 67,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ebusd-brink-hru\\534e9f7ea8524be980cb4b174dedc06a7bf6966b\\src\\parse_xaml.py",
    "question_type": "Data processing and transformation",
    "summary": "parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the model_answer_result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n",
        "test_code": "import unittest\nimport xml.etree.ElementTree as ET\nfrom io import StringIO\n\n\nclass TestParseXamlToDict(unittest.TestCase):\n    def test_valid_strings(self):\n        xaml_data = \"\"\"<root>\n                         <String Key=\"Username\">Alice</String>\n                         <String Key=\"Password\">secret</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Alice', 'Password': 'secret'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_missing_key_attribute(self):\n        xaml_data = \"\"\"<root>\n                         <String>Alice</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n\n    def test_no_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Data>Some question</Data>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_nested_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Container>\n                           <String Key=\"Username\">Bob</String>\n                         </Container>\n                         <String Key=\"Location\">Earth</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Bob', 'Location': 'Earth'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the model_answer_result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 68,
    "code_type": "method",
    "original_language": "python",
    "file_path": "CFK_Delete_Python\\db808d2f6992ab79a6795a41f864fcee8e07760c\\my_multiprocessing.py",
    "question_type": "Data processing and transformation",
    "summary": "divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef divide_list(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestDivideList(unittest.TestCase):\n    def test_even_division(self):\n        lst = [1, 2, 3, 4, 5, 6]\n        n = 3\n        expected = [[1, 2], [3, 4], [5, 6]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_uneven_division(self):\n        lst = [1, 2, 3, 4, 5, 6, 7]\n        n = 3\n        expected = [[1, 2, 3], [4, 5], [6, 7]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_more_parts_than_items(self):\n        lst = [1, 2, 3]\n        n = 5\n        expected = [[1], [2], [3], [], []]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_single_element(self):\n        lst = [1]\n        n = 1\n        expected = [[1]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_empty_list(self):\n        lst = []\n        n = 3\n        expected = [[], [], []]\n        self.assertEqual(divide_list(lst, n), expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef divide_list(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 70,
    "code_type": "method",
    "original_language": "python",
    "file_path": "SystemGPT\\222807b913f65574fff12f0ffd803a8e20952214\\sysGPT.py",
    "question_type": "Data processing and transformation",
    "summary": "extracts the contents of the code block from the given Markdown string\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestCodeBlockRemover(unittest.TestCase):\n\n    def test_single_code_block(self):\n        markdown = \"\"\"\n        This is a markdown with a code block.\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['print(\"Hello, World!\")']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_multiple_code_blocks(self):\n        markdown = \"\"\"\n        First code block:\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        Second code block:\n\n        ```javascript\n        console.log(\"Hello, World!\");\n        ```\n        \"\"\"\n        expected = [\n            'print(\"Hello, World!\")',\n            'console.log(\"Hello, World!\");'\n        ]\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_no_code_block(self):\n        markdown = \"\"\"\n        This markdown has no code blocks.\n\n        Just some plain text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_empty_code_block(self):\n        markdown = \"\"\"\n        Here is an empty code block:\n\n        ```python\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_malformed_code_block(self):\n        markdown = \"\"\"\n        This code block is missing ending:\n\n        ```python\n        print(\"Hello, World!\")\n\n        And some more text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 71,
    "code_type": "method",
    "original_language": "python",
    "file_path": "BAD\\8f17432451f1cd9bef90581ed6cd4ce4df0c1a54\\BAD\\mag_reader.py",
    "question_type": "Data processing and transformation",
    "summary": "Reads numerical columns from a file starting from the line after the last line containing '/'.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef read_columns(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n",
        "test_code": "import unittest\nimport numpy as np\nimport os\n\n\ndef read_columns(file_name):\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n    # Initialize a variable to track the last slash line index\n    last_slash_index = None\n\n    with open(file_name) as f:\n        lines = f.readlines()\n\n    # Find the index of the last line that contains the \"/\" character\n    for i, line in enumerate(lines):\n        if \"/\" in line:\n            last_slash_index = i\n\n    # If no \"/\" character was found, raise an error\n    if last_slash_index is None:\n        raise ValueError(\"File does not contain '/' character\")\n\n    # Read the remaining lines in the file, starting from the line after the last \"/\"\n    data_lines = lines[last_slash_index + 1:]\n\n    # Remove any empty lines or lines that start with a comment character\n    data_lines = [line.strip() for line in data_lines if line.strip() and not line.strip().startswith('!')]\n\n    # If no valid lines remain, return an empty array\n    if not data_lines:\n        return np.array([])\n\n    # Get the row and column count by counting the number of columns in the first line\n    col_count = len(data_lines[0].split())\n\n    # Create an empty numpy array of the required size\n    arr = np.zeros((len(data_lines), col_count))\n\n    # Loop through the lines in the file\n    for i, line in enumerate(data_lines):\n        # Split the line into numbers and convert them to floats\n        nums = [float(x) for x in line.split()]\n        # Store the numbers in the array\n        arr[i, :] = nums\n\n    # Return the array\n    return arr\n\n\nclass TestReadColumns(unittest.TestCase):\n\n    def setUp(self):\n        # Setup a temporary directory to use for each test\n        self.test_file = 'test_file.txt'\n\n    def tearDown(self):\n        # Clean up the temporary file after each test\n        if os.path.exists(self.test_file):\n            os.remove(self.test_file)\n\n    def test_basic_functionality(self):\n        # Test reading a file with a valid structure and numerical question\n        content = \"\"\"Line 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_columns(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_no_slash_character(self):\n        # Test that a ValueError is raised if no '/' character is found\n        content = \"\"\"Line 1\nLine 2\nLine 3\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n\n    def test_file_with_comments_and_empty_lines(self):\n        # Test handling of comments and empty lines\n        content = \"\"\"Line 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_columns(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_different_number_of_columns(self):\n        # Test that the function handles different number of columns correctly\n        content = \"\"\"Line 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n\n    def test_empty_file(self):\n        # Test handling of an empty file\n        content = \"\"\"\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef read_columns(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 72,
    "code_type": "method",
    "original_language": "python",
    "file_path": "motlee\\fb09c97977edf1be0118ad9bb8a7fd96dce6cad5\\motlee\\utils\\cam_utils.py",
    "question_type": "Data processing and transformation",
    "summary": "    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef get_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n    Args:\n        K ((3,3) np.array): camera intrinsic matrix\n        d (float): depth (distance along z-axis)\n        x (float): pixel x coordinate\n        y (float): pixel y coordinate\n\n    Returns:\n        np.array: x, y, z 3D point coordinates in camera RDF coordinates\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestGet3DCoordinates(unittest.TestCase):\n    def setUp(self):\n        # Define a common intrinsic matrix for testing\n        self.K = np.array([[1000, 0, 320],\n                           [0, 1000, 240],\n                           [0, 0, 1]])\n\n    def test_center_coordinates(self):\n        \"\"\" Test with center pixel coordinates where x and y should map to zero in NDC. \"\"\"\n        result = get_3d_coordinates(self.K, 100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 100]))\n\n    def test_boundary_coordinates(self):\n        \"\"\" Test with boundary values in the image frame. \"\"\"\n        result = get_3d_coordinates(self.K, 50, 640, 480)\n        expected_x = (640 - 320) / 1000 * 50\n        expected_y = (480 - 240) / 1000 * 50\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 50]))\n\n    def test_negative_depth(self):\n        \"\"\" Test with a negative depth to see if it handles incorrect input properly. \"\"\"\n        result = get_3d_coordinates(self.K, -100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, -100]))\n\n    def test_zero_depth(self):\n        \"\"\" Test with zero depth which should lead to a zero-length vector. \"\"\"\n        result = get_3d_coordinates(self.K, 0, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 0.0]))\n\n    def test_non_integer_values(self):\n        \"\"\" Test with non-integer pixel coordinates. \"\"\"\n        result = get_3d_coordinates(self.K, 100, 320.5, 240.5)\n        expected_x = (320.5 - 320) / 1000 * 100\n        expected_y = (240.5 - 240) / 1000 * 100\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 100]))",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n    Args:\n        K ((3,3) np.array): camera intrinsic matrix\n        d (float): depth (distance along z-axis)\n        x (float): pixel x coordinate\n        y (float): pixel y coordinate\n\n    Returns:\n        np.array: x, y, z 3D point coordinates in camera RDF coordinates\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 73,
    "code_type": "method",
    "original_language": "python",
    "file_path": "gpt_react_repl_w_method_search\\9775bb5fb00d320b91340eb3b2bca3bc83d746af\\src\\react_repl_agent\\apis\\utils.py",
    "question_type": "Data processing and transformation",
    "summary": "convert a dictionary of lists to a list of dictionaries",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestDictOfListsToListOfDicts(unittest.TestCase):\n    def test_standard_conversion(self):\n        \"\"\"Test standard conversion with equal length lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n            \"age\": [25, 30, 35],\n            \"city\": [\"New York\", \"Los Angeles\", \"Chicago\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'},\n            {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'},\n            {'name': 'Charlie', 'age': 35, 'city': 'Chicago'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_empty_lists(self):\n        \"\"\"Test the function with empty lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [],\n            \"age\": [],\n            \"city\": []\n        }\n        expected_result = []\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_lists(self):\n        \"\"\"Test the function with single-element lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\"],\n            \"age\": [25],\n            \"city\": [\"New York\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n",
        "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 74,
    "code_type": "method",
    "original_language": "python",
    "file_path": "unuseful_tools\\8fd726cec63c0d24c9dbd7b1d53fc835b861d39b\\decimal_to_binary\\decimal_to_binary.py",
    "question_type": "Data processing and transformation",
    "summary": "Convert a decimal number to a 32-bit or 64-bit binary representation.",
    "language_version_list": {
      "python": {
        "code_signature": "import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n    For example:\n        input: decimal 3.14 bit 32\n        output: 01000000010010001111010111000011\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestConvertDecimalToBinary(unittest.TestCase):\n    def test_basic_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 32),\n                         '01000000010010001111010111000011',\n                         \"3.14 should be correctly converted to 32-bit binary\")\n\n    def test_basic_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 64),\n                         '0100000000001001000111101011100001010001111010111000010100011111',\n                         \"3.14 should be correctly converted to 64-bit binary\")\n\n    def test_advance_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 32), '00111111110000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n\n    def test_advance_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 64),\n                         '0011111111111000000000000000000000000000000000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n",
        "prompt": "please write a python function , the function signature as below import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n    For example:\n        input: decimal 3.14 bit 32\n        output: 01000000010010001111010111000011\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 75,
    "code_type": "method",
    "original_language": "python",
    "file_path": "early_fonts_inventory\\88fc8faa3af50c2a61705cb122bda5610e16496a\\tools\\renumber.py",
    "question_type": "File operations and I/O operation",
    "summary": " Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.eg image1.png after change to be image1001.png",
    "language_version_list": {
      "python": {
        "code_signature": "def rename_files(directory: str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n    For example:\n        director have three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\"\n        after renaming PNG files are \"image1001.png\", \"image2001.png\", \"image3001.png\"\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"\n",
        "test_code": "import re\nimport unittest\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\n\n\n\nclass TestRenameFiles(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for each test\n        self.test_dir = tempfile.mkdtemp()\n\n    def tearDown(self):\n        # Remove the temporary directory after each test\n        shutil.rmtree(self.test_dir)\n\n    def create_png_files(self, filenames):\n        for filename in filenames:\n            file_path = Path(self.test_dir) / filename\n            file_path.touch()  # Create an empty file\n\n    def test_basic_renaming(self):\n        # Test renaming in a basic scenario with simple filenames\n        filenames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'image3001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_reset_counter_for_different_base_names(self):\n        # Test that the counter resets for different base names\n        filenames = [\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'picture1001.png', 'picture2001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_no_png_files(self):\n        # Test handling of directories with no PNG files\n        filenames = [\"file1.txt\", \"file2.jpg\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = filenames  # No changes expected\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_empty_directory(self):\n        # Test handling of an empty directory\n        rename_files(self.test_dir)\n        expected_files = []  # No files to rename\n        result_files = os.listdir(self.test_dir)\n        self.assertEqual(result_files, expected_files)\n\n    def test_files_with_existing_numbers(self):\n        # Test renaming files that already have numbers in their names\n        filenames = [\"file001.png\", \"file002.png\", \"file003.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['file001001.png', 'file002001.png', 'file003001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)",
        "prompt": "please write a python function , the function signature as below def rename_files(directory: str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n    For example:\n        director have three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\"\n        after renaming PNG files are \"image1001.png\", \"image2001.png\", \"image3001.png\"\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 76,
    "code_type": "method",
    "original_language": "python",
    "file_path": "visual_graph_datasets\\8b98d9d4005ba97e83037b5a5cb4edd989106d91\\visual_graph_datasets\\util.py",
    "question_type": "Data processing and transformation",
    "summary": "Write a function to process a given multi-line string. The function should calculate the minimum indentation of all lines in the string and remove that indentation from each line, eliminating the extra indentation. Make sure that the relative indentation of the string is preserved.",
    "language_version_list": {
      "python": {
        "code_signature": "def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\"",
        "test_code": "import unittest\n\nclass TestRemoveCommonIndentation(unittest.TestCase):\n\n    def test_empty_string(self):\n        # Testing edge case with an empty string\n        self.assertEqual(remove_common_indentation(\"\"), \"\", \"Should return an empty string\")\n\n    def test_single_line_string(self):\n        # Testing a single line with no indentation\n        self.assertEqual(remove_common_indentation(\"No indentation here\"), \"No indentation here\", \"Should return the same string as input\")\n\n    def test_multiple_lines_with_uniform_indentation(self):\n        # Testing basic logic with uniform indentation across multiple lines\n        input_text = \"    Line one\\n    Line two\\n    Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove common leading indentation\")\n\n    def test_multiple_lines_with_mixed_indentation(self):\n        # Testing lines with mixed indentation levels\n        input_text = \"  Line one\\n  Line two\\n  Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove the minimum common indentation\")\n\n",
        "prompt": "please write a python function , the function signature as below def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 77,
    "code_type": "method",
    "original_language": "python",
    "file_path": "web-mit-public\\95604408158ee62d72348ac24b99f0deee119cb0\\add-files-by-date.py",
    "question_type": "File operations and I/O operation",
    "summary": "Formats the given timestamp (mtime) as a string, according to the specified format (the default format is '%a %b %d %I:%M:%S %p %z %Y'), and uses the system's local time zone.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Optional\n\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom typing import Optional\n\nclass TestFormatTimestampToString(unittest.TestCase):\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with a known timestamp.\"\"\"\n        timestamp = 1655364000.0  # Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        # Assuming the local timezone is UTC\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the timestamp\")\n\n    def test_default_format(self):\n        \"\"\"Test using the default format string.\"\"\"\n        timestamp = 1655364000.0\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Default format should match the expected date string\")\n\n    def test_custom_format(self):\n        \"\"\"Test with a custom format string.\"\"\"\n        timestamp = 1655364000.0\n        custom_format = '%Y-%m-%d %H:%M:%S'\n        expected_date_str = '2022-06-16 15:20:00'\n        self.assertEqual(format_timestamp_to_string(timestamp, custom_format), expected_date_str, \"Should correctly format the timestamp using the custom format\")\n\n\n    def test_edge_case_boundary_value(self):\n        \"\"\"Test with an edge case timestamp (e.g., Unix epoch start).\"\"\"\n        timestamp = 0.0  # Unix epoch start\n        expected_date_str = 'Thu Jan 01 08:00:00 AM +0800 1970'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the Unix epoch start time\")",
        "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 78,
    "code_type": "method",
    "original_language": "python",
    "file_path": "CITS5505-group-project\\9037447caf192eee5c5f834c986fbfa12777502a\\app\\models.py",
    "question_type": "Framework and library",
    "summary": "Convert Euler angles (roll, pitch, yaw) to a rotation matrix.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n",
        "test_code": "import unittest\nimport numpy as np\n\nclass TestEulerToRotationMatrix(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Test with zero rotation for all axes\n        R = euler_to_rotation_matrix(0, 0, 0)\n        np.testing.assert_array_almost_equal(R, np.identity(3))\n\n    def test_rotation_about_x(self):\n        # Test rotation about the x-axis\n        R = euler_to_rotation_matrix(90, 0, 0)\n        expected = np.array([\n            [1, 0, 0],\n            [0, 0, -1],\n            [0, 1, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_y(self):\n        # Test rotation about the y-axis\n        R = euler_to_rotation_matrix(0, 90, 0)\n        expected = np.array([\n            [0, 0, 1],\n            [0, 1, 0],\n            [-1, 0, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_z(self):\n        # Test rotation about the z-axis\n        R = euler_to_rotation_matrix(0, 0, 90)\n        expected = np.array([\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_combined_rotation(self):\n        # Test combined rotation\n        R = euler_to_rotation_matrix(30, 45, 60)\n        # Expected model_answer_result manually calculated or verified via a reliable source\n        expected = np.array([[ 0.35355339, -0.5732233,   0.73919892], [ 0.61237244 , 0.73919892,  0.28033009], [-0.70710678 , 0.35355339,  0.61237244]])\n        np.testing.assert_array_almost_equal(R, np.array(expected), decimal=5)",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 79,
    "code_type": "method",
    "original_language": "python",
    "file_path": "FRC-MatchBot\\7e618246256c651fcef7dc303c81ddb4a61e6a4b\\utils.py",
    "question_type": "Data processing and transformation",
    "summary": "Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\"\n",
    "language_version_list": {
      "python": {
        "code_signature": "def date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n\n    For example:\n        input:\n            start_date: 2023-08-01\n            end_date: 2023-08-15\n        output:\n            August 1 to 15, 2023\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestDateRangeString(unittest.TestCase):\n    def test_same_month(self):\n        # Test dates within the same month\n        result = date_range_string(\"2023-08-01\", \"2023-08-15\")\n        self.assertEqual(result, \"August 1 to 15, 2023\")\n\n    def test_same_month_star_end(self):\n        # Test dates within the same month\n        result = date_range_string(\"2023-08-01\", \"2023-08-31\")\n        self.assertEqual(result, \"August 1 to 31, 2023\")\n\n    def test_different_months_same_year(self):\n        # Test dates across different months within the same year\n        result = date_range_string(\"2023-08-30\", \"2023-09-05\")\n        self.assertEqual(result, \"August 30, 2023 to September 5, 2023\")\n\n    def test_different_years(self):\n        # Test dates across different years\n        result = date_range_string(\"2023-12-30\", \"2024-01-02\")\n        self.assertEqual(result, \"December 30, 2023 to January 2, 2024\")\n",
        "prompt": "please write a python function , the function signature as below def date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n\n    For example:\n        input:\n            start_date: 2023-08-01\n            end_date: 2023-08-15\n        output:\n            August 1 to 15, 2023\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 80,
    "code_type": "method",
    "original_language": "python",
    "file_path": "CFK_Delete_Python\\8f5ef0df4ab0a9af0b7ba178919200819eb18801\\CFKdownload_subprocesses.py",
    "question_type": "Data processing and transformation",
    "summary": "remove illegal characters from strings and handle spaces and empty characters to make the modified string comply with windows file name rules\n",
    "language_version_list": {
      "python": {
        "code_signature": "def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from windows file path string\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestSanitizeFilename(unittest.TestCase):\n\n    def test_valid_filename(self):\n        self.assertEqual(sanitize_filename(\"valid_filename.txt\"), \"valid_filename.txt\")\n\n    def test_illegal_characters(self):\n        self.assertEqual(sanitize_filename(\"invalid<filename>.txt\"), \"invalid_filename_.txt\")\n        self.assertEqual(sanitize_filename(\"file/name:with*illegal|chars?.txt\"), \"file_name_with_illegal_chars_.txt\")\n\n\n    def test_long_filename(self):\n        long_filename = \"a\" * 300 + \".txt\"\n        sanitized_filename = sanitize_filename(long_filename)\n        self.assertEqual(len(sanitized_filename), 255)\n        self.assertEqual(sanitized_filename, \"a\" * 255)\n\n    def test_empty_filename(self):\n        self.assertEqual(sanitize_filename(\"\"), \"\")",
        "prompt": "please write a python function , the function signature as below def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from windows file path string\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 81,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Programming\\065b625d489dc21248569f9af98e4c7f8502df7e\\AP-Comp-Codes\\04242023 Data Science\\Lesson 3\\crash.py",
    "question_type": "Algorithm and data structure",
    "summary": "Takes a list of numbers as input and finds the element in it that is closest to a specified target number.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFindClosestElement(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        self.assertEqual(find_closest_element(5, [1, 3, 7, 8, 9]), 3,\n                         \"Should return 3 as it is the first closest element to 5\")\n\n    def test_exact_match(self):\n        self.assertEqual(find_closest_element(7, [1, 3, 7, 8, 9]), 7,\n                         \"Should return 7 as it exactly matches the target\")\n\n    def test_multiple_closest_values(self):\n        self.assertEqual(find_closest_element(5, [4, 6, 8, 9]), 4,\n                         \"Should return 4 as it is the first closest element to 5\")\n\n    def test_float_values(self):\n        self.assertEqual(find_closest_element(5.5, [1.1, 3.3, 7.7, 8.8]), 3.3,\n                         \"Should return 3.3 as it is the first closest element to 5.5\")\n",
        "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 82,
    "code_type": "method",
    "original_language": "python",
    "file_path": "pypatchy\\16897095606bb2884765cc207c550655e5a65b30\\pypatchy\\design\\design_yield.py",
    "question_type": "Algorithm and data structure",
    "summary": "find the unique cycles from the graph, classify them according to cycle size, and return a dictionary, the key of which is the cycle size, and the value is a list of cycles of corresponding size. The function also provides an option to filter out loops that visit the same node multiple times and ensure that each loop contains at least three nodes\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n",
        "test_code": "import unittest\nfrom collections import defaultdict\n\n\nclass TestGraphCycles(unittest.TestCase):\n    def test_empty_graph(self):\n        g = Graph([])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for an empty graph.\")\n\n    def test_graph_no_cycles(self):\n        g = Graph([(1, 2), (2, 3)])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for a graph with no cycles.\")\n\n    def test_simple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertIn(list(results[3][0].nodes()), [[1, 2, 3]], \"Failed: Expected cycle nodes to match.\")\n\n    def test_multiple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertEqual(len(results[4]), 1, \"Failed: Expected one cycle of length 4.\")\n",
        "prompt": "please write a python function , the function signature as below from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 83,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Fragmented\\84aa0d8cfc9af1623cb9edb3d541eac39ec47d10\\renpy-8.1.3-sdk\\Fragmented\\game\\test_combat_281.py",
    "question_type": "Algorithm and data structure",
    "summary": "Shift the list elements right one position in a loop: move the first element of the list to the end, and move the remaining elements forward one position in turn.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestRotateListElements(unittest.TestCase):\n\n    def test_basic_rotation(self):\n        self.assertEqual(rotate_list_elements([1, 2, 3, 4]), [2, 3, 4, 1], \"Should rotate the list elements correctly\")\n\n    def test_single_element_list(self):\n        self.assertEqual(rotate_list_elements([10]), [10], \"Single element list should remain unchanged\")\n\n    def test_empty_list(self):\n        self.assertEqual(rotate_list_elements([]), [], \"Empty list should remain unchanged\")\n\n    def test_two_element_list(self):\n        self.assertEqual(rotate_list_elements([5, 9]), [9, 5], \"Should correctly rotate a two-element list\")\n\n    def test_large_list(self):\n        large_list = list(range(1, 1001))\n        rotated_list = rotate_list_elements(large_list)\n        self.assertEqual(rotated_list, list(range(2, 1001)) + [1], \"Should correctly rotate a large list\")\n\n\n\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 84,
    "code_type": "method",
    "original_language": "python",
    "file_path": "NeetCode\\822d5781a0d703330ae1940fa2a9c8cbc3b3717a\\sliding_window\\minimum_window_substring.py",
    "question_type": "Algorithm and data structure",
    "summary": "Write a function that takes two strings, s and t, and returns the smallest substring in s that contains all the characters in t. If there are multiple such substrings, return any one of them. If no such substring exists, return an empty string.",
    "language_version_list": {
      "python": {
        "code_signature": "from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestFindMinWindowSubstring(unittest.TestCase):\n\n    def test_empty_source_string(self):\n        # Test with an empty source string\n        self.assertEqual(find_min_window_substring(\"\", \"abc\"), \"\", \"Should return an empty string when source is empty\")\n\n    def test_empty_target_string(self):\n        # Test with an empty target string\n        self.assertEqual(find_min_window_substring(\"abc\", \"\"), \"\", \"Should return an empty string when target is empty\")\n\n    def test_no_valid_window(self):\n        # Test when there is no valid window\n        self.assertEqual(find_min_window_substring(\"abcdef\", \"xyz\"), \"\",\n                         \"Should return an empty string when no valid window exists\")\n\n    def test_exact_match_window(self):\n        # Test when the entire source string is the exact match\n        self.assertEqual(find_min_window_substring(\"abcd\", \"abcd\"), \"abcd\",\n                         \"Should return the entire string when it is an exact match\")\n\n    def test_minimal_valid_window(self):\n        # Test with a minimal valid window case\n        self.assertEqual(find_min_window_substring(\"ADOBECODEBANC\", \"ABC\"), \"BANC\",\n                         \"Should return 'BANC' as the smallest window containing all characters of 'ABC'\")\n\n\n",
        "prompt": "please write a python function , the function signature as below from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 85,
    "code_type": "method",
    "original_language": "python",
    "file_path": "dive-map\\a857ae4735b9e1616258de48faa9b8a8d5142109\\mapper.py",
    "question_type": "Data processing and transformation",
    "summary": "Uses the first valid value in the specified column to fill the pandas dataframe with the missing value for that column",
    "language_version_list": {
      "python": {
        "code_signature": "import pandas\nimport pandas as pd\n\n\ndef fill_missing_with_first_valid(df: pandas.DataFrame, column_name: str) -> pd.DataFrame:\n    \"\"\"\n    Fills missing values in the specified column of the DataFrame with the first valid value in that column.\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame.\n        column_name (str): The name of the column to fill missing values.\n\n    Returns:\n        pd.DataFrame: The DataFrame with missing values filled.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport pandas as pd\n\n\nclass TestFillMissingWithFirstValid(unittest.TestCase):\n\n    def test_basic_filling(self):\n        df = pd.DataFrame({'A': [1, None, 3, None], 'B': ['foo', 'bar', None, 'baz']})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, 3, None], 'B': ['foo', 'bar', 'foo', 'baz']})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_no_missing_values(self):\n        df = pd.DataFrame({'A': [1, 2, 3], 'B': ['foo', 'bar', 'baz']})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, 2, 3], 'B': ['foo', 'bar', 'baz']})\n        pd.testing.assert_frame_equal(result, expected)\n\n\n    def test_single_valid_value(self):\n        df = pd.DataFrame({'A': [1, None, None, 4], 'B': [None, 'bar', None, None]})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, None, 4], 'B': ['bar', 'bar', 'bar', 'bar']})\n        pd.testing.assert_frame_equal(result, expected)\n\n    def test_multiple_valid_values(self):\n        df = pd.DataFrame({'A': [1, None, 3, 4], 'B': [None, 'bar', 'foo', None]})\n        result = fill_missing_with_first_valid(df, 'B')\n        expected = pd.DataFrame({'A': [1, None, 3, 4], 'B': ['bar', 'bar', 'foo', 'bar']})\n        pd.testing.assert_frame_equal(result, expected)\n",
        "prompt": "please write a python function , the function signature as below import pandas\nimport pandas as pd\n\n\ndef fill_missing_with_first_valid(df: pandas.DataFrame, column_name: str) -> pd.DataFrame:\n    \"\"\"\n    Fills missing values in the specified column of the DataFrame with the first valid value in that column.\n    Args:\n        df (pandas.DataFrame): The pandas DataFrame.\n        column_name (str): The name of the column to fill missing values.\n\n    Returns:\n        pd.DataFrame: The DataFrame with missing values filled.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 86,
    "code_type": "method",
    "original_language": "python",
    "file_path": "HandwrittenLaTeXRecognition\\7fbbeacae63d438ed81e3f97ebb0fefadc6e4a70\\data_formatting.py",
    "question_type": "Data processing and transformation",
    "summary": "using bresenham, calculate the coordinates of all integer points on the line from point A to point B\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        self.assertEqual(bresenham_line(1, 5, 5, 5), [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5)])\n\n    def test_vertical_line(self):\n        self.assertEqual(bresenham_line(3, 2, 3, 6), [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6)])\n\n    def test_diagonal_line(self):\n        self.assertEqual(bresenham_line(2, 2, 6, 6), [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])\n\n    def test_steep_slope(self):\n        self.assertEqual(bresenham_line(1, 1, 4, 6), [(1, 1), (2, 2), (2, 3), (3, 4), (3, 5), (4, 6)])\n\n    def test_negative_slope(self):\n        self.assertEqual(bresenham_line(5, 1, 1, 5), [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5)])\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 213,
    "code_type": "method",
    "original_language": "python",
    "file_path": "MJ-Bench\\79f4e9ef3cd1b9f97a1f862327ccff728d3001b6\\trl_modified\\examples\\research_projects\\tools\\calculator.py",
    "question_type": "Algorithm and data structure",
    "summary": "Apply the im2col operation to an input image.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\"",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestIm2Col(unittest.TestCase):\n\n    def test_single_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 3, 5, 6, 7, 9, 10, 11],\n            [2, 3, 4, 6, 7, 8, 10, 11, 12],\n            [5, 6, 7, 9, 10, 11, 13, 14, 15],\n            [6, 7, 8, 10, 11, 12, 14, 15, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_single_channel_no_padding_stride_2(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 2\n        padding = 0\n\n        expected_output = np.array([\n            [1, 3, 9, 11],\n            [2, 4, 10, 12],\n            [5, 7, 13, 15],\n            [6, 8, 14, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_multi_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3],\n             [4, 5, 6],\n             [7, 8, 9]],\n            [[9, 8, 7],\n             [6, 5, 4],\n             [3, 2, 1]]\n        ])  # Shape (2, 3, 3), 2 channels\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 4, 5],\n            [2, 3, 5, 6],\n            [4, 5, 7, 8],\n            [5, 6, 8, 9],\n            [9, 8, 6, 5],\n            [8, 7, 5, 4],\n            [6, 5, 3, 2],\n            [5, 4, 2, 1]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 214,
    "code_type": "method",
    "original_language": "python",
    "file_path": "study-tracker-proj\\0ea9f7d5d3582353f546ed98190dd56fa2fc122c\\generate_db.py",
    "question_type": "Data processing and transformation",
    "summary": "Reads data from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n",
        "test_code": "import re\nimport unittest\nfrom unittest.mock import patch, mock_open\n\n\nclass TestReadMappingFile(unittest.TestCase):\n\n    def test_valid_mapping_file(self):\n        # Test with a valid mapping file content\n        mock_file_content = \"'old_pattern1','new_word1'\\n'old_pattern2','new_word2'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            result = read_mapping_file(\"dummy_path.txt\")\n            expected = [\n                (re.compile(\"old_pattern1\"), \"new_word1\"),\n                (re.compile(\"old_pattern2\"), \"new_word2\"),\n            ]\n            self.assertEqual(result, expected)\n\n    def test_missing_file(self):\n        # Test with a missing file\n        with self.assertRaises(FileNotFoundError):\n            read_mapping_file(\"non_existent_file.txt\")\n\n    def test_malformed_line_no_comma(self):\n        # Test with a line that does not contain a comma\n        mock_file_content = \"'old_pattern1' 'new_word1'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            with self.assertRaises(ValueError) as context:\n                read_mapping_file(\"dummy_path.txt\")\n            self.assertEqual(str(context.exception), \"Each line must contain exactly one comma separating the pattern and the replacement.\")\n\n    def test_valid_patterns_with_special_characters(self):\n        # Test with valid patterns that contain special regex characters\n        mock_file_content = \"'\\\\d+', 'number'\\n'\\\\w+', 'word'\\n\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_file_content)):\n            result = read_mapping_file(\"dummy_path.txt\")\n            expected = [\n                (re.compile(r\"\\d+\"), \"number\"),\n                (re.compile(r\"\\w+\"), \"word\"),\n            ]\n            self.assertEqual(result, expected)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 215,
    "code_type": "method",
    "original_language": "python",
    "file_path": "study-tracker-proj\\0ea9f7d5d3582353f546ed98190dd56fa2fc122c\\generate_db.py",
    "question_type": "Data processing and transformation",
    "summary": "Read a text file according to the file path, replace the word according to the dictionary map, and return the replaced text",
    "language_version_list": {
      "python": {
        "code_signature": "def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReplaceWordsInFile(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_single_word(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"hi world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_multiple_words(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\", \"world\": \"earth\"}\n        expected_output = \"hi earth\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_no_replacement(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"goodbye\": \"bye\"}\n        expected_output = \"hello world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"\")\n    def test_empty_file(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n",
        "prompt": "please write a python function , the function signature as below def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 216,
    "code_type": "method",
    "original_language": "python",
    "file_path": "CHATGPT\\16c1ed04ea01e23251f1c2114c7b39ce5eafeb50\\bot\\bot.py",
    "question_type": "Network requests and API call",
    "summary": "gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n",
    "language_version_list": {
      "python": {
        "code_signature": "import re\nimport subprocess\n\n\ndef get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\"",
        "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIp(unittest.TestCase):\n    def setUp(self):\n        # Sample IP command output for a wlan0 interface\n        self.sample_output = \"3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n\" \\\n                             \"    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic wlan0\\n\" \\\n                             \"       valid_lft 86394sec preferred_lft 86394sec\\n\"\n\n    @patch('subprocess.run')\n    def test_successful_ip_retrieval(self, mock_run):\n        # Configure the mock to return a successful output\n        mock_run.return_value = MagicMock(stdout=self.sample_output, check=True)\n        # Test function with wlan0 interface\n        ip = get_local_ip('wlan0')\n        self.assertEqual(ip, '192.168.1.100')\n\n    @patch('subprocess.run')\n    def test_command_failure(self, mock_run):\n        # Simulate a subprocess failure\n        mock_run.side_effect = subprocess.CalledProcessError(1, ['ip', 'addr', 'show', 'wlan0'])\n        self.assertRaises(Exception)\n    @patch('subprocess.run')\n    def test_different_interface(self, mock_run):\n        # Configure the mock for a different interface\n        mock_run.return_value = MagicMock(\n            stdout=\"3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500\\n    inet 10.0.0.1/24\", check=True)\n        ip = get_local_ip('eth0')\n        self.assertEqual(ip, '10.0.0.1')",
        "prompt": "please write a python function , the function signature as below import re\nimport subprocess\n\n\ndef get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 219,
    "code_type": "method",
    "original_language": "python",
    "file_path": "DeepLearningModel-ForImageSegmentation\\50bcf97bc45127a4b1e2da8af6c3deb843e6fb12\\implementation\\use_creator.py",
    "question_type": "Algorithm and data structure",
    "summary": "Check the incoming list of records(eg ('AAPL', '2023-09-01', 0.22),) such as this for the presence of ticker symbols with the same ex-dividend date, but for amounts of different dividend amounts",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n    Args:\n        records (List): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n        List: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestCheckDividendVariances(unittest.TestCase):\n\n    def test_no_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.22),\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_one_inconsistency(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = [('AAPL', '2023-09-01')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_multiple_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('MSFT', '2023-09-01', 0.60),  # Different amount\n            ('GOOG', '2023-09-02', 0.00),\n            ('TSLA', '2023-09-03', 0.10),\n            ('TSLA', '2023-09-03', 0.10),  # Same amount, no inconsistency\n            ('TSLA', '2023-09-03', 0.15)  # Different amount\n        ]\n        expected_output = [('AAPL', '2023-09-01'), ('MSFT', '2023-09-01'), ('TSLA', '2023-09-03')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_single_record(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_empty_list(self):\n        records = []\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n    Args:\n        records (List): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n        List: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 220,
    "code_type": "class",
    "original_language": "python",
    "file_path": "panorama\\9134aec85e06562fcb3095c22353ac560d8e4258\\Deep-EIoU\\Deep-EIoU\\tools\\sport_interpolation.py",
    "question_type": "Algorithm and data structure",
    "summary": "Using double-ended queues and collections to implement a data structure without duplicate data, add, delete and query operations",
    "language_version_list": {
      "python": {
        "code_signature": "from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n\n    def __len__(self):\n        \"\"\"\n        Get the number of elements in the deque.\n\n        Returns:\n        - int: The number of unique elements in the deque.\n        \"\"\"\n\n    def __iter__(self):\n        \"\"\"\n        Create an iterator for the deque.\n\n        Returns:\n        - iterator: An iterator over the elements in the deque.\n        \"\"\"\n",
        "test_code": "import unittest\nfrom collections import deque\n\nclass TestUniqueDeque(unittest.TestCase):\n\n    def test_add_unique_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertTrue(ud.add(2))\n        self.assertTrue(ud.add(3))\n        self.assertEqual(len(ud), 3)\n        self.assertEqual(list(ud), [1, 2, 3])\n\n    def test_add_duplicate_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertFalse(ud.add(1))  # Duplicate add should return False\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [1])\n\n    def test_delete_elements(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        ud.add(3)\n        self.assertTrue(ud.delete(2))\n        self.assertFalse(ud.delete(2))  # Deleting non-existing element should return False\n        self.assertEqual(len(ud), 2)\n        self.assertEqual(list(ud), [1, 3])\n\n    def test_contains(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        self.assertTrue(ud.contains(1))\n        self.assertFalse(ud.contains(2))\n        ud.delete(1)\n        self.assertFalse(ud.contains(1))\n\n    def test_iter_and_len(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        self.assertEqual(len(ud), 2)\n        items = list(iter(ud))\n        self.assertEqual(items, [1, 2])\n        ud.delete(1)\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [2])",
        "prompt": "please write a python class , the class signature as below from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n\n    def __len__(self):\n        \"\"\"\n        Get the number of elements in the deque.\n\n        Returns:\n        - int: The number of unique elements in the deque.\n        \"\"\"\n\n    def __iter__(self):\n        \"\"\"\n        Create an iterator for the deque.\n\n        Returns:\n        - iterator: An iterator over the elements in the deque.\n        \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 221,
    "code_type": "method",
    "original_language": "python",
    "file_path": "guarantees-based-mechanistic-interpretability-with-data\\bc999acd93d093d66fd1b9b1c840a01f71179dd3\\gbmi\\utils\\__init__.py",
    "question_type": "File operations and I/O operation",
    "summary": "extract and parse strings containing Python dictionary syntax from a given file\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractParseDicts(unittest.TestCase):\n    def test_extract_single_valid_dictionary(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}])\n\n    def test_extract_multiple_dictionaries(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}\\n{\"city\": \"New York\", \"country\": \"USA\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}, {\"city\": \"New York\", \"country\": \"USA\"}])\n\n    def test_invalid_dictionary_format(self):\n        mock_content = '{\"name\": \"John\", \"age\": \"thirty\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{'name': 'John', 'age': 'thirty'}])\n\n    def test_empty_file(self):\n        with patch('builtins.open', mock_open(read_data='')):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [])\n\n",
        "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 224,
    "code_type": "method",
    "original_language": "python",
    "file_path": "GenAI_RAG\\ae365a3cc4dcc1bae65dea488e5a857e488c135d\\Create_Embeddings.py",
    "question_type": "File operations and I/O operation",
    "summary": "Empty all files and subdirectories in the specified directory\n",
    "language_version_list": {
      "python": {
        "code_signature": "def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n",
        "test_code": "import os\nimport shutil\nimport tempfile\nimport unittest\n\n\nclass TestEmptyDirectory(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory with some files and directories\n        self.test_dir = tempfile.mkdtemp()\n        # Create some files and directories\n        os.mkdir(os.path.join(self.test_dir, 'subdir'))\n        with open(os.path.join(self.test_dir, 'file1.txt'), 'w') as f:\n            f.write(\"Hello\")\n        with open(os.path.join(self.test_dir, 'subdir', 'file2.txt'), 'w') as f:\n            f.write(\"World\")\n\n    def tearDown(self):\n        # Remove the temporary directory after each test.js\n        shutil.rmtree(self.test_dir)\n\n    def test_empty_directory_success(self):\n        \"\"\" Test that the directory is emptied successfully \"\"\"\n        empty_directory(self.test_dir)\n        self.assertEqual(os.listdir(self.test_dir), [])  # Directory should be empty\n\n\n\n    def test_empty_directory_with_subdirectories(self):\n        \"\"\" Test emptying a directory that includes subdirectories \"\"\"\n        empty_directory(self.test_dir)\n        self.assertFalse(os.listdir(self.test_dir))  # Directory and subdirectory should be empty\n\n    def test_empty_already_empty_directory(self):\n        \"\"\" Test emptying a directory that is already empty \"\"\"\n        empty_directory(self.test_dir)  # First emptying\n        empty_directory(self.test_dir)  # Empty again\n        self.assertEqual(os.listdir(self.test_dir), [])  # Still should be empty\n",
        "prompt": "please write a python function , the function signature as below def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 226,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Final_NLP\\1bc3ddcfc74a5661898ea201ef7d7b6a1f42b9e0\\contrast_sets\\tsv_to_jsonl.py",
    "question_type": "Data processing and transformation",
    "summary": "convert tsv file to jsonl file\n",
    "language_version_list": {
      "python": {
        "code_signature": "import pandas as pd\n\n\ndef tsv_to_jsonl(tsv_file: str, jsonl_file: str):\n    \"\"\"\n    Convert tsv file to jsonl file\n\n    Args:\n        tsv_file: tsf file path\n        jsonl_file: jsonl file path\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestTSVtoJSONL(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for testing\n        self.test_dir = tempfile.TemporaryDirectory()\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n\n    def test_standard_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_standard.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_standard.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Country\":\"Canada\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n\n    def test_single_row_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_single_row.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_single_row.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n    def test_numeric_and_boolean_values(self):\n        tsv_content = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Is_Student\":true}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Is_Student\":false}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n",
        "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef tsv_to_jsonl(tsv_file: str, jsonl_file: str):\n    \"\"\"\n    Convert tsv file to jsonl file\n\n    Args:\n        tsv_file: tsf file path\n        jsonl_file: jsonl file path\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 227,
    "code_type": "method",
    "original_language": "python",
    "file_path": "image_color_distribution\\e4011b1cb8e9c3966bb5eeb675f608a62707ada6\\color_distribution.py",
    "question_type": "Data processing and transformation",
    "summary": "Count how many colors appear in the picture",
    "language_version_list": {
      "python": {
        "code_signature": "def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Args:\n        image_path (str): Path to the image file.\n\n    Returns:\n        int: The number of unique colors in the image.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestCountUniqueColor(unittest.TestCase):\n\n    def test_case1(self):\n        picture_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase01.png\"\n        expected_color_num = 1\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case2(self):\n        picture_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase02.png\"\n        expected_color_num = 2\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case3(self):\n        picture_path =r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase03.png\"\n        expected_color_num = 3\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n    def test_case4(self):\n        picture_path =r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t227\\testcase04.png\"\n        expected_color_num = 466\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)",
        "prompt": "please write a python function , the function signature as below def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Args:\n        image_path (str): Path to the image file.\n\n    Returns:\n        int: The number of unique colors in the image.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 229,
    "code_type": "method",
    "original_language": "python",
    "file_path": "computer-vision-american-sign-language\\f93eebaa293856d64f977f1caf1bc76a12e74f39\\custom_functions\\fileinfo.py",
    "question_type": "File operations and I/O operation",
    "summary": "Convert the file size from byte units to a more readable format (e.g. KB, MB, GB) such as 2120B, convert the bits to 2KB, keeping only the integer parts\n",
    "language_version_list": {
      "python": {
        "code_signature": "def convert_file_size(size_bytes: int) -> str:\n    \"\"\"\n    Converts a file size in bytes to a human-readable format.\n    For example:\n        input: 2120\n        output: 2KB\n    Args:\n        size_bytes (int): The size in bytes to be converted.\n\n    Returns:\n        str: The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n    \"\"\"\n",
        "test_code": "# Unit test class\nimport unittest\n\n\nclass TestFileSizeConverter(unittest.TestCase):\n\n\n    def test_zero_bytes(self):\n        self.assertEqual(convert_file_size(0), \"0B\")\n\n    def test_bytes_less_than_1KB(self):\n        self.assertEqual(convert_file_size(512), \"512B\")\n\n    def test_exactly_1KB(self):\n        self.assertEqual(convert_file_size(1024), \"1KB\")\n\n    def test_2KB(self):\n        self.assertEqual(convert_file_size(2048), \"2KB\")\n\n    def test_exactly_1MB(self):\n        self.assertEqual(convert_file_size(1048576), \"1MB\")\n\n    def test_5MB(self):\n        self.assertEqual(convert_file_size(5242880), \"5MB\")\n\n    def test_exactly_1GB(self):\n        self.assertEqual(convert_file_size(1073741824), \"1GB\")",
        "prompt": "please write a python function , the function signature as below def convert_file_size(size_bytes: int) -> str:\n    \"\"\"\n    Converts a file size in bytes to a human-readable format.\n    For example:\n        input: 2120\n        output: 2KB\n    Args:\n        size_bytes (int): The size in bytes to be converted.\n\n    Returns:\n        str: The converted size in a human-readable format (e.g., \"2KB\", \"1MB\").\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 230,
    "code_type": "method",
    "original_language": "python",
    "file_path": "heavenfire\\c76110867c82e6d45f233cea4b5760822da72aac\\python\\utils.py",
    "question_type": "Data processing and transformation",
    "summary": "move the emoj expression in the string to the end of the text\n",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestMoveEmojisToEnd(unittest.TestCase):\n\n    def test_no_emojis(self):\n        # Case: String with no emojis\n        input_text = \"This is a test.\"\n        expected_output = \"This is a test.\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_all_emojis(self):\n        # Case: String with only emojis\n        input_text = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\"\n        expected_output = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_at_start(self):\n        # Case: Emojis at the start of the text\n        input_text = \"\ud83d\ude00\ud83d\ude03Hello world!\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_at_end(self):\n        # Case: Emojis already at the end of the text\n        input_text = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_in_middle(self):\n        # Case: Emojis in the middle of the text\n        input_text = \"Hello \ud83d\ude00world\ud83d\ude03!\"\n        expected_output = \"Hello world!\ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_mixed_characters(self):\n        # Case: Text with mixed characters and emojis\n        input_text = \"Hi! \ud83d\ude00 How are you? \ud83d\ude03\"\n        expected_output = \"Hi!  How are you? \ud83d\ude00\ud83d\ude03\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 231,
    "code_type": "method",
    "original_language": "python",
    "file_path": "BN-ViT\\b16754870cbe4d4d2701a0a35f28473e0c513f96\\img\\plot.py",
    "question_type": "Data processing and transformation",
    "summary": "Reads a log file where each line is a JSON object containing 'test_acc1' and 'train_loss' values.Parses these lines and collects the values into two lists, one for each metric. ",
    "language_version_list": {
      "python": {
        "code_signature": "def read_log(log_file_path):\n    \"\"\"\n    Reads a log file containing JSON entries and extracts training loss and test accuracy.\n    Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n    Args:\n        log_file_path (str): The path to the log file to be read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - train_loss_list (list): A list of training loss values extracted from the log.\n            - test_acc1_list (list): A list of test accuracy values extracted from the log.\n    \"\"\"\n",
        "test_code": "import json\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReadLog(unittest.TestCase):\n\n    def test_read_correct_data(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 89.0, \"train_loss\": 0.70}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75, 0.70])\n            self.assertEqual(test_acc1, [88.5, 89.0])\n\n    def test_read_correct_data_single(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75])\n            self.assertEqual(test_acc1, [88.5])\n    def test_empty_file(self):\n        \"\"\" Test reading an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data=\"\")):\n            train_loss, test_acc1 = read_log(\"empty_file.json\")\n            self.assertEqual(train_loss, [])\n            self.assertEqual(test_acc1, [])\n\n    def test_partial_data_entries(self):\n        \"\"\" Test file with missing fields in some entries \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 90.0,\"train_loss\": 0.75,\"f1\":0.91}'  # Missing train_loss\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"partial_data_file.json\")\n            self.assertEqual(train_loss, [0.75, 0.75])  # Only one complete entry\n            self.assertEqual(test_acc1, [88.5, 90.0])\n",
        "prompt": "please write a python function , the function signature as below def read_log(log_file_path):\n    \"\"\"\n    Reads a log file containing JSON entries and extracts training loss and test accuracy.\n    Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n    Args:\n        log_file_path (str): The path to the log file to be read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - train_loss_list (list): A list of training loss values extracted from the log.\n            - test_acc1_list (list): A list of test accuracy values extracted from the log.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 232,
    "code_type": "method",
    "original_language": "python",
    "file_path": "heavenfire\\3e3e4ddf0ae625de172dd2c37bf71d987dbe5464\\python\\remind_me.py",
    "question_type": "Data processing and transformation",
    "summary": "convert a string containing hours, minutes, and seconds to milliseconds, for example, convert the string \"1h20 min30s\" to milliseconds\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestConvertHmsToMilliseconds(unittest.TestCase):\n\n    def test_basic_conversion(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"1h20min30s\"), 4830000, \"Should convert 1h20min30s to 4830000 milliseconds\")\n\n    def test_no_hours_or_minutes(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"30s\"), 30000, \"Should convert 30s to 30000 milliseconds\")\n\n    def test_invalid_format(self):\n        self.assertIsNone(convert_hms_to_milliseconds(\"1hour20minutes\"), \"Should return None for invalid time format\")\n\n    def test_edge_case_max_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"23h59min59s\"), 86399000, \"Should convert 23h59min59s to 86399000 milliseconds\")\n\n    def test_exceeding_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"24h1min\"), 86460000,\n                         \"Should correctly convert 24h1min to 86460000 milliseconds\")",
        "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 233,
    "code_type": "method",
    "original_language": "python",
    "file_path": "quizly\\a340f345bc55daecbb4e5dcaa252155f2858f481\\puzzle_extractor.py",
    "question_type": "Data processing and transformation",
    "summary": "from the given string, delete the comment section that starts with the pound sign (#) and ends the line\n",
    "language_version_list": {
      "python": {
        "code_signature": "def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    For example:\n        input: Hello, world! # This is a comment\n        output:  Hello, world!\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestRemoveComments(unittest.TestCase):\n\n    def test_single_line_comment(self):\n        \"\"\" Test string with a comment on a single line \"\"\"\n        input_string = \"Hello, world!# This is a comment\"\n        expected_output = \"Hello, world!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n\n    def test_no_comments(self):\n        \"\"\" Test string with no comments \"\"\"\n        input_string = \"Hello, world!\\nPython is fun!\"\n        expected_output = \"Hello, world!\\nPython is fun!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_empty_string(self):\n        \"\"\" Test an empty string \"\"\"\n        input_string = \"\"\n        expected_output = \"\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_comments_only(self):\n        \"\"\" Test string where all lines are comments \"\"\"\n        input_string = \"# comment only line\\n#another comment line\"\n        expected_output = \"\\n\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n",
        "prompt": "please write a python function , the function signature as below def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    For example:\n        input: Hello, world! # This is a comment\n        output:  Hello, world!\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 234,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ngrok-stable-linux-arm\\c2986b7785ebdb030904e4e3af1ff6691c0b0fb4\\compareADIF.py",
    "question_type": "Data processing and transformation",
    "summary": "Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.",
    "language_version_list": {
      "python": {
        "code_signature": "def append_or_skip_row(file_handler, reader, row_candidate):\n    \"\"\"\n    Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n\n    Args:\n        file_handler: File handler of the CSV file opened in read-plus mode ('r+').\n        reader: CSV reader object for reading existing rows.\n        row_candidate: List containing the new row to be appended.\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import csv\nimport io\nimport unittest\n\n\nclass TestAppendOrSkipRow(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a mock CSV file using StringIO.\"\"\"\n        self.mock_file = io.StringIO()\n        self.mock_file.write(\"Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n\")\n        self.mock_file.seek(0)  # Reset pointer to the start of the mock file\n        self.reader = csv.reader(self.mock_file)\n\n    def test_append_new_row(self):\n        \"\"\"Test appending a new row when there are no matching values.\"\"\"\n        new_row = ['David', '28', 'Australia']\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_skip_different_values(self):\n        \"\"\"Test appending a new row with different values.\"\"\"\n        new_row = ['Alice', '31', 'USA']  # Same name, different age\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_append_row_with_different_columns(self):\n        \"\"\"Test appending a row with different values in the first three columns.\"\"\"\n        new_row = ['Eve', '40', 'Australia', 'Engineer']\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_multiple_appends(self):\n        \"\"\"Test appending multiple new rows correctly.\"\"\"\n        new_rows = [\n            ['Frank', '29', 'Germany'],\n            ['Grace', '22', 'France']\n        ]\n\n        for row in new_rows:\n            append_or_skip_row(self.mock_file, self.reader, row)\n            self.mock_file.seek(0)  # Reset pointer for the next read\n            self.reader = csv.reader(self.mock_file)  # Recreate the reader after each append\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        for row in new_rows:\n            self.assertIn(row, result)",
        "prompt": "please write a python function , the function signature as below def append_or_skip_row(file_handler, reader, row_candidate):\n    \"\"\"\n    Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n\n    Args:\n        file_handler: File handler of the CSV file opened in read-plus mode ('r+').\n        reader: CSV reader object for reading existing rows.\n        row_candidate: List containing the new row to be appended.\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 235,
    "code_type": "method",
    "original_language": "python",
    "file_path": "trdosl\\5ed74bb15f726589cddeb39e950774bf74c4875f\\_scripts\\calculate_bearing.py",
    "question_type": "Algorithm and data structure",
    "summary": "calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n",
    "language_version_list": {
      "python": {
        "code_signature": "def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestCalculateBearing(unittest.TestCase):\n    def test_north_bearing(self):\n        # From equator directly north\n        self.assertAlmostEqual(calculate_bearing(0, 0, 10, 0), 0)\n\n    def test_east_bearing(self):\n        # From prime meridian directly east\n        self.assertAlmostEqual(calculate_bearing(0, 0, 0, 10), 90)\n\n    def test_south_bearing(self):\n        # From a point directly south\n        self.assertAlmostEqual(calculate_bearing(10, 0, 0, 0), 180)\n\n    def test_west_bearing(self):\n        # From a point directly west\n        self.assertAlmostEqual(calculate_bearing(0, 10, 0, 0), 270)\n\n    def test_across_prime_meridian(self):\n        # From a point west of the prime meridian to a point east\n        self.assertAlmostEqual(calculate_bearing(0, -1, 0, 1), 90)",
        "prompt": "please write a python function , the function signature as below def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 240,
    "code_type": "method",
    "original_language": "python",
    "file_path": "heavenfire\\da7903f58b6c05a96a9c210d4900dc92f78e9100\\python\\luna_discord_bot.py",
    "question_type": "Data processing and transformation",
    "summary": "    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    Each unit should be specified by an integer followed by its corresponding unit letter.",
    "language_version_list": {
      "python": {
        "code_signature": "from datetime import timedelta\nimport re\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg. \"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n\n    Args:\n        time_string (str): A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"",
        "test_code": "import unittest\nfrom datetime import timedelta\n\n\nclass TestGenTimeoutTimedelta(unittest.TestCase):\n    def test_single_unit_days(self):\n        self.assertEqual(gen_timeout_timedelta(\"5d\"), timedelta(days=5))\n\n\n    def test_single_unit_hours(self):\n        self.assertEqual(gen_timeout_timedelta(\"8h\"), timedelta(hours=8))\n\n    def test_single_unit_minutes(self):\n        self.assertEqual(gen_timeout_timedelta(\"45m\"), timedelta(minutes=45))\n\n    def test_single_unit_seconds(self):\n        self.assertEqual(gen_timeout_timedelta(\"30s\"), timedelta(seconds=30))\n\n    def test_complex_mix(self):\n        self.assertEqual(gen_timeout_timedelta(\"2d 20h 30m\"), timedelta(days=2, hours=20, minutes=30))\n\n    def test_no_units(self):\n        self.assertEqual(gen_timeout_timedelta(\"\"), timedelta(0))",
        "prompt": "please write a python function , the function signature as below from datetime import timedelta\nimport re\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg. \"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n\n    Args:\n        time_string (str): A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 241,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Daybyday\\f522008ddf9af17287b47845f5753ccbf5c30a5d\\16.06\\Python\\worms\\worms-chatgpt.py",
    "question_type": "Algorithm and data structure",
    "summary": "finds the minimum distance between two words in a text file, considering each line as a separate sequence \uff0creturns the line number and shortest distance at which the distance occurs\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        \"\"\" Test basic functionality with expected input \"\"\"\n        mock_content = \"hello world\\napple banana apple\\norange apple banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (2, 1))\n\n\n    def test_words_not_present(self):\n        \"\"\" Test case where one or both words are not present \"\"\"\n        mock_content = \"apple orange pear\\norange pear apple\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_empty_file(self):\n        \"\"\" Test an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data='')):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_multiple_lines_with_varying_distances(self):\n        \"\"\" Test multiple lines with varying distances between words \"\"\"\n        mock_content = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (1, 1))",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 242,
    "code_type": "method",
    "original_language": "python",
    "file_path": "python-3-fundamentals\\1d2e3e04a3ef7b83e4e1a673c78f56a0d51c8bf8\\organize.py",
    "question_type": "File operations and I/O operation",
    "summary": "Classify an array of file names according to its file extension, and return the final class result in the form of a dictionary\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Dict\n\n\ndef classify_files_by_extension(file_names: List[str]) -> Dict:\n    \"\"\"\n    Classify an array of file names according to their file extensions.\n\n    Args:\n        file_names: List of file names (strings).\n\n    Returns:\n        Dict: Dictionary with file extensions as keys and lists of file names as values.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestClassifyFilesByExtension(unittest.TestCase):\n\n    def test_multiple_file_types(self):\n        \"\"\"Test with multiple file types.\"\"\"\n        files = [\n            \"document.docx\",\n            \"photo.jpeg\",\n            \"report.pdf\",\n            \"image.png\",\n            \"archive.zip\"\n        ]\n        expected_result = {\n            'docx': ['document.docx'],\n            'jpeg': ['photo.jpeg'],\n            'pdf': ['report.pdf'],\n            'png': ['image.png'],\n            'zip': ['archive.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_empty_list(self):\n        \"\"\"Test with an empty list of file names.\"\"\"\n        files = []\n        expected_result = {}\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_same_extension(self):\n        \"\"\"Test with multiple files having the same extension.\"\"\"\n        files = [\n            \"file1.txt\",\n            \"file2.txt\",\n            \"file3.txt\",\n        ]\n        expected_result = {\n            'txt': [\n                \"file1.txt\",\n                \"file2.txt\",\n                \"file3.txt\",\n            ]\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_multiple_dots(self):\n        \"\"\"Test files that have multiple dots in their names.\"\"\"\n        files = [\n            \"my.document.docx\",\n            \"report.final.pdf\",\n            \"photo.album.jpeg\",\n            \"archive.backup.zip\"\n        ]\n        expected_result = {\n            'docx': ['my.document.docx'],\n            'pdf': ['report.final.pdf'],\n            'jpeg': ['photo.album.jpeg'],\n            'zip': ['archive.backup.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)",
        "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef classify_files_by_extension(file_names: List[str]) -> Dict:\n    \"\"\"\n    Classify an array of file names according to their file extensions.\n\n    Args:\n        file_names: List of file names (strings).\n\n    Returns:\n        Dict: Dictionary with file extensions as keys and lists of file names as values.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 244,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ad_modelling_fyp\\d65e93d4dc1f99465e5aa8bfa3115cc79725e56a\\whole_brain_models\\whobpyt\\functions\\arg_type_check.py",
    "question_type": "Data processing and transformation",
    "summary": "Write a function to check whether the parameters passed to a given method object (for example, a class of methods) comply with their\nExpected data type, based on method signature, if there is a difference, a ValueError will be raised",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Callable\n\n\nimport inspect\n\n\ndef method_arg_type_check(method_obj, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected question types, based on the method's signature.js.py.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n\n    Optional argument:\n        exclude (list of str): Names of parameters to exclude from the type check.\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\nfrom typing import Callable\n\n\nclass MyClass:\n    def my_method(self, arg1: int, arg2: str, optional_arg: float = 3.14):\n        pass\n\n\nclass TestMethodArgTypeCheck(unittest.TestCase):\n    def test_correct_types(self):\n        \"\"\" Test with correct argument types. \"\"\"\n        try:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, \"hello\", optional_arg=3.14)\n        except ValueError:\n            self.fail(\"method_arg_type_check() raised ValueError unexpectedly!\")\n\n    def test_missing_argument(self):\n        \"\"\" Test with missing required argument. \"\"\"\n        with self.assertRaises(TypeError):\n            method_arg_type_check(MyClass.my_method, MyClass(), 10)  # Missing arg2\n",
        "prompt": "please write a python function , the function signature as below from typing import Callable\n\n\nimport inspect\n\n\ndef method_arg_type_check(method_obj, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected question types, based on the method's signature.js.py.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n\n    Optional argument:\n        exclude (list of str): Names of parameters to exclude from the type check.\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 248,
    "code_type": "method",
    "original_language": "python",
    "file_path": "website-2024\\252065dd22d32491fb30866fac26c7125f433d3c\\static\\python-scripts\\sanitize_hotcrp_json.py",
    "question_type": "Data processing and transformation",
    "summary": "remove the corresponding sensitive data in the given dictionary based on the given key_to_remove list\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive question in the given dictionary based on the given key_to_remove list\n\n    Args:\n        data (Dict): original question dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        Dict: removed dict\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestSanitizeData(unittest.TestCase):\n    def test_empty_dict(self):\n        \"\"\" Test with an empty dictionary. \"\"\"\n        data = {}\n        key_to_remove = [\"email\", \"metadata\"]\n\n        expected = {}\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_remove_default_keys(self):\n        \"\"\" Test removing default keys from a nested structure. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"email\": \"johndoe@example.com\",\n            \"metadata\": {\"submitted_at\": \"2021-07-10\", \"status\": \"pending\"},\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        key_to_remove = [\"email\", \"metadata\"]\n        expected = {\n            \"name\": \"John Doe\",\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_specified_key_to_remove(self):\n        \"\"\" Test removing a specified key from the dictionary. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\",\n            \"email\": \"johndoe@example.com\"\n        }\n        expected = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\"\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove=[\"email\"]), expected)",
        "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive question in the given dictionary based on the given key_to_remove list\n\n    Args:\n        data (Dict): original question dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        Dict: removed dict\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 249,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Spectrum\\928b58b455406a6f08b05c1d752bf0eef79e04f0\\Assets\\Other\\ofl_to_spectrum.py",
    "question_type": "File operations and I/O operation",
    "summary": "Extract text from a given pdf file",
    "language_version_list": {
      "python": {
        "code_signature": "def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestExtractTextFromPDF(unittest.TestCase):\n    def test_empty_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase01.pdf\"\n        expected = \" \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_normal_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase02.pdf\"\n        expected = \"11111  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_more_text_file(self):\n        pdf_path = r\"E:\\code\\code_back\\python_project\\RealisticEval-Data\\envs\\python\\test_case\\t249\\testcase03.pdf\"\n        expected = \"11111  \\n22222  \\n33333  \\n44444  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n",
        "prompt": "please write a python function , the function signature as below def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 250,
    "code_type": "method",
    "original_language": "python",
    "file_path": "RegRank\\ba03f17603783d94961ba936113d3b44423468aa\\regrank\\draw\\utils.py",
    "question_type": "Data processing and transformation",
    "summary": "Invert the keys and values in the dictionary, change the values of the original dictionary to the keys of the new dictionary, and the keys of the original dictionary become the values of the new dictionary. If the values in the original dictionary are duplicate (that is, multiple keys share the same value), the keys of the new dictionary will be mapped to a list containing all corresponding original keys\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestInvertDictionary(unittest.TestCase):\n\n    def test_normal_dictionary(self):\n        \"\"\"Test inversion of a dictionary without duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 2, 'c': 3}\n        expected = {1: 'a', 2: 'b', 3: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_dictionary_with_duplicates(self):\n        \"\"\"Test inversion of a dictionary with duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 1, 'c': 2}\n        expected = {1: ['a', 'b'], 2: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_empty_dictionary(self):\n        \"\"\"Test inversion of an empty dictionary.\"\"\"\n        original_dict = {}\n        expected = {}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_non_string_keys(self):\n        \"\"\"Test inversion of a dictionary with non-string keys.\"\"\"\n        original_dict = {1: 'apple', 2: 'banana', 3: 'apple'}\n        expected = {'apple': [1, 3], 'banana': 2}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_mixed_types(self):\n        \"\"\"Test inversion of a dictionary with mixed key and value types.\"\"\"\n        original_dict = {'a': 1, 2: 'two', 'three': 3}\n        expected = {1: 'a', 'two': 2, 3: 'three'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 252,
    "code_type": "method",
    "original_language": "python",
    "file_path": "EL9115_interactive_config\\6c573aa30877c32cf6324b5f0f3e7d9175d69b4b\\src\\spi_utilities.py",
    "question_type": "Algorithm and data structure",
    "summary": "Write a JSON decoding class that inherits from json.JSONEncoder. When encoding data into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n",
    "language_version_list": {
      "python": {
        "code_signature": "import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding question into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n    For example 'bits': 255 after encoder \"bits\": \"11111111\"\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n",
        "test_code": "import unittest\nimport json\n\nclass TestBitSequenceEncoder(unittest.TestCase):\n    def test_basic_encoding(self):\n        \"\"\" Test encoding with simple dictionary containing 'bits'. \"\"\"\n        data = {'name': 'Processor', 'bits': 255}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"bits\": \"11111111\"}')\n\n    def test_nested_encoding(self):\n        \"\"\" Test encoding with nested dictionary containing 'bits'. \"\"\"\n        data = {'component': {'name': 'ALU', 'bits': 128}, 'bits': 1}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"component\": {\"name\": \"ALU\", \"bits\": \"10000000\"}, \"bits\": \"00000001\"}')\n\n    def test_non_bits_key(self):\n        \"\"\" Test encoding with dictionary not containing 'bits' key. \"\"\"\n        data = {'name': 'Processor', 'value': 123}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"value\": 123}')\n\n    def test_no_bits_conversion_needed(self):\n        \"\"\" Test encoding with dictionary where 'bits' key needs no conversion. \"\"\"\n        data = {'name': 'Unit', 'bits': 'Already binary'}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Unit\", \"bits\": \"Already binary\"}')\n\n    def test_complex_structure_with_bits(self):\n        \"\"\" Test encoding a complex dictionary structure containing multiple 'bits' keys. \"\"\"\n        data = {\n            'processor': {'bits': 3, 'type': 'A'},\n            'memory': {'bits': 255, 'size': 16},\n            'ports': {'count': 2, 'bits': 128}\n        }\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"processor\": {\"bits\": \"00000011\", \"type\": \"A\"}, \"memory\": {\"bits\": \"11111111\", \"size\": 16}, \"ports\": {\"count\": 2, \"bits\": \"10000000\"}}')\n",
        "prompt": "please write a python function , the function signature as below import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding question into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n    For example 'bits': 255 after encoder \"bits\": \"11111111\"\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 253,
    "code_type": "method",
    "original_language": "python",
    "file_path": "lego-spike-prime\\c7804b0df3da4ea368405f6b379be287dace2dec\\GyroMoveAndRotate.py",
    "question_type": "File operations and I/O operation",
    "summary": "Write a function to process different types of log entries. This function can process strings, numbers, dictionaries and lists, and can serialize dictionaries and lists into JSON format for output. If the input data type is not supported, an error will be thrown.\n",
    "language_version_list": {
      "python": {
        "code_signature": "def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogFunction(unittest.TestCase):\n    @patch('builtins.print')\n    def test_log_string(self, mock_print):\n        \"\"\" Test logging a simple string \"\"\"\n        log(\"Hello, world!\")\n        mock_print.assert_called_once_with(\"Hello, world!\")\n\n    @patch('builtins.print')\n    def test_log_number(self, mock_print):\n        \"\"\" Test logging a number \"\"\"\n        log(123.456)\n        mock_print.assert_called_once_with(123.456)\n\n    @patch('builtins.print')\n    def test_log_dictionary(self, mock_print):\n        \"\"\" Test logging a dictionary as JSON \"\"\"\n        log({\"key\": \"value\", \"number\": 42})\n        expected_json_output = '{\\n    \"key\": \"value\",\\n    \"number\": 42\\n}'\n        mock_print.assert_called_once_with(expected_json_output)\n\n    @patch('builtins.print')\n    def test_log_list(self, mock_print):\n        \"\"\" Test logging a list as JSON \"\"\"\n        log([1, 2, 3, 4, 5])\n        expected_json_output = '[\\n    1,\\n    2,\\n    3,\\n    4,\\n    5\\n]'\n        mock_print.assert_called_once_with(expected_json_output)",
        "prompt": "please write a python function , the function signature as below def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 255,
    "code_type": "method",
    "original_language": "python",
    "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py",
    "question_type": "File operations and I/O operation",
    "summary": "Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom io import BytesIO\nfrom PIL import Image\n\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def create_image(self, mode, size, color):\n        \"\"\"\n        Helper method to create an in-memory image.\n\n        Args:\n            mode (str): The color mode of the image (e.g., '1' for binary, 'L' for grayscale).\n            size (tuple): A tuple of the image size (width, height).\n            color (int or tuple): The color to fill the image. 255 for white, 0 for black in '1' mode.\n\n        Returns:\n            Image: A PIL Image object.\n        \"\"\"\n        image = Image.new(mode, size, color)\n        return image\n\n    def test_all_white_image(self):\n        image = self.create_image('1', (4, 4), 255)\n        expected_bits = [1] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_all_black_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        expected_bits = [0] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_checkerboard_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if (x + y) % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         0, 1, 0, 1,\n                         1, 0, 1, 0,\n                         0, 1, 0, 1]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_horizontal_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if y % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 1, 1, 1,\n                         0, 0, 0, 0,\n                         1, 1, 1, 1,\n                         0, 0, 0, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_vertical_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if x % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 256,
    "code_type": "method",
    "original_language": "python",
    "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py",
    "question_type": "Data processing and transformation",
    "summary": "convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestBitsToBytes(unittest.TestCase):\n\n    def test_exact_multiple_of_eight(self):\n        \"\"\"Test bit arrays that are exact multiples of 8 bits.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]\n        expected = bytearray([0b10110010, 0b01001111])  # Corrected to match actual byte values\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_incomplete_byte_discarded(self):\n        \"\"\"Test bit arrays where the last bits do not make up a full byte.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]  # Last two bits should be discarded\n        expected = bytearray([0b10110010])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_empty_bit_array(self):\n        \"\"\"Test an empty bit array.\"\"\"\n        bits = []\n        expected = bytearray()\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_single_full_byte(self):\n        \"\"\"Test bit arrays that exactly make one byte.\"\"\"\n        bits = [1, 1, 1, 1, 1, 1, 1, 1]  # Represents the byte 0xFF\n        expected = bytearray([0xFF])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_no_bits_discarded(self):\n        \"\"\"Test bit arrays with multiple of 8 bits and no extra bits.\"\"\"\n        bits = [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1]\n        expected = bytearray([0xCC, 0x77])  # Corrected the second byte from 0xB7 to 0x77\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 258,
    "code_type": "method",
    "original_language": "python",
    "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py",
    "question_type": "Data processing and transformation",
    "summary": "given a character set, extract the position of a specific character from a byte array. First, determine whether the desired character exists in the character set, and if so, calculate the character's position in the byte array, and extract the character's bits\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple, List\n\n\ndef extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> Tuple[int, str]:\n    \"\"\"\n    Extracts the position and bits of a specific character from a byte array.\n\n    Args:\n        byte_array (bytes): The byte array to search within\n        char (str): The character to find in the byte array\n        charset (str): The character encoding of the byte array\n\n    Returns:\n        A tuple of (position, bits) if the character is found, otherwise None.\n    \"\"\"\n",
        "test_code": "import unittest\n\n# Assuming extract_character_bits is imported from your module\n# from your_module import extract_character_bits\n\nclass TestExtractCharacterBits(unittest.TestCase):\n\n    def test_case_1_valid_utf8(self):\n        byte_array = b'Hello, World!'\n        char = 'W'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        expected_result = (7, '01010111')  # 'W' is at position 7 with binary bits\n        self.assertEqual(result, expected_result)\n\n    def test_case_2_non_existent_character(self):\n        byte_array = b'This is a test.'\n        char = 'z'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        self.assertIsNone(result)  # Character 'z' is not in the byte array\n\n    def test_case_3_invalid_encoding(self):\n        byte_array = b'\\xff\\xfe'\n        char = 'A'\n        result = extract_character_bits(byte_array, char, 'ascii')  # Invalid bytes for ASCII\n        self.assertIsNone(result)  # Should handle UnicodeDecodeError and return None\n\n    def test_case_4_valid_utf16(self):\n        byte_array = 'Hello, World!'.encode('utf-16')\n        char = '!'\n        result = extract_character_bits(byte_array, char, 'utf-16')\n        expected_result = (12, '00100001 00000000')  # '!' at position 12 in UTF-16 encoding\n        self.assertEqual(result, expected_result)\n\n    def test_case_5_special_characters_utf8(self):\n        byte_array = 'Python \ud83d\udc0d is fun!'.encode('utf-8')\n        char = '\ud83d\udc0d'\n        result = extract_character_bits(byte_array, char, 'utf-8')\n        expected_result = (7, '11110000 10011111 10010000 10001101')  # Unicode character \ud83d\udc0d in UTF-8\n        self.assertEqual(result, expected_result)\n",
        "prompt": "please write a python function , the function signature as below from typing import Tuple, List\n\n\ndef extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> Tuple[int, str]:\n    \"\"\"\n    Extracts the position and bits of a specific character from a byte array.\n\n    Args:\n        byte_array (bytes): The byte array to search within\n        char (str): The character to find in the byte array\n        charset (str): The character encoding of the byte array\n\n    Returns:\n        A tuple of (position, bits) if the character is found, otherwise None.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 259,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Course_Sys_Rec\\6cbc3bbf6d4592c8e79f1477433ae14434a9a3da\\backend\\search\\validators.py",
    "question_type": "Algorithm and data structure",
    "summary": "determine whether a number is a compliant four-digit number\n",
    "language_version_list": {
      "python": {
        "code_signature": "def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestIsCompliantFourDigit(unittest.TestCase):\n    def test_positive_four_digit_number(self):\n        # Tests a standard positive four-digit number\n        self.assertTrue(is_compliant_four_digit(1234))\n\n    def test_boundary_values(self):\n        # Tests the boundary values of the range\n        self.assertTrue(is_compliant_four_digit(1000))\n        self.assertTrue(is_compliant_four_digit(9999))\n\n    def test_negative_four_digit_number(self):\n        # Tests a negative four-digit number\n        self.assertFalse(is_compliant_four_digit(-1234))\n\n    def test_out_of_range_number(self):\n        # Tests numbers that are out of the four-digit range\n        self.assertFalse(is_compliant_four_digit(999))\n        self.assertFalse(is_compliant_four_digit(10000))",
        "prompt": "please write a python function , the function signature as below def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 260,
    "code_type": "method",
    "original_language": "python",
    "file_path": "hci-2023-self-experiment\\e91c857a34c01e7586b98e435930d9d763020da8\\remove_empty_csv_lines.py",
    "question_type": "File operations and I/O operation",
    "summary": "Process the csv file and delete rows with two empty columns\n",
    "language_version_list": {
      "python": {
        "code_signature": "import pandas as pd\n\n\ndef process_csv(file_path: str, output_path: str):\n    \"\"\"\n    Processes a CSV file and removes rows with two or more empty columns.If file is empty return empty str\n\n    Args:\n        file_path (str): The path to the input CSV file.\n        output_path (str): The path where the processed CSV file will be saved.\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\n\nimport os\n\n\n# Assuming process_csv function is imported from the module\n# from your_module import process_csv\n\nclass TestProcessCSV(unittest.TestCase):\n\n    def setUp(self):\n        self.input_data_1 = \"\"\"A,B,C\n1,2,3\n4,,6\n7,8,\n9,10,11\"\"\"\n\n\n        self.input_data_2 = \"\"\"A,B,C,D\n,,\n1,,3,4\n2,3,,5\n,,,\"\"\"\n\n\n        self.input_data_3 = \"\"\"A\n1\n2\n3\"\"\"\n\n\n    def process_data(self, input_data):\n        input_file = StringIO(input_data)\n        output_file = StringIO()\n        input_file_path = \"input.csv\"\n        output_file_path = \"output.csv\"\n\n        # Write input data to a temp CSV file\n        with open(input_file_path, 'w') as f:\n            f.write(input_data)\n\n        # Process the CSV\n        process_csv(input_file_path, output_file_path)\n\n        # Read the output\n        with open(output_file_path, 'r') as f:\n            output_data = f.read()\n\n        # Clean up temp files\n        os.remove(input_file_path)\n        os.remove(output_file_path)\n\n        return output_data\n\n    def test_case_1(self):\n        output = self.process_data(self.input_data_1)\n        expected_output = \"\"\"A,B,C\\n1,2.0,3.0\\n4,,6.0\\n7,8.0,\\n9,10.0,11.0\\n\"\"\"\n        self.assertEqual(output, expected_output)\n\n    def test_case_2(self):\n        output = self.process_data(self.input_data_2)\n        expected_output = \"\"\"A,B,C,D\\n1.0,,3.0,4.0\\n2.0,3.0,,5.0\\n\"\"\"\n        self.assertEqual(output, expected_output)\n\n    def test_case_3(self):\n        output = self.process_data(self.input_data_3)\n        expected_output = \"\"\"A\\n1\\n2\\n3\\n\"\"\"  # Single-column CSV should remain unchanged\n        self.assertEqual(output, expected_output)",
        "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef process_csv(file_path: str, output_path: str):\n    \"\"\"\n    Processes a CSV file and removes rows with two or more empty columns.If file is empty return empty str\n\n    Args:\n        file_path (str): The path to the input CSV file.\n        output_path (str): The path where the processed CSV file will be saved.\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 262,
    "code_type": "method",
    "original_language": "python",
    "file_path": "leetcode_problems\\6ffa50a7ebae1f0ab6092efa49d3839644859510\\avg_binary_tree\\avg_binary_tree.py",
    "question_type": "Algorithm and data structure",
    "summary": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. ",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass TestAverageOfLevels(unittest.TestCase):\n\n    def test_empty_tree(self):\n        root = None\n        expected = []\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_single_node_tree(self):\n        root = TreeNode(5)\n        expected = [5.0]\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_balanced_tree_two_levels(self):\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20)\n        expected = [3.0, 14.5]  # Level 0: 3; Level 1: (9+20)/2 = 14.5\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_unbalanced_tree(self):\n        root = TreeNode(1)\n        root.right = TreeNode(2)\n        root.right.right = TreeNode(3)\n        expected = [1.0, 2.0, 3.0]  # Level 0: 1; Level 1: 2; Level 2: 3\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_tree_multiple_levels(self):\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(8)\n        expected = [1.0, 2.5, 5.67]  # Level 0: 1; Level 1: (2+3)/2 = 2.5; Level 2: (4+5+8)/3 \u2248 5.67\n        self.assertAlmostEqual(average_of_levels(root)[2], expected[2], places=2)\n        self.assertEqual(average_of_levels(root)[:2], expected[:2])",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 263,
    "code_type": "method",
    "original_language": "python",
    "file_path": "leetcode_problems\\2c1d6ebdef1030b7793d957291fcebb771480477\\spiral_matrix\\optimized_with_ai.py",
    "question_type": "Data processing and transformation",
    "summary": "Please write a function that traverses a two-dimensional matrix in spiral order and returns a list of the elements of the traversal result",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\"",
        "test_code": "import unittest\n\nclass TestMatrixTraversal(unittest.TestCase):\n    def setUp(self):\n        self.mt = MatrixTraversal()\n\n    def test_empty_matrix(self):\n        # \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        self.assertEqual(self.mt.spiral_traversal([]), [], \"Should return an empty list for an empty matrix\")\n\n    def test_single_element_matrix(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        matrix = [[42]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [42], \"Should return the single element in the matrix\")\n\n    def test_single_row_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        matrix = [[1, 2, 3, 4, 5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single row\")\n\n    def test_single_column_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        matrix = [[1], [2], [3], [4], [5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single column\")\n\n    def test_general_case(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 6, 9, 8, 7, 4, 5], \"Should return elements in spiral order for a general case matrix\")\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 264,
    "code_type": "method",
    "original_language": "python",
    "file_path": "PythonCollection\\454a4924cd2db9a101283c1c21b2ae7631220ea2\\clearTypo3Log.py",
    "question_type": "File operations and I/O operation",
    "summary": "extract log entries at the WARNING, ERROR, CRITICAL, and ALERT levels from a log file and save the log entries at each level to a different file\n",
    "language_version_list": {
      "python": {
        "code_signature": "def extract_log_entries(log_file_path:str):\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n        log_file_path: Path to the log file.\n\n    Returns:\n\n    \"\"\"\n\n\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n    log_file_path (str): Path to the log file.\n    \"\"\"",
        "test_code": "import unittest\nimport os\n\n\nclass TestExtractLogEntries(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Setup a temporary log file with sample question for testing.\"\"\"\n        self.log_file_path = 'test_log.log'\n        self.log_contents = [\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        ]\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines(self.log_contents)\n\n\n\n    def test_no_logs_of_certain_levels(self):\n        \"\"\"Test the situation where there are no log entries for one or more levels.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"INFO: This is another informational message.\\n\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_file_not_found(self):\n        \"\"\"Test behavior when the log file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            extract_log_entries(\"nonexistent.log\")\n\n    def test_empty_log_file(self):\n        \"\"\"Test behavior with an empty log file.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_mixed_content_log_file(self):\n        \"\"\"Test extracting logs from a file with mixed content.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines([\n                \"INFO: Some info.\\n\",\n                \"WARNING: Watch out!\\n\",\n                \"DEBUG: Debugging.\\n\",\n                \"ERROR: Oops!\\n\",\n                \"CRITICAL: Failed badly.\\n\",\n                \"ALERT: High alert!\\n\",\n                \"INFO: More info.\\n\"\n            ])\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                content = file.read().strip()\n                self.assertIn(level, content)\n",
        "prompt": "please write a python function , the function signature as below def extract_log_entries(log_file_path:str):\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n        log_file_path: Path to the log file.\n\n    Returns:\n\n    \"\"\"\n\n\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n    log_file_path (str): Path to the log file.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 266,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ot-harjoitustyo\\037f762749a5c7dfde328c37e42e1d9901177020\\src\\utils\\utils.py",
    "question_type": "Data processing and transformation",
    "summary": "Handle nested data structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested question structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): question object\n\n    Returns:\n        after converted question\n    \"\"\"\n",
        "test_code": "import unittest\nfrom enum import Enum\nfrom numbers import Number\n\n\nclass TestHandleNestedData(unittest.TestCase):\n    def test_simple_dictionary(self):\n        data = {\"name\": b\"Alice\", \"age\": \"30\"}\n        expected = {\"name\": \"Alice\", \"age\": 30}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_nested_dictionary(self):\n        data = {\"user\": {\"name\": b\"Bob\", \"details\": {\"age\": \"25\", \"height\": \"175.5\"}}}\n        expected = {\"user\": {\"name\": \"Bob\", \"details\": {\"age\": 25, \"height\": 175.5}}}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_list_of_mixed_data_types(self):\n        data = [\"100\", b\"200\", 300.0, \"400.5\"]\n        expected = [100, \"200\", 300.0, 400.5]\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_incorrect_byte_decoding(self):\n        data = {\"invalid_bytes\": b\"\\xff\\xfe\\xfd\\xfc\"}\n        with self.assertRaises(UnicodeDecodeError):\n            handle_nested_data(data)\n\n    def test_complex_nested_structure(self):\n        data = {\n            \"team\": [\n                {\"name\": b\"Charlie\", \"scores\": [\"1000\", \"2000.2\"]},\n                {\"name\": b\"Daisy\", \"skills\": [b\"Coding\", \"Design\"], \"age\": \"22\"}\n            ]\n        }\n        expected = {\n            \"team\": [\n                {\"name\": \"Charlie\", \"scores\": [1000, 2000.2]},\n                {\"name\": \"Daisy\", \"skills\": [\"Coding\", \"Design\"], \"age\": 22}\n            ]\n        }\n        self.assertEqual(handle_nested_data(data), expected)",
        "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested question structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): question object\n\n    Returns:\n        after converted question\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 267,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ot-harjoitustyo\\037f762749a5c7dfde328c37e42e1d9901177020\\src\\utils\\utils.py",
    "question_type": "Algorithm and data structure",
    "summary": "extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestExtractSldTld(unittest.TestCase):\n    def test_standard_fqdn(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.com\"), (\"example\", \"com\"))\n\n    def test_standard_fqdn2(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.xyz\"), (\"example\", \"xyz\"))\n\n    def test_fqdn_with_subdomains(self):\n        # Test an FQDN with multiple subdomains\n        self.assertEqual(extract_sld_tld(\"blog.subdomain.example.com\"), (\"example\", \"com\"))\n\n    def test_numeric_tld(self):\n        # Test a numeric TLD, which can occur in private networks\n        self.assertEqual(extract_sld_tld(\"server.example.123\"), (\"example\", \"123\"))\n",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 268,
    "code_type": "method",
    "original_language": "python",
    "file_path": "leetcode_problems\\fb16642c3e03da8209e860c644c6e7a3f165f34a\\gas_station\\gas_station.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "There are n gas stations along a circular route,\nwhere the amount of gas at the ith station is gas[i].\n\nYou have a car with an unlimited gas tank and\nit costs cost[i] of gas to travel from the ith station to its next (i + 1)th station.\nYou begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays gas and cost,\nreturn the starting gas station's index \nif you can travel around the circuit once in the clockwise direction,\notherwise return -1. If there exists a solution, it is guaranteed to be unique ",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestCanCompleteCircuit(unittest.TestCase):\n\n    def test_possible_single_station(self):\n        gas = [5]\n        cost = [4]\n        expected = 0\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_impossible_single_station(self):\n        gas = [4]\n        cost = [5]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_two_stations_possible(self):\n        gas = [1, 2]\n        cost = [2, 1]\n        expected = 1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_possible(self):\n        gas = [1, 2, 3, 4, 5]\n        cost = [3, 4, 5, 1, 2]\n        expected = 3\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_impossible(self):\n        gas = [2, 3, 4]\n        cost = [3, 4, 3]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 269,
    "code_type": "method",
    "original_language": "python",
    "file_path": "CLICK_PLC_Tools\\8438dcba5d7b5885d52f4ec8a3a34694399e7fed\\clicksploit.py",
    "question_type": "Network requests and API call",
    "summary": "checks whether a string is compliant IP\n",
    "language_version_list": {
      "python": {
        "code_signature": "def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check whether the IP address is a legal IP address.\n\n    Args:\n        ip (str): The IP address in string format.\n\n    Returns:\n        bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestIsCompliantIP(unittest.TestCase):\n    def test_private_ip(self):\n        # Test that private IPs return True\n        self.assertTrue(is_compliant_ip('192.168.1.1'))\n\n    def test_public_ip(self):\n        # Test that public IPs return False\n        self.assertTrue(is_compliant_ip('8.8.8.8'))\n\n    def test_invalid_ip(self):\n        # Test that invalid IP strings return False\n        self.assertFalse(is_compliant_ip('999.999.999.999'))\n",
        "prompt": "please write a python function , the function signature as below def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check whether the IP address is a legal IP address.\n\n    Args:\n        ip (str): The IP address in string format.\n\n    Returns:\n        bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 281,
    "code_type": "method",
    "original_language": "python",
    "file_path": "uozp-hw1\\b91e588821c3c344e33d48660821af1bc02be862\\hw0.py",
    "question_type": "Algorithm and data structure",
    "summary": "compute the squared Euclidean distance between two vectors\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef squared_euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors.\n\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestSquaredEuclideanDistance(unittest.TestCase):\n    def test_standard_vectors(self):\n        \"\"\"Test squared distance calculation for typical vectors.\"\"\"\n        vec1 = [1, 2, 3]\n        vec2 = [4, 5, 6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_zeros(self):\n        \"\"\"Test vectors that include zero values.\"\"\"\n        vec1 = [0, 0, 0]\n        vec2 = [0, 0, 0]\n        expected_result = 0\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_negative_values(self):\n        \"\"\"Test vectors that include negative values.\"\"\"\n        vec1 = [-1, -2, -3]\n        vec2 = [-4, -5, -6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_vectors(self):\n        \"\"\"Test single element vectors.\"\"\"\n        vec1 = [5]\n        vec2 = [-5]\n        expected_result = 100  # (10^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef squared_euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors.\n\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 282,
    "code_type": "method",
    "original_language": "python",
    "file_path": "uozp-hw1\\b91e588821c3c344e33d48660821af1bc02be862\\hw0.py",
    "question_type": "Data processing and transformation",
    "summary": "convert a multi-dimensional array into a one-dimensional array\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFlattenArray(unittest.TestCase):\n    def test_deeply_nested_array(self):\n        \"\"\"Test a deeply nested array.\"\"\"\n        nested_array = [1, [2, [3, [4, [5]]]]]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(nested_array), expected_result)\n\n    def test_mixed_types(self):\n        \"\"\"Test an array with mixed question types.\"\"\"\n        mixed_array = [\"a\", [\"b\", 2, [True, [3.14]]], False]\n        expected_result = [\"a\", \"b\", 2, True, 3.14, False]\n        self.assertEqual(flatten_array(mixed_array), expected_result)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        empty_array = []\n        expected_result = []\n        self.assertEqual(flatten_array(empty_array), expected_result)\n\n    def test_array_with_empty_subarrays(self):\n        \"\"\"Test an array that includes empty subarrays.\"\"\"\n        complex_array = [1, [], [2, [], 3], [4, [5, [], 6], 7], []]\n        expected_result = [1, 2, 3, 4, 5, 6, 7]\n        self.assertEqual(flatten_array(complex_array), expected_result)\n\n    def test_no_nested_array(self):\n        \"\"\"Test an array that has no nested structure.\"\"\"\n        flat_array = [1, 2, 3, 4, 5]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(flat_array), expected_result)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 286,
    "code_type": "method",
    "original_language": "python",
    "file_path": "partial-model-merging\\d919c66a8b5f50c6ab7f599a0605d6a18834bcb1\\src\\plot_scripts\\plot_correlation_histogram.py",
    "question_type": "Algorithm and data structure",
    "summary": "find the largest integer between a given number n and half of it that is divisible by 10 or 5",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFindLargestDivisible(unittest.TestCase):\n    def test_typical_case(self):\n        \"\"\"Test with a typical input where the largest divisible number should be found.\"\"\"\n        self.assertEqual(find_largest_divisible(50), 50)\n        self.assertEqual(find_largest_divisible(47), 45)\n\n    def test_no_divisible_found(self):\n        \"\"\"Test a case where no divisible number is found within the range.\"\"\"\n        self.assertIsNone(find_largest_divisible(4))\n\n    def test_exact_half_divisible(self):\n        \"\"\"Test when the half of n is exactly divisible by 5.\"\"\"\n        self.assertEqual(find_largest_divisible(10), 10)\n\n    def test_large_number(self):\n        \"\"\"Test with a large number to ensure performance and correctness.\"\"\"\n        self.assertEqual(find_largest_divisible(1000), 1000)\n\n    def test_lower_bound(self):\n        \"\"\"Test the function with the lowest bound that should find a divisible number.\"\"\"\n        self.assertEqual(find_largest_divisible(5), 5)\n",
        "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 290,
    "code_type": "method",
    "original_language": "python",
    "file_path": "integrity-datamodels\\f35cdaabb51a81f692c6dcce24ba10acc92e6cc1\\ontologies\\rdf_to_ngsi.py",
    "question_type": "Data processing and transformation",
    "summary": "convert the data in RDF JSON-LD format to NGSI-LD format",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the question in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted question as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n",
        "test_code": "import unittest\nimport json\n\n\nclass TestRDFJSONLDToNGSILDConversion(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\"Test a basic and correct conversion from JSON-LD to NGSI-LD.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_missing_id_and_type(self):\n        \"\"\"Test conversion when @id and @type are missing.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_with_nested_objects(self):\n        \"\"\"Test conversion with nested objects.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"location\": {\"latitude\": 48.8566, \"longitude\": 2.3522}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"location\", \"value\": {\"latitude\": 48.8566, \"longitude\": 2.3522}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_invalid_json_input(self):\n        \"\"\"Test the function's response to invalid JSON input.\"\"\"\n        rdf_jsonld = \"This is not a valid JSON\"\n        with self.assertRaises(json.JSONDecodeError):\n            rdf_jsonld_to_ngsild(rdf_jsonld)\n\n    def test_empty_jsonld(self):\n        \"\"\"Test the conversion of an empty JSON-LD document.\"\"\"\n        rdf_jsonld = json.dumps({})\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"https://schema.lab.fiware.org/ld/context\",\n            \"attributes\": []\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n",
        "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the question in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted question as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 291,
    "code_type": "method",
    "original_language": "python",
    "file_path": "aitechtalk20230712\\feb0696125ad08d951eb03357a2ef4c4421f22d3\\trainingdata\\prepareTrainingData.py",
    "question_type": "File operations and I/O operation",
    "summary": "appends the specified string to the beginning of each line of the file and then updates the entire file",
    "language_version_list": {
      "python": {
        "code_signature": "def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n",
        "test_code": "import unittest\nimport os\n\nclass TestPrependToEachLine(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary file for testing.\"\"\"\n        self.test_file_path = \"test_file.txt\"\n        with open(self.test_file_path, 'w') as f:\n            f.write(\"Line 1\\nLine 2\\nLine 3\")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary file after testing.\"\"\"\n        os.remove(self.test_file_path)\n\n    def test_prepend_string(self):\n        \"\"\"Test appending a simple string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"Test: \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Test: Line 1\\n\", \"Test: Line 2\\n\", \"Test: Line 3\"])\n\n    def test_prepend_empty_string(self):\n        \"\"\"Test appending an empty string.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"\")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\"])\n\n    def test_prepend_special_characters(self):\n        \"\"\"Test appending special characters to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"#$%^&* \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"#$%^&* Line 1\\n\", \"#$%^&* Line 2\\n\", \"#$%^&* Line 3\"])\n\n    def test_prepend_numeric_string(self):\n        \"\"\"Test appending numeric string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"123 \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"123 Line 1\\n\", \"123 Line 2\\n\", \"123 Line 3\"])\n\n    def test_file_not_found(self):\n        \"\"\"Test the response when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            prepend_to_each_line(\"non_existent_file.txt\", \"Test: \")",
        "prompt": "please write a python function , the function signature as below def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 366,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Spectrum\\928b58b455406a6f08b05c1d752bf0eef79e04f0\\Assets\\Other\\ofl_to_spectrum.py",
    "question_type": "File operations and I/O operation",
    "summary": "Extracts text content from a given word file",
    "language_version_list": {
      "python": {
        "code_signature": "from docx import Document\n\ndef extract_text_from_word(docx_file_path):\n    \"\"\"\n    Extracts text content from a given Word file (.docx).\n\n    Args:\n        docx_file_path (str): The path to the Word file.\n\n    Returns:\n        str: The extracted text content.\n    \"\"\"",
        "test_code": "import unittest\nimport os\nfrom docx import Document\n\n\nclass TestExtractTextFromWord(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up the testing environment.\"\"\"\n        # Create a temporary Word file for testing\n        self.test_docx_path = \"test_document.docx\"\n        self.create_sample_docx()\n\n    def tearDown(self):\n        \"\"\"Clean up the test environment.\"\"\"\n        # Remove created files after tests\n        if os.path.exists(self.test_docx_path):\n            os.remove(self.test_docx_path)\n\n    def create_sample_docx(self):\n        \"\"\"Helper method to create a sample Word document for testing.\"\"\"\n        doc = Document()\n        doc.add_paragraph(\"Hello World!\")\n        doc.add_paragraph(\"This is a test document.\")\n        doc.save(self.test_docx_path)\n\n    def test_extract_text_success(self):\n        \"\"\"Test extracting text from a normal Word document.\"\"\"\n        expected_text = \"Hello World!\\nThis is a test document.\"\n        extracted_text = extract_text_from_word(self.test_docx_path)\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n    def test_extract_empty_document(self):\n        \"\"\"Test extracting text from an empty Word document.\"\"\"\n        empty_docx_path = \"empty_document.docx\"\n        Document().save(empty_docx_path)\n\n        extracted_text = extract_text_from_word(empty_docx_path)\n        self.assertEqual(extracted_text, \"\")  # Expecting an empty string\n\n        os.remove(empty_docx_path)  # Clean up\n\n\n    def test_extract_text_with_special_characters(self):\n        \"\"\"Test extracting text from a document containing special characters.\"\"\"\n        special_docx_path = \"special_characters.docx\"\n        doc = Document()\n        doc.add_paragraph(\"Hello, \u4e16\u754c! @#$%^&*()\")\n        doc.save(special_docx_path)\n\n        extracted_text = extract_text_from_word(special_docx_path)\n        expected_text = \"Hello, \u4e16\u754c! @#$%^&*()\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(special_docx_path)  # Clean up\n\n    def test_extract_text_with_multiple_paragraphs(self):\n        \"\"\"Test extracting text from a document with multiple paragraphs.\"\"\"\n        multi_para_docx_path = \"multi_paragraphs.docx\"\n        doc = Document()\n        doc.add_paragraph(\"First paragraph.\")\n        doc.add_paragraph(\"Second paragraph.\")\n        doc.add_paragraph(\"Third paragraph.\")\n        doc.save(multi_para_docx_path)\n\n        extracted_text = extract_text_from_word(multi_para_docx_path)\n        expected_text = \"First paragraph.\\nSecond paragraph.\\nThird paragraph.\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(multi_para_docx_path)  # Clean up\n",
        "prompt": "please write a python function , the function signature as below from docx import Document\n\ndef extract_text_from_word(docx_file_path):\n    \"\"\"\n    Extracts text content from a given Word file (.docx).\n\n    Args:\n        docx_file_path (str): The path to the Word file.\n\n    Returns:\n        str: The extracted text content.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 369,
    "code_type": "method",
    "original_language": "python",
    "file_path": "python\\9dac241780aa9e5292ae196b0612c953e5181065\\nqueens",
    "question_type": "Algorithm and data structure",
    "summary": "solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"",
    "language_version_list": {
      "python": {
        "code_signature": "def eight_queens():\n    \"\"\"\n    solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"\n    print example as below:\n    . . Q . . . . .\n    . . . . Q . . .\n    . Q . . . . . .\n    . . . . . . . Q\n    . . . . . Q . .\n    . . . Q . . . .\n    . . . . . . Q .\n    Q . . . . . . .\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\n\nclass TestEightQueens(unittest.TestCase):\n    def setUp(self):\n        self.board = [['.' for _ in range(8)] for _ in range(8)]\n\n    def test_solution_exists(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            self.assertTrue(\"Q\" in fake_out.getvalue(), \"The board should contain at least one queen.\")\n\n    def test_correct_number_of_queens(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            output = fake_out.getvalue().strip().split('\\n\\n')  # Split the output into blocks for each board\n            for board in output:\n                # Count number of 'Q's in each board\n                num_queens = board.count('Q')\n                self.assertEqual(num_queens, 8, \"Each board should contain exactly 8 queens.\")\n\n    def test_no_solution_scenario(self):\n        # As the Eight Queens always has a solution for an 8x8 board,\n        # to test the 'No solution' output we need a scenario where no solution exists.\n        # We will manipulate the board to a smaller size where no solution is possible.\n        # Here we consider a 3x3 board for simplicity.\n        def no_solution_queens():\n            board = [['.' for _ in range(3)] for _ in range(3)]\n            if not solve_queens(board, 0):\n                print(\"No solution\")\n\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            no_solution_queens()\n            self.assertIn(\"No solution\", fake_out.getvalue(), \"Should print 'No solution' when no solution exists.\")\n",
        "prompt": "please write a python function , the function signature as below def eight_queens():\n    \"\"\"\n    solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"\n    print example as below:\n    . . Q . . . . .\n    . . . . Q . . .\n    . Q . . . . . .\n    . . . . . . . Q\n    . . . . . Q . .\n    . . . Q . . . .\n    . . . . . . Q .\n    Q . . . . . . .\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 370,
    "code_type": "method",
    "original_language": "python",
    "file_path": "stride\\b57d0323a671ba9aff267643ce11b791e38d5c7e\\playground.py",
    "question_type": "Data processing and transformation",
    "summary": "Convert the index of a one-dimensional array to the index of the corresponding multi-dimensional array\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\n\ndef decompose(n: int, shape: Tuple) -> Tuple:\n    \"\"\"\n    Decompose a flat index `n` into a multidimensional index based on the given shape.\n\n    Args:\n        n: Flat index (non-negative integer).\n        shape: Tuple representing the dimensions of the multi-dimensional array.\n\n    Returns:\n        Tuple: Tuple representing the multidimensional index corresponding to `n`.\n    Raises:\n        ValueError: If `n` is out of bounds for the array defined by `shape`.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestDecomposeFunction(unittest.TestCase):\n\n    def test_edge_case_with_larger_shap(self):\n        self.assertEqual(decompose(60, (4, 4, 4)), (3, 3, 0))\n\n    def test_last_valid_index(self):\n        self.assertEqual(decompose(63, (4, 4, 4)), (3, 3, 3))\n\n    def test_single_dimension_case(self):\n        self.assertEqual(decompose(2, (5,)), (2,))\n\n    def test_invalid_cases(self):\n        # Test case 5: Out of bounds case (negative index)\n        with self.assertRaises(ValueError):\n            decompose(-1, (3, 4, 5))\n\n        # Test case 6: Out of bounds case (index too large)\n        with self.assertRaises(ValueError):\n            decompose(100, (3, 4, 5))\n",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef decompose(n: int, shape: Tuple) -> Tuple:\n    \"\"\"\n    Decompose a flat index `n` into a multidimensional index based on the given shape.\n\n    Args:\n        n: Flat index (non-negative integer).\n        shape: Tuple representing the dimensions of the multi-dimensional array.\n\n    Returns:\n        Tuple: Tuple representing the multidimensional index corresponding to `n`.\n    Raises:\n        ValueError: If `n` is out of bounds for the array defined by `shape`.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 380,
    "code_type": "method",
    "original_language": "python",
    "file_path": "scripts\\9406f19eae2cf146a6a4ca06015eb4ce364d58ec\\time-converter\\time2s.py",
    "question_type": "Data processing and transformation",
    "summary": "Calculate the total number of seconds based on combinations of different time units (days, hours, minutes, seconds)\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\n\ndef calculate_total_seconds(time: Tuple[int]):\n    \"\"\"\n    Calculate the total number of seconds given a tuple or list of time periods in the order of\n    days, hours, minutes, and seconds.\n\n    :param time: tuple or list, where\n        time[0] - number of days (optional)\n        time[1] - number of hours (optional)\n        time[2] - number of minutes (optional)\n        time[3] - number of seconds (optional)\n    :return: int, total number of seconds\n\n    Examples:\n        calculate_total_seconds([1, 2, 3, 4]) returns 93784\n        calculate_total_seconds([0, 2, 3]) returns 7380\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestCalculateTotalSeconds(unittest.TestCase):\n\n    def test_complete_time(self):\n        # Test with full values provided for days, hours, minutes, and seconds\n        time = [1, 2, 3, 4]  # 1 day, 2 hours, 3 minutes, 4 seconds\n        expected = 93784\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_partial_time(self):\n        # Test with some values missing (assumed trailing zeros)\n        time = [0, 2, 3]  # 0 days, 2 hours, 3 minutes\n        expected = 7380\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_seconds_only(self):\n        # Test with only seconds provided\n        time = [7200]  # 7200 seconds\n        expected = 622080000\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_no_time(self):\n        # Test with no time values provided\n        time = []\n        expected = 0\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef calculate_total_seconds(time: Tuple[int]):\n    \"\"\"\n    Calculate the total number of seconds given a tuple or list of time periods in the order of\n    days, hours, minutes, and seconds.\n\n    :param time: tuple or list, where\n        time[0] - number of days (optional)\n        time[1] - number of hours (optional)\n        time[2] - number of minutes (optional)\n        time[3] - number of seconds (optional)\n    :return: int, total number of seconds\n\n    Examples:\n        calculate_total_seconds([1, 2, 3, 4]) returns 93784\n        calculate_total_seconds([0, 2, 3]) returns 7380\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 381,
    "code_type": "method",
    "original_language": "python",
    "file_path": "pycookbook\\8599d1f263e1d8ca350196a147ad65dd92f6f78c\\emailparser.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Extract the user name and mailbox suffix from the mailbox string, for example, extract xxx and gmail.com from xxx@gmail.com",
    "language_version_list": {
      "python": {
        "code_signature": "def extract_email_details(email: str):\n    \"\"\"\n    Extracts the username and mailbox suffix from an email address.eg extract_email_details(\"xxx@gmail.com\") returns ('xxx', 'gmail.com')\n    Args:\n        email (str): the email address to extract details from\n\n    Returns:\n        tuple: (username, domain)\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestExtractEmailDetails(unittest.TestCase):\n\n    def test_valid_email(self):\n        # Test with a typical email address\n        email = \"user@example.com\"\n        expected = (\"user\", \"example.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n    def test_valid_email_with_subdomain(self):\n        # Test with an email that includes a subdomain\n        email = \"user@mail.office.com\"\n        expected = (\"user\", \"mail.office.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n\n    def test_email_without_at_symbol(self):\n        # Test with an email that lacks an '@' symbol\n        email = \"userexample.com\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)\n\n    def test_empty_email(self):\n        # Test with an empty string as an email\n        email = \"\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)",
        "prompt": "please write a python function , the function signature as below def extract_email_details(email: str):\n    \"\"\"\n    Extracts the username and mailbox suffix from an email address.eg extract_email_details(\"xxx@gmail.com\") returns ('xxx', 'gmail.com')\n    Args:\n        email (str): the email address to extract details from\n\n    Returns:\n        tuple: (username, domain)\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 386,
    "code_type": "method",
    "original_language": "python",
    "file_path": "SoraTranslator\\5cb5566d66aa2c0312046710f42cf77ec6281795\\backend\\Integrators\\utils\\encoding_fix.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "Converts the object file to the specified encoding format",
    "language_version_list": {
      "python": {
        "code_signature": "import shutil\n\n\ndef convert_encoding(input_file_path: str, output_file_path: str, original_encoding=\"cp932\",\n                     target_encoding=\"utf_16\") -> bool:\n    \"\"\"\n    This function converts the encoding of a file from one encoding to another\n\n    Parameters:\n        input_file_path (str): The path to the input file.\n        output_file_path (str): The path to the output file where the converted content is saved.\n        original_encoding (str): The original encoding of the file (default is cp932).\n        target_encoding (str): The target encoding to convert to (default is utf_16).\n\n    Returns:\n        bool: True if the conversion was successful, or if no conversion was needed; False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\nimport os\nimport shutil\nfrom io import open\n\nclass TestFixEncoding(unittest.TestCase):\n    def setUp(self):\n        # Create a directory for test files if it doesn't exist\n        self.test_dir = 'test_files'\n        os.makedirs(self.test_dir, exist_ok=True)\n        self.input_file_path = os.path.join(self.test_dir, 'test_input.txt')\n        self.output_file_path = os.path.join(self.test_dir, 'test_output.txt')\n\n    def tearDown(self):\n        # Remove test directory and all created files after each test\n        shutil.rmtree(self.test_dir)\n\n    def write_to_file(self, file_path, text, encoding):\n        # Helper method to write text to a file with a specific encoding\n        with open(file_path, 'w', encoding=encoding) as f:\n            f.write(text)\n\n    def test_basic_conversion(self):\n        # Test basic conversion from cp932 to utf_16\n        self.write_to_file(self.input_file_path, '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059', 'cp932')\n        result = convert_encoding(self.input_file_path, self.output_file_path)\n        self.assertTrue(result)\n        with open(self.output_file_path, 'r', encoding='utf_16') as f:\n            self.assertEqual(f.read(), '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059')\n\n    def test_no_conversion_needed(self):\n        # Test when no conversion is needed because file is already in target encoding\n        self.write_to_file(self.input_file_path, 'No conversion needed', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'utf_16')\n        self.assertTrue(result)\n\n    def test_output_already_converted(self):\n        # Test behavior when file is already in target encoding and copied directly\n        self.write_to_file(self.input_file_path, 'Already utf_16', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'cp932', 'utf_16')\n        self.assertTrue(result)",
        "prompt": "please write a python function , the function signature as below import shutil\n\n\ndef convert_encoding(input_file_path: str, output_file_path: str, original_encoding=\"cp932\",\n                     target_encoding=\"utf_16\") -> bool:\n    \"\"\"\n    This function converts the encoding of a file from one encoding to another\n\n    Parameters:\n        input_file_path (str): The path to the input file.\n        output_file_path (str): The path to the output file where the converted content is saved.\n        original_encoding (str): The original encoding of the file (default is cp932).\n        target_encoding (str): The target encoding to convert to (default is utf_16).\n\n    Returns:\n        bool: True if the conversion was successful, or if no conversion was needed; False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 390,
    "code_type": "method",
    "original_language": "python",
    "file_path": "dash-chatgpt-challenge\\6b5e530ee1e4d21b8bf7e78c2df7ca15293d0636\\demo_sentiment\\demo.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Split the input text string into sentences",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef split_into_sentences(text:str) -> List[str]:\n    \"\"\"\n    Split the input text string into sentences.\n\n    Args:\n        text (str): The input text to be split into sentences.\n\n    Returns:\n        list: A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestSplitIntoSentences(unittest.TestCase):\n\n    def test_basic_splitting(self):\n        # Test splitting a basic text with clear punctuation\n        text = \"Hello world! How are you? I am fine.\"\n        expected = [\"Hello world!\", \"How are you?\", \"I am fine.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_complex_punctuation(self):\n        # Test splitting text that includes quotes and commas\n        text = 'He said, This is amazing! Then he left.'\n        expected = ['He said, This is amazing!', \"Then he left.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_with_no_punctuation(self):\n        # Test text that has no punctuation marks\n        text = \"Hello world how are you\"\n        expected = [\"Hello world how are you\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_empty_string(self):\n        # Test empty string input\n        text = \"\"\n        expected = []\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_into_sentences(text:str) -> List[str]:\n    \"\"\"\n    Split the input text string into sentences.\n\n    Args:\n        text (str): The input text to be split into sentences.\n\n    Returns:\n        list: A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 392,
    "code_type": "method",
    "original_language": "python",
    "file_path": "AoC\\2161e6aef7c480f3fb013dd9224ee014073097d6\\2015\\Day_10\\number.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,grouping by consecutive digits.",
    "language_version_list": {
      "python": {
        "code_signature": "def look_and_say(number: str):\n    \"\"\"\n    Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n    grouping by consecutive digits.\n\n    Args:\n        number (str): The current sequence as a string.\n\n    Returns:\n        str: The next sequence in the 'look-and-say' series.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestLookAndSay(unittest.TestCase):\n\n    def test_single_digit(self):\n        # Test with a single digit to see if it replicates correctly\n        self.assertEqual(look_and_say('1'), '11')\n\n    def test_repetitive_digits(self):\n        # Test a sequence of the same digits\n        self.assertEqual(look_and_say('111'), '31')\n\n    def test_mixed_digits(self):\n        # Test a sequence with different digits\n        self.assertEqual(look_and_say('1211'), '111221')\n\n    def test_complex_sequence(self):\n        # Test a more complex sequence\n        self.assertEqual(look_and_say('312211'), '13112221')\n",
        "prompt": "please write a python function , the function signature as below def look_and_say(number: str):\n    \"\"\"\n    Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n    grouping by consecutive digits.\n\n    Args:\n        number (str): The current sequence as a string.\n\n    Returns:\n        str: The next sequence in the 'look-and-say' series.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 395,
    "code_type": "method",
    "original_language": "python",
    "file_path": "advent-of-code-2023\\52c3e66ec60e675ab7963c812fb62177ce210a02\\day-01\\chat-gpt-pt1.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n",
    "language_version_list": {
      "python": {
        "code_signature": "def sum_calibration_values(calibration_document) -> int:\n    \"\"\"\n    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n\n    Args:\n        calibration_document (iterable): An iterable of strings, each representing a line of text.\n\n    Returns:\n        int: The total sum of all calibration values.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestSumCalibrationValues(unittest.TestCase):\n\n    def test_basic_calculations(self):\n        # Test with a simple input where lines contain at least two digits\n        document = [\n            \"Reading 1234 calibration\",\n            \"Measure 5678 complete\",\n            \"End of data 91011\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 163)\n\n    def test_no_digits(self):\n        # Test lines with no digits\n        document = [\n            \"No numbers here\",\n            \"Still no numbers\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_empty_lines(self):\n        # Test with empty lines or lines with spaces\n        document = [\n            \"\",\n            \"   \"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_mixed_content(self):\n        # Test with a mixture of valid and invalid lines\n        document = [\n            \"Good line 1524 end\",\n            \"Bad line\",\n            \"Another good line 7681\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 85)",
        "prompt": "please write a python function , the function signature as below def sum_calibration_values(calibration_document) -> int:\n    \"\"\"\n    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n\n    Args:\n        calibration_document (iterable): An iterable of strings, each representing a line of text.\n\n    Returns:\n        int: The total sum of all calibration values.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 396,
    "code_type": "method",
    "original_language": "python",
    "file_path": "compprog\\be5d4a09aa5297c9afc2ef85baa61b3732149a5b\\abc\\abc354\\f\\chatgpt.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Given an array of integers nums, find the length of the longest strictly increasing subsequence in it",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest strictly increasing subsequence in it\n\n    Args:\n        nums (List[int]): int array\n\n    Returns:\n        int: longest strictly increasing subsequence\n    \"\"\"",
        "test_code": "import unittest\nfrom typing import List\n\nclass TestLengthOfLIS(unittest.TestCase):\n\n    def test_empty_list(self):\n        # Test the function with an empty list\n        self.assertEqual(length_of_LIS([]), 0)\n\n    def test_single_element(self):\n        # Test with a list containing only one element\n        self.assertEqual(length_of_LIS([7]), 1)\n\n    def test_increasing_sequence(self):\n        # Test with a list where the elements are strictly increasing\n        self.assertEqual(length_of_LIS([1, 2, 3, 4, 5]), 5)\n\n    def test_decreasing_sequence(self):\n        # Test with a list where the elements are strictly decreasing\n        self.assertEqual(length_of_LIS([5, 4, 3, 2, 1]), 1)\n\n    def test_complex_sequence(self):\n        # Test with a complex sequence with mix of increasing and decreasing elements\n        self.assertEqual(length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]), 4)\n\n    def test_all_equal_elements(self):\n        # Test with all elements in the list being equal\n        self.assertEqual(length_of_LIS([2, 2, 2, 2]), 1)\n\n    def test_with_negative_numbers(self):\n        # Test with a mix of negative and positive numbers\n        self.assertEqual(length_of_LIS([-1, -2, -3, 0, 1, 2]), 4)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest strictly increasing subsequence in it\n\n    Args:\n        nums (List[int]): int array\n\n    Returns:\n        int: longest strictly increasing subsequence\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 398,
    "code_type": "method",
    "original_language": "python",
    "file_path": "python-sample\\2b6587f7a16471244cc9e8cca58ac4f2d2a92d51\\3.Extract files not in the csv.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Copy files from folderA to folderB excluding those listed in the specified CSV file ",
    "language_version_list": {
      "python": {
        "code_signature": "import os\nimport csv\nimport shutil\n\n\ndef extract_files_excluding_csv(folderA: str, csv_file: str, folderB: str):\n    \"\"\"\n    Copy files from folderA to folderB excluding those listed in the specified CSV file.\n\n    Args:\n        folderA: Path to the source folder containing all files (str).\n        csv_file: Path to the CSV file containing filenames to exclude (str).\n        folderB: Path to the destination folder (str).\n\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import os\nimport shutil\nimport unittest\n\n\nclass TestExtractFiles(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up test directories and files before each test case.\"\"\"\n        self.folderA = \"test_folderA\"\n        self.folderB = \"test_folderB\"\n        os.makedirs(self.folderA, exist_ok=True)\n        os.makedirs(self.folderB, exist_ok=True)\n\n    def tearDown(self):\n        \"\"\"Clean up the test directories after each test case.\"\"\"\n        shutil.rmtree(self.folderA)\n        shutil.rmtree(self.folderB)\n\n    def create_csv(self, filename_list):\n        \"\"\"Helper method to create a CSV file for testing.\"\"\"\n        csv_file = \"test_exclude.csv\"\n        with open(csv_file, \"w\", newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"filename\"])  # Write header\n            for name in filename_list:\n                writer.writerow([name])\n        return csv_file\n\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with some files excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n        with open(os.path.join(self.folderA, \"file3.txt\"), \"w\") as f:\n            f.write(\"Content of file 3\")\n\n        csv_file = self.create_csv([\"file2.txt\"])  # Exclude file2.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n        self.assertFalse(os.path.exists(os.path.join(self.folderB, \"file2.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file3.txt\")))\n\n    def test_empty_folderA(self):\n        \"\"\"Test when folderA is empty.\"\"\"\n        csv_file = self.create_csv([\"file1.txt\"])  # Exclude file1.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_all_files_excluded(self):\n        \"\"\"Test when all files are excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n\n        csv_file = self.create_csv([\"file1.txt\", \"file2.txt\"])  # Exclude all files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_destination_folder_already_has_files(self):\n        \"\"\"Test when folderB already contains files.\"\"\"\n        with open(os.path.join(self.folderB, \"existing_file.txt\"), \"w\") as f:\n            f.write(\"This is an existing file.\")\n\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        # Check if both existing and new files are present\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"existing_file.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n\n    def test_empty_csv_file(self):\n        \"\"\"Test with an empty CSV file.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Empty CSV, do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))",
        "prompt": "please write a python function , the function signature as below import os\nimport csv\nimport shutil\n\n\ndef extract_files_excluding_csv(folderA: str, csv_file: str, folderB: str):\n    \"\"\"\n    Copy files from folderA to folderB excluding those listed in the specified CSV file.\n\n    Args:\n        folderA: Path to the source folder containing all files (str).\n        csv_file: Path to the CSV file containing filenames to exclude (str).\n        folderB: Path to the destination folder (str).\n\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 401,
    "code_type": "method",
    "original_language": "python",
    "file_path": "bitbox-wallet-app\\e6706873ef4ea1ad9332009fd01b82c076e71416\\scripts\\check-locize-placeholders.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Find a placeholder in the format {{ placeholder }}} from the string and return a list of all matching placeholders\n",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\ndef find_placeholders(text):\n    \"\"\"\n    Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n\n    Args:\n        text (str): The input string containing potential placeholders.\n\n    Returns:\n        list: A list of matching placeholders.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestFindPlaceholders(unittest.TestCase):\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test string with multiple placeholders.\"\"\"\n        input_text = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\"\n        expected_output = ['placeholder1', 'placeholder2', 'placeholder3']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_no_placeholders(self):\n        \"\"\"Test string with no placeholders.\"\"\"\n        input_text = \"This string has no placeholders.\"\n        expected_output = []\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_single_placeholder(self):\n        \"\"\"Test string with a single placeholder.\"\"\"\n        input_text = \"The only placeholder is {{ singlePlaceholder }}.\"\n        expected_output = ['singlePlaceholder']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_placeholder_with_spaces(self):\n        \"\"\"Test string with placeholders that have extra spaces.\"\"\"\n        input_text = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\"\n        expected_output = ['placeholder_with_spaces', 'placeholder2']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n",
        "prompt": "please write a python function , the function signature as below import re\n\ndef find_placeholders(text):\n    \"\"\"\n    Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n\n    Args:\n        text (str): The input string containing potential placeholders.\n\n    Returns:\n        list: A list of matching placeholders.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 404,
    "code_type": "method",
    "original_language": "python",
    "file_path": "dengjunhui-data-structure\\f54a9a850704302a6eb3d0eb2660149563346007\\src\\fibonacci\\matrix_exponentiation.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Computes the n-th power of a matrix using the fast exponentiation method.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    \"\"\"\n    Computes the n-th power of a matrix using the fast exponentiation method.\n\n    Args:\n        matrix (List[List[int]]): A square matrix to be exponentiated.\n        n (int): The exponent to raise the matrix to. Must be a non-negative integer.\n\n    Returns:\n        List[List[int]]: The matrix raised to the power of n.\n\n    Raises:\n        ValueError: If n is negative.\n        TypeError: If matrix is not a list of lists or n is not an integer.\n    \"\"\"",
        "test_code": "import unittest\n\nclass TestMatrixPower(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        # Testing the power function with an identity matrix\n        matrix = [[1, 0], [0, 1]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 1)\n        self.assertEqual(result, expected)\n\n    def test_zero_power(self):\n        # Testing matrix to the power of zero (should return identity)\n        matrix = [[2, 3], [1, 4]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 0)\n        self.assertEqual(result, expected)\n\n    def test_positive_power(self):\n        # Testing matrix to a positive power\n        matrix = [[2, 1], [1, 3]]\n        expected = [[5, 5], [5, 10]]  # This is the result of matrix^2\n        result = power(matrix, 2)\n        self.assertEqual(result, expected)\n\n    def test_negative_power(self):\n        # Testing matrix to a negative power (should raise ValueError)\n        matrix = [[2, 1], [1, 3]]\n        with self.assertRaises(ValueError):\n            power(matrix, -1)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    \"\"\"\n    Computes the n-th power of a matrix using the fast exponentiation method.\n\n    Args:\n        matrix (List[List[int]]): A square matrix to be exponentiated.\n        n (int): The exponent to raise the matrix to. Must be a non-negative integer.\n\n    Returns:\n        List[List[int]]: The matrix raised to the power of n.\n\n    Raises:\n        ValueError: If n is negative.\n        TypeError: If matrix is not a list of lists or n is not an integer.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 405,
    "code_type": "method",
    "original_language": "python",
    "file_path": "redditSidebarUpdater\\8faf879dbfb8dcd51bc536ff4c1f66128e22b03b\\src\\redditSidebarUpdater_Playoffs.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Remove the part before the first upper case letter and the first lower case letter from the string",
    "language_version_list": {
      "python": {
        "code_signature": "def remove_parts_of_string(*strings):\n    \"\"\"\n    Remove the part before the first upper case letter and the first lower case letter from the string\n\n    For example:\n        input: 1234AbCde5678\n        output: AbCde5678\n    Args:\n        *strings: Accepts one or more strings as variable arguments\n    Returns:\n\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestRemovePartsOfString(unittest.TestCase):\n\n    def test_case_3(self):\n        # Test with a string that has no uppercase letters\n        result = remove_parts_of_string(\"abcdefg\")\n        self.assertEqual(result, [\"abcdefg\"])\n\n    def test_case_4(self):\n        # Test with a string that has no lowercase letters\n        result = remove_parts_of_string(\"ABCDEFG\")\n        self.assertEqual(result, [\"ABCDEFG\"])\n\n    def test_case_5(self):\n        # Test with a string that has mixed cases\n        result = remove_parts_of_string(\"1234AbCde5678\")\n        self.assertEqual(result, [\"AbCde5678\"])\n\n    def test_case_6(self):\n        # Test with an empty string\n        result = remove_parts_of_string(\"\")\n        self.assertEqual(result, [\"\"])\n\n    def test_case_7(self):\n        # Test with a string that has only one uppercase letter\n        result = remove_parts_of_string(\"X\")\n        self.assertEqual(result, [\"X\"])\n\n    def test_case_8(self):\n        # Test with a string that has only one lowercase letter\n        result = remove_parts_of_string(\"y\")\n        self.assertEqual(result, [\"y\"])\n",
        "prompt": "please write a python function , the function signature as below def remove_parts_of_string(*strings):\n    \"\"\"\n    Remove the part before the first upper case letter and the first lower case letter from the string\n\n    For example:\n        input: 1234AbCde5678\n        output: AbCde5678\n    Args:\n        *strings: Accepts one or more strings as variable arguments\n    Returns:\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 406,
    "code_type": "class",
    "original_language": "python",
    "file_path": "autogit\\ba45731233991817239e8116a024edb962dc602e\\autogit\\utils.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Implement a colors class that prints strings in color",
    "language_version_list": {
      "python": {
        "code_signature": "class Colors:\n\n    @staticmethod\n    def red(text: str) -> str:\n        \"\"\"text in red color\"\"\"\n        pass\n\n    @staticmethod\n    def green(text: str) -> str:\n        \"\"\"text in green color\"\"\"\n\n    @staticmethod\n    def blue(text: str) -> str:\n        \"\"\"text in blue color\"\"\"\n\n    @staticmethod\n    def yellow(text: str) -> str:\n        \"\"\"text in yellow color\"\"\"\n\n    @staticmethod\n    def magenta(text: str) -> str:\n        \"\"\"text in magenta color\"\"\"\n\n    @staticmethod\n    def cyan(text: str) -> str:\n        \"\"\"text in cyan color\"\"\"\n",
        "test_code": "import unittest\n\nclass TestColors(unittest.TestCase):\n\n    def test_red(self):\n        \"\"\"Test the red color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[91mHello\\033[0m\"\n        self.assertEqual(Colors.red(input_text), expected_output)\n\n    def test_green(self):\n        \"\"\"Test the green color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[92mHello\\033[0m\"\n        self.assertEqual(Colors.green(input_text), expected_output)\n\n    def test_blue(self):\n        \"\"\"Test the blue color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[94mHello\\033[0m\"\n        self.assertEqual(Colors.blue(input_text), expected_output)\n\n    def test_yellow(self):\n        \"\"\"Test the yellow color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[93mHello\\033[0m\"\n        self.assertEqual(Colors.yellow(input_text), expected_output)\n\n    def test_magenta(self):\n        \"\"\"Test the magenta color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[95mHello\\033[0m\"\n        self.assertEqual(Colors.magenta(input_text), expected_output)\n\n    def test_cyan(self):\n        \"\"\"Test the cyan color method\"\"\"\n        input_text = \"Hello\"\n        expected_output = \"\\033[96mHello\\033[0m\"\n        self.assertEqual(Colors.cyan(input_text), expected_output)\n\n    def test_combined_colors(self):\n        \"\"\"Test combining different color methods\"\"\"\n        input_text_red = Colors.red(\"Red\")\n        input_text_blue = Colors.blue(\"Blue\")\n        input_text_combined = f\"{input_text_red} and {input_text_blue}\"\n        expected_output = \"\\033[91mRed\\033[0m and \\033[94mBlue\\033[0m\"\n        self.assertEqual(input_text_combined, expected_output)\n",
        "prompt": "please write a python class , the class signature as below class Colors:\n\n    @staticmethod\n    def red(text: str) -> str:\n        \"\"\"text in red color\"\"\"\n        pass\n\n    @staticmethod\n    def green(text: str) -> str:\n        \"\"\"text in green color\"\"\"\n\n    @staticmethod\n    def blue(text: str) -> str:\n        \"\"\"text in blue color\"\"\"\n\n    @staticmethod\n    def yellow(text: str) -> str:\n        \"\"\"text in yellow color\"\"\"\n\n    @staticmethod\n    def magenta(text: str) -> str:\n        \"\"\"text in magenta color\"\"\"\n\n    @staticmethod\n    def cyan(text: str) -> str:\n        \"\"\"text in cyan color\"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 410,
    "code_type": "method",
    "original_language": "python",
    "file_path": "digital-forensics-lab\\d7a59b5c116a003994d0b9e9258c32aa228dab09\\Illegal_Possession_Images\\lab_files\\wlan_decrypt\\crackWEP40_GPU_Improved_v1.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Checks the XOR sums of specific columns in a given combination array.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef check_xor_sum(combination: np.ndarray):\n    \"\"\"\n    Checks the XOR sums of specific columns in a given combination array.\n\n    Args:\n        combination (np.ndarray): A 2D numpy array where each column corresponds\n                                  to a specific value.\n\n    Returns:\n        bool: True if the XOR sums of the specified columns match the required\n              values; otherwise, False.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCheckXorSum(unittest.TestCase):\n\n    def test_correct_xor_sums(self):\n        \"\"\" Test with combination values that produce the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_incorrect_xor_sums(self):\n        \"\"\" Test with combination values that do not meet the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_edge_case_with_zero(self):\n        \"\"\" Test with a combination where all values are zero. \"\"\"\n        combination = np.zeros((1, 8), dtype=int)  # 1 row of zeros\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_large_numbers(self):\n        \"\"\" Test with large numbers in the combination. \"\"\"\n        combination = np.array([\n            [0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000],\n            [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_multiple_rows(self):\n        \"\"\" Test with a combination that contains multiple rows. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00]\n        ])\n        self.assertTrue(check_xor_sum(combination))",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef check_xor_sum(combination: np.ndarray):\n    \"\"\"\n    Checks the XOR sums of specific columns in a given combination array.\n\n    Args:\n        combination (np.ndarray): A 2D numpy array where each column corresponds\n                                  to a specific value.\n\n    Returns:\n        bool: True if the XOR sums of the specified columns match the required\n              values; otherwise, False.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 412,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ecdo\\40700402154c8b71029f908b758a9afa10847c32\\5-TOOLS-DATA-DEV\\scripts\\remove-newlines.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "Read the input file input.txt, remove line breaks, and add Spaces between each line",
    "language_version_list": {
      "python": {
        "code_signature": "",
        "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestFormatText(unittest.TestCase):\n\n    def test_basic_text(self):\n        # Test with basic text\n        input_text = \"This is line one.\\nThis is line two.\\nThis is line three.\"\n        expected_output = \"This is line one. This is line two. This is line three.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)  # Go back to the start of the file\n            output_file_path = tempfile.mktemp(suffix='.txt')  # Create a temporary output file\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_single_line(self):\n        # Test with a single line\n        input_text = \"This is a single line.\"\n        expected_output = \"This is a single line.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_empty_file(self):\n        # Test with an empty file\n        input_text = \"\"\n        expected_output = \"\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_file_with_no_newlines(self):\n        # Test with text that has no newlines\n        input_text = \"This is a continuous line without breaks.\"\n        expected_output = \"This is a continuous line without breaks.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n",
        "prompt": "please write a python function , the function signature as below ",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 413,
    "code_type": "method",
    "original_language": "python",
    "file_path": "AtCoder\\19300ad200cbf5fa8ba9c6f0616c60a7c3168f19\\ABC\\ABC363\\D.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef get_palindrome_list(n: int) ->  List[int]:\n    \"\"\"\n    Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n\n    Args:\n        n (int): range number\n\n    Returns:\n        List[int]: Palindrome numbers\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestNthPalindrome(unittest.TestCase):\n    def test_single_digit(self):\n        \"\"\"Test case for the first palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1), [0], \"The first palindrome should be 0\")\n\n    def test_edge_of_single_and_double_digits(self):\n        \"\"\"Test case for the tenth palindrome, transitioning to double digits\"\"\"\n        self.assertEqual(get_palindrome_list(10), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n                         \"The tenth palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\")\n\n    def test_edge_of_double_and_triple_digits(self):\n        \"\"\"Test case for the 100th palindrome, transitioning to triple digits\"\"\"\n        self.assertEqual(get_palindrome_list(100), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99],\n                         \"The 100th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]\")\n\n    def test_large_number(self):\n        \"\"\"Test case for a larger number, e.g., the 1000th palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1000),\n                         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141,\n                          151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333,\n                          343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525,\n                          535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717,\n                          727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909,\n                          919, 929, 939, 949, 959, 969, 979, 989, 999]\n                         ,\n                         \"The 1000th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]\")\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_palindrome_list(n: int) ->  List[int]:\n    \"\"\"\n    Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n\n    Args:\n        n (int): range number\n\n    Returns:\n        List[int]: Palindrome numbers\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 414,
    "code_type": "method",
    "original_language": "python",
    "file_path": "alexwan0.github.io\\ab9cb15f26f86dfdce94be3a1c6d5986fa42bdae\\bibtex_to_html.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "Extract the title, author and year of the article from the bib file.",
    "language_version_list": {
      "python": {
        "code_signature": "def extract_bib_info(bib_file: str):\n    \"\"\"\n    Extracts the title, author, and year from a BibTeX file.bib file content such as @article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\n\n    Args:\n        bib_file (str): The path to the BibTeX file.\n\n    Returns:\n        list of dict: A list containing dictionaries with title, author, and year for each article.\n    \"\"\"\n",
        "test_code": "import re\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractBibInfo(unittest.TestCase):\n\n    def test_valid_entry(self):\n        \"\"\"Test extraction from a valid BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'A Comprehensive Study on AI', 'author': 'John Doe and Jane Smith', 'year': '2024'}]\n            self.assertEqual(result, expected)\n\n    def test_multiple_entries(self):\n        \"\"\"Test extraction from multiple BibTeX entries.\"\"\"\n        mock_bib = (\n            \"@article{sample2024,\\n\"\n            \"  author = {John Doe},\\n\"\n            \"  title = {A Comprehensive Study on AI},\\n\"\n            \"  year = {2024}\\n}\\n\"\n            \"@article{sample2023,\\n\"\n            \"  author = {Jane Smith},\\n\"\n            \"  title = {Deep Learning Techniques},\\n\"\n            \"  year = {2023}\\n}\"\n        )\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [\n                {'title': 'A Comprehensive Study on AI', 'author': 'John Doe', 'year': '2024'},\n                {'title': 'Deep Learning Techniques', 'author': 'Jane Smith', 'year': '2023'}\n            ]\n            self.assertEqual(result, expected)\n\n    def test_missing_fields(self):\n        \"\"\"Test extraction when some fields are missing.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe},\\n  title = {Title Missing Year}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Missing Year', 'author': 'John Doe', 'year': None}]\n            self.assertEqual(result, expected)\n\n    def test_empty_file(self):\n        \"\"\"Test extraction from an empty BibTeX file.\"\"\"\n        mock_bib = \"\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = []\n            self.assertEqual(result, expected)\n\n    def test_incorrect_format(self):\n        \"\"\"Test extraction from a badly formatted BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = John Doe,\\n  title = {Title Without Braces},\\n  year = 2024\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Without Braces', 'author': None, 'year': None}]\n            self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below def extract_bib_info(bib_file: str):\n    \"\"\"\n    Extracts the title, author, and year from a BibTeX file.bib file content such as @article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\n\n    Args:\n        bib_file (str): The path to the BibTeX file.\n\n    Returns:\n        list of dict: A list containing dictionaries with title, author, and year for each article.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 418,
    "code_type": "method",
    "original_language": "python",
    "file_path": "competitive-coding\\89a0142a948fcc2e092ad94c71ac8019f48c3c0f\\src\\leetcode_329.py",
    "question_type": "Algorithm and data structure",
    "summary": "Give you an integer array nums and find the length of the longest strictly increasing subsequence in it.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Give you an integer array nums and find the length of the longest strictly increasing subsequence in it.\n    For example:\n        input: [10, 9, 2, 5, 3, 7, 101, 18]\n        output: 4\n\n    Args:\n        nums(List[int]): integer array\n\n    Returns:\n        int: the length of the longest strictly increasing subsequence\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestLengthOFLIS(unittest.TestCase):\n    def test_case_1(self):\n        nums = [10, 9, 2, 5, 3, 7, 101, 18]\n        expected = 4\n        self.assertEqual(length_of_LIS(nums), expected)\n\n    def test_case_2(self):\n        nums = [0, 1, 0, 3, 2, 3]\n        expected = 4\n        self.assertEqual(length_of_LIS(nums), expected)\n\n    def test_case_3(self):\n        nums = [7, 7, 7, 7, 7, 7, 7]\n        expected = 1\n        self.assertEqual(length_of_LIS(nums), expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Give you an integer array nums and find the length of the longest strictly increasing subsequence in it.\n    For example:\n        input: [10, 9, 2, 5, 3, 7, 101, 18]\n        output: 4\n\n    Args:\n        nums(List[int]): integer array\n\n    Returns:\n        int: the length of the longest strictly increasing subsequence\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 420,
    "code_type": "class",
    "original_language": "python",
    "file_path": "computer-sciences\\c5d11d4b8387f01bb804788db030bf035ace10ad\\Python\\exams\\worms\\worms-chatgpt.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n",
    "language_version_list": {
      "python": {
        "code_signature": "def get_min_distance(file_path, word1, word2):\n    \"\"\"\n    Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n\n    Args:\n        file_path (str):\n        word1 (str):\n        word2 (str):\n\n    Returns:\n\n    \"\"\"",
        "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n    @patch('builtins.open')\n    def test_simple_case(self, mock_open):\n        # Mock the file read operation\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n\n\n    @patch('builtins.open')\n    def test_multiple_lines(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello planet\",\n            \"world hello planet\",\n            \"hello world planet\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (1, 1))\n\n    @patch('builtins.open')\n    def test_large_distance(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 27))\n\n    @patch('builtins.open')\n    def test_adjacent_words(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n",
        "prompt": "please write a python class , the class signature as below def get_min_distance(file_path, word1, word2):\n    \"\"\"\n    Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n\n    Args:\n        file_path (str):\n        word1 (str):\n        word2 (str):\n\n    Returns:\n\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 423,
    "code_type": "method",
    "original_language": "python",
    "file_path": "TestGen-Thesis\\245b7d14338b7495bd5c6b6eb7ff66f49c3bbdad\\scripts\\helpers.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "Writes a line to a text file, checks whether a line with the same content already exists before writing, and does not write if it does",
    "language_version_list": {
      "python": {
        "code_signature": "def write_unique_line_to_file(filename: str, line_content: str):\n    \"\"\"\n    Writes a line to a text file only if the line with the same content does not already exist.\n\n    Args:\n        filename (str): The name of the file to write to.\n        line_content (str): The content of the line to write.\n\n    Returns:\n        None\n    \"\"\"",
        "test_code": "import unittest\nimport os\n\n\nclass TestWriteUniqueLineToFile(unittest.TestCase):\n    def setUp(self):\n        # Setup: create a temporary file for testing.\n        self.filename = 'test_file.txt'\n        with open(self.filename, 'w') as file:\n            file.write('')\n\n    def test_write_new_line(self):\n        # Test case 1: Writing a new line to an empty file.\n        line_content = \"First unique line.\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertIn(line_content, file.read())\n\n    def test_write_duplicate_line(self):\n        # Test case 2: Attempting to write a duplicate line.\n        line_content = \"First unique line.\"\n        # Write the line once.\n        write_unique_line_to_file(self.filename, line_content)\n        # Attempt to write it again.\n        write_unique_line_to_file(self.filename, line_content)\n        # Check if the line was written only once.\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read().strip().count(line_content), 1)\n\n    def test_write_multiple_unique_lines(self):\n        # Test case 3: Writing multiple unique lines.\n        lines = [\"First unique line.\", \"Second unique line.\", \"Third unique line.\"]\n        for line in lines:\n            write_unique_line_to_file(self.filename, line)\n        with open(self.filename, 'r') as file:\n            file_content = file.read()\n            for line in lines:\n                self.assertIn(line, file_content)\n\n    def test_write_empty_line(self):\n        # Test case 5: Writing an empty line, should not write.\n        line_content = \"\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read(), \"\")\n",
        "prompt": "please write a python function , the function signature as below def write_unique_line_to_file(filename: str, line_content: str):\n    \"\"\"\n    Writes a line to a text file only if the line with the same content does not already exist.\n\n    Args:\n        filename (str): The name of the file to write to.\n        line_content (str): The content of the line to write.\n\n    Returns:\n        None\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 424,
    "code_type": "method",
    "original_language": "python",
    "file_path": "adventofcode\\60cdeebfe2448f8ae516c0e4dd34adf7e63503c5\\2019\\day15\\floyd_warshall.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.",
    "language_version_list": {
      "python": {
        "code_signature": "import heapq\nfrom typing import Dict\n\n\ndef dijkstra(graph: Dict, start: str) -> Dict:\n    \"\"\"\n    Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n    Args:\n        graph(Dict): A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n        start(str): The starting node for the shortest path search.\n\n    Returns:\n        Dict: A dictionary with the shortest distance from the start node to each node.\n    \"\"\"\n",
        "test_code": "import unittest\n\nclass TestDijkstraAlgorithm(unittest.TestCase):\n\n    def setUp(self):\n        # Sample graphs for testing\n        self.graph1 = {\n            'A': [('B', 1), ('C', 4)],\n            'B': [('A', 1), ('C', 2), ('D', 5)],\n            'C': [('A', 4), ('B', 2), ('D', 1)],\n            'D': [('B', 5), ('C', 1)],\n        }\n\n        self.graph2 = {\n            'A': [('B', 2)],\n            'B': [('A', 2), ('C', 3)],\n            'C': [('B', 3), ('D', 1)],\n            'D': [('C', 1)],\n        }\n\n        self.graph_with_isolated_node = {\n            'A': [('B', 1)],\n            'B': [('A', 1)],\n            'C': [],  # Isolated node\n        }\n\n        self.graph_with_negative_weight = {\n            'A': [('B', 2), ('C', 1)],\n            'B': [('D', 3)],\n            'C': [('B', -1), ('D', 4)],\n            'D': [],\n        }\n\n    def test_shortest_paths_graph1(self):\n        \"\"\"Test shortest paths in a normal graph.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': 3, 'D': 4}\n        result = dijkstra(self.graph1, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_graph2(self):\n        \"\"\"Test shortest paths in a different normal graph.\"\"\"\n        expected = {'A': 0, 'B': 2, 'C': 5, 'D': 6}\n        result = dijkstra(self.graph2, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_with_isolated_node(self):\n        \"\"\"Test shortest paths with an isolated node.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'A')\n        self.assertEqual(result, expected)\n\n\n    def test_starting_at_isolated_node(self):\n        \"\"\"Test when starting at an isolated node.\"\"\"\n        expected = {'C': 0, 'A': float('inf'), 'B': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'C')\n        self.assertEqual(result, expected)",
        "prompt": "please write a python function , the function signature as below import heapq\nfrom typing import Dict\n\n\ndef dijkstra(graph: Dict, start: str) -> Dict:\n    \"\"\"\n    Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n    Args:\n        graph(Dict): A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n        start(str): The starting node for the shortest path search.\n\n    Returns:\n        Dict: A dictionary with the shortest distance from the start node to each node.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 427,
    "code_type": "method",
    "original_language": "python",
    "file_path": "computer-sciences\\40f5a3ec7464e27b79fe1e0d9cd0e797f3ee05ef\\Python\\exams\\munodi\\munodi-chatbox_gpt.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict\n\n\ndef check_sequences(filename:str) -> Dict:\n    \"\"\"\n    Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1.\n    For example: (2, 4, 6, 8) is Mundi sequence\n\n    Args:\n        filename(str): file path\n\n    Returns:\n        Dict: sequences weather is Munodi sequence\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestCheckSequences(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test cases with sequences.\"\"\"\n        # Create a temporary file with test cases\n        self.test_file = 'test_sequences.dat'\n        with open(self.test_file, 'w') as f:\n            f.write(\"2,4,6,8\\n\")    # Munodi sequence (d = 2)\n            f.write(\"1,3,5,7\\n\")    # Munodi sequence (d = 2)\n            f.write(\"10,20,30\\n\")   # Munodi sequence (d = 10)\n            f.write(\"1,2,4,8\\n\")    # Not a Munodi sequence (d changes)\n            f.write(\"5,10,15,20\\n\") # Munodi sequence (d = 5)\n\n    def test_sequences(self):\n        \"\"\"Test the sequences for Munodi property.\"\"\"\n        expected_results = {\n            (2, 4, 6, 8): True,\n            (1, 3, 5, 7): True,\n            (10, 20, 30): True,\n            (1, 2, 4, 8): False,\n            (5, 10, 15, 20): True,\n        }\n        results = check_sequences(self.test_file)\n        for seq in expected_results:\n            self.assertEqual(results[seq], expected_results[seq])\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after tests.\"\"\"\n        import os\n        os.remove(self.test_file)",
        "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef check_sequences(filename:str) -> Dict:\n    \"\"\"\n    Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1.\n    For example: (2, 4, 6, 8) is Mundi sequence\n\n    Args:\n        filename(str): file path\n\n    Returns:\n        Dict: sequences weather is Munodi sequence\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 428,
    "code_type": "method",
    "original_language": "python",
    "file_path": "omnipy\\b1b9e610257c1ba11f73472fcf8452fd6fe8d90e\\src\\omnipy\\util\\mako_helpers.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Parses a Python type hint string and returns the individual types as a list of strings.",
    "language_version_list": {
      "python": {
        "code_signature": "import ast\nfrom typing import List\n\n\ndef parse_type_hint(type_hint_string:str) -> List:\n    \"\"\"\n    Parses a Python type hint string and returns the individual types as a list of strings.\n\n    Args:\n        type_hint_string (str): The type hint string to parse.\n\n    Returns:\n        list: The individual types parsed from the type hint string.\n\n    Example:\n        type_hint = \"Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]\"\n        parsed_types = parse_type_hint(type_hint)\n        print(parsed_types)\n        # Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',\n                   'str', 'Optional', 'int']\n    \"\"\"\n",
        "test_code": "import unittest\n\n\n# Assuming the parse_type_hint function is defined above or imported here\n\nclass TestParseTypeHint(unittest.TestCase):\n\n    def test_basic_types(self):\n        type_hint = 'int'\n        expected = ['int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_list_type(self):\n        type_hint = 'List[int]'\n        expected = ['List', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_union_type(self):\n        type_hint = 'Union[str, float]'\n        expected = ['Union', 'str', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_tuple_type(self):\n        type_hint = 'Tuple[str, int, float]'\n        expected = ['Tuple', 'str', 'int', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_complex_type(self):\n        type_hint = 'List[Union[int, float], Tuple[str, int]]'\n        expected = ['List', 'Union', 'int', 'float', 'Tuple', 'str', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n",
        "prompt": "please write a python function , the function signature as below import ast\nfrom typing import List\n\n\ndef parse_type_hint(type_hint_string:str) -> List:\n    \"\"\"\n    Parses a Python type hint string and returns the individual types as a list of strings.\n\n    Args:\n        type_hint_string (str): The type hint string to parse.\n\n    Returns:\n        list: The individual types parsed from the type hint string.\n\n    Example:\n        type_hint = \"Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]\"\n        parsed_types = parse_type_hint(type_hint)\n        print(parsed_types)\n        # Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',\n                   'str', 'Optional', 'int']\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 430,
    "code_type": "method",
    "original_language": "python",
    "file_path": "scratch\\b004193d0799617bd21194a35a69bf20c37f1230\\misc\\paths_between_rects.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Check whether two rectangles intersect in the vertical direction",
    "language_version_list": {
      "python": {
        "code_signature": "def intersect_vertically(rect1, rect2):\n    \"\"\"\n    Check whether two rectangles intersect in the vertical direction\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect vertically, False otherwise.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestIntersectVertically(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case3(self):\n        # Test case where rectangles partially overlap vertically\n        rect1 = (0, 1, 2, 4)\n        rect2 = (1, 0, 3, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case4(self):\n        # Test case where rectangles are identical\n        rect1 = (0, 0, 2, 2)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case5(self):\n        # Test case where one rectangle is completely inside the other\n        rect1 = (0, 0, 4, 4)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n",
        "prompt": "please write a python function , the function signature as below def intersect_vertically(rect1, rect2):\n    \"\"\"\n    Check whether two rectangles intersect in the vertical direction\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect vertically, False otherwise.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 431,
    "code_type": "method",
    "original_language": "python",
    "file_path": "scratch\\b004193d0799617bd21194a35a69bf20c37f1230\\misc\\paths_between_rects.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Check whether two rectangles intersect in the horizontal direction",
    "language_version_list": {
      "python": {
        "code_signature": "def intersect_horizontally(rect1, rect2):\n    \"\"\"\n    Determine if two rectangles intersect horizontally.\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect horizontally, False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestIntersectHorizontally(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with rectangles touching at a point (not overlapping).\"\"\"\n        rect1 = (0, 0, 1, 1)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case3(self):\n        \"\"\"Test with adjacent rectangles (no overlap).\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (2, 0, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case4(self):\n        \"\"\"Test with one rectangle fully inside another.\"\"\"\n        rect1 = (1, 1, 4, 4)\n        rect2 = (2, 2, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case5(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n",
        "prompt": "please write a python function , the function signature as below def intersect_horizontally(rect1, rect2):\n    \"\"\"\n    Determine if two rectangles intersect horizontally.\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect horizontally, False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 433,
    "code_type": "method",
    "original_language": "python",
    "file_path": "simd-bot\\9e5fa6904dc8e0d459ac3cc3679b62fdc336f660\\tools\\txt2pdf.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Extracts paragraph (separated by two newlines) lines (separated by one newline) in text\n",
    "language_version_list": {
      "python": {
        "code_signature": "def extract_paragraphs_and_lines(text: str):\n    \"\"\"\n    Extracts paragraphs and lines from the given text.The paragraphs end with \\n\\n The line end with \\n\n    For example:\n        input: First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\n        output:\n\n    Args:\n        text (str): The input text from which paragraphs and lines will be extracted.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'paragraphs': A list of paragraphs extracted from the text.\n            - 'lines': A list of lines extracted from the text.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestExtractParagraphsAndLines(unittest.TestCase):\n\n    def test_single_paragraph(self):\n        input_text = \"This is a single paragraph.\"\n        expected_output = {\n            'paragraphs': [\"This is a single paragraph.\"],\n            'lines': [\"This is a single paragraph.\"]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_paragraphs(self):\n        input_text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n        expected_output = {\n            'paragraphs': [\n                \"First paragraph.\\nThis is the second line.\",\n                \"Second paragraph.\\nAnother line.\"\n            ],\n            'lines': [\n                \"First paragraph.\",\n                \"This is the second line.\",\n                \"Second paragraph.\",\n                \"Another line.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_leading_and_trailing_whitespace(self):\n        input_text = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \"\n        expected_output = {\n            'paragraphs': [\n                \"This paragraph has leading whitespace.\\nAnd a line after.\",\n                \"This one has trailing whitespace.\"\n            ],\n            'lines': [\n                \"This paragraph has leading whitespace.\",\n                \"And a line after.\",\n                \"This one has trailing whitespace.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_empty_string(self):\n        input_text = \"\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_empty_paragraphs(self):\n        input_text = \"\\n\\n\\n\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n",
        "prompt": "please write a python function , the function signature as below def extract_paragraphs_and_lines(text: str):\n    \"\"\"\n    Extracts paragraphs and lines from the given text.The paragraphs end with \\n\\n The line end with \\n\n    For example:\n        input: First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\n        output:\n\n    Args:\n        text (str): The input text from which paragraphs and lines will be extracted.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'paragraphs': A list of paragraphs extracted from the text.\n            - 'lines': A list of lines extracted from the text.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 438,
    "code_type": "method",
    "original_language": "python",
    "file_path": "CS_TA_work_week5\\6c19b5ecf46fd81927499bee5e42f58cebacebcf\\src\\starter_code\\chatgpt_solution_1.py\n",
    "question_type": "Data processing and transformation",
    "summary": "conver csv file to dataframe",
    "language_version_list": {
      "python": {
        "code_signature": "import pandas as pd\n\n\ndef read_csv_to_dataframe(file_path: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a CSV file and converts it to a pandas DataFrame.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the CSV file.\n    \"\"\"\n",
        "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestReadCsvToDataFrame(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up temporary CSV files for testing.\"\"\"\n        # Create a valid CSV file\n        self.valid_csv_path = 'valid.csv'\n        pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]}).to_csv(self.valid_csv_path, index=False)\n\n        # Create an empty CSV file\n        self.empty_csv_path = 'empty.csv'\n        open(self.empty_csv_path, 'w').close()\n\n        # Create an invalid format CSV file\n        self.invalid_csv_path = 'invalid.csv'\n        with open(self.invalid_csv_path, 'w') as f:\n            f.write(\"col1, col2\\n1, 2\\n3, 4\\ninvalid_line\")\n\n    def tearDown(self):\n        \"\"\"Clean up temporary files after tests.\"\"\"\n        if os.path.exists(self.valid_csv_path):\n            os.remove(self.valid_csv_path)\n        if os.path.exists(self.empty_csv_path):\n            os.remove(self.empty_csv_path)\n        if os.path.exists(self.invalid_csv_path):\n            os.remove(self.invalid_csv_path)\n\n    def test_valid_csv(self):\n        \"\"\"Test reading a valid CSV file.\"\"\"\n        df = read_csv_to_dataframe(self.valid_csv_path)\n        self.assertIsInstance(df, pd.DataFrame)\n        self.assertEqual(df.shape, (2, 2))\n        self.assertListEqual(list(df.columns), ['col1', 'col2'])\n\n\n\n    def test_correct_data(self):\n        \"\"\"Test if the correct data is read from the CSV file.\"\"\"\n        df = read_csv_to_dataframe(self.valid_csv_path)\n        expected_data = {'col1': [1, 2], 'col2': [3, 4]}\n        pd.testing.assert_frame_equal(df, pd.DataFrame(expected_data))\n\n    def test_read_csv_with_missing_values(self):\n        \"\"\"Test reading a CSV file with missing values.\"\"\"\n        missing_values_csv_path = 'missing_values.csv'\n        pd.DataFrame({'col1': [1, None], 'col2': [None, 4]}).to_csv(missing_values_csv_path, index=False)\n        df = read_csv_to_dataframe(missing_values_csv_path)\n        self.assertTrue(df.isnull().values.any())\n        os.remove(missing_values_csv_path)\n\n    def test_large_csv_file(self):\n        \"\"\"Test reading a large CSV file.\"\"\"\n        large_csv_path = 'large.csv'\n        large_df = pd.DataFrame({'col1': range(1000), 'col2': range(1000, 2000)})\n        large_df.to_csv(large_csv_path, index=False)\n        df = read_csv_to_dataframe(large_csv_path)\n        self.assertEqual(df.shape, (1000, 2))\n        os.remove(large_csv_path)",
        "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef read_csv_to_dataframe(file_path: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a CSV file and converts it to a pandas DataFrame.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the CSV file.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 442,
    "code_type": "method",
    "original_language": "python",
    "file_path": "fiware-orion\\cca7d63318dee393d4e8874ada0f7790b63b28c9\\scripts\\oriondb_consistency\\oriondb_co",
    "question_type": "Data processing and transformation",
    "summary": "Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Dict, Union\n\n\ndef convert_strings_to_numbers(data: Union[Dict, List]) -> Union[Dict, List]:\n    \"\"\"\n    Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n\n    Args:\n        data (Union[Dict,List]): before convert data\n\n    Returns:\n        Union[Dict,List]: after convert data\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestConvertStringsToNumbers(unittest.TestCase):\n\n    def test_flat_dict(self):\n        data = {'a': '1', 'b': '2.5', 'c': 'not a number'}\n        expected = {'a': 1, 'b': 2.5, 'c': 'not a number'}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_nested_dict(self):\n        data = {'x': {'y': '10', 'z': '3.14'}, 'w': '20.0'}\n        expected = {'x': {'y': 10, 'z': 3.14}, 'w': 20.0}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_list_of_strings(self):\n        data = ['1', '2.5', '3', 'invalid']\n        expected = [1, 2.5, 3, 'invalid']\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_mixed_structure(self):\n        data = {'numbers': ['1', '2.0', 3], 'more_numbers': [{'num': '4'}, '5']}\n        expected = {'numbers': [1, 2.0, 3], 'more_numbers': [{'num': 4}, 5]}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_empty_structure(self):\n        data = {}\n        expected = {}\n        self.assertEqual(convert_strings_to_numbers(data), expected)",
        "prompt": "please write a python function , the function signature as below from typing import List, Dict, Union\n\n\ndef convert_strings_to_numbers(data: Union[Dict, List]) -> Union[Dict, List]:\n    \"\"\"\n    Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n\n    Args:\n        data (Union[Dict,List]): before convert data\n\n    Returns:\n        Union[Dict,List]: after convert data\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 443,
    "code_type": "method",
    "original_language": "python",
    "file_path": "GQLSpection\\19536007e2c2721b74b780daf4d15f6e31f78927\\src\\gqlspection\\utils.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Process a string by compressing multiple consecutive whitespace characters into a single space\n",
    "language_version_list": {
      "python": {
        "code_signature": "def compress_whitespace(input_string: str):\n    \"\"\"\n    Compress multiple consecutive whitespace characters in a string into a single space.\n\n    Args:\n        input_string(str): The string to be processed.\n\n    Returns:\n        str: The processed string with compressed whitespace.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestCompressWhitespace(unittest.TestCase):\n\n    def test_single_spaces(self):\n        \"\"\"Test with a string containing single spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This is a test string.\"), \"This is a test string.\")\n\n    def test_multiple_spaces(self):\n        \"\"\"Test with a string containing multiple spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This    is  a   test   string.\"), \"This is a test string.\")\n\n    def test_leading_trailing_spaces(self):\n        \"\"\"Test with leading and trailing spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"   Leading and trailing spaces   \"), \"Leading and trailing spaces\")\n\n    def test_only_spaces(self):\n        \"\"\"Test with a string containing only spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"       \"), \"\")\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        self.assertEqual(compress_whitespace(\"\"), \"\")",
        "prompt": "please write a python function , the function signature as below def compress_whitespace(input_string: str):\n    \"\"\"\n    Compress multiple consecutive whitespace characters in a string into a single space.\n\n    Args:\n        input_string(str): The string to be processed.\n\n    Returns:\n        str: The processed string with compressed whitespace.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 444,
    "code_type": "method",
    "original_language": "python",
    "file_path": "GQLSpection\\19536007e2c2721b74b780daf4d15f6e31f78927\\src\\gqlspection\\utils.py\n",
    "question_type": NaN,
    "summary": "Formats a string into a commented block with specified maximum line length.",
    "language_version_list": {
      "python": {
        "code_signature": "def format_comment(string, max_length=60):\n    \"\"\"\n    Formats a string into a commented block with specified maximum line length.\n\n    Args:\n        string (str): The input string to format.\n        max_length (int): Maximum length of each line in the output.\n\n    Returns:\n        str: A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestFormatComment(unittest.TestCase):\n\n    def test_short_string(self):\n        \"\"\"Test with a short string that fits within max_length\"\"\"\n        input_string = \"This is a test.\"\n        expected_output = \"# This is a test.\"\n        self.assertEqual(format_comment(input_string), expected_output)\n\n    def test_long_string(self):\n        \"\"\"Test with a longer string that exceeds max_length\"\"\"\n        input_string = \"This is a test of the format_comment function which should wrap long lines correctly.\"\n        expected_output = (\n            \"# This is a test of the format_comment function which should\\n\"\n            \"# wrap long lines correctly.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_multiple_lines(self):\n        \"\"\"Test with multiple lines of input\"\"\"\n        input_string = \"First line.\\nSecond line that is quite long and needs to be wrapped.\"\n        expected_output = (\n            \"# First line.\\n\"\n            \"# Second line that is quite long and needs to be wrapped.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_exact_max_length(self):\n        \"\"\"Test with a line that is exactly max_length characters long\"\"\"\n        input_string = \"A\" * 60  # 60 characters long\n        expected_output = \"# \" + \"A\" * 60\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        input_string = \"\"\n        expected_output = \"# \"\n        self.assertEqual(format_comment(input_string), expected_output)\n",
        "prompt": "please write a python function , the function signature as below def format_comment(string, max_length=60):\n    \"\"\"\n    Formats a string into a commented block with specified maximum line length.\n\n    Args:\n        string (str): The input string to format.\n        max_length (int): Maximum length of each line in the output.\n\n    Returns:\n        str: A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 445,
    "code_type": "method",
    "original_language": "python",
    "file_path": "arena-py\\0bd135904574bb26425a253ed4e67a7c92fa2697\\tools\\calibrate-vr\\calibrate.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Create a pose matrix representing a rotation about a given axis",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy\nimport numpy as np\n\n\ndef create_rot_matrix(angle_deg: float, axis: str) -> numpy.ndarray:\n    \"\"\"\n    Create a pose matrix representing a rotation about a given axis.\n\n    Args:\n        angle_deg (float): Rotation angle in degrees.\n        axis (str): Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n\n    Returns:\n        numpy.ndarray: 4x4 pose matrix representing the rotation.\n    \"\"\"\n",
        "test_code": "import unittest\nimport numpy as np\nfrom numpy.testing import assert_array_almost_equal\n\n\n\nclass TestCreateRotMatrix(unittest.TestCase):\n    def test_rotation_x_90_degrees(self):\n        \"\"\" Test rotation around X-axis for 90 degrees \"\"\"\n        expected_matrix = np.array([\n            [1, 0, 0, 0],\n            [0, 0, -1, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(90, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_y_180_degrees(self):\n        \"\"\" Test rotation around Y-axis for 180 degrees \"\"\"\n        expected_matrix = np.array([\n            [-1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, -1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(180, 'y')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_z_270_degrees(self):\n        \"\"\" Test rotation around Z-axis for 270 degrees (or -90 degrees) \"\"\"\n        expected_matrix = np.array([\n            [0, 1, 0, 0],\n            [-1, 0, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(270, 'z')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_invalid_axis(self):\n        \"\"\" Test behavior with invalid axis input \"\"\"\n        with self.assertRaises(ValueError):\n            create_rot_matrix(90, 'a')\n\n    def test_zero_rotation(self):\n        \"\"\" Test zero degree rotation which should lead to identity matrix \"\"\"\n        expected_matrix = np.eye(4)\n        result_matrix = create_rot_matrix(0, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)",
        "prompt": "please write a python function , the function signature as below import numpy\nimport numpy as np\n\n\ndef create_rot_matrix(angle_deg: float, axis: str) -> numpy.ndarray:\n    \"\"\"\n    Create a pose matrix representing a rotation about a given axis.\n\n    Args:\n        angle_deg (float): Rotation angle in degrees.\n        axis (str): Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n\n    Returns:\n        numpy.ndarray: 4x4 pose matrix representing the rotation.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 451,
    "code_type": "method",
    "original_language": "python",
    "file_path": "avenet42\\28a087a9b35de7f7b5c7999b9d5b1e72c2e878c4\\tools\\helper_convertfont.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0",
    "language_version_list": {
      "python": {
        "code_signature": "def convert_image_to_bits(image_path: str):\n    \"\"\"\n    Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0\n\n    Args:\n        image_path (str): The file path of the image to convert.\n\n    Returns:\n        list: A list of bits representing the image, where 1 is for white pixels\n              and 0 is for black pixels.\n    \"\"\"\n",
        "test_code": "import os\nimport unittest\n\nfrom PIL import Image\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create test images before each test.\"\"\"\n        # Create a white image (all pixels white)\n        self.white_image_path = 'white_image.bmp'\n        white_image = Image.new('1', (2, 2), color=1)  # 1 is for white\n        white_image.save(self.white_image_path)\n\n        # Create a black image (all pixels black)\n        self.black_image_path = 'black_image.bmp'\n        black_image = Image.new('1', (2, 2), color=0)  # 0 is for black\n        black_image.save(self.black_image_path)\n\n        # Create a mixed image (half white, half black)\n        self.mixed_image_path = 'mixed_image.bmp'\n        mixed_image = Image.new('1', (2, 2))\n        mixed_image.putpixel((0, 0), 1)  # White\n        mixed_image.putpixel((0, 1), 0)  # Black\n        mixed_image.putpixel((1, 0), 0)  # Black\n        mixed_image.putpixel((1, 1), 1)  # White\n        mixed_image.save(self.mixed_image_path)\n\n    def tearDown(self):\n        \"\"\"Remove the test images after each test.\"\"\"\n        os.remove(self.white_image_path)\n        os.remove(self.black_image_path)\n        os.remove(self.mixed_image_path)\n\n    def test_white_image(self):\n        \"\"\"Test converting a white image.\"\"\"\n        expected_output = [1, 1, 1, 1]  # All pixels should be 1 (white)\n        result = convert_image_to_bits(self.white_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_black_image(self):\n        \"\"\"Test converting a black image.\"\"\"\n        expected_output = [0, 0, 0, 0]  # All pixels should be 0 (black)\n        result = convert_image_to_bits(self.black_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_mixed_image(self):\n        \"\"\"Test converting a mixed image.\"\"\"\n        expected_output = [1, 0, 0, 1]  # 1 white, 3 black\n        result = convert_image_to_bits(self.mixed_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_invalid_image_path(self):\n        \"\"\"Test converting an invalid image path.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            convert_image_to_bits('invalid_image_path.bmp')\n\n    def test_large_image(self):\n        \"\"\"Test converting a larger image.\"\"\"\n        # Create a larger image (3x3)\n        large_image_path = 'large_image.bmp'\n        large_image = Image.new('1', (3, 3))\n        large_image.putpixel((0, 0), 1)\n        large_image.putpixel((1, 1), 1)\n        large_image.putpixel((2, 2), 1)\n        large_image.save(large_image_path)\n\n        expected_output = [\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        ]\n        result = convert_image_to_bits(large_image_path)\n        self.assertEqual(result, expected_output)\n\n        # Clean up\n        os.remove(large_image_path)\n",
        "prompt": "please write a python function , the function signature as below def convert_image_to_bits(image_path: str):\n    \"\"\"\n    Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0\n\n    Args:\n        image_path (str): The file path of the image to convert.\n\n    Returns:\n        list: A list of bits representing the image, where 1 is for white pixels\n              and 0 is for black pixels.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 460,
    "code_type": "method",
    "original_language": "python",
    "file_path": "MATH-HPC\\1c0fc9efc66d356f7d25bb7851bb311e31c38006\\Session1\\build\\solution\\exercise1.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Multiplies a matrix by a vector and returns the resulting vector.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef matrix_vector_multiplication(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    \"\"\"\n    Multiplies a matrix by a vector and returns the resulting vector.\n\n    Args:\n        matrix (List[List[float]]): A 2D list representing the matrix.\n        vector (List[float]): A 1D list representing the vector.\n\n    Returns:\n        List[float]: The resulting vector after multiplication.\n\n    Raises:\n        ValueError: If the dimensions of the matrix and vector are not compatible for multiplication.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_non_square_matrix(self):\n        \"\"\"Test case for a non-square matrix and a compatible vector.\"\"\"\n        matrix = [[1, 2], [3, 4], [5, 6]]\n        vector = [2, 3]\n        expected_result = [8.0, 18.0, 28.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_zero_vector(self):\n        \"\"\"Test case for a matrix and a zero vector.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        vector = [0, 0, 0]\n        expected_result = [0.0, 0.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_single_element(self):\n        \"\"\"Test case for a single element matrix and vector.\"\"\"\n        matrix = [[5]]\n        vector = [3]\n        expected_result = [15.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_single_element_matrix_and_vector(self):\n        # Test case with a single element in the matrix and vector\n        matrix = [[3]]\n        vector = [4]\n        expected = [12]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected)\n\n    def test_compatible_sizes(self):\n        # Test case with compatible sizes but different dimensions\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        vector = [1, 1, 1]\n        expected = [6, 15, 24]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_vector_multiplication(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    \"\"\"\n    Multiplies a matrix by a vector and returns the resulting vector.\n\n    Args:\n        matrix (List[List[float]]): A 2D list representing the matrix.\n        vector (List[float]): A 1D list representing the vector.\n\n    Returns:\n        List[float]: The resulting vector after multiplication.\n\n    Raises:\n        ValueError: If the dimensions of the matrix and vector are not compatible for multiplication.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 461,
    "code_type": "method",
    "original_language": "python",
    "file_path": "leetcode_problems\\6ffa50a7ebae1f0ab6092efa49d3839644859510\\avg_binary_tree\\avg_binary_tree.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Calculate the average value of nodes at each level of a binary tree.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: Optional[TreeNode]) -> List[float]:\n    \"\"\"\n    Calculate the average value of nodes at each level of a binary tree.\n\n    Args:\n        root (Optional[TreeNode]): The root of the binary tree.\n\n    Returns:\n        List[float]: A list of averages for each level of the binary tree.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass TestAverageOfLevels(unittest.TestCase):\n    def test_empty_tree(self):\n        \"\"\"Test case for an empty tree.\"\"\"\n        self.assertEqual(average_of_levels(None), [])\n\n    def test_single_node(self):\n        \"\"\"Test case for a tree with a single node.\"\"\"\n        root = TreeNode(5)\n        self.assertEqual(average_of_levels(root), [5.0])\n\n    def test_three_levels(self):\n        \"\"\"Test case for a tree with three levels.\"\"\"\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(6)\n        self.assertEqual(average_of_levels(root), [1.0, 2.5, 5.0])  # (1), (2, 3) -> [1.0, (2+3)/2], (4, 5, 6) -> [5.0]\n",
        "prompt": "please write a python function , the function signature as below from typing import List, Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: Optional[TreeNode]) -> List[float]:\n    \"\"\"\n    Calculate the average value of nodes at each level of a binary tree.\n\n    Args:\n        root (Optional[TreeNode]): The root of the binary tree.\n\n    Returns:\n        List[float]: A list of averages for each level of the binary tree.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 462,
    "code_type": "method",
    "original_language": "python",
    "file_path": "leetcode_problems\\2c1d6ebdef1030b7793d957291fcebb771480477\\spiral_matrix\\optimized_with_ai.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Given a 2D matrix, return all elements of the matrix in spiral order",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return all elements of the matrix in spiral order.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the matrix elements in spiral order.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestSpiralOrder(unittest.TestCase):\n    def test_empty_matrix(self):\n        self.assertEqual(spiral_order([]), [])\n\n    def test_single_row_matrix(self):\n        self.assertEqual(spiral_order([[1, 2, 3]]), [1, 2, 3])\n\n    def test_single_column_matrix(self):\n        self.assertEqual(spiral_order([[1], [2], [3]]), [1, 2, 3])\n\n    def test_square_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]), [1, 2, 3, 6, 9, 8, 7, 4, 5])\n\n    def test_rectangle_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]), [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7])",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return all elements of the matrix in spiral order.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the matrix elements in spiral order.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 463,
    "code_type": "method",
    "original_language": "python",
    "file_path": "PythonCollection\\454a4924cd2db9a101283c1c21b2ae7631220ea2\\clearTypo3Log.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef extract_log_levels(log_file_path:str, output_file_path:str):\n    \"\"\"\n    Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file\n    log content such as:\n        [INFO] Information message\n        [WARNING] Warning message\n        [DEBUG] Debug message\n\n    Args:\n        log_file_path: log file path\n        output_file_path: output log file path\n\n    Returns:\n\n    \"\"\"",
        "test_code": "import unittest\nimport tempfile\nimport os\n\n\n# Assuming the extract_log_levels function is defined here or imported\n\nclass TestLogExtraction(unittest.TestCase):\n    def create_temp_log_file(self, content):\n        # Create a temporary log file\n        temp_file = tempfile.NamedTemporaryFile(delete=False, mode='w+')\n        temp_file.write(content)\n        temp_file.close()\n        return temp_file.name\n\n    def read_output_file(self, file_path):\n        # Read content from a file\n        with open(file_path, 'r') as file:\n            return file.read()\n\n    def test_warning_level(self):\n        logs = \"\"\"[INFO] Information message\n[WARNING] Warning message\n[DEBUG] Debug message\"\"\"\n        expected_output = \"[WARNING] Warning message\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_error_level(self):\n        logs = \"\"\"[ERROR] Error occurred\n[INFO] Just an info\"\"\"\n        expected_output = \"[ERROR] Error occurred\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_critical_and_alert_levels(self):\n        logs = \"\"\"[ALERT] Security breach\n[CRITICAL] System failure\n[NOTICE] Something to notice\"\"\"\n        expected_output = \"[ALERT] Security breach\\n[CRITICAL] System failure\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_no_relevant_logs(self):\n        logs = \"[INFO] No issues here\\n[DEBUG] All systems go\"\n        expected_output = \"\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_mixed_logs(self):\n        logs = \"\"\"[WARNING] Low disk space\n[INFO] Update completed\n[ERROR] Failed to load module\n[CRITICAL] Memory leak detected\n[DEBUG] This is a debug message\"\"\"\n        expected_output = \"[WARNING] Low disk space\\n[ERROR] Failed to load module\\n[CRITICAL] Memory leak detected\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_log_levels(log_file_path:str, output_file_path:str):\n    \"\"\"\n    Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file\n    log content such as:\n        [INFO] Information message\n        [WARNING] Warning message\n        [DEBUG] Debug message\n\n    Args:\n        log_file_path: log file path\n        output_file_path: output log file path\n\n    Returns:\n\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 465,
    "code_type": "method",
    "original_language": "python",
    "file_path": "MATH-HPC\\1c0fc9efc66d356f7d25bb7851bb311e31c38006\\Session2\\build\\solution\\exercise3_2.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Implement matrix and vector multiplication",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy\nimport numpy as np\n\n\ndef matrix_vector_multiplication(matrix: np.array, vector: np.array) -> numpy.ndarray:\n    \"\"\"\n    Multiplies a given matrix by a vector using NumPy's dot product.\n\n    Parameters:\n    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows\n                            and n is the number of columns.\n    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector\n                            compatible for multiplication with the given matrix.\n\n    Returns:\n    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of\n                   the matrix and the vector.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with a simple 2x2 matrix and a 2-element vector\n        matrix = np.array([[1, 2], [3, 4]])\n        vector = np.array([5, 6])\n        expected_result = np.array([17, 39])  # [1*5 + 2*6, 3*5 + 4*6]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_2(self):\n        # Test with a 3x3 matrix and a 3-element vector\n        matrix = np.array([[1, 0, 2], [0, 1, 2], [1, 1, 0]])\n        vector = np.array([3, 4, 5])\n        expected_result = np.array([13, 14, 7])  # [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_3(self):\n        # Test with a zero matrix and a vector\n        matrix = np.array([[0, 0], [0, 0]])\n        vector = np.array([1, 1])\n        expected_result = np.array([0, 0])  # Zero matrix multiplied by any vector yields zero\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_4(self):\n        # Test with a matrix having negative values\n        matrix = np.array([[-1, -2], [-3, -4]])\n        vector = np.array([1, 1])\n        expected_result = np.array([-3, -7])  # [-1*1 + -2*1, -3*1 + -4*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_5(self):\n        # Test with non-square matrix (2x3) and a compatible vector (3-element)\n        matrix = np.array([[1, 2, 3], [4, 5, 6]])\n        vector = np.array([1, 0, 1])\n        expected_result = np.array([4, 10])  # [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)",
        "prompt": "please write a python function , the function signature as below import numpy\nimport numpy as np\n\n\ndef matrix_vector_multiplication(matrix: np.array, vector: np.array) -> numpy.ndarray:\n    \"\"\"\n    Multiplies a given matrix by a vector using NumPy's dot product.\n\n    Parameters:\n    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows\n                            and n is the number of columns.\n    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector\n                            compatible for multiplication with the given matrix.\n\n    Returns:\n    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of\n                   the matrix and the vector.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 468,
    "code_type": "method",
    "original_language": "python",
    "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Given a 3x3 matrix, return the corresponding translation vector",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef get_translation(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 matrix, return the corresponding translation vector.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        np.ndarray: A 2-element array containing the translation components (translation_x, translation_y).\n    \"\"\"",
        "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_translation function is defined as provided\n\nclass TestGetTranslationFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no translation) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_translation = np.array([0.0, 0.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_translation_matrix(self):\n        \"\"\" Test for a translation matrix (5 in x, 10 in y) \"\"\"\n        matrix = np.array([[1, 0, 5],\n                           [0, 1, 10],\n                           [0, 0, 1]])\n        expected_translation = np.array([5.0, 10.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_negative_translation(self):\n        \"\"\" Test for a translation matrix with negative values \"\"\"\n        matrix = np.array([[1, 0, -3],\n                           [0, 1, -6],\n                           [0, 0, 1]])\n        expected_translation = np.array([-3.0, -6.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_translation(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 matrix, return the corresponding translation vector.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        np.ndarray: A 2-element array containing the translation components (translation_x, translation_y).\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 469,
    "code_type": "method",
    "original_language": "python",
    "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple\n\nimport numpy as np\n\n\ndef get_scale(matrix: np.ndarray) -> Tuple[np.float64, np.float64]:\n    \"\"\"\n    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        Tuple[np.float64, np.float64]: A tuple containing the scale factors (scale_x, scale_y).\n    \"\"\"\n",
        "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_scale function is defined as provided\n\nclass TestGetScaleFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no scaling) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_scale = (1.0, 1.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n    def test_scaling_matrix(self):\n        \"\"\" Test for a scaling matrix (2x in x and 3x in y) \"\"\"\n        matrix = np.array([[2, 0, 0],\n                           [0, 3, 0],\n                           [0, 0, 1]])\n        expected_scale = (2.0, 3.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n\n    def test_uniform_scaling(self):\n        # Test case with uniform scaling\n        matrix = np.array([[2, 0, 0],\n                           [0, 2, 0],\n                           [0, 0, 1]])\n        expected = (2.0, 2.0)\n        self.assertEqual(get_scale(matrix), expected)\n\n    def test_non_uniform_scaling(self):\n        # Test case with non-uniform scaling\n        matrix = np.array([[3, 0, 0],\n                           [0, 5, 0],\n                           [0, 0, 1]])\n        expected = (3.0, 5.0)\n        self.assertEqual(get_scale(matrix), expected)\n\n    def test_reflection_matrix(self):\n        # Test case with reflection matrix\n        matrix = np.array([[-1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected = (1.0, 1.0)\n        self.assertEqual(get_scale(matrix), expected)",
        "prompt": "please write a python function , the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\ndef get_scale(matrix: np.ndarray) -> Tuple[np.float64, np.float64]:\n    \"\"\"\n    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        Tuple[np.float64, np.float64]: A tuple containing the scale factors (scale_x, scale_y).\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 470,
    "code_type": "method",
    "original_language": "python",
    "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Applies a shear transformation to a 2D matrix along the x-axis.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef apply_shear_x(matrix: np.array, shear_factor: float):\n    \"\"\"\n    Applies a shear transformation to a 2D matrix along the x-axis.\n\n    Args:\n    matrix (np.ndarray): A 2D numpy array representing the original matrix.\n    shear_factor (float): The factor by which the matrix is sheared along the x-axis.\n\n    Returns:\n    np.ndarray: The sheared matrix.\n    \"\"\"\n",
        "test_code": "import numpy as np\nimport unittest\n\nclass TestShearTransformation(unittest.TestCase):\n    def test_identity_shear(self):\n        \"\"\" Test with zero shear factor which should return the original matrix unchanged. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 0\n        expected_output = np.array([[1, 2], [3, 4]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should remain unchanged with zero shear factor.\")\n\n    def test_positive_shear(self):\n        \"\"\" Test with a positive shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 1\n        expected_output = np.array([[1, 3], [3, 7]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared.\")\n\n    def test_negative_shear(self):\n        \"\"\" Test with a negative shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = -1\n        expected_output = np.array([[1, 1], [3, 1]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared negatively.\")\n\n\n    def test_high_shear_factor(self):\n        \"\"\" Test with a high shear factor to see how the matrix adapts to extreme transformations. \"\"\"\n        matrix = np.array([[1, 1], [1, 1]])\n        shear_factor = 10\n        expected_output = np.array([[1, 11], [1, 11]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared with a high shear factor.\")",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef apply_shear_x(matrix: np.array, shear_factor: float):\n    \"\"\"\n    Applies a shear transformation to a 2D matrix along the x-axis.\n\n    Args:\n    matrix (np.ndarray): A 2D numpy array representing the original matrix.\n    shear_factor (float): The factor by which the matrix is sheared along the x-axis.\n\n    Returns:\n    np.ndarray: The sheared matrix.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 471,
    "code_type": "method",
    "original_language": "python",
    "file_path": "raimad\\fc52183dfaa99c0d2546bf70a6bfe64caf7a5d3b\\src\\raimad\\affine.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Given an affine transformation matrix, return the corresponding rotation angle in radians.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\ndef get_rotation(matrix:np.array) -> float:\n    \"\"\"\n    Given an affine transformation matrix, return the corresponding rotation angle in radians.\n\n    Args:\n        matrix (np.array): A 2D affine transformation matrix.\n\n    Returns:\n        float: The rotation angle in radians, extracted from the affine matrix.\n    \"\"\"",
        "test_code": "import numpy as np\nimport unittest\n\n\nclass TestGetRotationFunction(unittest.TestCase):\n\n    def test_rotation_0_degrees(self):\n        \"\"\" Test for a rotation of 0 degrees (identity matrix) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_rotation = 0.0\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_90_degrees(self):\n        \"\"\" Test for a rotation of 90 degrees \"\"\"\n        matrix = np.array([[0, -1, 0],\n                           [1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi / 2  # 90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_180_degrees(self):\n        \"\"\" Test for a rotation of 180 degrees \"\"\"\n        matrix = np.array([[-1, 0, 0],\n                           [0, -1, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi  # 180 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_negative_90_degrees(self):\n        \"\"\" Test for a rotation of -90 degrees \"\"\"\n        matrix = np.array([[0, 1, 0],\n                           [-1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = -np.pi / 2  # -90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef get_rotation(matrix:np.array) -> float:\n    \"\"\"\n    Given an affine transformation matrix, return the corresponding rotation angle in radians.\n\n    Args:\n        matrix (np.array): A 2D affine transformation matrix.\n\n    Returns:\n        float: The rotation angle in radians, extracted from the affine matrix.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 474,
    "code_type": "method",
    "original_language": "python",
    "file_path": "CSU-CS_DS-Assignments\\7859969e199472c9fdf2462ebfeac7aeb6754dbf\\2-Sophomore-Year\\Python-Programming\\nothing\\py_grammer_selfstudy\\993.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Given a binary tree array, determine whether the given two values are sibling nodes",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef are_siblings(tree:List[int], val1:int, val2:int):\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    Args:\n        tree(List[int]): the binary tree level-order representation\n        val1(int):\n        val2(int):\n\n    Returns:\n\n    \"\"\"\n\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    :param tree: List[int], the binary tree level-order representation\n    :param val1: int, first value to check for sibling relationship\n    :param val2: int, second value to check for sibling relationship\n    :return: bool, True if val1 and val2 are siblings, False otherwise\n    \"\"\"",
        "test_code": "import unittest\n\nclass TestAreSiblings(unittest.TestCase):\n    def setUp(self):\n        # Setting up a binary tree used for all the test cases\n        self.tree = [1, 2, 3, 4, 5, 6, 7]\n\n    def test_basic_case(self):\n        # Test with nodes 4 and 5, which are siblings\n        result = are_siblings(self.tree, 4, 5)\n        self.assertTrue(result)\n\n    def test_non_sibling_case(self):\n        # Test with nodes 4 and 6, which are not siblings\n        result = are_siblings(self.tree, 4, 6)\n        self.assertFalse(result)\n\n    def test_root_node_case(self):\n        # Test with node 1 (root) and any other node, should return False\n        result = are_siblings(self.tree, 1, 2)\n        self.assertFalse(result)\n\n    def test_non_existent_values(self):\n        # Test with non-existent values\n        result = are_siblings(self.tree, 8, 9)\n        self.assertFalse(result)\n\n    def test_same_node_case(self):\n        # Test with the same node for both values\n        result = are_siblings(self.tree, 4, 4)\n        self.assertFalse(result)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef are_siblings(tree:List[int], val1:int, val2:int):\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    Args:\n        tree(List[int]): the binary tree level-order representation\n        val1(int):\n        val2(int):\n\n    Returns:\n\n    \"\"\"\n\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    :param tree: List[int], the binary tree level-order representation\n    :param val1: int, first value to check for sibling relationship\n    :param val2: int, second value to check for sibling relationship\n    :return: bool, True if val1 and val2 are siblings, False otherwise\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 475,
    "code_type": "method",
    "original_language": "python",
    "file_path": "midjourney-batch-prompt\\4ced4f82f6fba6dbccafcf2b8f2943b8bce52612\\aiprompt.py\n",
    "question_type": "Data processing and transformation",
    "summary": "    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.",
    "language_version_list": {
      "python": {
        "code_signature": "def safe_format(template, **kwargs):\n    \"\"\"\n    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.\n\n    Args:\n        template (str): The string template containing placeholders in the form {key}.\n        **kwargs: Keyword arguments that map keys to their replacement values.\n\n    Returns:\n        str: The formatted string with placeholders replaced by values.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestSafeFormat(unittest.TestCase):\n\n    def test_full_replacement(self):\n        \"\"\"Test with all placeholders having corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\", place=\"Wonderland\")\n        expected = \"Hello, Alice! Welcome to Wonderland.\"\n        self.assertEqual(result, expected)\n\n    def test_partial_replacement(self):\n        \"\"\"Test with some placeholders missing corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"Hello, Alice! Welcome to {place}.\"\n        self.assertEqual(result, expected)\n\n    def test_no_replacement(self):\n        \"\"\"Test when no placeholders are provided.\"\"\"\n        template = \"Hello, world!\"\n        result = safe_format(template)\n        expected = \"Hello, world!\"\n        self.assertEqual(result, expected)\n\n    def test_missing_placeholder(self):\n        \"\"\"Test with a placeholder that has no corresponding value.\"\"\"\n        template = \"My name is {name}, and I live in {city}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"My name is Alice, and I live in {city}.\"\n        self.assertEqual(result, expected)\n\n    def test_numeric_values(self):\n        \"\"\"Test with numeric values as replacements.\"\"\"\n        template = \"Your score is {score} out of {total}.\"\n        result = safe_format(template, score=85, total=100)\n        expected = \"Your score is 85 out of 100.\"\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below def safe_format(template, **kwargs):\n    \"\"\"\n    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.\n\n    Args:\n        template (str): The string template containing placeholders in the form {key}.\n        **kwargs: Keyword arguments that map keys to their replacement values.\n\n    Returns:\n        str: The formatted string with placeholders replaced by values.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 476,
    "code_type": "method",
    "original_language": "python",
    "file_path": "tensorneat\\5fdf7b29bca1ff3a13733732fa234459de53a3d8\\src\\tensorneat\\common\\graph.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "achieve topological sorting, based on depth priority search",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List, Tuple\n\n\ndef topological_sort_dfs(vertices: List[int], edges: List[Tuple]) -> List:\n    \"\"\"\n    achieve topological sorting, based on depth priority search\n\n    Args:\n        vertices (List[int]): A list of vertices in the graph. Each vertex should be a unique integer.\n        edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge\n                                       in the graph and is formed as (start_vertex, end_vertex).\n\n    Returns:\n        List[int]: A list of vertices in topological order. If the graph contains a cycle,\n                   and thus cannot have a valid topological ordering, an empty list is returned.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestTopologicalSortDFS(unittest.TestCase):\n    def test_simple_chain(self):\n        vertices = [1, 2, 3]\n        edges = [(1, 2), (2, 3)]\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1, 2, 3])\n\n\n    def test_disconnected_graph(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2)]\n        # There are multiple correct answers possible\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(3 in result and 4 in result)\n\n    def test_complex_graph(self):\n        vertices = [1, 2, 3, 4, 5, 6]\n        edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (6, 1)]\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(result.index(1) < result.index(3))\n        self.assertTrue(result.index(2) < result.index(4))\n        self.assertTrue(result.index(3) < result.index(4))\n        self.assertTrue(result.index(4) < result.index(5))\n        self.assertTrue(result.index(6) < result.index(1))\n\n    def test_single_vertex(self):\n        vertices = [1]\n        edges = []\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1])",
        "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef topological_sort_dfs(vertices: List[int], edges: List[Tuple]) -> List:\n    \"\"\"\n    achieve topological sorting, based on depth priority search\n\n    Args:\n        vertices (List[int]): A list of vertices in the graph. Each vertex should be a unique integer.\n        edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge\n                                       in the graph and is formed as (start_vertex, end_vertex).\n\n    Returns:\n        List[int]: A list of vertices in topological order. If the graph contains a cycle,\n                   and thus cannot have a valid topological ordering, an empty list is returned.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 477,
    "code_type": "method",
    "original_language": "python",
    "file_path": "markpickle\\f29202998c0d5ae3ebc2bd22de57bc1c2c6bacbb\\markpickle\\simplify_types.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Check if the given object can be treated as a dictionary.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Any\n\ndef can_class_to_dict(obj: Any) -> bool:\n    \"\"\"\n    Check if the given object can be treated as a dictionary.\n\n    Args:\n        obj (Any): any type\n\n    Returns:\n        bool: can obj to dict\n    \"\"\"",
        "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\nclass EmptyClass:\n    pass\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\nclass TestCanClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertTrue(can_class_to_dict(person))\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertTrue(can_class_to_dict(car))\n\n    def test_regular_class_with_private_attribute(self):\n        dog = Dog(name=\"Buddy\", breed=\"Golden Retriever\")\n        self.assertTrue(can_class_to_dict(dog))\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertTrue(can_class_to_dict(empty))\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertTrue(can_class_to_dict(student))\n\n    def test_non_class_object(self):\n        number = 42\n        self.assertFalse(can_class_to_dict(number))\n",
        "prompt": "please write a python function , the function signature as below from typing import Any\n\ndef can_class_to_dict(obj: Any) -> bool:\n    \"\"\"\n    Check if the given object can be treated as a dictionary.\n\n    Args:\n        obj (Any): any type\n\n    Returns:\n        bool: can obj to dict\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 478,
    "code_type": "method",
    "original_language": "python",
    "file_path": "markpickle\\f29202998c0d5ae3ebc2bd22de57bc1c2c6bacbb\\markpickle\\simplify_types.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Converts a dataclass or class instance to a dictionary.",
    "language_version_list": {
      "python": {
        "code_signature": "from dataclasses import is_dataclass\nfrom typing import Any, Dict\n\n\ndef class_to_dict(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass or class instance to a dictionary.\n\n    Args:\n        obj: An instance of a dataclass or a class.\n\n    Returns:\n        A dictionary representation of the class or dataclass.\n    \"\"\"\n",
        "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n# The class_to_dict function should already be defined above.\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n        self.year = 2020\n\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\n\nclass EmptyClass:\n    pass\n\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\n\nclass TestClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertEqual(class_to_dict(person), {'name': 'Alice', 'age': 30})\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertEqual(class_to_dict(car), {'make': 'Toyota', 'model': 'Corolla', 'year': 2020})\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertEqual(class_to_dict(empty), {})\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertEqual(class_to_dict(student), {'name': 'John', 'grade': 'A'})\n",
        "prompt": "please write a python function , the function signature as below from dataclasses import is_dataclass\nfrom typing import Any, Dict\n\n\ndef class_to_dict(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass or class instance to a dictionary.\n\n    Args:\n        obj: An instance of a dataclass or a class.\n\n    Returns:\n        A dictionary representation of the class or dataclass.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 482,
    "code_type": "method",
    "original_language": "python",
    "file_path": "TestGen-Thesis\\91b00426653cbcadd6d779fd3f0a07e695edad63\\scripts\\csvToGraph.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Extract the contents of the outermost bracket\n",
    "language_version_list": {
      "python": {
        "code_signature": "def extract_outermost_brackets(s: str) -> str:\n    \"\"\"\n    Extracts the contents of the outermost brackets from the input string.\n    For example:\n        input: Text [with [nested] brackets] and more text\n        output: with [nested] brackets\n    Args:\n        s (str): The input string containing brackets.\n\n    Returns:\n        str: The contents within the outermost brackets, or an empty string if no brackets are found.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestExtractOutermostBrackets(unittest.TestCase):\n    \n    def test_single_parentheses(self):\n        self.assertEqual(extract_outermost_brackets(\"Text (example) more text\"), \"example\")\n\n    def test_nested_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text {with some {nested} brackets}\"), \"with some {nested} brackets\")\n\n    def test_square_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text [with [nested] brackets] and more text\"), \"with [nested] brackets\")\n\n    def test_mixed_bracket_types(self):\n        self.assertEqual(extract_outermost_brackets(\"Mixed (types {of brackets [in use]})\"), \"types {of brackets [in use]}\")\n\n    def test_no_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"No brackets here\"), \"\")",
        "prompt": "please write a python function , the function signature as below def extract_outermost_brackets(s: str) -> str:\n    \"\"\"\n    Extracts the contents of the outermost brackets from the input string.\n    For example:\n        input: Text [with [nested] brackets] and more text\n        output: with [nested] brackets\n    Args:\n        s (str): The input string containing brackets.\n\n    Returns:\n        str: The contents within the outermost brackets, or an empty string if no brackets are found.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 483,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Pictionary\\a23c12e1b60494ac96ac2554371d583d0d76e8f1\\app\\routes.py",
    "question_type": "Data processing and transformation",
    "summary": "Verify that the mailbox string is a qualified mailbox\n",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verifies if the provided string is a valid email address.\n\n    Args:\n        email (str):The email address to validate.\n\n    Returns:\n        bool: True if the email address is valid, False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestEmailValidation(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"test@example.com\"))\n\n    def test_valid_email_with_subdomain(self):\n        self.assertTrue(is_valid_email(\"user@subdomain.example.com\"))\n\n    def test_valid_email_with_plus_tag(self):\n        self.assertTrue(is_valid_email(\"user.name+tag+sorting@example.com\"))\n\n    def test_invalid_email_missing_username(self):\n        self.assertFalse(is_valid_email(\"@missingusername.com\"))\n\n    def test_invalid_email_missing_at_symbol(self):\n        self.assertFalse(is_valid_email(\"missingatsign.com\"))\n\n\n    def test_invalid_email_tld_too_short(self):\n        self.assertFalse(is_valid_email(\"user@domain.c\"))\n\n    def test_invalid_email_with_special_characters(self):\n        self.assertFalse(is_valid_email(\"user@domain.com!\"))\n\n",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verifies if the provided string is a valid email address.\n\n    Args:\n        email (str):The email address to validate.\n\n    Returns:\n        bool: True if the email address is valid, False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 485,
    "code_type": "method",
    "original_language": "python",
    "file_path": "fastgql\\47ddbf9f5bd444d51ebc210f9158dbf2bc165a7b\\fastgql\\query_builders\\sql\\query_builder.py\n",
    "question_type": "Data processing and transformation",
    "summary": "This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef prepare_query(sql: str, params: dict) -> tuple:\n    \"\"\"\n    This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.\n    For example:\n        input:\n            sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n            params: {'user_id': 42,'status': 'active'}\n        output:\n            SELECT * FROM users WHERE id = $1 AND status = $2,[42, 'active']\n\n    Args:\n        sql (str): The original SQL query string with named parameters.\n        params (dict): A dictionary mapping parameter names to their values.\n\n    Returns:\n        tuple: A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n    \"\"\"",
        "test_code": "import unittest\n\n\n# Assuming the prepare_query function is defined above or imported\n\nclass TestPrepareQuery(unittest.TestCase):\n\n    def test_valid_named_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n        parameters = {\n            'user_id': 42,\n            'status': 'active'\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\"\n        expected_values = [42, 'active']\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_missing_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n        parameters = {\n            'user_id': 42  # 'status' is missing\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\"\n        expected_values = [42]  # 'status' is not included\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_no_parameters(self):\n        sql_query = \"SELECT * FROM users\"\n        parameters = {}  # No parameters provided\n        expected_sql = \"SELECT * FROM users\"\n        expected_values = []\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_multiple_same_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $user_id\"\n        parameters = {\n            'user_id': 42\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $1\"\n        expected_values = [42]  # Only one value for 'user_id'\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_special_characters_in_parameters(self):\n        sql_query = \"INSERT INTO users (name, email) VALUES ($name, $email)\"\n        parameters = {\n            'name': \"John Doe\",\n            'email': \"john.doe@example.com\"\n        }\n        expected_sql = \"INSERT INTO users (name, email) VALUES ($1, $2)\"\n        expected_values = [\"John Doe\", \"john.doe@example.com\"]\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef prepare_query(sql: str, params: dict) -> tuple:\n    \"\"\"\n    This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.\n    For example:\n        input:\n            sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n            params: {'user_id': 42,'status': 'active'}\n        output:\n            SELECT * FROM users WHERE id = $1 AND status = $2,[42, 'active']\n\n    Args:\n        sql (str): The original SQL query string with named parameters.\n        params (dict): A dictionary mapping parameter names to their values.\n\n    Returns:\n        tuple: A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 486,
    "code_type": "method",
    "original_language": "python",
    "file_path": "calculator\\252881ee22af936f9ca4a8e5a1b2bc19bfba8db7\\calc.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "a class implements add, subtract, multiply, and divide\n",
    "language_version_list": {
      "python": {
        "code_signature": "class Calculator:\n    def add(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the sum of a and b.\n        \"\"\"\n        pass\n\n    def subtract(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the difference of a and b.\n        \"\"\"\n        pass\n\n    def multiply(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the product of a and b.\n        \"\"\"\n        pass\n\n    def divide(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the quotient of a and b.\n        Raises ValueError if b is zero.\n        \"\"\"\n        pass\n",
        "test_code": "import unittest\n\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create an instance of Calculator before each test.\"\"\"\n        self.calculator = Calculator()\n\n    def test_add(self):\n        \"\"\"Test the addition method.\"\"\"\n        result = self.calculator.add(10, 5)\n        self.assertEqual(result, 15)\n\n    def test_subtract(self):\n        \"\"\"Test the subtraction method.\"\"\"\n        result = self.calculator.subtract(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_multiply(self):\n        \"\"\"Test the multiplication method.\"\"\"\n        result = self.calculator.multiply(10, 5)\n        self.assertEqual(result, 50)\n\n    def test_divide(self):\n        \"\"\"Test the division method.\"\"\"\n        result = self.calculator.divide(10, 5)\n        self.assertEqual(result, 2.0)\n\n    def test_divide_by_zero(self):\n        \"\"\"Test division by zero raises ValueError.\"\"\"\n        self.assertRaises(Exception)",
        "prompt": "please write a python function , the function signature as below class Calculator:\n    def add(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the sum of a and b.\n        \"\"\"\n        pass\n\n    def subtract(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the difference of a and b.\n        \"\"\"\n        pass\n\n    def multiply(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the product of a and b.\n        \"\"\"\n        pass\n\n    def divide(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the quotient of a and b.\n        Raises ValueError if b is zero.\n        \"\"\"\n        pass\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 487,
    "code_type": "method",
    "original_language": "python",
    "file_path": "athina-sdk\\50646629f89f8e25d0a7b7a8edb69305605fcabb\\magik\\evaluators.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Check if the string contains an email address\n",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef contains_email(text: str) -> bool:\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n        text (str): The string to search for an email address.\n\n    Returns:\n        bool: True if an email address is found, False otherwise.\n    \"\"\"\n\n\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n    text (str): The string to search for an email address.\n\n    Returns:\n    bool: True if an email address is found, False otherwise.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestContainsEmail(unittest.TestCase):\n\n    def test_contains_valid_email(self):\n        \"\"\"Test if a valid email is detected in the string.\"\"\"\n        test_string = \"You can reach me at example@example.com for more info.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_email_with_special_characters(self):\n        \"\"\"Test if an email with special characters is detected.\"\"\"\n        test_string = \"My email address is john.doe123+test@gmail.com!\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_does_not_contain_email(self):\n        \"\"\"Test a string that does not contain any email address.\"\"\"\n        test_string = \"This string does not have an email.\"\n        self.assertFalse(contains_email(test_string))\n\n    def test_contains_multiple_emails(self):\n        \"\"\"Test a string containing multiple email addresses.\"\"\"\n        test_string = \"You can contact me at example1@example.com or example2@example.com.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_invalid_email_format(self):\n        \"\"\"Test a string with an invalid email format.\"\"\"\n        test_string = \"Please contact me at example@.com or test@domain.\"\n        self.assertFalse(contains_email(test_string))",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef contains_email(text: str) -> bool:\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n        text (str): The string to search for an email address.\n\n    Returns:\n        bool: True if an email address is found, False otherwise.\n    \"\"\"\n\n\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n    text (str): The string to search for an email address.\n\n    Returns:\n    bool: True if an email address is found, False otherwise.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 488,
    "code_type": "method",
    "original_language": "python",
    "file_path": "MobileComputingAssignments\\83fc9405bb9ed970ef84f9d292de3e3e49837cc7\\Assignment 4\\utils.py\n",
    "question_type": "Network requests and API call",
    "summary": "Retrieve the local IP address of the specified network interface on Windows.",
    "language_version_list": {
      "python": {
        "code_signature": "import subprocess\nimport re\nfrom typing import Optional\n\n\ndef get_local_ip(interface: str = 'Wi-Fi') -> Optional[str]:\n    \"\"\"\n    Retrieve the local IP address of the specified network interface on Windows.\n\n    Args:\n        interface (str): The name of the network interface to check (default is 'Wi-Fi').\n\n    Returns:\n        Optional[str]: The local IP address if found, otherwise None.\n    \"\"\"\n",
        "test_code": "import subprocess\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIP(unittest.TestCase):\n\n    @patch('subprocess.run')\n    def test_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where a local IP is found\n        mock_run.return_value = MagicMock(stdout='192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_no_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where no local IP is found\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_multiple_ips_found(self, mock_run):\n        # Mock the output with multiple local IPs\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n'\n                                                  '192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_invalid_command(self, mock_run):\n        # Simulate a case where subprocess.run raises a CalledProcessError\n        mock_run.side_effect = subprocess.CalledProcessError(1, 'ipconfig')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_unexpected_error(self, mock_run):\n        # Simulate an unexpected error\n        mock_run.side_effect = Exception(\"Unexpected error\")\n        result = get_local_ip()\n        self.assertIsNone(result)",
        "prompt": "please write a python function , the function signature as below import subprocess\nimport re\nfrom typing import Optional\n\n\ndef get_local_ip(interface: str = 'Wi-Fi') -> Optional[str]:\n    \"\"\"\n    Retrieve the local IP address of the specified network interface on Windows.\n\n    Args:\n        interface (str): The name of the network interface to check (default is 'Wi-Fi').\n\n    Returns:\n        Optional[str]: The local IP address if found, otherwise None.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 490,
    "code_type": "method",
    "original_language": "python",
    "file_path": "yet-another-applied-llm-benchmark\\e50ca985fc38cd848471e3bf82d24525238862e5\\create_results_html.py",
    "question_type": "Data processing and transformation",
    "summary": "    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.",
    "language_version_list": {
      "python": {
        "code_signature": "def format_str(x: str) -> str:\n    \"\"\"\n    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.\n\n    Args:\n        x (str): The input string to be formatted. If the input is not a\n        string, it will be converted to one.\n\n    Returns:\n        str: The formatted string with each line prefixed by '> ' and\n        with balanced code block delimiters.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFormatStr(unittest.TestCase):\n\n    def test_simple_string(self):\n        \"\"\"Test a simple string input.\"\"\"\n        input_str = \"Hello, World!\"\n        expected_output = \"> Hello, World!\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_multiline_string(self):\n        \"\"\"Test a multiline string input.\"\"\"\n        input_str = \"Line 1\\nLine 2\\nLine 3\"\n        expected_output = \"> Line 1\\n> Line 2\\n> Line 3\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_code_block_delimiters_even(self):\n        \"\"\"Test a string with an even number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\\n```\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_code_block_delimiters_odd(self):\n        \"\"\"Test a string with an odd number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_non_string_input(self):\n        \"\"\"Test non-string input (e.g., integer) to ensure it's converted.\"\"\"\n        input_value = 123\n        expected_output = \"> 123\"\n        self.assertEqual(format_str(input_value), expected_output)",
        "prompt": "please write a python function , the function signature as below def format_str(x: str) -> str:\n    \"\"\"\n    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.\n\n    Args:\n        x (str): The input string to be formatted. If the input is not a\n        string, it will be converted to one.\n\n    Returns:\n        str: The formatted string with each line prefixed by '> ' and\n        with balanced code block delimiters.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 492,
    "code_type": "method",
    "original_language": "python",
    "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py",
    "question_type": "Data processing and transformation",
    "summary": "    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.",
    "language_version_list": {
      "python": {
        "code_signature": "def save_content_to_file(content: str, path: str) -> None:\n    \"\"\"\n    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.\n\n    Args:\n        content (str): The text content to be saved to the file.\n        path (str): The file path where the content will be saved.\n\n    Returns:\n        None\n    \"\"\"",
        "test_code": "import os\nimport unittest\n\n\nclass TestSaveContentToFile(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a temporary file path for testing.\"\"\"\n        self.test_file_path = 'test_output.txt'\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after each test.\"\"\"\n        if os.path.exists(self.test_file_path):\n            os.remove(self.test_file_path)\n\n    def test_basic_content(self):\n        \"\"\"Test with basic content and check if it saves correctly.\"\"\"\n        content = \"Hello,  World!  \"\n        expected = \"Hello, World!\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_multiple_spaces_and_empty_lines(self):\n        \"\"\"Test handling of multiple spaces and empty lines.\"\"\"\n        content = \"\"\"\n\n        This is a    test.\n\n        Another line.      \n        \"\"\"\n        expected = \"This is a test. Another line.\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_only_whitespace(self):\n        \"\"\"Test if only whitespace is handled correctly.\"\"\"\n        content = \"    \\n  \\n   \"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_empty_content(self):\n        \"\"\"Test if empty content is saved correctly.\"\"\"\n        content = \"\"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below def save_content_to_file(content: str, path: str) -> None:\n    \"\"\"\n    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.\n\n    Args:\n        content (str): The text content to be saved to the file.\n        path (str): The file path where the content will be saved.\n\n    Returns:\n        None\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 493,
    "code_type": "method",
    "original_language": "python",
    "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py",
    "question_type": "Data processing and transformation",
    "summary": "Wrap the text content to the specified maximum width and generate these lines line by line\n",
    "language_version_list": {
      "python": {
        "code_signature": "import textwrap\n\n\ndef wrap_content_generator(content: str, width=80):\n    \"\"\"\n    Wrap the text content to the specified maximum width and generate these lines line by line\n\n    Args:\n        content (str): The content to be wrapped and yielded line by line.\n        width (str): The maximum width of the lines, default is 80 characters.\n\n    Yields:\n        str: Each line of the content wrapped to the specified width.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestWrapContentGenerator(unittest.TestCase):\n\n    def test_empty_content(self):\n        \"\"\"Test with empty content.\"\"\"\n        result = list(wrap_content_generator(\"\"))\n        self.assertEqual(result, [])\n\n    def test_single_line_content(self):\n        \"\"\"Test with a single line of content within default width.\"\"\"\n        result = list(wrap_content_generator(\"Hello, world!\"))\n        self.assertEqual(result, [\"Hello, world!\"])\n\n    def test_multi_line_content(self):\n        \"\"\"Test with multiple lines of content each fitting within default width.\"\"\"\n        content = \"Hello\\nWorld\\nPython\"\n        result = list(wrap_content_generator(content))\n        self.assertEqual(result, [\"Hello\", \"World\", \"Python\"])\n\n    def test_long_line(self):\n        \"\"\"Test with a single long line that exceeds the default width.\"\"\"\n        content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\"\n        result = list(wrap_content_generator(content))\n        self.assertTrue(len(max(result, key=len)) <= 80)\n\n    def test_custom_width(self):\n        \"\"\"Test with a custom width.\"\"\"\n        content = \"This is a test for custom width setting.\"\n        result = list(wrap_content_generator(content, width=10))\n        self.assertTrue(all(len(line) <= 10 for line in result))\n\n    def test_only_whitespaces(self):\n        \"\"\"Test content that contains only whitespace characters.\"\"\"\n        result = list(wrap_content_generator(\"     \"))\n        self.assertEqual(result, [\"\\n\"])",
        "prompt": "please write a python function , the function signature as below import textwrap\n\n\ndef wrap_content_generator(content: str, width=80):\n    \"\"\"\n    Wrap the text content to the specified maximum width and generate these lines line by line\n\n    Args:\n        content (str): The content to be wrapped and yielded line by line.\n        width (str): The maximum width of the lines, default is 80 characters.\n\n    Yields:\n        str: Each line of the content wrapped to the specified width.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 494,
    "code_type": "method",
    "original_language": "python",
    "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py",
    "question_type": "Data processing and transformation",
    "summary": "Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict\n\n\ndef clean_dictionary(input_dict:Dict) -> Dict:\n    \"\"\"\n    Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.\n\n    Args:\n        input_dict (Dict): A dictionary to be cleaned.\n\n    Returns:\n        Dict: A new dictionary containing only valid values.\n    \"\"\"",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCleanDictionary(unittest.TestCase):\n\n    def test_valid_strings(self):\n        \"\"\" Test a dictionary with valid strings. \"\"\"\n        input_dict = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        expected_output = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_none_and(self):\n        \"\"\" Test a dictionary with None and NaN values. \"\"\"\n        input_dict = {\n            'key1': None,\n            'key3': 'valid string'\n        }\n        expected_output = {\n            'key3': 'valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_whitespace_strings(self):\n        \"\"\" Test a dictionary with whitespace strings. \"\"\"\n        input_dict = {\n            'key1': '   ',\n            'key2': '',\n            'key3': 'valid'\n        }\n        expected_output = {\n            'key3': 'valid'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_empty_dictionary(self):\n        \"\"\" Test an empty dictionary. \"\"\"\n        input_dict = {}\n        expected_output = {}\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n",
        "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef clean_dictionary(input_dict:Dict) -> Dict:\n    \"\"\"\n    Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.\n\n    Args:\n        input_dict (Dict): A dictionary to be cleaned.\n\n    Returns:\n        Dict: A new dictionary containing only valid values.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 495,
    "code_type": "method",
    "original_language": "python",
    "file_path": "experiments\\86f0146b22d18c19be3d7318ee367f5fef4eb366\\mlx\\lora\\lib\\prepare_training_data.py",
    "question_type": "Data processing and transformation",
    "summary": "    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.",
    "language_version_list": {
      "python": {
        "code_signature": "import re\nfrom typing import List\n\n\ndef filter_content_with_context(\n        content: str,\n        keywords: List[str],\n        lines_before: int = 1,\n        lines_after: int = 1\n) -> str:\n    \"\"\"\n    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.\n\n    Args:\n        content (str): The full text content of the website.\n        keywords (List[str]): A list of strings to search for within the content.\n        lines_before (int): Number of lines to include before a matching line.\n        lines_after (int): Number of lines to include after a matching line.\n\n    Returns:\n        str: A string containing the filtered content with additional context.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFilterContentWithContext(unittest.TestCase):\n\n    def test_single_keyword_match(self):\n        \"\"\"Test a single keyword match with context lines.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to filter content for a single keyword.\")\n\n\n    def test_no_keyword_match(self):\n        \"\"\"Test when no keywords match.\"\"\"\n        content = \"\"\"Line one.\n        Line two.\n        Line three.\"\"\"\n        keywords = [\"missing\"]\n        expected_output = \"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output, \"Failed to return empty string for no matches.\")\n\n\n    def test_lines_before_and_after(self):\n        \"\"\"Test functionality with specified lines before and after.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\n        Line four.\n        Line five.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to correctly include context lines.\")\n",
        "prompt": "please write a python function , the function signature as below import re\nfrom typing import List\n\n\ndef filter_content_with_context(\n        content: str,\n        keywords: List[str],\n        lines_before: int = 1,\n        lines_after: int = 1\n) -> str:\n    \"\"\"\n    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.\n\n    Args:\n        content (str): The full text content of the website.\n        keywords (List[str]): A list of strings to search for within the content.\n        lines_before (int): Number of lines to include before a matching line.\n        lines_after (int): Number of lines to include after a matching line.\n\n    Returns:\n        str: A string containing the filtered content with additional context.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 496,
    "code_type": "method",
    "original_language": "python",
    "file_path": "modeling-info-spread\\f138143cdc0057ca1a2ec2be8ef4d0babb4bf2f8\\src\\models\\channel.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Generates the ith row of Pascal's Triangle.",
    "language_version_list": {
      "python": {
        "code_signature": "import math\nfrom typing import List\n\n\ndef pascal_triangle_row(i: int) -> List:\n    \"\"\"\n    Generates the ith row of Pascal's Triangle.\n\n    Args:\n        i (int): Row index (0-indexed)\n\n    Returns:\n        List: A list representing the ith row of Pascal's Triangle\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestPascalTriangleRow(unittest.TestCase):\n\n    def test_row_0(self):\n        \"\"\" Test the 0th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(0), [1])\n\n    def test_row_1(self):\n        \"\"\" Test the 1st row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(1), [1, 1])\n\n    def test_row_2(self):\n        \"\"\" Test the 2nd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(2), [1, 2, 1])\n\n    def test_row_3(self):\n        \"\"\" Test the 3rd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(3), [1, 3, 3, 1])\n\n    def test_row_4(self):\n        \"\"\" Test the 4th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(4), [1, 4, 6, 4, 1])\n\n    def test_row_5(self):\n        \"\"\" Test the 5th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(5), [1, 5, 10, 10, 5, 1])\n",
        "prompt": "please write a python function , the function signature as below import math\nfrom typing import List\n\n\ndef pascal_triangle_row(i: int) -> List:\n    \"\"\"\n    Generates the ith row of Pascal's Triangle.\n\n    Args:\n        i (int): Row index (0-indexed)\n\n    Returns:\n        List: A list representing the ith row of Pascal's Triangle\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 498,
    "code_type": "method",
    "original_language": "python",
    "file_path": "kaggle\\7365ae9fc3caf06b7220ceca94ab0efeb3a9d77f\\classify_leaves\\utils\\find_duplicates.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Computes and returns the MD5 hash of the string\n",
    "language_version_list": {
      "python": {
        "code_signature": "import hashlib\n\n\ndef compute_md5(input_string: str) -> str:\n    \"\"\"\n    Computes and returns the MD5 hash of the input string.\n\n    Args:\n        input_string (str): The string to be hashed\n\n    Returns:\n        str: he MD5 hash of the input string in hexadecimal format\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestComputeMD5(unittest.TestCase):\n\n    def test_empty_string(self):\n        \"\"\" Test the MD5 hash of an empty string. \"\"\"\n        self.assertEqual(compute_md5(''), 'd41d8cd98f00b204e9800998ecf8427e')\n\n    def test_simple_string(self):\n        \"\"\" Test the MD5 hash of a simple string. \"\"\"\n        self.assertEqual(compute_md5('Hello, World!'), '65a8e27d8879283831b664bd8b7f0ad4')\n\n    def test_numeric_string(self):\n        \"\"\" Test the MD5 hash of a numeric string. \"\"\"\n        self.assertEqual(compute_md5('123456'), 'e10adc3949ba59abbe56e057f20f883e')\n\n    def test_special_characters(self):\n        \"\"\" Test the MD5 hash of a string with special characters. \"\"\"\n        self.assertEqual(compute_md5('!@#$%^&*()'), '05b28d17a7b6e7024b6e5d8cc43a8bf7')\n\n    def test_long_string(self):\n        \"\"\" Test the MD5 hash of a long string. \"\"\"\n        long_string = 'a' * 1000  # A string of 1000 'a' characters\n        expected_hash = 'cabe45dcc9ae5b66ba86600cca6b8ba8'  # MD5 of 'aaaa....' (1000 'a's)\n        self.assertEqual(compute_md5(long_string), expected_hash)",
        "prompt": "please write a python function , the function signature as below import hashlib\n\n\ndef compute_md5(input_string: str) -> str:\n    \"\"\"\n    Computes and returns the MD5 hash of the input string.\n\n    Args:\n        input_string (str): The string to be hashed\n\n    Returns:\n        str: he MD5 hash of the input string in hexadecimal format\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 499,
    "code_type": "method",
    "original_language": "python",
    "file_path": "NumbER\\fc0df31b5fadf058e48afa3ba5cedd7a50595ff0\\NumbER\\dataset_cleaning\\baby_products\\clean.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Extracts a numeric value from the input string based on the given regex pattern.",
    "language_version_list": {
      "python": {
        "code_signature": "import re\nfrom typing import Union\n\n\ndef clean_pattern(x: str, pattern: str) -> Union[str,float]:\n    \"\"\"\n    Extracts a numeric value from the input string based on the given regex pattern.\n\n    Args:\n        x (str or any): The input from which to extract the value. It will be converted to a string.\n        pattern (str): The regular expression pattern to use for matching.\n\n    Returns:\n        Union[str,float]: The extracted weight value if a match is found, otherwise an empty string.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestCleanPattern(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Sets up a common regex pattern for testing.\"\"\"\n        self.pattern = r'(\\d+\\.?\\d*) kg'  # Regex pattern to match weight in kg\n\n    def test_valid_integer_weight(self):\n        \"\"\"Test case for valid integer weight.\"\"\"\n        input_string = \"The weight is 25 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 25.0)\n\n    def test_valid_float_weight(self):\n        \"\"\"Test case for valid float weight.\"\"\"\n        input_string = \"Weight measured at 15.75 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 15.75)\n\n    def test_no_weight_found(self):\n        \"\"\"Test case where no weight is present.\"\"\"\n        input_string = \"No weight provided.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_invalid_float_conversion(self):\n        \"\"\"Test case for non-numeric weight.\"\"\"\n        input_string = \"The weight is thirty kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_weight_with_extra_text(self):\n        \"\"\"Test case for weight with additional text.\"\"\"\n        input_string = \"The total weight is 45.3 kg as per the last measurement.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 45.3)\n",
        "prompt": "please write a python function , the function signature as below import re\nfrom typing import Union\n\n\ndef clean_pattern(x: str, pattern: str) -> Union[str,float]:\n    \"\"\"\n    Extracts a numeric value from the input string based on the given regex pattern.\n\n    Args:\n        x (str or any): The input from which to extract the value. It will be converted to a string.\n        pattern (str): The regular expression pattern to use for matching.\n\n    Returns:\n        Union[str,float]: The extracted weight value if a match is found, otherwise an empty string.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 500,
    "code_type": "method",
    "original_language": "python",
    "file_path": "NumbER\\fc0df31b5fadf058e48afa3ba5cedd7a50595ff0\\NumbER\\dataset_cleaning\\baby_products\\clean.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Converts the string representation of a score to its decimal value\n",
    "language_version_list": {
      "python": {
        "code_signature": "def convert_score_to_decimal(score_str: str) -> float:\n    \"\"\"\n    Converts the string representation of a score to its decimal value.\n    For example:\n        input: 10/4\n        output: 2.5\n    Args:\n        score_str (str): The score as a string, can be a decimal or a fraction\n\n    Returns:\n        float: The decimal value of the score as a float, or None if the input is invalid\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestConvertScoreToDecimal(unittest.TestCase):\n\n    def test_decimal_score(self):\n        \"\"\" Test a simple decimal score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"2.5\"), 2.5)\n\n    def test_fraction_score(self):\n        \"\"\" Test a fraction score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"10/4\"), 2.5)\n\n    def test_integer_score(self):\n        \"\"\" Test an integer score represented as a string. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"5\"), 5.0)\n\n    def test_integer_divide_score(self):\n        self.assertEqual(convert_score_to_decimal(\"12/3\"), 4.0)",
        "prompt": "please write a python function , the function signature as below def convert_score_to_decimal(score_str: str) -> float:\n    \"\"\"\n    Converts the string representation of a score to its decimal value.\n    For example:\n        input: 10/4\n        output: 2.5\n    Args:\n        score_str (str): The score as a string, can be a decimal or a fraction\n\n    Returns:\n        float: The decimal value of the score as a float, or None if the input is invalid\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 501,
    "code_type": "method",
    "original_language": "python",
    "file_path": "neurorient\\1d34765b7588e11c385433277e3b203df300b51c\\neurorient\\utils_config.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Converts strings concatenated with _ to a short format. For example, converting the string f1_p1_g1_b1_c1 to \"fpgbc\"",
    "language_version_list": {
      "python": {
        "code_signature": "def convert_to_short_format(input_str) -> str:\n    \"\"\"\n    Converts a string concatenated with underscores to a short format.\n    For example:\n        input: f1_p1_g1_b1_c1\n        output: fpgbc\n    Args:\n        input_str (str): The input string with segments separated by underscores.\n\n    Returns:\n        str: A short format string derived from the first characters of each segment.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestConvertToShortFormat(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\" Test a standard input with mixed characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"f1_p1_g1_b1_c1\"), \"fpgbc\")\n\n    def test_multiple_segments(self):\n        \"\"\" Test input with multiple segments. \"\"\"\n        self.assertEqual(convert_to_short_format(\"a2_b3_c4\"), \"abc\")\n\n    def test_non_alpha_numeric(self):\n        \"\"\" Test input with non-alphanumeric characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"hello_world_test\"), \"hwt\")\n\n    def test_single_segment(self):\n        \"\"\" Test a single segment input. \"\"\"\n        self.assertEqual(convert_to_short_format(\"single\"), \"s\")\n",
        "prompt": "please write a python function , the function signature as below def convert_to_short_format(input_str) -> str:\n    \"\"\"\n    Converts a string concatenated with underscores to a short format.\n    For example:\n        input: f1_p1_g1_b1_c1\n        output: fpgbc\n    Args:\n        input_str (str): The input string with segments separated by underscores.\n\n    Returns:\n        str: A short format string derived from the first characters of each segment.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 505,
    "code_type": "method",
    "original_language": "python",
    "file_path": "backend\\2a8b52493d9195046114127f3f8387e95d1b5a06\\src\\utils.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Convert a CamelCase string to snake_case.",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"\n    Convert a CamelCase string to snake_case.\n\n    Args:\n        camel_str (str): The CamelCase string to convert.\n\n    Returns:\n        str: The converted snake_case string.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestCamelToSnake(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic CamelCase to snake_case conversion. \"\"\"\n        self.assertEqual(camel_to_snake(\"HelloWorld\"), \"hello_world\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a CamelCase string with multiple words. \"\"\"\n        self.assertEqual(camel_to_snake(\"ThisIsATest\"), \"this_is_a_test\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(camel_to_snake(\"ConvertThis123String\"), \"convert_this123_string\")\n\n    def test_leading_uppercase(self):\n        \"\"\" Test conversion with leading uppercase letters. \"\"\"\n        self.assertEqual(camel_to_snake(\"PythonFunction\"), \"python_function\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(camel_to_snake(\"\"), \"\")\n",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"\n    Convert a CamelCase string to snake_case.\n\n    Args:\n        camel_str (str): The CamelCase string to convert.\n\n    Returns:\n        str: The converted snake_case string.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 506,
    "code_type": "method",
    "original_language": "python",
    "file_path": "backend\\2a8b52493d9195046114127f3f8387e95d1b5a06\\src\\utils.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Convert a snake_case string to CamelCase",
    "language_version_list": {
      "python": {
        "code_signature": "def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Convert a snake_case string to CamelCase.\n\n    Args:\n        snake_str (str): The snake_case string to convert.\n\n    Returns:\n        str: The converted CamelCase string.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestSnakeToCamel(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic snake_case to CamelCase conversion. \"\"\"\n        self.assertEqual(snake_to_camel(\"hello_world\"), \"HelloWorld\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a snake_case string with multiple words. \"\"\"\n        self.assertEqual(snake_to_camel(\"this_is_a_test\"), \"ThisIsATest\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(snake_to_camel(\"convert_this_123_string\"), \"ConvertThis123String\")\n\n    def test_leading_trailing_underscores(self):\n        \"\"\" Test conversion with leading and trailing underscores. \"\"\"\n        self.assertEqual(snake_to_camel(\"_leading_and_trailing_\"), \"LeadingAndTrailing\")\n        self.assertEqual(snake_to_camel(\"___multiple___underscores___\"), \"MultipleUnderscores\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(snake_to_camel(\"\"), \"\")",
        "prompt": "please write a python function , the function signature as below def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Convert a snake_case string to CamelCase.\n\n    Args:\n        snake_str (str): The snake_case string to convert.\n\n    Returns:\n        str: The converted CamelCase string.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 507,
    "code_type": "method",
    "original_language": "python",
    "file_path": "backend\\2a8b52493d9195046114127f3f8387e95d1b5a06\\src\\utils.py\n",
    "question_type": "Program input code",
    "summary": "Check that a password satisfies the criteria for a strong password, has at least one lowercase letter, at least one uppercase letter, at least one number, and is at least 8 bits long",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef is_strong_password(password: str) -> bool:\n    \"\"\"\n    Check if the provided password is strong.\n\n    A strong password must satisfy the following criteria:\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one number\n    - At least 8 characters long\n\n    Args:\n        password (str): The password to check.\n\n    Returns:\n        bool: True if the password is strong, False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestStrongPassword(unittest.TestCase):\n    def test_valid_password(self):\n        \"\"\" Test a strong password that meets all criteria. \"\"\"\n        self.assertTrue(is_strong_password(\"StrongPass1\"))\n\n    def test_missing_lowercase(self):\n        \"\"\" Test a password missing a lowercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"STRONGPASS1\"))\n\n    def test_missing_uppercase(self):\n        \"\"\" Test a password missing an uppercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"strongpass1\"))\n\n    def test_missing_number(self):\n        \"\"\" Test a password missing a number. \"\"\"\n        self.assertFalse(is_strong_password(\"StrongPassword\"))\n\n    def test_too_short(self):\n        \"\"\" Test a password that is too short. \"\"\"\n        self.assertFalse(is_strong_password(\"Short1\"))\n\n    def test_valid_with_special_characters(self):\n        \"\"\" Test a password that includes special characters but is still strong. \"\"\"\n        self.assertTrue(is_strong_password(\"Strong!Password1\"))",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_strong_password(password: str) -> bool:\n    \"\"\"\n    Check if the provided password is strong.\n\n    A strong password must satisfy the following criteria:\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one number\n    - At least 8 characters long\n\n    Args:\n        password (str): The password to check.\n\n    Returns:\n        bool: True if the password is strong, False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 509,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Approx-Multipliers-SMC\\5a0d8d7c37a02c2ff6d2c79cba3e609ae21178f2\\auxiliary\\density\\in\\elgamal\\elgamal.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Perform modular exponentiation: (base^exponent) % modulus efficiently.",
    "language_version_list": {
      "python": {
        "code_signature": "def mod_exp(base:int, exponent:int, modulus:int) -> int:\n    \"\"\"\n    Perform modular exponentiation: (base^exponent) % modulus efficiently.\n\n    Args:\n        base (int): The base value.\n        exponent (int): The exponent value (should be non-negative).\n        modulus (int): The modulus value (should be positive).\n\n    Returns:\n        int: The result of (base^exponent) % modulus.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestModExp(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\" Test with base = 2, exponent = 10, modulus = 1000 \"\"\"\n        self.assertEqual(mod_exp(2, 10, 1000), 24)\n\n    def test_case_2(self):\n        \"\"\" Test with base = 3, exponent = 7, modulus = 50 \"\"\"\n        self.assertEqual(mod_exp(3, 7, 50), 37)\n\n    def test_case_3(self):\n        \"\"\" Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1) \"\"\"\n        self.assertEqual(mod_exp(5, 0, 13), 1)\n\n    def test_case_4(self):\n        \"\"\" Test with base = 7, exponent = 5, modulus = 20 \"\"\"\n        self.assertEqual(mod_exp(7, 5, 20), 7)  # 7^5 = 16807, 16807 % 20 = 7\n\n    def test_case_5(self):\n        \"\"\" Test with base = 10, exponent = 5, modulus = 6 \"\"\"\n        self.assertEqual(mod_exp(10, 5, 6), 4)  # 10^5 = 100000, 100000 % 6 = 4",
        "prompt": "please write a python function , the function signature as below def mod_exp(base:int, exponent:int, modulus:int) -> int:\n    \"\"\"\n    Perform modular exponentiation: (base^exponent) % modulus efficiently.\n\n    Args:\n        base (int): The base value.\n        exponent (int): The exponent value (should be non-negative).\n        modulus (int): The modulus value (should be positive).\n\n    Returns:\n        int: The result of (base^exponent) % modulus.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 510,
    "code_type": "method",
    "original_language": "python",
    "file_path": "AtCoder\\e7abdb335d403877150df2522f5cb1957ef0938b\\AtCoderBeginnerContest\\324\\b.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Find the powers of 2 and 3 that multiply to produce the given number.",
    "language_version_list": {
      "python": {
        "code_signature": "def find_powers(num: int) -> tuple:\n    \"\"\"\n    Find the powers of 2 and 3 that multiply to produce the given number.\n\n    Args:\n        num (int): A positive integer greater than zero.\n\n    Returns:\n        tuple: A tuple (n, m) where n is the power of 2 and m is the power of 3.\n           Returns None if the number is zero or if the number has prime factors other than 2 and 3.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestFindPowers(unittest.TestCase):\n\n    def test_valid_cases(self):\n        \"\"\"Test valid numbers with only 2's and 3's as prime factors.\"\"\"\n        self.assertEqual(find_powers(18), (1, 2))  # 18 = 2^1 * 3^2\n        self.assertEqual(find_powers(8), (3, 0))   # 8 = 2^3 * 3^0\n        self.assertEqual(find_powers(27), (0, 3))  # 27 = 2^0 * 3^3\n        self.assertEqual(find_powers(12), (2, 1))  # 12 = 2^2 * 3^1\n        self.assertEqual(find_powers(1), (0, 0))    # 1 = 2^0 * 3^0\n\n    def test_invalid_cases(self):\n        \"\"\"Test numbers with prime factors other than 2 and 3.\"\"\"\n        self.assertIsNone(find_powers(7))    # 7 is a prime factor\n        self.assertIsNone(find_powers(14))   # 14 = 2^1 * 7^1 (contains 7)\n        self.assertIsNone(find_powers(10))   # 10 = 2^1 * 5^1 (contains 5)\n\n\n    def test_large_numbers(self):\n        \"\"\"Test large numbers that have only 2 and 3 as prime factors.\"\"\"\n        self.assertEqual(find_powers(864), (5, 3))  # 864 = 2^5 * 3^3\n        self.assertEqual(find_powers(729), (0, 6))  # 729 = 2^0 * 3^6\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases for minimal inputs.\"\"\"\n        self.assertEqual(find_powers(2), (1, 0))   # 2 = 2^1 * 3^0\n        self.assertEqual(find_powers(3), (0, 1))   # 3 = 2^0 * 3^1",
        "prompt": "please write a python function , the function signature as below def find_powers(num: int) -> tuple:\n    \"\"\"\n    Find the powers of 2 and 3 that multiply to produce the given number.\n\n    Args:\n        num (int): A positive integer greater than zero.\n\n    Returns:\n        tuple: A tuple (n, m) where n is the power of 2 and m is the power of 3.\n           Returns None if the number is zero or if the number has prime factors other than 2 and 3.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 511,
    "code_type": "method",
    "original_language": "python",
    "file_path": "ObjectiveCli\\fbe60c455d846047b0fe9e2e4d3449f46a9a847f\\libs\\packaged\\Drawlib2\\generators.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Convert a hexadecimal color code to an ANSI escape code",
    "language_version_list": {
      "python": {
        "code_signature": "def hex_to_ansi(hex_color: str) -> str:\n    \"\"\"\n    Convert a hexadecimal color code to an ANSI escape code.\n\n    Args:\n        hex_color (str): A string representing the hexadecimal color code, e.g., '#FF5733'.\n\n    Returns:\n        str: An ANSI escape code for the specified RGB color.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestHexToAnsi(unittest.TestCase):\n\n    def test_valid_colors(self):\n        \"\"\"Test valid hex color inputs.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#FF5733\"), \"\\x1b[38;2;255;87;51m\")\n        self.assertEqual(hex_to_ansi(\"#00FF00\"), \"\\x1b[38;2;0;255;0m\")\n        self.assertEqual(hex_to_ansi(\"#0000FF\"), \"\\x1b[38;2;0;0;255m\")\n\n    def test_black_and_white(self):\n        \"\"\"Test edge cases with black and white colors.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#000000\"), \"\\x1b[38;2;0;0;0m\")  # Black\n        self.assertEqual(hex_to_ansi(\"#FFFFFF\"), \"\\x1b[38;2;255;255;255m\")  # White\n",
        "prompt": "please write a python function , the function signature as below def hex_to_ansi(hex_color: str) -> str:\n    \"\"\"\n    Convert a hexadecimal color code to an ANSI escape code.\n\n    Args:\n        hex_color (str): A string representing the hexadecimal color code, e.g., '#FF5733'.\n\n    Returns:\n        str: An ANSI escape code for the specified RGB color.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 512,
    "code_type": "method",
    "original_language": "python",
    "file_path": "digipick-solver\\1b3da607cb095cf439721a8f4a1d84ad5076fd9e\\orig\\digipick.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Convert a list of hole positions to the ring format (list of 1s and 0s).",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef convert_to_ring_format(holes: List) -> List:\n    \"\"\"\n    Convert a list of hole positions to the ring format (list of 1s and 0s).\n\n    Args:\n        holes (list): A list of integers representing the positions of the holes (0-indexed).\n\n    Returns:\n        List: A list of length 32, where positions with holes are 0 and others are 1.\n\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestConvertToRingFormat(unittest.TestCase):\n\n    def test_no_holes(self):\n        \"\"\" Test with no holes provided. \"\"\"\n        holes = []\n        expected = [1] * 32  # All positions should be 1\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_single_hole(self):\n        \"\"\" Test with a single hole position. \"\"\"\n        holes = [5]\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_multiple_holes(self):\n        \"\"\" Test with multiple hole positions. \"\"\"\n        holes = [0, 2, 4, 8, 16]\n        expected = [1] * 32\n        for hole in holes:\n            expected[hole] = 0  # Set specified positions to 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_hole_out_of_bounds(self):\n        \"\"\" Test with some hole positions out of bounds. \"\"\"\n        holes = [-1, 32, 5, 10]  # -1 and 32 are out of bounds\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 and 10 should be 0\n        expected[10] = 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_all_holes(self):\n        \"\"\" Test with all positions as holes. \"\"\"\n        holes = list(range(32))  # All positions from 0 to 31\n        expected = [0] * 32  # All positions should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_to_ring_format(holes: List) -> List:\n    \"\"\"\n    Convert a list of hole positions to the ring format (list of 1s and 0s).\n\n    Args:\n        holes (list): A list of integers representing the positions of the holes (0-indexed).\n\n    Returns:\n        List: A list of length 32, where positions with holes are 0 and others are 1.\n\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 513,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Scrapers_Matei\\c3342a3e2348fff2edf8d4d612ba3e86c670374d\\sites\\__utils\\found_county.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Check whether the phrase exists in the string, ignoring the case of the phrase\n",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef is_phrase_in_string_ignore_case(phrase: str, string: str) -> bool:\n    \"\"\"\n    Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n\n    Args:\n        phrase (str): The phrase to search for in the string.\n        string (str): The target string in which to search for the phrase.\n\n    Returns:\n        bool: True if the phrase is found as a whole word in the string, False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestIsPhraseInStringIgnoreCase(unittest.TestCase):\n\n    def test_exact_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"hello world\", \"Hello World\"))\n\n\n    def test_partial_word_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"Hello\", \"saying Hello there\"))\n\n    def test_different_cases(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"HELLO\", \"hello there!\"))\n        self.assertTrue(is_phrase_in_string_ignore_case(\"world\", \"WORLD is great\"))\n\n    def test_non_existent_phrase(self):\n        self.assertFalse(is_phrase_in_string_ignore_case(\"goodbye\", \"Hello world\"))\n        self.assertFalse(is_phrase_in_string_ignore_case(\"hello\", \"goodbye world\"))\n\n",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_phrase_in_string_ignore_case(phrase: str, string: str) -> bool:\n    \"\"\"\n    Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n\n    Args:\n        phrase (str): The phrase to search for in the string.\n        string (str): The target string in which to search for the phrase.\n\n    Returns:\n        bool: True if the phrase is found as a whole word in the string, False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 514,
    "code_type": "method",
    "original_language": "python",
    "file_path": "kuda-assistant\\e7b8ef7b819bec85ddf4425660a03e88310f56b4\\utils\\processes.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Extracts the date in the format YYYY-MM-DD from the given file name.",
    "language_version_list": {
      "python": {
        "code_signature": "import re\n\n\ndef extract_date_from_filename(file_name: str):\n    \"\"\"\n    Extracts the date in the format YYYY-MM-DD from the given file name.\n\n    Args:\n        file_name (str): The name of the file which may contain a date.\n\n    Returns:\n        str or None: The extracted date string in YYYY-MM-DD format if found, else None.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestExtractDateFromFilename(unittest.TestCase):\n\n    def test_date_extraction_success(self):\n        \"\"\"Test case where the date is successfully extracted.\"\"\"\n        file_name = \"report-2023-09-28.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_no_date_in_filename(self):\n        \"\"\"Test case where no date is present in the filename.\"\"\"\n        file_name = \"report.txt\"\n        self.assertIsNone(extract_date_from_filename(file_name))\n\n    def test_multiple_dates_in_filename(self):\n        \"\"\"Test case where multiple dates are present, should return the first one.\"\"\"\n        file_name = \"report-2023-09-28-backup-2023-10-01.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_date_at_start_of_filename(self):\n        \"\"\"Test case where the date is at the start of the filename.\"\"\"\n        file_name = \"2023-09-28-report.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_incorrect_date_format(self):\n        \"\"\"Test case where the date format is incorrect.\"\"\"\n        file_name = \"report-2023-99-99.txt\"  # Invalid date\n        expected_date = \"2023-99-99\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n",
        "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_date_from_filename(file_name: str):\n    \"\"\"\n    Extracts the date in the format YYYY-MM-DD from the given file name.\n\n    Args:\n        file_name (str): The name of the file which may contain a date.\n\n    Returns:\n        str or None: The extracted date string in YYYY-MM-DD format if found, else None.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 515,
    "code_type": "method",
    "original_language": "python",
    "file_path": "kuda-assistant\\e7b8ef7b819bec85ddf4425660a03e88310f56b4\\utils\\processes.py\n",
    "question_type": "Data processing and transformation",
    "summary": "    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.",
    "language_version_list": {
      "python": {
        "code_signature": "from datetime import datetime\n\ndef format_date_string(date_str:str):\n    \"\"\"\n    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.\n\n    Args:\n        date_str (str): The input date string.\n\n    Returns:\n        str: The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n        None: If the input date string is invalid.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestFormatDateString(unittest.TestCase):\n\n    def test_valid_date_conversion(self):\n        \"\"\"Test case for a valid date string.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\"\n        expected_date = \"2023-09-28_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)\n\n    def test_invalid_date_format(self):\n        \"\"\"Test case for an invalid date string format.\"\"\"\n        date_str = \"Invalid date format\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_missing_components(self):\n        \"\"\"Test case for a date string missing components.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_edge_case_date(self):\n        \"\"\"Test case for an edge case date string (e.g., leap year).\"\"\"\n        date_str = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\"\n        expected_date = \"2024-02-29_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)",
        "prompt": "please write a python function , the function signature as below from datetime import datetime\n\ndef format_date_string(date_str:str):\n    \"\"\"\n    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.\n\n    Args:\n        date_str (str): The input date string.\n\n    Returns:\n        str: The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n        None: If the input date string is invalid.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 516,
    "code_type": "method",
    "original_language": "python",
    "file_path": "prompt-optimizer\\ea72ca56973559ad5d37b38da96caa22cfb2310d\\evaluations\\utils.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "Reads a YAML file and returns its content as a Python dictionary or list.",
    "language_version_list": {
      "python": {
        "code_signature": "import os\n\n\ndef read_yaml(file_path: str):\n    \"\"\"\n    Reads a YAML file and returns its content as a Python dictionary or list.\n\n    Args:\n        file_path (str): The path to the YAML file.\n\n    Returns:\n        dict or list: Parsed YAML content as a Python data structure.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        yaml.YAMLError: If there is an error parsing the YAML file.\n    \"\"\"",
        "test_code": "import os\nimport unittest\n\nimport yaml\n\n\nclass TestReadYaml(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a temporary YAML file for testing.\"\"\"\n        self.valid_yaml_file = 'test_valid.yaml'\n        self.invalid_yaml_file = 'test_invalid.yaml'\n        self.non_existent_file = 'non_existent.yaml'\n\n        # Valid YAML content\n        with open(self.valid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\")\n\n        # Invalid YAML content\n        with open(self.invalid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary YAML files after testing.\"\"\"\n        if os.path.isfile(self.valid_yaml_file):\n            os.remove(self.valid_yaml_file)\n        if os.path.isfile(self.invalid_yaml_file):\n            os.remove(self.invalid_yaml_file)\n\n    def test_read_valid_yaml(self):\n        \"\"\"Test reading a valid YAML file.\"\"\"\n        expected_data = {\n            'name': 'Example',\n            'version': 1.0,\n            'dependencies': ['package1', 'package2']\n        }\n        result = read_yaml(self.valid_yaml_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_yaml(self.non_existent_file)\n\n\n    def test_empty_yaml_file(self):\n        \"\"\"Test reading an empty YAML file.\"\"\"\n        empty_yaml_file = 'test_empty.yaml'\n        with open(empty_yaml_file, 'w') as file:\n            file.write(\"\")  # Create an empty YAML file\n\n        result = read_yaml(empty_yaml_file)\n        self.assertIsNone(result)  # Expecting None for empty file\n\n        os.remove(empty_yaml_file)  # Cleanup after the test",
        "prompt": "please write a python function , the function signature as below import os\n\n\ndef read_yaml(file_path: str):\n    \"\"\"\n    Reads a YAML file and returns its content as a Python dictionary or list.\n\n    Args:\n        file_path (str): The path to the YAML file.\n\n    Returns:\n        dict or list: Parsed YAML content as a Python data structure.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        yaml.YAMLError: If there is an error parsing the YAML file.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 517,
    "code_type": "method",
    "original_language": "python",
    "file_path": "prompt-optimizer\\ea72ca56973559ad5d37b38da96caa22cfb2310d\\evaluations\\utils.py\n",
    "question_type": "File operations and I/O operation",
    "summary": "Reads a JSON Lines file and returns its content as a list of dictionaries.",
    "language_version_list": {
      "python": {
        "code_signature": "import json\nimport os\nfrom typing import List, Dict, Any\n\ndef read_jsonl(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Reads a JSON Lines file and returns its content as a list of dictionaries.\n\n    Args:\n        file_path (str): The path to the JSON Lines file.\n\n    Returns:\n        List[Dict[str, Any]]: A list of JSON objects parsed from the file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If there is an error parsing a line in the JSON Lines file.\n    \"\"\"",
        "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestReadJsonl(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create temporary JSON Lines files for testing.\"\"\"\n        self.valid_jsonl_file = 'test_valid.jsonl'\n        self.invalid_jsonl_file = 'test_invalid.jsonl'\n        self.non_existent_file = 'non_existent.jsonl'\n\n        # Valid JSON Lines content\n        with open(self.valid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": 25}\\n')\n            file.write('{\"name\": \"Charlie\", \"age\": 35}\\n')\n\n        # Invalid JSON Lines content\n        with open(self.invalid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": \"twenty-five}\\n')  # Missing closing quote\n\n    def tearDown(self):\n        \"\"\"Remove the temporary JSON Lines files after testing.\"\"\"\n        if os.path.isfile(self.valid_jsonl_file):\n            os.remove(self.valid_jsonl_file)\n        if os.path.isfile(self.invalid_jsonl_file):\n            os.remove(self.invalid_jsonl_file)\n\n    def test_read_valid_jsonl(self):\n        \"\"\"Test reading a valid JSON Lines file.\"\"\"\n        expected_data = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25},\n            {\"name\": \"Charlie\", \"age\": 35}\n        ]\n        result = read_jsonl(self.valid_jsonl_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_jsonl(self.non_existent_file)\n\n    def test_empty_jsonl_file(self):\n        \"\"\"Test reading an empty JSON Lines file.\"\"\"\n        empty_jsonl_file = 'test_empty.jsonl'\n        with open(empty_jsonl_file, 'w') as file:\n            file.write(\"\")  # Create an empty JSON Lines file\n\n        result = read_jsonl(empty_jsonl_file)\n        self.assertEqual(result, [])  # Expecting an empty list for empty file\n\n        os.remove(empty_jsonl_file)  # Cleanup after the test",
        "prompt": "please write a python function , the function signature as below import json\nimport os\nfrom typing import List, Dict, Any\n\ndef read_jsonl(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Reads a JSON Lines file and returns its content as a list of dictionaries.\n\n    Args:\n        file_path (str): The path to the JSON Lines file.\n\n    Returns:\n        List[Dict[str, Any]]: A list of JSON objects parsed from the file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If there is an error parsing a line in the JSON Lines file.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 518,
    "code_type": "method",
    "original_language": "python",
    "file_path": "TRGB-BikeComputer\\2537af5d089f764d74269c04410485827529af7b\\Tools\\csv2influx.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Convert numeric values in a CSV row from string format to a standardized format.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Dict, Optional\n\ndef convert_csv_values(row: Dict[str, str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Convert numeric values in a CSV row from string format to a standardized format.\n\n    Args:\n        row (Dict[str, str]): A dictionary representing a row of CSV data where\n                               keys are column names and values are strings.\n\n    Returns:\n        Dict[str, Optional[str]]: A new dictionary with values converted:\n                                   - Numeric strings have commas replaced with dots.\n                                   - Non-numeric strings are set to None.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestConvertCsvValues(unittest.TestCase):\n\n    def test_valid_numeric_strings(self):\n        \"\"\"Test with valid numeric strings including commas.\"\"\"\n        row = {'value1': '1,234', 'value2': '5,678', 'value3': '9,876'}\n        expected = {'value1': '1.234', 'value2': '5.678', 'value3': '9.876'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_non_numeric_strings(self):\n        \"\"\"Test with non-numeric strings.\"\"\"\n        row = {'value1': 'not_a_number', 'value2': 'hello', 'value3': 'world'}\n        expected = {'value1': None, 'value2': None, 'value3': None}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_mixed_values(self):\n        \"\"\"Test with a mix of numeric and non-numeric strings.\"\"\"\n        row = {'value1': '1,234', 'value2': 'not_a_number', 'value3': '3,14159'}\n        expected = {'value1': '1.234', 'value2': None, 'value3': '3.14159'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_no_values(self):\n        row = {'value1': 'aaaa', 'value2': 'not_a_number', 'value3': '3,14'}\n        expected = {'value1': None, 'value2': None, 'value3': '3.14'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases with empty strings and negative numbers.\"\"\"\n        row = {'value1': '', 'value2': '0.0', 'value3': '1,23'}\n        expected = {'value1': None, 'value2': '0.0', 'value3': '1.23'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import Dict, Optional\n\ndef convert_csv_values(row: Dict[str, str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Convert numeric values in a CSV row from string format to a standardized format.\n\n    Args:\n        row (Dict[str, str]): A dictionary representing a row of CSV data where\n                               keys are column names and values are strings.\n\n    Returns:\n        Dict[str, Optional[str]]: A new dictionary with values converted:\n                                   - Numeric strings have commas replaced with dots.\n                                   - Non-numeric strings are set to None.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 519,
    "code_type": "method",
    "original_language": "python",
    "file_path": "gicog\\44da3e0ad3c6c46a8d4d218d69808a9163746038\\alphabetMatrix\\alphabetsToMatrix.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Transpose a given matrix (2D array).",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\ndef transpose_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transpose a given matrix (2D array).\n\n    Args:\n        matrix (List[List[int]]): The input 2D array to be transposed.\n\n    Returns:\n        List[List[int]]: The transposed 2D array.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestTransposeMatrix(unittest.TestCase):\n\n    def test_square_matrix(self):\n        \"\"\"Test transposing a square matrix.\"\"\"\n        matrix = [[1, 2], [3, 4]]\n        expected = [[1, 3], [2, 4]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_rectangular_matrix(self):\n        \"\"\"Test transposing a rectangular matrix.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        expected = [[1, 4], [2, 5], [3, 6]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n\n    def test_matrix_with_empty_rows(self):\n        \"\"\"Test transposing a matrix with an empty row.\"\"\"\n        matrix = [[], []]\n        expected = []\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_single_element_matrix(self):\n        \"\"\"Test transposing a matrix with a single element.\"\"\"\n        matrix = [[5]]\n        expected = [[5]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)",
        "prompt": "please write a python function , the function signature as below from typing import List\n\ndef transpose_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transpose a given matrix (2D array).\n\n    Args:\n        matrix (List[List[int]]): The input 2D array to be transposed.\n\n    Returns:\n        List[List[int]]: The transposed 2D array.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 520,
    "code_type": "method",
    "original_language": "python",
    "file_path": "geometric-algebra\\a5de1818b58da50d2cb7084c4d540238076358c7\\src\\Multivector.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.",
    "language_version_list": {
      "python": {
        "code_signature": "def compute_output_index(idx_1: int, idx_2: int) -> int:\n    \"\"\"\n    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.\n\n    This function interprets the integers as little-endian bitstrings, takes their XOR,\n    and interprets the result as an integer in little-endian.\n\n    Args:\n        idx_1 (int): Input index 1.\n        idx_2 (int): Input index 2.\n\n    Returns:\n        int: The computed output index.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestComputeOutputIndex(unittest.TestCase):\n\n    def test_standard_case(self):\n        \"\"\"Test with two standard positive integers.\"\"\"\n        idx_1 = 3  # binary: 11\n        idx_2 = 5  # binary: 101\n        expected = 6  # 3 XOR 5 = 6\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_identical_indices(self):\n        \"\"\"Test with identical indices (should return 0).\"\"\"\n        idx_1 = 7  # binary: 111\n        idx_2 = 7  # binary: 111\n        expected = 0  # 7 XOR 7 = 0\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_zero_index(self):\n        \"\"\"Test with one index as zero.\"\"\"\n        idx_1 = 0  # binary: 0\n        idx_2 = 5  # binary: 101\n        expected = 5  # 0 XOR 5 = 5\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_large_numbers(self):\n        \"\"\"Test with large integer values.\"\"\"\n        idx_1 = 1024  # binary: 10000000000\n        idx_2 = 2048  # binary: 100000000000\n        expected = 3072  # 1024 XOR 2048 = 3072\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n",
        "prompt": "please write a python function , the function signature as below def compute_output_index(idx_1: int, idx_2: int) -> int:\n    \"\"\"\n    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.\n\n    This function interprets the integers as little-endian bitstrings, takes their XOR,\n    and interprets the result as an integer in little-endian.\n\n    Args:\n        idx_1 (int): Input index 1.\n        idx_2 (int): Input index 2.\n\n    Returns:\n        int: The computed output index.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 521,
    "code_type": "method",
    "original_language": "python",
    "file_path": "WM9A4-Digital-Development-with-Python\\67907a0e7f78729083fa6055cf367dba6a0c8f04\\10 practice questions\\word_filter.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.",
    "language_version_list": {
      "python": {
        "code_signature": "import re\nfrom collections import Counter\nfrom typing import List, Dict\n\n\ndef word_filter_counter(text: str, filter_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.\n\n    Args:\n        text (str): The input text from which to count words.\n        filter_words (List[str]): A list of words to filter and count.\n\n    Returns:\n        Dict[str, int]: A dictionary with the count of each filter word in the text,\n                         maintaining the order from filter_words.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestWordFilterCounter(unittest.TestCase):\n\n    def test_case1(self):\n        text = \"go to the school.go to the park.\"\n        filter_words = [\"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"go\": 2,\n            \"to\": 2,\n            \"the\": 2,\n            \"school\": 1,\n            \"park\": 1,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_case2(self):\n        text = \"This is a completely different sentence.\"\n        filter_words = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"I'll\": 0,\n            \"go\": 0,\n            \"to\": 0,\n            \"the\": 0,\n            \"school\": 0,\n            \"park\": 0,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_case3(self):\n        text = \"I will not go to the school's park.\"\n        filter_words = [\"I\", \"will\", \"not\", \"go\", \"to\", \"the\", \"school's\", \"park\"]\n        expected_output = {\n            \"I\": 1,\n            \"will\": 1,\n            \"not\": 1,\n            \"go\": 1,\n            \"to\": 1,\n            \"the\": 1,\n            \"school's\": 1,\n            \"park\": 1,\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n",
        "prompt": "please write a python function , the function signature as below import re\nfrom collections import Counter\nfrom typing import List, Dict\n\n\ndef word_filter_counter(text: str, filter_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.\n\n    Args:\n        text (str): The input text from which to count words.\n        filter_words (List[str]): A list of words to filter and count.\n\n    Returns:\n        Dict[str, int]: A dictionary with the count of each filter word in the text,\n                         maintaining the order from filter_words.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 522,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Rotate the point cloud around the Y axis by a given angle.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef rotate_point_cloud(point_cloud: np.ndarray, rotation_angle: float) -> np.ndarray:\n    \"\"\"\n    Rotate the point cloud around the Y axis by a given angle.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        rotation_angle (float): The angle (in radians) to rotate the point cloud.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the rotated point cloud.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestRotatePointCloud(unittest.TestCase):\n\n    def test_no_rotation(self):\n        \"\"\"Test when rotation angle is 0 (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 0\n        expected_output = point_cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_180_degree_rotation(self):\n        \"\"\"Test rotation of 180 degrees (\u03c0 radians) around Y axis.\"\"\"\n        point_cloud = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])\n        rotation_angle = np.pi  # 180 degrees\n        expected_output = np.array([[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])  # [1,0,0] -> [-1,0,0]\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_full_rotation(self):\n        \"\"\"Test rotation of 360 degrees (2\u03c0 radians) around Y axis (should return same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 2 * np.pi  # 360 degrees\n        expected_output = point_cloud  # Should return the same point cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef rotate_point_cloud(point_cloud: np.ndarray, rotation_angle: float) -> np.ndarray:\n    \"\"\"\n    Rotate the point cloud around the Y axis by a given angle.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        rotation_angle (float): The angle (in radians) to rotate the point cloud.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the rotated point cloud.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 523,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Translate the point cloud by a given vector.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef translate_point_cloud(point_cloud: np.ndarray, translation_vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Translate the point cloud by a given vector.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        translation_vector (np.ndarray): A 1 x 3 numpy array or list representing the translation vector.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the translated point cloud.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestTranslatePointCloud(unittest.TestCase):\n\n    def test_simple_translation(self):\n        \"\"\"Test a simple translation of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([1.0, 1.0, 1.0])\n        expected_output = np.array([[2.0, 3.0, 4.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_multiple_points_translation(self):\n        \"\"\"Test translation of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([1.0, 2.0, 3.0])\n        expected_output = np.array([[2.0, 4.0, 6.0], [5.0, 7.0, 9.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_zero_translation(self):\n        \"\"\"Test translation by a zero vector (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([0.0, 0.0, 0.0])\n        expected_output = point_cloud  # No change expected\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_negative_translation(self):\n        \"\"\"Test translation with negative values.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([-1.0, -2.0, -3.0])\n        expected_output = np.array([[0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef translate_point_cloud(point_cloud: np.ndarray, translation_vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Translate the point cloud by a given vector.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        translation_vector (np.ndarray): A 1 x 3 numpy array or list representing the translation vector.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the translated point cloud.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 524,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Scale the point cloud by a given factor.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\ndef scale_point_cloud(point_cloud: np.ndarray, scale_factor: float) -> np.ndarray:\n    \"\"\"\n    Scale the point cloud by a given factor.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        scale_factor ( float): A float representing the scaling factor.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the scaled point cloud.\n    \"\"\"",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestScalePointCloud(unittest.TestCase):\n\n    def test_simple_scaling(self):\n        \"\"\"Test scaling of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = 2.0\n        expected_output = np.array([[2.0, 4.0, 6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_multiple_points_scaling(self):\n        \"\"\"Test scaling of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.5\n        expected_output = np.array([[0.5, 1.0, 1.5], [2.0, 2.5, 3.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_zero_scaling(self):\n        \"\"\"Test scaling by a factor of zero (should return a point cloud of zeros).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.0\n        expected_output = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_negative_scaling(self):\n        \"\"\"Test scaling with a negative factor.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = -2.0\n        expected_output = np.array([[-2.0, -4.0, -6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef scale_point_cloud(point_cloud: np.ndarray, scale_factor: float) -> np.ndarray:\n    \"\"\"\n    Scale the point cloud by a given factor.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        scale_factor ( float): A float representing the scaling factor.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the scaled point cloud.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 525,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Facial_Expressions_Impact_3DFR\\9fab644a538bed6d2b96305a47fce2c1de0c34e7\\src\\src\\src\\utils.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Flip the point cloud across a specified axis.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef flip_point_cloud(point_cloud: np.ndarray, axis: int) -> np.ndarray:\n    \"\"\"\n    Flip the point cloud across a specified axis.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        axis (int): An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the flipped point cloud.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestFlipPointCloud(unittest.TestCase):\n\n    def test_flip_x_axis(self):\n        \"\"\"Test flipping the point cloud across the x-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=1), expected_output)\n\n    def test_flip_y_axis(self):\n        \"\"\"Test flipping the point cloud across the y-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)\n\n    def test_flip_z_axis(self):\n        \"\"\"Test flipping the point cloud across the z-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=2), expected_output)\n\n    def test_invalid_axis(self):\n        \"\"\"Test handling of an invalid axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        self.assertRaises(Exception)\n\n\n    def test_empty_point_cloud(self):\n        \"\"\"Test flipping an empty point cloud.\"\"\"\n        point_cloud = np.array([]).reshape(0, 3)  # Empty point cloud with shape (0, 3)\n        expected_output = np.array([]).reshape(0, 3)  # Expect the output to be the same\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef flip_point_cloud(point_cloud: np.ndarray, axis: int) -> np.ndarray:\n    \"\"\"\n    Flip the point cloud across a specified axis.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        axis (int): An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the flipped point cloud.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 526,
    "code_type": "method",
    "original_language": "python",
    "file_path": "NeetCode\\822d5781a0d703330ae1940fa2a9c8cbc3b3717a\\sliding_window\\minimum_window_substring.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Find the minimum window substring in `s` that contains all characters of `t`.",
    "language_version_list": {
      "python": {
        "code_signature": "from collections import Counter\n\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring in `s` that contains all characters of `t`.\n\n    Args:\n        s (str): The input string in which to search for the substring.\n        t (str): The target string whose characters must be included in the substring.\n\n    Returns:\n        str: The minimum window substring of `s` that contains all characters of `t`.Returns an empty string if no such substring exists.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestMinWindow(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a normal case where the minimum window exists.\"\"\"\n        s = \"ADOBECODEBANC\"\n        t = \"ABC\"\n        expected_output = \"BANC\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_no_window_exists(self):\n        \"\"\"Test where no window can satisfy the condition.\"\"\"\n        s = \"A\"\n        t = \"AA\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty input string s.\"\"\"\n        s = \"\"\n        t = \"ABC\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n\n    def test_multiple_valid_windows(self):\n        \"\"\"Test with multiple valid windows to ensure the smallest one is returned.\"\"\"\n        s = \"AA\"\n        t = \"AA\"\n        expected_output = \"AA\"\n        self.assertEqual(min_window(s, t), expected_output)\n",
        "prompt": "please write a python function , the function signature as below from collections import Counter\n\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring in `s` that contains all characters of `t`.\n\n    Args:\n        s (str): The input string in which to search for the substring.\n        t (str): The target string whose characters must be included in the substring.\n\n    Returns:\n        str: The minimum window substring of `s` that contains all characters of `t`.Returns an empty string if no such substring exists.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 527,
    "code_type": "method",
    "original_language": "python",
    "file_path": "Brick-Breaker\\7c88c3316aaf18a428bc1c98e8861aec6686512d\\source\\Process\\Triangle.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Check if a point is inside a triangle defined by three vertices.",
    "language_version_list": {
      "python": {
        "code_signature": "def is_point_inside_triangle(px: float, py: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float):\n    \"\"\"\n    Check if a point is inside a triangle defined by three vertices.\n\n    Args:\n        px (float): The x-coordinate of the point to check.\n        py (float): The y-coordinate of the point to check.\n        x1 (float): The x-coordinate of the first vertex of the triangle.\n        y1 (float): The y-coordinate of the first vertex of the triangle.\n        x2 (float): The x-coordinate of the second vertex of the triangle.\n        y2 (float): The y-coordinate of the second vertex of the triangle.\n        x3 (float): The x-coordinate of the third vertex of the triangle.\n        y3 (float): The y-coordinate of the third vertex of the triangle.\n\n    Returns:\n        bool: True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestPointInsideTriangle(unittest.TestCase):\n\n    def test_point_inside_triangle(self):\n        \"\"\"Test case where point is inside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 2)  # Inside the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_on_edge(self):\n        \"\"\"Test case where point is on the edge of the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 0)  # On the edge of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_outside_triangle(self):\n        \"\"\"Test case where point is outside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (6, 2)  # Outside the triangle\n        self.assertFalse(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_at_vertex(self):\n        \"\"\"Test case where point is at one of the triangle's vertices.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (0, 0)  # At the vertex of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))",
        "prompt": "please write a python function , the function signature as below def is_point_inside_triangle(px: float, py: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float):\n    \"\"\"\n    Check if a point is inside a triangle defined by three vertices.\n\n    Args:\n        px (float): The x-coordinate of the point to check.\n        py (float): The y-coordinate of the point to check.\n        x1 (float): The x-coordinate of the first vertex of the triangle.\n        y1 (float): The y-coordinate of the first vertex of the triangle.\n        x2 (float): The x-coordinate of the second vertex of the triangle.\n        y2 (float): The y-coordinate of the second vertex of the triangle.\n        x3 (float): The x-coordinate of the third vertex of the triangle.\n        y3 (float): The y-coordinate of the third vertex of the triangle.\n\n    Returns:\n        bool: True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 546,
    "code_type": "method",
    "original_language": "python",
    "file_path": "NephScripts/991e118f5c32db6fa954d21e4745a8ecfe06eff5/bin/tsv2md\n",
    "question_type": "Data processing and transformation",
    "summary": "    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.",
    "language_version_list": {
      "python": {
        "code_signature": "import csv\nimport sys\n\n\ndef read_tsv_from_stdin():\n    \"\"\"\n    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row of data.\n    \"\"\"\n",
        "test_code": "import unittest\nimport sys\nimport io\nfrom unittest.mock import patch\n\n\nclass TestReadTsvFromStdin(unittest.TestCase):\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_basic_tsv_input(self, mock_stdin):\n        mock_stdin.write(\"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\")\n        mock_stdin.seek(0)  # Move to the start of the StringIO object\n        expected_output = [['col1', 'col2', 'col3'], ['val1', 'val2', 'val3']]\n        self.assertEqual(read_tsv_from_stdin(), expected_output)\n\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_single_column(self, mock_stdin):\n        mock_stdin.write(\"col1\\nval1\\nval2\\n\")\n        mock_stdin.seek(0)\n        expected_output = [['col1'], ['val1'], ['val2']]\n        self.assertEqual(read_tsv_from_stdin(), expected_output)\n",
        "prompt": "please write a python function , the function signature as below import csv\nimport sys\n\n\ndef read_tsv_from_stdin():\n    \"\"\"\n    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row of data.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 547,
    "code_type": "method",
    "original_language": "python",
    "file_path": "NephScripts/991e118f5c32db6fa954d21e4745a8ecfe06eff5/bin/tsv2md\n",
    "question_type": "Data processing and transformation",
    "summary": "Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import List\n\n\ndef calculate_column_widths(data: List[List[str]]) -> List[int]:\n    \"\"\"\n    Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n\n    Args:\n        data (List[List[str]]): A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n\n    Returns:\n        List[int]: A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n    \"\"\"\n",
        "test_code": "import unittest\n\n\nclass TestCalculateColumnWidths(unittest.TestCase):\n\n    def test_standard_case(self):\n        data = [[\"Name\", \"Age\", \"City\"],\n                [\"Alice\", \"22\", \"New York\"],\n                [\"Bob\", \"30\", \"San Francisco\"]]\n        expected = [5, 3, 13]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n\n    def test_single_element(self):\n        data = [[\"Name\"]]\n        expected = [4]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_varied_length(self):\n        data = [[\"a\", \"bb\", \"ccc\"],\n                [\"dddd\", \"ee\", \"f\"]]\n        expected = [4, 2, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_all_empty_strings(self):\n        data = [[\"\", \"\", \"\"],\n                [\"\", \"\", \"\"]]\n        expected = [0, 0, 0]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_mixed_content(self):\n        data = [[\"1234\", \"567\", \"890\"],\n                [\"abc\", \"defg\", \"h\"]]\n        expected = [4, 4, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_single_column_multiple_rows(self):\n        data = [[\"one\"],\n                [\"two\"],\n                [\"three\"]]\n        expected = [5]\n        self.assertEqual(calculate_column_widths(data), expected)\n",
        "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_column_widths(data: List[List[str]]) -> List[int]:\n    \"\"\"\n    Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n\n    Args:\n        data (List[List[str]]): A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n\n    Returns:\n        List[int]: A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 548,
    "code_type": "method",
    "original_language": "python",
    "file_path": "stock/2b2a2f8a1c6273e54e9fc873fd911e382094aa5b/pyplot_linechart_Revenue.py\n",
    "question_type": "Data processing and transformation",
    "summary": "Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.",
    "language_version_list": {
      "python": {
        "code_signature": "import json\n\n\ndef read_txt_add_json_bracket(filename:str):\n    \"\"\"\n    Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.\n\n    Args:\n        filename (str): The path to the text file to be read.\n\n    Returns:\n        list: A list parsed from the JSON content wrapped in brackets.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If the content cannot be parsed as JSON.\n    \"\"\"",
        "test_code": "import os\nimport unittest\nfrom unittest.mock import patch, mock_open\n\n\nclass TestReadTxtAddJsonBracket(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}')\n    def test_valid_json(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='[]')\n    def test_empty_json_array(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [[]])  # Should return an empty list\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}\\n')\n    def test_valid_json_with_newline(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data='{\"key\": \"value\"}')\n    def test_json_with_array(self, mock_file):\n        result = read_txt_add_json_bracket(\"fakefile.txt\")\n        self.assertEqual(result, [{\"key\": \"value\"}])\n",
        "prompt": "please write a python function , the function signature as below import json\n\n\ndef read_txt_add_json_bracket(filename:str):\n    \"\"\"\n    Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.\n\n    Args:\n        filename (str): The path to the text file to be read.\n\n    Returns:\n        list: A list parsed from the JSON content wrapped in brackets.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If the content cannot be parsed as JSON.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 549,
    "code_type": "method",
    "original_language": "python",
    "file_path": "xpsi/02e399f659576bf80daaf888128e1f46c078073f/examples/examples_modeling_tutorial/modules/helper_functions.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Converts temperature from keV to log10(K) for a given input (scalar or tuple)",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Union, Tuple\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef get_T_in_log10_Kelvin(T_keV: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from keV to log10(K) for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_keV (float or tuple): The temperature in keV. Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in log10(K) corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\nclass TestGetTInLog10Kelvin(unittest.TestCase):\n\n    # Existing test cases here...\n\n    def test_scalar_input_high_temperature(self):\n        \"\"\"Test with a high scalar input.\"\"\"\n        T_keV = 100.0\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_scalar_input_low_temperature(self):\n        \"\"\"Test with a low scalar input.\"\"\"\n        T_keV = 0.01\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_large_range(self):\n        \"\"\"Test with a tuple of temperatures over a large range.\"\"\"\n        T_keV = (0.1, 1.0, 10.0, 100.0, 1000.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_tuple_input_repeated_values(self):\n        \"\"\"Test with a tuple of repeated temperature values.\"\"\"\n        T_keV = (1.0, 1.0, 1.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_scalar_input_non_integer(self):\n        \"\"\"Test with a non-integer scalar input.\"\"\"\n        T_keV = 2.5\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_floating_point(self):\n        \"\"\"Test with a tuple of floating-point temperatures.\"\"\"\n        T_keV = (1.5, 2.5, 3.5)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n\n    def test_large_tuple_input(self):\n        \"\"\"Test with a large tuple of temperature values.\"\"\"\n        T_keV = tuple(np.arange(1, 1001, 1))  # Temperatures from 1 keV to 1000 keV\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n",
        "prompt": "please write a python function , the function signature as below from typing import Union, Tuple\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef get_T_in_log10_Kelvin(T_keV: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from keV to log10(K) for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_keV (float or tuple): The temperature in keV. Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in log10(K) corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 550,
    "code_type": "method",
    "original_language": "python",
    "file_path": "xpsi/02e399f659576bf80daaf888128e1f46c078073f/examples/examples_modeling_tutorial/modules/helper_functions.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5",
    "language_version_list": {
      "python": {
        "code_signature": "from typing import Tuple, Union\n\nimport numpy as np\n\n# Define the constant for conversion: Boltzmann constant in keV/K\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef convert_log10_K_to_keV(T_log10_K: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_log10_K (float or tuple): The temperature in log10(K). Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in keV corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n",
        "test_code": "import unittest\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\nclass TestConvertLog10KToKeV(unittest.TestCase):\n\n    def test_scalar_input(self):\n        \"\"\"Test conversion of a single scalar log10(K) value.\"\"\"\n        T_log10_K = 3.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input(self):\n        \"\"\"Test conversion of a tuple of log10(K) values.\"\"\"\n        T_log10_K = (2.0, 3.0, 4.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_zero_input(self):\n        \"\"\"Test conversion of log10(K) = 0.\"\"\"\n        T_log10_K = 0.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_negative_input(self):\n        \"\"\"Test conversion of a negative log10(K) value.\"\"\"\n        T_log10_K = -1.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_large_tuple_input(self):\n        \"\"\"Test conversion of a large tuple of log10(K) values.\"\"\"\n        T_log10_K = (1.0, 2.0, 3.0, 4.0, 5.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_single_large_value(self):\n        \"\"\"Test conversion of a large log10(K) value.\"\"\"\n        T_log10_K = 10.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_invalid_input(self):\n        \"\"\"Test conversion with invalid input (string).\"\"\"\n        T_log10_K = \"invalid\"\n        with self.assertRaises(ValueError):\n            convert_log10_K_to_keV(T_log10_K)\n",
        "prompt": "please write a python function , the function signature as below from typing import Tuple, Union\n\nimport numpy as np\n\n# Define the constant for conversion: Boltzmann constant in keV/K\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef convert_log10_K_to_keV(T_log10_K: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_log10_K (float or tuple): The temperature in log10(K). Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in keV corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 551,
    "code_type": "method",
    "original_language": "python",
    "file_path": "xpsi/02e399f659576bf80daaf888128e1f46c078073f/examples/examples_modeling_tutorial/modules/helper_functions.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Calculate the midpoints from a given array of edges",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef get_mids_from_edges(edges: np.ndarray):\n    \"\"\"\n    Calculate the midpoints from a given array of edges.\n    For example:\n        input: [0, 1, 2]\n        output: [0.5, 1.5]\n\n    Args:\n        edges (np.ndarray): An array of edge values.\n\n    Returns:\n        np.ndarray: An array of midpoints calculated from the edges.\n    \"\"\"\n",
        "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestGetMidsFromEdges(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a standard range of edges.\"\"\"\n        edges = np.array([1, 2, 3, 4])\n        expected_mids = np.array([1.5, 2.5, 3.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_single_interval(self):\n        \"\"\"Test with two edges (single interval).\"\"\"\n        edges = np.array([5, 10])\n        expected_mids = np.array([7.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_multiple_intervals(self):\n        \"\"\"Test with multiple intervals.\"\"\"\n        edges = np.array([0, 1, 2, 3, 4, 5])\n        expected_mids = np.array([0.5, 1.5, 2.5, 3.5, 4.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_negative_edges(self):\n        \"\"\"Test with negative edges.\"\"\"\n        edges = np.array([-5, -3, -1, 1])\n        expected_mids = np.array([-4.0, -2.0, 0.0])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_zero_edges(self):\n        \"\"\"Test with edges including zero.\"\"\"\n        edges = np.array([0, 1, 2])\n        expected_mids = np.array([0.5, 1.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_float_edges(self):\n        \"\"\"Test with floating-point edges.\"\"\"\n        edges = np.array([0.0, 1.5, 3.0])\n        expected_mids = np.array([0.75, 2.25])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_empty_array(self):\n        \"\"\"Test with an empty array.\"\"\"\n        edges = np.array([])\n        expected_mids = np.array([])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_mids_from_edges(edges: np.ndarray):\n    \"\"\"\n    Calculate the midpoints from a given array of edges.\n    For example:\n        input: [0, 1, 2]\n        output: [0.5, 1.5]\n\n    Args:\n        edges (np.ndarray): An array of edge values.\n\n    Returns:\n        np.ndarray: An array of midpoints calculated from the edges.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 552,
    "code_type": "method",
    "original_language": "python",
    "file_path": "gradescope_grading_template/78e5ac5f34188d8d8683763cb23d3c1b9821f1ac/assert_utilities.py\n",
    "question_type": "Algorithm and data structure",
    "summary": "Compares two sets of floats for equality within a relative and absolute tolerance.",
    "language_version_list": {
      "python": {
        "code_signature": "import numpy as np\n\n\ndef are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6):\n    \"\"\"\n    Compares two sets of floats for equality within a relative and absolute tolerance.\n\n    Args:\n        set1: The first set of floats.\n        set2: The second set of floats.\n        rtol: The relative tolerance (default: 1e-5).\n        atol: The absolute tolerance (default: 1e-6).\n\n    Returns:\n        True if the sets are equal within the specified tolerances, False otherwise.\n    \"\"\"",
        "test_code": "import unittest\n\n\nclass TestAreSetsEqual(unittest.TestCase):\n\n    def test_identical_sets(self):\n        \"\"\"Test with two identical sets of floats.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.0, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2))\n\n    def test_sets_with_close_values(self):\n        \"\"\"Test with two sets that are close within the tolerance.\"\"\"\n        set1 = {1.0, 2.00001, 3.0}\n        set2 = {1.0, 2.00002, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_sets_with_large_difference(self):\n        \"\"\"Test with two sets that have large differences beyond tolerance.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.5, 3.0}\n        self.assertFalse(are_sets_equal(set1, set2))\n\n    def test_sets_with_one_different_values(self):\n        \"\"\"Test with two sets containing one different floats.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.000001, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_empty_sets(self):\n        \"\"\"Test with two empty sets.\"\"\"\n        set1 = set()\n        set2 = set()\n        self.assertTrue(are_sets_equal(set1, set2))\n",
        "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6):\n    \"\"\"\n    Compares two sets of floats for equality within a relative and absolute tolerance.\n\n    Args:\n        set1: The first set of floats.\n        set2: The second set of floats.\n        rtol: The relative tolerance (default: 1e-5).\n        atol: The absolute tolerance (default: 1e-6).\n\n    Returns:\n        True if the sets are equal within the specified tolerances, False otherwise.\n    \"\"\"",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 555,
    "code_type": "method",
    "original_language": "python",
    "file_path": "rigamajig2/b8fc87142efd66e974c4cdc1af1624f4c787dedb/python/rigamajig2/maya/mathUtils.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Convert a quaternion into an angle",
    "language_version_list": {
      "python": {
        "code_signature": "import math\nfrom typing import Tuple\n\n\ndef quaternion_to_angle(quaternion: Tuple[float]) -> float:\n    \"\"\"\n    Converts a quaternion to a rotation angle in radians.\n\n    Args:\n        quaternion (Tuple[float]): A tuple or list containing the quaternion components (w, x, y, z)\n\n    Returns:\n        float: The rotation angle in radians\n    \"\"\"\n",
        "test_code": "import math\nimport unittest\n\n\nclass TestQuaternionToAngle(unittest.TestCase):\n\n    def test_identity_quaternion(self):\n        \"\"\"Test the identity quaternion (no rotation).\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)\n        expected_angle = 0.0\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_180_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a 180-degree rotation.\"\"\"\n        quaternion = (0.0, 0.0, 1.0, 0.0)  # 180 degrees around Z axis\n        expected_angle = math.pi  # 180 degrees in radians\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n    def test_360_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a full 360-degree rotation.\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)  # Full rotation\n        expected_angle = 0.0  # 360 degrees is equivalent to 0 degrees\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_non_unit_quaternion(self):\n        \"\"\"Test a non-unit quaternion (should still give correct angle).\"\"\"\n        quaternion = (0.5, 0.5, 0.5, 0.5)  # This is not normalized\n        # Normalize the quaternion first\n        norm = math.sqrt(sum(x ** 2 for x in quaternion))\n        normalized_quaternion = tuple(x / norm for x in quaternion)\n        expected_angle = 2 * math.acos(normalized_quaternion[0])  # Should be same angle\n        self.assertAlmostEqual(quaternion_to_angle(normalized_quaternion), expected_angle)\n\n    def test_invalid_quaternion(self):\n        \"\"\"Test that an invalid quaternion raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            quaternion_to_angle((1.0, 0.0, 0.0))  # Only 3 components",
        "prompt": "please write a python function , the function signature as below import math\nfrom typing import Tuple\n\n\ndef quaternion_to_angle(quaternion: Tuple[float]) -> float:\n    \"\"\"\n    Converts a quaternion to a rotation angle in radians.\n\n    Args:\n        quaternion (Tuple[float]): A tuple or list containing the quaternion components (w, x, y, z)\n\n    Returns:\n        float: The rotation angle in radians\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 557,
    "code_type": "method",
    "original_language": "python",
    "file_path": "rigamajig2/b8fc87142efd66e974c4cdc1af1624f4c787dedb/python/rigamajig2/maya/mathUtils.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Convert an angle from radians to degrees",
    "language_version_list": {
      "python": {
        "code_signature": "def radians_to_degrees(radians: float) -> int:\n    \"\"\"\n    Convert an angle from radians to degrees.\n\n    Args:\n        radians (float): The angle in radians to convert.\n\n    Returns:\n        int: The angle in degrees.\n    \"\"\"\n",
        "test_code": "import math\nimport unittest\n\n\nclass TestRadiansToDegrees(unittest.TestCase):\n    def test_zero_radians(self):\n        \"\"\"Test conversion of 0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(0), 0, places=5)\n\n    def test_pi_over_two_radians(self):\n        \"\"\"Test conversion of \u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi / 2), 90, places=5)\n\n    def test_pi_radians(self):\n        \"\"\"Test conversion of \u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi), 180, places=5)\n\n    def test_three_pi_over_two_radians(self):\n        \"\"\"Test conversion of 3\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(3 * math.pi / 2), 270, places=5)\n\n    def test_two_pi_radians(self):\n        \"\"\"Test conversion of 2\u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(2 * math.pi), 360, places=5)\n\n    def test_negative_pi_over_two_radians(self):\n        \"\"\"Test conversion of -\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(-math.pi / 2), -90, places=5)\n\n    def test_large_radians(self):\n        \"\"\"Test conversion of a large angle (4\u03c0 radians)\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(4 * math.pi), 720, places=5)",
        "prompt": "please write a python function , the function signature as below def radians_to_degrees(radians: float) -> int:\n    \"\"\"\n    Convert an angle from radians to degrees.\n\n    Args:\n        radians (float): The angle in radians to convert.\n\n    Returns:\n        int: The angle in degrees.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 558,
    "code_type": "method",
    "original_language": "python",
    "file_path": "rigamajig2/b8fc87142efd66e974c4cdc1af1624f4c787dedb/python/rigamajig2/maya/mathUtils.py\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Convert an angle from degrees to radians",
    "language_version_list": {
      "python": {
        "code_signature": "import math\n\n\ndef degrees_to_radians(degrees: int) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n\n    Args:\n        degrees (int): The angle in degrees to convert.\n\n    Returns:\n        float: The angle in radians.\n    \"\"\"\n",
        "test_code": "import math\nimport unittest\n\n\nclass TestDegreesToRadians(unittest.TestCase):\n    def test_zero_degrees(self):\n        \"\"\"Test conversion of 0 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(0), 0, places=5)\n\n    def test_ninety_degrees(self):\n        \"\"\"Test conversion of 90 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(90), math.pi / 2, places=5)\n\n    def test_one_eighty_degrees(self):\n        \"\"\"Test conversion of 180 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(180), math.pi, places=5)\n\n    def test_two_seventy_degrees(self):\n        \"\"\"Test conversion of 270 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(270), 3 * math.pi / 2, places=5)\n\n    def test_three_sixty_degrees(self):\n        \"\"\"Test conversion of 360 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(360), 2 * math.pi, places=5)\n\n    def test_negative_degrees(self):\n        \"\"\"Test conversion of negative degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(-90), -math.pi / 2, places=5)\n\n    def test_large_degrees(self):\n        \"\"\"Test conversion of a large angle (720 degrees)\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(720), 4 * math.pi, places=5)\n",
        "prompt": "please write a python function , the function signature as below import math\n\n\ndef degrees_to_radians(degrees: int) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n\n    Args:\n        degrees (int): The angle in degrees to convert.\n\n    Returns:\n        float: The angle in radians.\n    \"\"\"\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 87,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "send-to-telegram\\8fa1f460972b02ae35f746e6e525dfe395b2b99e\\src\\pages\\js\\logs.js",
    "question_type": "User interface",
    "summary": "Convert UNIX timestamps to a more readable time format in month-date-24h format",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n",
        "test_code": "describe('timestampToReadableDate', () => {\n    test('should convert UNIX timestamp to readable format', () => {\n        const timestamp = 1696516800;\n        expect(timestampToReadableDate(timestamp)).toBe('Oct 5, 22:40');\n    });\n\n    test('should handle timestamp at the start of the year', () => {\n        const timestamp = 1672531200;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n\n    test('should handle timestamp at the end of the year', () => {\n        const timestamp = 1672531199;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 7:59');\n    });\n\n    test('should handle timestamps in the leap year', () => {\n        const timestamp = 1583020800;\n        expect(timestampToReadableDate(timestamp)).toBe('Mar 1, 8:00');\n    });\n\n    test('should convert timestamp to readable format with single-digit day', () => {\n        const timestamp = 1675190400;\n        expect(timestampToReadableDate(timestamp)).toBe('Feb 1, 2:40');\n    });\n\n\n    test('should handle zero UNIX timestamp', () => {\n        const timestamp = 0;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 88,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "yunzai-meme\\e0ff65cf02d95507e9bb3af75ba3ab0044d5c4c8\\meme.js",
    "question_type": "Configuration and deployment",
    "summary": "Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}",
        "test_code": "describe('isCronBetween2And4AM', () => {\n    test('should return true for specific hours 2, 3, and 4', () => {\n        expect(isCronBetween2And4AM('0 2,3,4 * * *')).toBe(true);\n    });\n\n    test('should return false for range that includes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 1-5 * * *')).toBe(false);\n    });\n\n    test('should return false for range that excludes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 0-1,5-23 * * *')).toBe(false);\n    });\n\n    test('should return true for wildcard in hour field', () => {\n        expect(isCronBetween2And4AM('0 * * * *')).toBe(false);\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 89,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "memory_game\\47a81aaca8659296710ce620a860143a653ab310\\assets\\js\\script.js",
    "question_type": "User interface",
    "summary": "calculates the elapsed time from a given start time in milliseconds and returns\nit as a formatted string in \"minutes:seconds\" format.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}",
        "test_code": "describe('timePassed function', () => {\n    const originalDateNow = Date.now;\n\n    beforeEach(() => {\n        // Freeze the Date.now() to a fixed timestamp\n        Date.now = jest.fn(() => 1609459200000); // January 1, 2021, 00:00:00\n    });\n\n    afterEach(() => {\n        // Restore original Date.now() function\n        Date.now = originalDateNow;\n    });\n\n    test('should correctly calculate time passed from 1 minute ago', () => {\n        const startTime = 1609459140000; // 1 minute earlier\n        expect(timePassed(startTime)).toBe(\"1:00\");\n    });\n\n    test('should handle the boundary of 59 seconds correctly', () => {\n        const startTime = 1609459194100; // 59 seconds and 900 milliseconds earlier\n        expect(timePassed(startTime)).toBe(\"0:05\");\n    });\n\n    test('should return 0:00 when start time is the same as current time', () => {\n        expect(timePassed(1609459200000)).toBe(\"0:00\");\n    });\n\n    test('should handle negative time differences (future start time)', () => {\n        const startTime = 1609459260000; // 1 minute into the future\n        expect(timePassed(startTime)).toMatch(/-/); // Expecting negative output or some error handling\n    });\n\n    test('should handle very large time differences correctly', () => {\n        const startTime = 1483228800000; // January 1, 2017, 00:00:00 (4 years difference)\n        expect(timePassed(startTime)).toBe(\"2103840:00\"); // Calculated minutes for 4 years\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 92,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "HackDaildemo\\b2cd54e9c43bc7f8aaa89682f30db1af5d2abf6c\\src\\content-script\\site-adapters\\youtube\\index.mjs",
    "question_type": "Data processing and transformation",
    "summary": "Decodes HTML entities in a given HTML string.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nconst {JSDOM} = require('jsdom');\nconst dom = new JSDOM();\nconst {document} = dom.window;\n\nfunction replaceHtmlEntities(htmlString) {\n}",
        "test_code": "describe('replaceHtmlEntities', () => {\n    test('decodes standard HTML entities', () => {\n        const input = 'The &amp; symbol should become an &quot;and&quot; sign.';\n        const expected = 'The & symbol should become an \"and\" sign.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('returns empty string for empty input', () => {\n        const input = '';\n        const expected = '';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n\n    test('decodes multiple different entities in one string', () => {\n        const input = '&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;';\n        const expected = '<div>Hello & Welcome to the \\'World\\'!</div>';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('handles strings with no entities', () => {\n        const input = 'Just a normal string without entities.';\n        const expected = 'Just a normal string without entities.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nconst {JSDOM} = require('jsdom');\nconst dom = new JSDOM();\nconst {document} = dom.window;\n\nfunction replaceHtmlEntities(htmlString) {\n}",
        "addition_info": "/**\n * @jest-environment jsdom\n */"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 93,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\94908d0d20eb0345457fe9275fec534ce0756330\\konduktiva-revised-2.js",
    "question_type": "Algorithm and data structure",
    "summary": "produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}",
        "test_code": "describe('getAllAlphabets', () => {\n    test('should return an array of 52 characters', () => {\n        const result = getAllAlphabets();\n        expect(result).toHaveLength(52);\n    });\n\n    test('should start with lowercase letters from a to z', () => {\n        const result = getAllAlphabets();\n        const lowercaseAlphabets = result.slice(0, 26);\n        expect(lowercaseAlphabets).toEqual([\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        ]);\n    });\n\n    test('should end with uppercase letters from A to Z', () => {\n        const result = getAllAlphabets();\n        const uppercaseAlphabets = result.slice(26);\n        expect(uppercaseAlphabets).toEqual([\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n        ]);\n    });\n\n    test('should return \"a\" as the first element', () => {\n        const result = getAllAlphabets();\n        expect(result[0]).toBe('a');\n    });\n\n    test('should return \"Z\" as the last element', () => {\n        const result = getAllAlphabets();\n        expect(result[result.length - 1]).toBe('Z');\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 94,
    "code_type": "yes",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\dbb39f39670ffae329b1cce77ed641f9ef758710\\example-melodies-data.js",
    "question_type": "Algorithm and data structure",
    "summary": "generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}",
        "test_code": "describe('createCircleOfFifths', () => {\n    test('should return 12 notes in the circle', () => {\n        const result = createCircleOfFifths('C');\n        expect(result).toHaveLength(12);\n    });\n\n    test('should start with the given starting note', () => {\n        const startingNote = 'G';\n        const result = createCircleOfFifths(startingNote);\n        expect(result[0]).toBe(startingNote);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from C', () => {\n        const result = createCircleOfFifths('C');\n        const expectedCircle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from G', () => {\n        const result = createCircleOfFifths('G');\n        const expectedCircle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from F', () => {\n        const result = createCircleOfFifths('F');\n        const expectedCircle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];\n        expect(result).toEqual(expectedCircle);\n    });\n});",
        "prompt": null,
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 95,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\infoFromArray.js",
    "question_type": "Algorithm and data structure",
    "summary": "finds the matching elements and their indices in the input array according to the specified comparison function",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array} arr - The input array to search through.\n * @param {Function} comparisonFn - The comparison function to determine matches.\n * @returns {Array} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements(arr, comparisonFn) {\n}",
        "test_code": "describe('findMatchingElements', () => {\n    test('should return an empty array for an empty input array', () => {\n        const result = findMatchingElements([], (el) => el > 0);\n        expect(result).toEqual([]);\n    });\n\n    test('should return matching elements and their indices', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const comparisonFunction = (num) => num > 3;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 4, index: 3},\n            {element: 5, index: 4},\n        ]);\n    });\n\n    test('should return elements that are strings matching a specific condition', () => {\n        const inputArray = ['apple', 'banana', 'cherry', 'date'];\n        const comparisonFunction = (fruit) => fruit.startsWith('b');\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 'banana', index: 1},\n        ]);\n    });\n\n    test('should return multiple elements with the same value', () => {\n        const inputArray = [1, 2, 2, 3, 2, 4];\n        const comparisonFunction = (num) => num === 2;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 2, index: 1},\n            {element: 2, index: 2},\n            {element: 2, index: 4},\n        ]);\n    });\n\n    test('should return matching objects based on a property', () => {\n        const inputArray = [\n            {name: 'Alice', age: 25},\n            {name: 'Bob', age: 30},\n            {name: 'Charlie', age: 30},\n        ];\n        const comparisonFunction = (person) => person.age === 30;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: {name: 'Bob', age: 30}, index: 1},\n            {element: {name: 'Charlie', age: 30}, index: 2},\n        ]);\n    });\n\n    test('should return no elements if no matches found', () => {\n        const inputArray = [1, 3, 5, 7];\n        const comparisonFunction = (num) => num % 2 === 0; // looking for even numbers\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([]);\n    });\n\n    test('should work with a comparison function that checks for negative numbers', () => {\n        const inputArray = [-1, -2, 0, 1, 2];\n        const comparisonFunction = (num) => num < 0;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: -1, index: 0},\n            {element: -2, index: 1},\n        ]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array} arr - The input array to search through.\n * @param {Function} comparisonFn - The comparison function to determine matches.\n * @returns {Array} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements(arr, comparisonFn) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 96,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "seattlecontratunes\\b370e3192aeab7972e85821490627714c8323aaa\\seattlecontratunes\\song_directory\\static\\song_directory\\tune_manipulation\\changedClef.js",
    "question_type": "Data processing and transformation",
    "summary": "modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K:), or \"bass\" if no clef is specified",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}",
        "test_code": "describe('changedClef', () => {\n    test('should insert the clef at the correct position when the clef is not specified (default to \"bass\")', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc);\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should insert the clef at the correct position when a specific clef is provided', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"treble\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should handle cases where there is no newline after the key signature.js.py.py.py', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\";\n        const result = changedClef(abc, \"alto\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        expect(result).toBe(expected);\n    });\n\n    test('should not alter the ABC notation if the key signature.js.py.py.py is not found', () => {\n        const abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"tenor\");\n        expect(result).toBe(abc); // Expect the original string to be returned unchanged\n    });\n\n    test('should correctly handle ABC notation with multiple key signatures', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        const result = changedClef(abc, \"baritone\");\n        const expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        expect(result).toBe(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 97,
    "code_type": "class",
    "original_language": "javascript",
    "file_path": "search-algo-visualizer\\fe16701379bbc1bb297e45ee0dd477c4ee60d5a5\\search-algo-visualizer\\src\\data-structures\\Queue.js",
    "question_type": "Data processing and transformation",
    "summary": "realize the basic functions of the data structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param {*} element - The element to be added to the queue.\n     */\n    enqueue(element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns {*} The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns {*} The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns {boolean} True if the queue is empty, otherwise false.\n     */\n    isEmpty() {\n    }\n\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns {string} A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue() {\n    }\n}",
        "test_code": "describe('Queue Class', () => {\n    let queue;\n\n    beforeEach(() => {\n        queue = new Queue();\n    });\n\n    test('should initialize an empty queue', () => {\n        expect(queue.isEmpty()).toBe(true);\n    });\n\n    test('should enqueue elements to the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        expect(queue.printQueue()).toBe('1 2 3');\n        expect(queue.isEmpty()).toBe(false);\n    });\n\n    test('should dequeue elements from the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        const dequeuedElement = queue.dequeue();\n        expect(dequeuedElement).toBe(1);\n    });\n\n\n    test('should return the front element without removing it', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        const frontElement = queue.front();\n        expect(frontElement).toBe(10);\n    });\n\n    test('should check if the queue is empty', () => {\n        expect(queue.isEmpty()).toBe(true);\n        queue.enqueue(5);\n        expect(queue.isEmpty()).toBe(false);\n        queue.dequeue();\n        expect(queue.isEmpty()).toBe(true);\n    });\n});",
        "prompt": "please write a javascript class , the class signature as below /**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param {*} element - The element to be added to the queue.\n     */\n    enqueue(element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns {*} The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns {*} The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns {boolean} True if the queue is empty, otherwise false.\n     */\n    isEmpty() {\n    }\n\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns {string} A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue() {\n    }\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 99,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "gptdoc\\108d3b70e187ed1f9c1b63424e0eb81fe13f7c0d\\example\\gpt.example.js",
    "question_type": "Algorithm and data structure",
    "summary": "Calculates the sum of all the numbers in a numeric array and returns it as a result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n",
        "test_code": "describe('Sum Function Tests', () => {\n    test('should return the sum of a normal array of positive numbers', () => {\n        expect(sum([1, 2, 3, 4, 5])).toBe(15);\n    });\n\n    test('should return the sum of an array containing negative numbers', () => {\n        expect(sum([-1, -2, -3, -4, -5])).toBe(-15);\n    });\n\n    test('should return 0 for an empty array', () => {\n        expect(sum([])).toBe(0);\n    });\n\n    test('should return the sum of an array containing both positive and negative numbers', () => {\n        expect(sum([10, -10, 5, -5, 15])).toBe(15);\n    });\n\n    test('should return the sum of an array with floating point numbers', () => {\n        expect(sum([1.5, 2.5, 3.5])).toBe(7.5);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 100,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "GoogleSnakePudding\\95d53b7a49998d07b3fc715c7a9cb59f938e7002\\Libraries\\SpeedInfo.js",
    "question_type": "Data processing and transformation",
    "summary": "The function is to convert the ISO 8601 duration format to string format, for example PT2H5M is converted to 2h5m",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n",
        "test_code": "describe('ConvertTime Function Tests', () => {\n    test('should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds', () => {\n        expect(convertTime('PT1H23M45.678S')).toBe('1h23m45s678ms');\n    });\n\n    test('should correctly convert duration with only seconds and milliseconds', () => {\n        expect(convertTime('PT45.5S')).toBe('45s500ms');\n    });\n\n    test('should correctly convert duration with hours and minutes, but no seconds', () => {\n        expect(convertTime('PT2H5M')).toBe('2h5m');\n    });\n\n    test('should correctly convert duration with only seconds, no milliseconds', () => {\n        expect(convertTime('PT20S')).toBe('20s');\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 101,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "ElectronClassSchedule\\599a1c59f3880057548633e9b3774b78defed0a4\\js\\index.js",
    "question_type": "Data processing and transformation",
    "summary": "Determine whether the current time is within the specified time range (i.e., whether it is a break)\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n",
        "test_code": "describe('isBreakTime Function Tests', () => {\n    test('should return true when current time is exactly at the start time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:00\")).toBe(true);\n    });\n\n    test('should return true when current time is within the break time range', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:30\")).toBe(true);\n    });\n\n    test('should return false when current time is exactly exceed the end time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"20:00\")).toBe(false);\n    });\n\n    test('should return false when current time is before the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"08:59\")).toBe(false);\n    });\n\n    test('should return false when current time is after the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:01\")).toBe(false);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 103,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\pages\\js\\explorer.js",
    "question_type": "Data processing and transformation",
    "summary": "\nTruncate the string to the specified length, if the string exceeds the specified length, the excess part is used with an ellipsis (...) replace",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str, maxLength) {\n}",
        "test_code": "describe('truncateStringWithReplacement', () => {\n    test('should return the original string if it is shorter than maxLength', () => {\n        const result = truncateStringWithReplacement('Hello World', 20);\n        expect(result).toBe('Hello World');\n    });\n\n    test('should truncate the string and replace the excess with ellipsis when longer than maxLength', () => {\n        const result = truncateStringWithReplacement('This is a long string that needs to be truncated.', 20);\n        expect(result).toBe('This is a long str...');\n    });\n\n    test('should truncate the string at maxLength and add ellipsis', () => {\n        const result = truncateStringWithReplacement('Short string', 10);\n        expect(result).toBe('Short str...');\n    });\n\n    test('should handle empty string correctly', () => {\n        const result = truncateStringWithReplacement('', 10);\n        expect(result).toBe('');\n    });\n\n    test('should return the original string when maxLength is equal to string length', () => {\n        const result = truncateStringWithReplacement('Exact length', 12);\n        expect(result).toBe('Exact length');\n    });\n\n    test('should replace excess part with ellipsis in a string with special characters', () => {\n        const result = truncateStringWithReplacement('This string has special characters: !@#$%^&*()', 30);\n        expect(result).toBe('This string has special c...');\n    });\n\n    test('should return ellipsis only when the maxLength is 0', () => {\n        const result = truncateStringWithReplacement('Hello, world!', 0);\n        expect(result).toBe('...');\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str, maxLength) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 104,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\pages\\js\\explorer.js",
    "question_type": "Data processing and transformation",
    "summary": "The incoming thread object is converted into a JSON file, which is represented as a Blob object.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n",
        "test_code": "describe('convertThreadToJSONFile Function Tests', () => {\n    test('should return a Blob object for a basic thread object', () => {\n        const thread1 = { id: 1, title: \"First Thread\", content: \"This is the first thread.\" };\n        const blob1 = convertThreadToJSONFile(thread1);\n        expect(blob1 instanceof Blob).toBe(true);\n        expect(blob1.type).toBe(\"application/json\");\n    });\n\n    test('should return a Blob object for an empty thread object', () => {\n        const thread2 = {};\n        const blob2 = convertThreadToJSONFile(thread2);\n        expect(blob2 instanceof Blob).toBe(true);\n        expect(blob2.size).toBe(2); // \"{}\" has a size of 2 bytes\n    });\n\n    test('should return a Blob object for a thread object with nested objects', () => {\n        const thread3 = { id: 2, title: \"Second Thread\", comments: [{ user: \"Alice\", comment: \"Great post!\" }] };\n        const blob3 = convertThreadToJSONFile(thread3);\n        expect(blob3 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with special characters', () => {\n        const thread4 = { id: 3, title: \"Thread & Special <Characters>\", content: 'This is a thread with special characters: <, >, &, \".' };\n        const blob4 = convertThreadToJSONFile(thread4);\n        expect(blob4 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with arrays', () => {\n        const thread5 = { id: 4, title: \"Thread with Array\", tags: [\"JavaScript\", \"JSON\", \"Blob\"] };\n        const blob5 = convertThreadToJSONFile(thread5);\n        expect(blob5 instanceof Blob).toBe(true);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 106,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Kommuniti\\d19d61943eb920b1705e05cf96a8fad534a0fb51\\lib\\utils.jsx",
    "question_type": "File operations and I/O operation",
    "summary": "Checks if the provided image data is a valid Base64 encoded image string.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n",
        "test_code": "describe('isBase64Image', () => {\n    test('should return true for a valid PNG Base64 image string', () => {\n        const validPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA';\n        expect(isBase64Image(validPng)).toBe(true);\n    });\n\n    test('should return true for a valid JPEG Base64 image string', () => {\n        const validJpeg = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA';\n        expect(isBase64Image(validJpeg)).toBe(true);\n    });\n\n    test('should return false for a string without the image data prefix', () => {\n        const invalidFormat = 'data:text/plain;base64,SGVsbG8gd29ybGQ=';\n        expect(isBase64Image(invalidFormat)).toBe(false);\n    });\n\n    test('should return false for a string with invalid Base64 characters', () => {\n        const invalidBase64 = 'data:image/png;base64,invalidBase64String@#%';\n        expect(isBase64Image(invalidBase64)).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isBase64Image('')).toBe(false);\n    });\n\n    test('should return false for a null input', () => {\n        expect(isBase64Image(null)).toBe(false);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 107,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "code-challenges\\3287f7e9be74d545375de59a03556e455f284bd2\\findMedian.js",
    "question_type": "Data processing and transformation",
    "summary": "Finds the median of a given array of numbers.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n",
        "test_code": "describe('findMedian', () => {\n    // Example usage with a large array\n    test('should find the median of a large array with 10001 random elements', () => {\n        const largeArray = Array.from({ length: 10001 }, () => Math.floor(Math.random() * 10000));\n        const medianLargeArray = findMedian(largeArray);\n        // It's difficult to assert the exact median here due to randomness,\n        // but this test can check if the function completes without error\n        expect(typeof medianLargeArray).toBe('number');\n    });\n\n    // Test Case 1: Odd number of elements\n    test('should return 3 for an array with odd number of elements', () => {\n        const arr1 = [3, 1, 4, 1, 5, 9, 2];\n        const median1 = findMedian(arr1);\n        expect(median1).toBe(3);\n    });\n\n    // Test Case 2: Even number of elements\n    test('should return 6 for an array with even number of elements', () => {\n        const arr2 = [10, 2, 3, 5, 7, 8];\n        const median2 = findMedian(arr2);\n        expect(median2).toBe(6);\n    });\n\n    // Test Case 3: Array with duplicate elements\n    test('should return 2 for an array with duplicate elements', () => {\n        const arr3 = [1, 2, 2, 2, 3];\n        const median3 = findMedian(arr3);\n        expect(median3).toBe(2);\n    });\n\n    // Test Case 4: Array with negative numbers\n    test('should return 0 for an array with negative and positive numbers', () => {\n        const arr4 = [-5, -10, 0, 5, 10];\n        const median4 = findMedian(arr4);\n        expect(median4).toBe(0);\n    });\n\n    // Test Case 5: Array with a single element\n    test('should return the only element for an array with a single element', () => {\n        const arr5 = [42];\n        const median5 = findMedian(arr5);\n        expect(median5).toBe(42);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 108,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "pariwise_survey\\0a19f184ce750341185d8c0a6eada6f29515fcbb\\js\\elo.js",
    "question_type": "Data processing and transformation",
    "summary": "Sort the images in ascending order based on their scores and return the reordered image score, name, and ID",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}",
        "test_code": "describe('reorderData', () => {\n\n    test('should reorder the question based on scores in ascending order', () => {\n        const imageScores = [90, 85, 95];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([85, 90, 95]);\n        expect(result.resultNames).toEqual([\"image2.png\", \"image1.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id2\", \"id1\", \"id3\"]);\n    });\n\n    test('should return the same order if scores are already in ascending order', () => {\n        const imageScores = [70, 75, 80];\n        const imageNames = [\"imageA.png\", \"imageB.png\", \"imageC.png\"];\n        const imageIDs = [\"idA\", \"idB\", \"idC\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([70, 75, 80]);\n        expect(result.resultNames).toEqual([\"imageA.png\", \"imageB.png\", \"imageC.png\"]);\n        expect(result.resultIDs).toEqual([\"idA\", \"idB\", \"idC\"]);\n    });\n\n    test('should handle an array with only one element', () => {\n        const imageScores = [50];\n        const imageNames = [\"imageSingle.png\"];\n        const imageIDs = [\"idSingle\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([50]);\n        expect(result.resultNames).toEqual([\"imageSingle.png\"]);\n        expect(result.resultIDs).toEqual([\"idSingle\"]);\n    });\n\n    test('should handle an empty array', () => {\n        const imageScores = [];\n        const imageNames = [];\n        const imageIDs = [];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([]);\n        expect(result.resultNames).toEqual([]);\n        expect(result.resultIDs).toEqual([]);\n    });\n\n    test('should reorder correctly when there are duplicate scores', () => {\n        const imageScores = [88, 88, 92];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([88, 88, 92]);\n        expect(result.resultNames).toEqual([\"image1.png\", \"image2.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id1\", \"id2\", \"id3\"]);\n    });\n\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 109,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js",
    "question_type": "Algorithm and data structure",
    "summary": "Returns the object from the list with the given ID, or null if it is not present",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}",
        "test_code": "describe('getObjectById', () => {\n\n    test('should return the object with the matching id', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(2, list);\n        expect(result).toEqual({ id: 2, name: 'Object 2' });\n    });\n\n    test('should return null if no object with the matching id is found', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(4, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if the list is empty', () => {\n        const list = [];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if objects in the list do not have an id property', () => {\n        const list = [\n            { name: 'Object 1' },\n            { name: 'Object 2' },\n            { name: 'Object 3' }\n        ];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return the correct object when id is a string', () => {\n        const list = [\n            { id: 'a', name: 'Object A' },\n            { id: 'b', name: 'Object B' },\n            { id: 'c', name: 'Object C' }\n        ];\n        const result = getObjectById('b', list);\n        expect(result).toEqual({ id: 'b', name: 'Object B' });\n    });\n\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 110,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js",
    "question_type": "Algorithm and data structure",
    "summary": "Generate a random UUID of length 36",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID At least one uppercase letter,At least one lowercase letter,At least one digit\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}",
        "test_code": "describe('generateUUID', () => {\n\n    test('should return a string', () => {\n        const result = generateUUID();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a string of length 36', () => {\n        const result = generateUUID();\n        expect(result.length).toBe(36);\n    });\n\n\n    test('should generate different UUIDs on consecutive calls', () => {\n        const uuid1 = generateUUID();\n        const uuid2 = generateUUID();\n        expect(uuid1).not.toBe(uuid2);\n    });\n\n    test('should generate UUIDs that include uppercase', () => {\n        const result = generateUUID();\n        expect(/[A-Z]/.test(result)).toBe(true); // At least one uppercase letter\n    });\n    test('should generate UUIDs that include  lowercase letters', () => {\n        const result = generateUUID();\n        expect(/[a-z]/.test(result)).toBe(true); // At least one lowercase letter\n    });\n    test('should generate UUIDs that include digits', () => {\n        const result = generateUUID();\n        expect(/[0-9]/.test(result)).toBe(true); // At least one digit\n    });\n\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID At least one uppercase letter,At least one lowercase letter,At least one digit\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 111,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\content-scripts\\utility.js",
    "question_type": "Data processing and transformation",
    "summary": "Convert the chat logs to Markdown format and generate a Blob object containing them",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}",
        "test_code": "describe('convertChatToMarkdown', () => {\n\n    test('should include the default title when no title is provided', () => {\n        const chat = [\"Hello\", \"Hi there!\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedStart = \"# ChatGPT Conversation\\n\\n**Human:**\\nHello\\n\\n***\\n\\n**Assistant:**\\nHi there!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should include the custom title when a title is provided', () => {\n        const chat = [\"How are you?\", \"I'm doing well, thank you!\"];\n        const title = \"Friendly Chat\";\n        const blob = convertChatToMarkdown(chat, title);\n        const expectedStart = \"# Friendly Chat\\n\\n**Human:**\\nHow are you?\\n\\n***\\n\\n**Assistant:**\\nI'm doing well, thank you!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should correctly alternate speakers between Human and Assistant', () => {\n        const chat = [\"Question?\", \"Answer.\", \"Another question?\", \"Another answer.\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedContent = `**Human:**\\nQuestion?\\n\\n***\\n\\n**Assistant:**\\nAnswer.\\n\\n***\\n\\n**Human:**\\nAnother question?\\n\\n***\\n\\n**Assistant:**\\nAnother answer.\\n\\n***\\n\\nExported on `;\n        return blob.text().then(text => {\n            expect(text.includes(expectedContent)).toBe(true);\n        });\n    });\n\n    test('should include the correct timestamp using getDate and getTime', () => {\n        const chat = [\"What's the time?\", \"It's now.\"];\n        const mockedDate = new Date(\"2024-01-01 12:00:00\");\n        global.Date = jest.fn(() => mockedDate);\n\n        const blob = convertChatToMarkdown(chat);\n        const expectedEnd = `Exported on 2024-01-01 12:00:00.`;\n        return blob.text().then(text => {\n            expect(text.endsWith(expectedEnd)).toBe(true);\n        });\n    });\n\n    test('should return a Blob of type text/markdown', () => {\n        const chat = [\"This is a test.js.\", \"Yes, it is.\"];\n        const blob = convertChatToMarkdown(chat);\n        expect(blob.type).toBe('text/markdown');\n    });\n\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 112,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\content-scripts\\utility.js",
    "question_type": "Data processing and transformation",
    "summary": "Convert H1-H6 tags in HTML to corresponding paragraphs 1 through 6 in markdown, for example h1 xxx to # xxx",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html) {}",
        "test_code": "describe('convertHtmlHeadingsToMarkdown', () => {\n    test('should convert <h1> to #', () => {\n        const input = '<h1>This is a Heading 1</h1>';\n        const output = '# This is a Heading 1';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h2> to ##', () => {\n        const input = '<h2>This is a Heading 2</h2>';\n        const output = '## This is a Heading 2';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h3> to ###', () => {\n        const input = '<h3>This is a Heading 3</h3>';\n        const output = '### This is a Heading 3';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h4> to ####', () => {\n        const input = '<h4>This is a Heading 4</h4>';\n        const output = '#### This is a Heading 4';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h5> to #####', () => {\n        const input = '<h5>This is a Heading 5</h5>';\n        const output = '##### This is a Heading 5';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h6> to ######', () => {\n        const input = '<h6>This is a Heading 6</h6>';\n        const output = '###### This is a Heading 6';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 113,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\e84e3bded63150d605bba6647572445f0116eeff\\src\\content-scripts\\utility.js",
    "question_type": "Data processing and transformation",
    "summary": "Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}",
        "test_code": "describe('getCSSFromSheet', () => {\n    let styleSheet;\n\n    beforeEach(() => {\n        // Create a style element with some CSS rules for testing\n        const style = document.createElement('style');\n        style.appendChild(document.createTextNode(`\n            body { background-color: red; }\n            p { color: blue; }\n        `));\n        document.head.appendChild(style);\n        styleSheet = style.sheet;\n    });\n\n    afterEach(() => {\n        // Clean up the document after each test\n        document.head.innerHTML = '';\n    });\n\n\n    test('Empty Stylesheet: should return an empty string', () => {\n        const emptyStyle = document.createElement('style');\n        document.head.appendChild(emptyStyle);\n        const emptyStyleSheet = emptyStyle.sheet;\n\n        const cssText = getCSSFromSheet(emptyStyleSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Invalid Input: should return an empty string for non-CSSStyleSheet input', () => {\n        expect(getCSSFromSheet(null)).toBe('');\n        expect(getCSSFromSheet({})).toBe('');\n        expect(getCSSFromSheet('not a stylesheet')).toBe('');\n    });\n\n    test('Cross-Origin Restrictions: should handle restricted stylesheets gracefully', () => {\n        // Simulate a cross-origin stylesheet\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'http://example.com/style.css';\n        document.head.appendChild(link);\n\n        // Accessing cssRules of a cross-origin stylesheet should throw an error\n        const restrictedSheet = link.sheet;\n\n        expect(() => {\n            getCSSFromSheet(restrictedSheet);\n        }).not.toThrow();  // The function should not throw an error\n\n        // Simulate behavior by returning an empty string\n        const cssText = getCSSFromSheet(restrictedSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Style Element with Inline CSS: should return CSS from inline style element', () => {\n        const styleElement = document.createElement('style');\n        styleElement.textContent = 'div { font-size: 16px; }';\n        document.head.appendChild(styleElement);\n\n        const cssText = getCSSFromSheet(styleElement.sheet);\n        expect(cssText).toBe('div {font-size: 16px;}');\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}",
        "addition_info": "/**\n * @jest-environment jsdom\n */"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 114,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "utilsNodeJs\\8bd1fec924b2b1141b47c2a10911ed8035002918\\src\\Sorter.js",
    "question_type": "Data processing and transformation",
    "summary": "Sort the array of objects that contain timestamps based on the timestamp value\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}",
        "test_code": "describe('sortByTimestamp function', () => {\n    test('should return an empty array when input is empty', () => {\n        expect(sortByTimestamp([])).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }];\n        expect(sortByTimestamp(singleElementArray)).toEqual([{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }]);\n    });\n\n    test('should sort an array of objects by timestamps correctly', () => {\n        const testData = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(testData)).toEqual(expected);\n    });\n\n    test('should not alter array if already sorted', () => {\n        const sortedArray = [\n            { id: 1, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 3, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(sortedArray)).toEqual(sortedArray);\n    });\n\n    test('should handle mixed format timestamps correctly', () => {\n        const mixedFormats = [\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" }\n        ];\n        expect(sortByTimestamp(mixedFormats)).toEqual(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 115,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "acsense-tcd\\730cc723b81283d3dc791a27c5adde0146e33c5c\\acsense-tcd\\composables\\sortArrayOfObjectsByKey.js",
    "question_type": "Data processing and transformation",
    "summary": "sort the array of objects alphabetically by the specified key\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}",
        "test_code": "describe('sortByKey function', () => {\n    test('should return an empty array when input is empty', () => {\n        const result = sortByKey([], 'name');\n        expect(result).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ name: 'Apple' }];\n        expect(sortByKey(singleElementArray, 'name')).toEqual([{ name: 'Apple' }]);\n    });\n\n    test('should sort an array of objects by the specified key', () => {\n        const testData = [\n            { name: 'banana' },\n            { name: 'apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(testData, 'name')).toEqual(expected);\n    });\n\n    test('should perform case-insensitive sorting', () => {\n        const mixedCaseArray = [\n            { name: 'banana' },\n            { name: 'Apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'Apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(mixedCaseArray, 'name')).toEqual(expected);\n    });\n\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 116,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "acm-fish\\7e985493411a046eddd249394e7b554708072cc2\\foish.js",
    "question_type": "Data processing and transformation",
    "summary": "Calculates the toroidal difference between two points",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}",
        "test_code": "describe('toroidalDiff', () => {\n    test('should return the direct difference when no wrapping is needed', () => {\n        const thisPoint = { x: 2, y: 3 };\n        const otherPoint = { x: 5, y: 6 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-3, -3]);\n    });\n\n    test('should handle wrapping around the x dimension', () => {\n        const thisPoint = { x: 9, y: 5 };\n        const otherPoint = { x: 1, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, 0]); // dx wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around the y dimension', () => {\n        const thisPoint = { x: 4, y: 9 };\n        const otherPoint = { x: 4, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, -2]); // dy wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around both x and y dimensions', () => {\n        const thisPoint = { x: 9, y: 9 };\n        const otherPoint = { x: 1, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, -2]); // Both dx and dy wrap around\n    });\n\n    test('should return the direct difference for points at the same position', () => {\n        const thisPoint = { x: 5, y: 5 };\n        const otherPoint = { x: 5, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, 0]); // No difference\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 117,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "libresprite-extensions\\dfd82d80fa0512f60fb423d304f8790dad32e96b\\src\\lib\\hsl.mjs",
    "question_type": "Data processing and transformation",
    "summary": "convert RGB colors to HSL color values\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}",
        "test_code": "describe('rgbToHsl function', () => {\n    test('converts pure red to HSL', () => {\n        expect(rgbToHsl(255, 0, 0)).toEqual({h: 0, s: 100, l: 50});\n    });\n\n    test('converts black to HSL', () => {\n        expect(rgbToHsl(0, 0, 0)).toEqual({h: 0, s: 0, l: 0});\n    });\n\n    test('converts white to HSL', () => {\n        expect(rgbToHsl(255, 255, 255)).toEqual({h: 0, s: 0, l: 100});\n    });\n\n    test('converts a color on the edge of RGB range', () => {\n        expect(rgbToHsl(0, 255, 255)).toEqual({h: 180, s: 100, l: 50});\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 118,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "libresprite-extensions\\dfd82d80fa0512f60fb423d304f8790dad32e96b\\src\\lib\\hsl.mjs",
    "question_type": "Data processing and transformation",
    "summary": "convert HSL color values to RGB color values\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}",
        "test_code": "describe('hslToRgb function', () => {\n    test('converts pure red hue correctly', () => {\n        expect(hslToRgb(0, 100, 50)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n\n    test('returns gray for zero saturation', () => {\n        expect(hslToRgb(240, 0, 50)).toEqual({ r: 128, g: 128, b: 128 });\n    });\n\n    test('returns white for full lightness', () => {\n        expect(hslToRgb(120, 50, 100)).toEqual({ r: 255, g: 255, b: 255 });\n    });\n\n    test('converts full saturation and mid lightness blue correctly', () => {\n        expect(hslToRgb(240, 100, 50)).toEqual({ r: 0, g: 0, b: 255 });\n    });\n\n    test('handles edge hue at 360 degrees correctly', () => {\n        expect(hslToRgb(360, 100, 50)).toEqual({ r: 255, g: 0, b: 0 }); // Should be the same as hue 0\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 119,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "WTA2023Q2_FlappyBird\\64efa4c68ed31c685d15953c82896f15acf3d8b4\\scripts\\script.js",
    "question_type": "Data processing and transformation",
    "summary": "gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}",
        "test_code": "describe('getCookie function tests', () => {\n    beforeEach(() => {\n        // Clear cookies before each test\n        Object.defineProperty(window.document, 'cookie', {\n            writable: true,\n            value: '',\n        });\n    });\n\n    test('returns correct cookie value for existing cookie', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n\n    test('returns undefined if cookie does not exist', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('user')).toBeFalsy();\n    });\n\n\n    test('returns undefined when no cookies are set', () => {\n        expect(getCookie('username')).toBeFalsy();\n    });\n\n    test('handles multiple cookies and retrieves the correct one', () => {\n        document.cookie = \"user=JaneDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}",
        "addition_info": "/**\n * @jest-environment jsdom\n */"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 120,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "TP1-dev-web\\061607b28ef007131c6e6a1fa1be36b575bd2021\\src\\Components\\NestedGrid.js",
    "question_type": "Data processing and transformation",
    "summary": "Extract table data from a document object containing HTML tables and return the data organized as a two-dimensional array.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Extract table question from a document object containing HTML tables and return the question organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  ",
        "test_code": "const { JSDOM } = require('jsdom');\n\ndescribe('HTML to CSV Extraction Tests', () => {\n  const createMockDocument = (html) => {\n    const dom = new JSDOM(html);\n    return dom.window.document;\n  };\n\n  const extractCSVDataFromHTML = (document) => {\n    const rows = document.querySelectorAll('table.waffle tbody tr');\n    return Array.from(rows).map(row =>\n      Array.from(row.cells).map(cell => cell.textContent || \"\")\n    );\n  };\n\n  test('Table with multiple rows and columns', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td>Cell 2</td></tr>\n          <tr><td>Cell 3</td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"Cell 2\"], [\"Cell 3\", \"Cell 4\"]]);\n  });\n\n  test('Table with empty cells', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td></td></tr>\n          <tr><td></td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"\"], [\"\", \"Cell 4\"]]);\n  });\n\n  test('Table with only one row', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Single Cell 1</td><td>Single Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Single Cell 1\", \"Single Cell 2\"]]);\n  });\n\n  test('Table with only one column', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Column Cell 1</td></tr>\n          <tr><td>Column Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Column Cell 1\"], [\"Column Cell 2\"]]);\n  });\n\n  test('No table with the class \"waffle\" present', () => {\n    const testCaseHTML = `\n      <div>\n        <p>No table here!</p>\n      </div>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([]);\n  });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Extract table question from a document object containing HTML tables and return the question organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  ",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 121,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js",
    "question_type": "Data processing and transformation",
    "summary": "Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n",
        "test_code": "describe('adjustArrayLength function tests', () => {\n    test('Array length equal to the target length', () => {\n        const result = adjustArrayLength(5, [1, 2, 3, 4, 5]);\n        expect(result).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test('Array length shorter than the target length', () => {\n        const result = adjustArrayLength(8, [1, 2, 3]);\n        expect(result).toEqual([1, 2, 3, 1, 2, 3, 1, 2]);\n    });\n\n    test('Array length shorter than the target length, target length is a multiple of array length', () => {\n        const result = adjustArrayLength(6, [10, 20]);\n        expect(result).toEqual([10, 20, 10, 20, 10, 20]);\n    });\n\n    test('Array length shorter than the target length, target length is not a multiple of array length', () => {\n        const result = adjustArrayLength(7, [7, 14, 21]);\n        expect(result).toEqual([7, 14, 21, 7, 14, 21, 7]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 122,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js",
    "question_type": "Data processing and transformation",
    "summary": "Safely splices an array by removing a specified number of elements from a given index,\n and optionally replaces them with a new element.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n",
        "test_code": "describe('safeSplice', () => {\n    test('replaces removed elements with a new element', () => {\n        const inputArray = ['a', 'b', 'c', 'd', 'e'];\n        const expected = ['a', 'z', 'e'];\n        expect(safeSplice(inputArray, 3, 1, 'z')).toEqual(expected);\n    });\n    test('should remove specified elements and replace with new element', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 1;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 99, 4, 5]);\n    });\n\n    test('should handle removing elements from the end of the array', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 3;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        expect(result).toEqual([1, 2, 3]);\n    });\n\n    test('should handle the case where no elements are removed', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 0;\n        const indexToRemove = 2;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 2, 99, 3, 4, 5]);\n    });\n\n    test('should handle edge case with an empty input array', () => {\n        const inputArray = [];\n        const amountToRemove = 1;\n        const indexToRemove = 0;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([99]);\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 123,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js",
    "question_type": "Data processing and transformation",
    "summary": "Scale the values in an array from one range to another. To ensure that the values in the input array do not exceed the given minimum and maximum values, we can add checks to filter out values that are out of range",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n",
        "test_code": "describe('scaleToRange function tests', () => {\n    test('simple scaling', () => {\n        const result = scaleToRange([1, 2, 3, 4, 5], 1, 5, 10, 50);\n        expect(result).toEqual([10, 20, 30, 40, 50]);\n    });\n\n    test('scaling with negative input range', () => {\n        const result = scaleToRange([-5, 0, 5], -5, 5, 0, 100);\n        expect(result).toEqual([0, 50, 100]);\n    });\n\n    test('scaling with negative output range', () => {\n        const result = scaleToRange([0, 50, 100], 0, 100, -100, 100);\n        expect(result).toEqual([-100, 0, 100]);\n    });\n\n    test('input array containing the same value', () => {\n        const result = scaleToRange([2, 2, 2], 1, 3, 0, 10);\n        expect(result).toEqual([5, 5, 5]);\n    });\n\n    test('input value out of range should throw an error', () => {\n        expect(() => {\n            scaleToRange([1, 2, 3, 6], 1, 5, 0, 10);\n        }).toThrow();\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 124,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\a4fe0844bfcb987ecdd1d62441365df72220678a\\arrayTransformations.js",
    "question_type": "Data processing and transformation",
    "summary": "Randomly sort the input array, that is, rearrange the elements of the array in a random order.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n",
        "test_code": "describe('shuffle function tests', () => {\n    test('shuffles an array of numbers', () => {\n        const array = [1, 2, 3, 4, 5];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n        expect(new Set(shuffledArray).size).toEqual(new Set(array).size); // Ensure no duplicates\n    });\n\n    test('shuffles an array of strings', () => {\n        const array = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with duplicate elements', () => {\n        const array = [1, 1, 2, 2, 3, 3];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with a single element', () => {\n        const array = [42];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray).toEqual(array);\n    });\n\n    test('shuffles an empty array', () => {\n        const array = [];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(0);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 125,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "TopLandWeb\\50b18e20cbcd43d6f072a1530c6af93d2f12f689\\src\\htmlHelper.js",
    "question_type": "Data processing and transformation",
    "summary": "Compressing HTML strings removes unexpected whitespace and newlines from strings in tags",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}",
        "test_code": "describe('compressHTML', () => {\n    test('should remove leading and trailing spaces around tags', () => {\n        const input = '  <div>  <p>Test</p>  </div>  ';\n        const expected = '<div><p>Test</p></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should replace multiple newlines with a single space', () => {\n        const input = '<div>\\n\\n<p>Test</p>\\n\\n</div>';\n        const expected = '<div> <p>Test</p> </div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should remove unnecessary spaces within text', () => {\n        const input = '<p>This    is a test</p>';\n        const expected = '<p>This is a test</p>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle empty strings', () => {\n        const input = '';\n        const expected = '';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should process complex nested HTML correctly', () => {\n        const input = '<div>   <span>    Text <i>    Italic </i> more text </span>   </div>';\n        const expected = '<div><span>Text <i>Italic</i> more text</span></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should not disrupt content within <pre> and <textarea> tags', () => {\n        const input = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>';\n        const expected = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'; // assuming no changes in <pre> and <textarea>\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle HTML with attributes correctly', () => {\n        const input = '<a href=\"http://example.com\"    title=\"Example\" >Link</a>';\n        const expected = '<a href=\"http://example.com\" title=\"Example\">Link</a>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 127,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\dbb39f39670ffae329b1cce77ed641f9ef758710\\chords.js",
    "question_type": "Data processing and transformation",
    "summary": "Splits a list of MIDI note numbers into separate arrays of octaves and root notes.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}",
        "test_code": "describe('separateOctaveAndRoot', () => {\n    test('correctly separates MIDI notes into octaves and root notes', () => {\n        const midiNotes = [60, 61, 62];  // C4, C#4, D4\n        const expected = {\n            octaveNotes: [5, 5, 5],  // All notes are in the 5th octave\n            rootNotes: [0, 1, 2]     // Root notes are C, C#, D\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('handles single MIDI note input', () => {\n        const midiNotes = [24];  // C1\n        const expected = {\n            octaveNotes: [2],  // 2nd octave\n            rootNotes: [0]     // C note\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('returns empty arrays for an empty input array', () => {\n        const midiNotes = [];\n        const expected = {\n            octaveNotes: [],\n            rootNotes: []\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('throws an error for invalid input types', () => {\n        const invalidInput = \"not an array\";\n        expect(() => separateOctaveAndRoot(invalidInput)).toThrow(TypeError);\n        expect(() => separateOctaveAndRoot([3.14])).toThrow(TypeError);\n    });\n\n    test('handles MIDI notes from different octaves', () => {\n        const midiNotes = [12, 25, 37];  // C1, C#2, D#3\n        const expected = {\n            octaveNotes: [1, 2, 3],  // 1st, 2nd, and 3rd octaves\n            rootNotes: [0, 1, 1]     // Root notes are C, C#, D#\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 129,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "ruffle\\6a94ec42bd9ad89ab68e1e57b94e8e3b125a81a4\\js\\tab.js",
    "question_type": "User interface",
    "summary": "Validates a URL string using a simplified and more comprehensive regular expression.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}",
        "test_code": "describe('validURL', () => {\n    test('validates a standard HTTP URL', () => {\n        const url = 'http://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('validates a secure HTTPS URL', () => {\n        const url = 'https://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('rejects a malformed URL', () => {\n        const url = 'htp:/www.example.com';\n        expect(validURL(url)).toBe(false);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 130,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "nodejs-worker-threads-talk\\4111c47ff0b976a0e451441f5dcfb085ae7686f6\\07-pi-with-atomics\\compute-pi.js",
    "question_type": "Data processing and transformation",
    "summary": "Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}",
        "test_code": "describe('computePi', () => {\n    test('should calculate pi to 5 decimal places correctly', () => {\n        const digits = 5;\n        const expected = '3.14159';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 10 decimal places correctly', () => {\n        const digits = 10;\n        const expected = '3.1415926536';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 15 decimal places correctly', () => {\n        const digits = 15;\n        const expected = '3.141592653589793';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 20 decimal places correctly', () => {\n        const digits = 20;\n        const expected = '3.14159265358979323846';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 30 decimal places correctly', () => {\n        const digits = 30;\n        const expected = '3.141592653589793238462643383280';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 131,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "edge-extension-examples\\f947cd27891885bc2c8462f56ecbae793f41deb6\\sharepoint-extension\\content.js",
    "question_type": "User interface",
    "summary": "Add a CSS rule to the HTML document to highlight search results",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}",
        "test_code": "describe('checkCSSHighlightAndAdd', () => {\n    beforeEach(() => {\n        // Clean up the document head and ensure at least one style sheet exists before each test\n        document.head.innerHTML = '<style></style>';\n    });\n\n    test('should add a new style element with the highlight CSS rule if it does not exist', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the style element contains the correct CSS rule\n        const styleElement = document.querySelector('style');\n        expect(styleElement.sheet.cssRules[0].cssText).toContain(\"background-color: yellow;\");\n    });\n\n    test('should not add a new CSS rule if the CSS rule already exists', () => {\n        // Manually add the rule to simulate existing condition\n        document.styleSheets[0].insertRule(\".highlight { background-color: yellow; }\", 0);\n\n        checkCSSHighlightAndAdd();\n\n        // Check that only one rule is present\n        expect(document.styleSheets[0].cssRules.length).toBe(2);\n    });\n\n    test('should add only one rule even if called multiple times', () => {\n        checkCSSHighlightAndAdd();\n        checkCSSHighlightAndAdd();  // Call the function again\n\n        // Check that only one rule is present\n        expect(document.styleSheets[0].cssRules.length).toBe(2);\n    });\n\n    test('should correctly append the style element to the document head', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the style element is indeed appended to the head\n        const styleElement = document.head.querySelector('style');\n        expect(document.head.contains(styleElement)).toBe(true);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}",
        "addition_info": "/**\n * @jest-environment jsdom\n */"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 132,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "edge-extension-examples\\f947cd27891885bc2c8462f56ecbae793f41deb6\\sharepoint-extension\\content.js",
    "question_type": "Configuration and deployment",
    "summary": "Use ESM syntax to import the file system module and define the file read and write operation functions",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes question to a file synchronously.\n *\n * @param {string} filePath - The path to the file where question will be written.\n * @param {string} data - The question to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}",
        "test_code": "// Mock fs in your Jest tests\njest.mock('fs');\n\ndescribe('File Utility Functions', () => {\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('readFile should return file content as a string', () => {\n        const mockContent = 'Hello, world!';\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/file.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/file.txt', 'utf8');\n    });\n\n    test('readFile should return an empty string for an empty file', () => {\n        const mockContent = '';\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/emptyfile.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/emptyfile.txt', 'utf8');\n    });\n\n    test('readFile should throw an error if file cannot be read', () => {\n        fs.readFileSync.mockImplementation(() => {\n            throw new Error('File not found');\n        });\n\n        expect(() => readFile('/invalid/path.txt')).toThrow();\n    });\n\n    test('writeFile should throw an error if file cannot be written', () => {\n        fs.writeFileSync.mockImplementation(() => {\n            throw new Error('Permission denied');\n        });\n\n        expect(() => writeFile('/invalid/path.txt', 'data')).toThrow();\n    });\n    test('readFile should handle large files correctly', () => {\n        const mockContent = 'a'.repeat(10000); // 10,000 characters long string\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/largefile.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/largefile.txt', 'utf8');\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes question to a file synchronously.\n *\n * @param {string} filePath - The path to the file where question will be written.\n * @param {string} data - The question to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}",
        "addition_info": "const fs = require('fs');"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 133,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Python-Syslog-Server\\eda56760300b5b3f6e17618dd4c0de30f60fed40\\frontend\\app\\api\\validators.js",
    "question_type": "Data processing and transformation",
    "summary": "Verify that the input string is a significant number between 5 and 18 in length\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param {string} input - The input string to check.\n * @returns {boolean} - Returns true if the input is a significant number; otherwise, false.\n */\nfunction isSignificantNumber(input) {}",
        "test_code": "describe('isSignificantNumber', () => {\n    test('should return true for a valid significant number with exactly 5 digits', () => {\n        expect(isSignificantNumber(\"12345\")).toBe(true);\n    });\n\n    test('should return false for a number with leading zero', () => {\n        expect(isSignificantNumber(\"01234\")).toBe(false);\n    });\n\n    test('should return true for a valid significant number with exactly 18 digits', () => {\n        expect(isSignificantNumber(\"123456789012345678\")).toBe(true);\n    });\n\n    test('should return false for a number with less than 5 digits', () => {\n        expect(isSignificantNumber(\"123\")).toBe(false);\n    });\n\n    test('should return false for a number with more than 18 digits', () => {\n        expect(isSignificantNumber(\"1234567890123456789\")).toBe(false);\n    });\n\n    test('should return false for a number containing non-digit characters', () => {\n        expect(isSignificantNumber(\"1234a\")).toBe(false);\n    });\n\n    test('should return false for a single zero', () => {\n        expect(isSignificantNumber(\"0\")).toBe(false);\n    });\n\n    test('should return false for non-string input', () => {\n        expect(isSignificantNumber(12345)).toBe(false);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the input string is a significant number.\n * A significant number is defined as a string that:\n * - Is between 5 and 18 characters in length.\n * - Consists only of digits (0-9).\n * - Does not start with '0' if its length is greater than 1.\n *\n * @param {string} input - The input string to check.\n * @returns {boolean} - Returns true if the input is a significant number; otherwise, false.\n */\nfunction isSignificantNumber(input) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 134,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Python-Syslog-Server\\eda56760300b5b3f6e17618dd4c0de30f60fed40\\frontend\\app\\api\\validators.js",
    "question_type": "Data processing and transformation",
    "summary": "Checks whether the username is a string of length 5 to 16 that contains only alphanumeric Spaces",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param {string} username - The username to validate.\n * @returns {boolean} - Returns true if the username is valid; otherwise, false.\n */\nfunction isValidUsername(username) {}",
        "test_code": "describe('isValidUsername', () => {\n    test('valid username with alphanumeric characters', () => {\n        expect(isValidUsername('User123')).toBe(true);\n    });\n\n    test('valid username with spaces', () => {\n        expect(isValidUsername('User 123')).toBe(true);\n    });\n\n    test('invalid username that is too short', () => {\n        expect(isValidUsername('User')).toBe(false);\n    });\n\n    test('invalid username that is too long', () => {\n        expect(isValidUsername('ThisIsAVeryLongUsername')).toBe(false);\n    });\n\n    test('invalid username with special characters', () => {\n        expect(isValidUsername('User!')).toBe(false);\n    });\n\n    test('invalid username with only spaces', () => {\n        expect(isValidUsername('     ')).toBe(false);\n    });\n\n    test('invalid input type (number)', () => {\n        expect(isValidUsername(12345)).toBe(false);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether the provided username is valid.\n * A valid username is defined as a string that:\n * - Has a length between 5 and 16 characters (inclusive).\n * - Contains only alphanumeric characters (letters and digits) and spaces.\n *\n * @param {string} username - The username to validate.\n * @returns {boolean} - Returns true if the username is valid; otherwise, false.\n */\nfunction isValidUsername(username) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 135,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Python-Syslog-Server\\eda56760300b5b3f6e17618dd4c0de30f60fed40\\frontend\\app\\api\\validators.js",
    "question_type": "Data processing and transformation",
    "summary": "Verify that the port number is within a valid range\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}",
        "test_code": "describe('isValidPortNumber', () => {\n    test('returns true for a valid port number in the middle of the range', () => {\n        expect(isValidPortNumber(8080)).toBe(true);\n    });\n\n    test('returns true for the lowest valid port number', () => {\n        expect(isValidPortNumber(1)).toBe(true);\n    });\n\n    test('returns true for the highest valid port number', () => {\n        expect(isValidPortNumber(65535)).toBe(true);\n    });\n\n    test('returns false for a port number below the valid range', () => {\n        expect(isValidPortNumber(0)).toBe(false);\n    });\n\n    test('returns false for a port number above the valid range', () => {\n        expect(isValidPortNumber(65536)).toBe(false);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 137,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "PolyPlus\\948c9b8fae1bdf899900825f2f2a125b9265932b\\settings.js",
    "question_type": "User interface",
    "summary": "Merges two objects into one object\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}",
        "test_code": "describe('mergeObjects', () => {\n    test('correctly merges two objects with non-conflicting keys', () => {\n        const obj1 = { name: \"Alice\" };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('properties from the second object overwrite properties from the first', () => {\n        const obj1 = { name: \"Alice\", age: 25 };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('merges objects with nested structures correctly', () => {\n        const obj1 = { user: { name: \"Alice\", age: 25 } };\n        const obj2 = { user: { age: 30 } };\n        const expected = { user: { age: 30 } };  // Note: obj2 does not merge deeply, it replaces the entire 'user' object\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 138,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "ducky-poc\\f8f45ca20066958baaebb27f89bf79c0d8b20161\\chrome-ext\\chrome-extension\\content-old.js",
    "question_type": "Data processing and transformation",
    "summary": "removes all punctuation from a given string, converts the string to lowercase,\nand trims whitespace from both ends. ",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}",
        "test_code": "describe('removePunctuation', () => {\n    test('removes punctuation from a simple sentence', () => {\n        const input = \"Hello, world!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('handles a string with no punctuation', () => {\n        const input = \"Hello world\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('converts mixed case letters to lowercase', () => {\n        const input = \"HeLLo WoRLd!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('removes a variety of punctuation', () => {\n        const input = \"Life, in a nutshell: eat, sleep, code!\";\n        const expected = \"life in a nutshell eat sleep code\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('trims whitespace from the ends of the string', () => {\n        const input = \"   What a wonderful world!   \";\n        const expected = \"what a wonderful world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 139,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "ai-news-scraper\\009b1eb29af2639aa6c9ef5e0e1df224ce3c9580\\utils\\parseCategoriesFromSummary.js",
    "question_type": "Data processing and transformation",
    "summary": "Extract Categories from the summary string, the first complete sentence",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}",
        "test_code": "describe('parseCategoriesFromSummary', () => {\n    test('extracts categories and cleans the summary correctly', () => {\n        const input = \"This is a summary. Categories: [Technology, Health]\";\n        const expected = {\n            summary: \"This is a summary.\",\n            categories: [\"Technology\", \"Health\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('returns empty categories and original summary when no categories are present', () => {\n        const input = \"This is a summary without categories.\";\n        const expected = {\n            summary: \"This is a summary without categories.\",\n            categories: []\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('ignores case of the category prefix', () => {\n        const input = \"Summary text. categories: [Education, Science]\";\n        const expected = {\n            summary: \"Summary text.\",\n            categories: [\"Education\", \"Science\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('handles extra spaces and malformed category strings correctly', () => {\n        const input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        const expected = {\n            summary: \"Details follow.\",\n            categories: [\"Business\", \"Finance\"]  // Note the removal of an empty string due to extra commas\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('removes the category string correctly even if it appears in the middle of the summary', () => {\n        const input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        const expected = {\n            summary: \"Beginning of summary. Continuation of summary.\",\n            categories: [\"Art\", \"Design\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 292,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "mortgage-calculator\\d951b4501deb1597a631d56e73f4f8c11488cc4c\\logic.js",
    "question_type": "Algorithm and data structure",
    "summary": "Calculate the monthly payment on the loan",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments) {\n}",
        "test_code": "describe('calculateRemainingPayment', () => {\n  test('calculates remaining balance for typical loan conditions', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 24)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for high interest rate', () => {\n    expect(calculateRemainingPayment(10000, 0.1, 12)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for low interest rate', () => {\n    expect(calculateRemainingPayment(10000, 0.001, 60)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for very short term', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 1)).toBeCloseTo(0);\n  });\n\n\n  test('calculates remaining balance with no payments', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 0)).toBeCloseTo(10000);\n  });\n\n  test('calculates remaining balance for a long term', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 360)).toBeCloseTo(0);\n  });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 293,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "portfolio\\3bf98c1cd32d9a43d14f38f0222313220a491c47\\src\\app\\projects\\page.jsx",
    "question_type": "Algorithm and data structure",
    "summary": "Sort image names and ids based on their scores. Specifically, it accepts three arrays as input: an array of image cores, an array of image names, and an array of image ids. The function then combines these arrays, sorts the image data in ascending order based on imageScores, and returns the sorted array of scores, names, and ids.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n",
        "test_code": "describe('reorderData', () => {\n    test('sorts question correctly for basic inputs', () => {\n        const scores = [3, 1, 2];\n        const names = ['Image3', 'Image1', 'Image2'];\n        const ids = [103, 101, 102];\n        const expected = {\n            resultScores: [1, 2, 3],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('sorts question correctly with mixed scores', () => {\n        const scores = [5, 1, 3, 5, 2];\n        const names = ['Image5', 'Image1', 'Image3', 'Image6', 'Image2'];\n        const ids = [105, 101, 103, 106, 102];\n        const expected = {\n            resultScores: [1, 2, 3, 5, 5],\n            resultNames: ['Image1', 'Image2', 'Image3', 'Image5', 'Image6'],\n            resultIDs: [101, 102, 103, 105, 106]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles duplicate scores', () => {\n        const scores = [2, 2, 1];\n        const names = ['Image2', 'Image3', 'Image1'];\n        const ids = [102, 103, 101];\n        const expected = {\n            resultScores: [1, 2, 2],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles empty arrays', () => {\n        const scores = [];\n        const names = [];\n        const ids = [];\n        const expected = {\n            resultScores: [],\n            resultNames: [],\n            resultIDs: []\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 298,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "IUM-TWEB\\b63d3b147923370e5578b6521c62b4f75da9ba3b\\Solution\\Main\\public\\javascripts\\club_valutation.js",
    "question_type": "Data processing and transformation",
    "summary": "Converts a numeric value to a format string with a thousand ('k') or million ('m') suffix to represent large values more concisely.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}",
        "test_code": "describe('setEurValue', () => {\n    test('formats standard values correctly', () => {\n        expect(setEurValue('250')).toBe('250');\n        expect(setEurValue('2500')).toBe('2.5k');\n    });\n\n    test('handles boundary values accurately', () => {\n        expect(setEurValue('999')).toBe('999');\n        expect(setEurValue('1000')).toBe('1.0k');\n        expect(setEurValue('999999')).toBe('1000.0k');\n        expect(setEurValue('1000000')).toBe('1.0m');\n    });\n\n    test('returns correct format for zero and negative inputs', () => {\n        expect(setEurValue('0')).toBe('0');\n    });\n\n    test('returns an empty string for invalid inputs', () => {\n        expect(setEurValue('hello')).toBe('');\n        expect(setEurValue(null)).toBe('');\n        expect(setEurValue(undefined)).toBe('');\n    });\n\n    test('ensures precision for large numbers', () => {\n        expect(setEurValue('10000000')).toBe('10.0m');\n        expect(setEurValue('987654321')).toBe('987.7m');\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 299,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "IUM-TWEB\\b63d3b147923370e5578b6521c62b4f75da9ba3b\\Solution\\Main\\public\\javascripts\\club_valutation.js",
    "question_type": "Algorithm and data structure",
    "summary": "Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n",
        "test_code": "describe('setEurValue', () => {\n    test('Birthday today, should be 24 years old', () => {\n        expect(calculateAge('2000-08-23')).toBe('2000-08-23 (24)')\n    });\n\n    test('Birthday has passed this year, should be 34 years old', () => {\n        expect(calculateAge('1990-01-15')).toBe('1990-01-15 (34)')\n    });\n\n    test('Birthday at the end of the year, should be 38 years old', () => {\n        expect(calculateAge('1985-12-31')).toBe('1985-12-31 (38)')\n    });\n\n    test('Recently turned 1 year old this year', () => {\n        expect(calculateAge('2023-05-05')).toBe('2023-05-05 (1)')\n    });\n\n\n    test('Invalid date input should return an empty string', () => {\n        expect(calculateAge('invalid-date')).toBe('')\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 300,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "dotfiles\\f984af6ad6e0c4111c00c57bcd26195a84320fe0\\.config\\qutebrowser\\greasemonkey\\instacartADRemover.user.js",
    "question_type": "User interface",
    "summary": "Iterate over list items on a web page and remove ads that contain a specific class name",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}",
        "test_code": "describe('removeAds', () => {\n    beforeEach(() => {\n        // Reset the DOM before each test.js\n        document.body.innerHTML = '';\n    });\n\n    test('removes a single sponsored product', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Sponsored');\n    });\n\n    test('removes multiple sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(4);\n        expect(listItems[0].textContent).toBe('Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n\n    test('does not remove any items if there are no sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>Regular Item</li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Regular Item');\n        expect(listItems[1].textContent).toBe('Another Regular Item');\n    });\n\n    test('removes items with nested sponsored indicators', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>\n                    <div>\n                        <span class=\"css-16lshh0\">Sponsored</span>\n                    </div>\n                </li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n    });\n\n    test('does not remove items with similar but non-sponsored class names', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh1\">Not Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Not Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n});\n\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}",
        "addition_info": "/**\n * @jest-environment jsdom\n */"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 305,
    "code_type": "class",
    "original_language": "javascript",
    "file_path": "NextNumber\\e1c82712c47ecec03add83c5a1d3efc337e51265\\script.js",
    "question_type": "Algorithm and data structure",
    "summary": "Define a class called SeededRandom for generating pseudorandom numbers with a specific seed",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}",
        "test_code": "describe('SeededRandom', () => {\n    test('generates consistent numbers with the same seed', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(42);\n\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('generates different numbers with different seeds', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(24);\n\n        expect(seededRand1.rand()).not.toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('returns numbers between 0 and 1', () => {\n        const seededRand = new SeededRandom(123456);\n\n        for (let i = 0; i < 1000; i++) {\n            const randValue = seededRand.rand();\n            expect(randValue).toBeGreaterThanOrEqual(0);\n            expect(randValue).toBeLessThan(1);\n        }\n    });\n\n    test('produces different sequences with different seeds', () => {\n        const seededRand1 = new SeededRandom(123);\n        const seededRand2 = new SeededRandom(456);\n\n        const sequence1 = Array.from({ length: 5 }, () => seededRand1.rand());\n        const sequence2 = Array.from({ length: 5 }, () => seededRand2.rand());\n\n        expect(sequence1).not.toEqual(sequence2);\n    });\n\n    test('consistent sequence with the same seed over multiple calls', () => {\n        const seededRand = new SeededRandom(987654321);\n\n        const sequence1 = [seededRand.rand(), seededRand.rand(), seededRand.rand()];\n\n        // Re-initialize with the same seed to test.js consistency\n        const seededRand2 = new SeededRandom(987654321);\n        const sequence2 = [seededRand2.rand(), seededRand2.rand(), seededRand2.rand()];\n\n        expect(sequence1).toEqual(sequence2);\n    });\n});\n",
        "prompt": "please write a javascript class , the class signature as below /**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 306,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "2800-202410-DTC13\\d2a3fe8302d732cbde4a88b4452d081a5307af53\\js\\getPrice.js",
    "question_type": "Algorithm and data structure",
    "summary": "The recipe ID is hashed to produce a price in the specified range",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}",
        "test_code": "describe('getPrice', () => {\n    test('should return a number within the default range for a given recipe ID', () => {\n        const price = getPrice('recipe123');\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n\n    test('should return the same price for the same recipe ID', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe123');\n        expect(price1).toBe(price2);\n    });\n\n    test('should return different prices for different recipe IDs', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe456');\n        expect(price1).not.toBe(price2);\n    });\n\n    test('should return a price within a custom range', () => {\n        const minVal = 20;\n        const maxVal = 50;\n        const price = getPrice('recipe789', minVal, maxVal);\n        expect(price).toBeGreaterThanOrEqual(minVal);\n        expect(price).toBeLessThanOrEqual(maxVal);\n    });\n\n    test('should handle very long recipe IDs without error', () => {\n        const longRecipeId = 'recipe' + 'A'.repeat(1000);\n        const price = getPrice(longRecipeId);\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 308,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "2800-202410-BBY17\\fac3c1cea77c0cfaff9cd537d175ca25cc6cc103\\index.js",
    "question_type": "Program input code",
    "summary": "Gets the current date and returns it as YYYY-MM-DD",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}",
        "test_code": "describe('getCurrentDate', () => {\n    test('should return a string in the format YYYY-MM-DD', () => {\n        const date = getCurrentDate();\n        expect(typeof date).toBe('string');\n        expect(date).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n    });\n\n    test('should return the correct date for today', () => {\n        const expectedDate = new Date().toISOString().split('T')[0];\n        const actualDate = getCurrentDate();\n        expect(actualDate).toBe(expectedDate);\n    });\n\n    test('should return the correct year part in YYYY-MM-DD', () => {\n        const currentYear = new Date().getFullYear().toString();\n        const actualDate = getCurrentDate();\n        expect(actualDate.startsWith(currentYear)).toBe(true);\n    });\n\n    test('should return the correct month part in YYYY-MM-DD', () => {\n        const currentMonth = (`0${new Date().getMonth() + 1}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(5, 7)).toBe(currentMonth);\n    });\n\n    test('should return the correct day part in YYYY-MM-DD', () => {\n        const currentDay = (`0${new Date().getDate()}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(8, 10)).toBe(currentDay);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 313,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "JS-Project-Color-Flipper\\14eb9584d3d693761c0d168514228d47c6d07d31\\js\\app.js",
    "question_type": NaN,
    "summary": "Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}",
        "test_code": "/**\n * @jest-environment jsdom\n */\n\ndescribe('isBackgroundTooDarkOrBright', () => {\n    let mainElement;\n\n    beforeEach(() => {\n        // Create a 'main' element and append it to the document body\n        mainElement = document.createElement('main');\n        document.body.appendChild(mainElement);\n    });\n\n    afterEach(() => {\n        // Clean up by removing the 'main' element after each test.js\n        document.body.removeChild(mainElement);\n    });\n\n    test('should return \"dark\" for a dark background color', () => {\n        // Set a dark background color\n        mainElement.style.backgroundColor = 'rgb(30, 30, 30)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n\n    test('should return \"bright\" for a bright background color', () => {\n        // Set a bright background color\n        mainElement.style.backgroundColor = 'rgb(250, 250, 250)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('bright');\n    });\n\n    test('should return \"normal\" for a background color with normal brightness', () => {\n        // Set a background color with normal brightness\n        mainElement.style.backgroundColor = 'rgb(150, 150, 150)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a bright color with high red component', () => {\n        // Set a bright color with a high red component\n        mainElement.style.backgroundColor = 'rgb(255, 100, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a dark color with low green and blue components', () => {\n        // Set a dark color with low green and blue components\n        mainElement.style.backgroundColor = 'rgb(10, 10, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}",
        "addition_info": "/**\n * @jest-environment jsdom\n */"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 315,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "JS-Backend\\1ef25695146d98fe7004c6f19c9446ccba9b63dd\\src\\utils\\cloudinary.js",
    "question_type": "User interface",
    "summary": "extract the file name from the given URL\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Extract the fileid from the given URL query args.If not find return null\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {\n}",
        "test_code": "describe('getFileIdFromUrl', () => {\n    test('should return the file ID when a valid URL with fileId is provided', () => {\n        const url = 'https://example.com/download?fileId=12345';\n        expect(getFileIdFromUrl(url)).toBe('12345');\n    });\n\n    test('should return null when the fileId query parameter is missing', () => {\n        const url = 'https://example.com/download';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n    test('should return null when the fileId query parameter is empty', () => {\n        const url = 'https://example.com/download?fileId=';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n\n\n    test('should return null for a malformed URL', () => {\n        const url = 'https://example.com/download?fileId=12345&otherParam';\n        expect(getFileIdFromUrl(url)).toBe('12345'); // Adjust this depending on your needs; the function should still work correctly.\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Extract the fileid from the given URL query args.If not find return null\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 317,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js",
    "question_type": "Program input code",
    "summary": "count the number of letters in a string\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str) {}",
        "test_code": "describe('countLetters', () => {\n    test('should return 10 for the string \"Hello, World!\"', () => {\n        expect(countLetters(\"Hello, World!\")).toBe(10);\n    });\n\n    test('should return 0 for a string with no letters \"12345\"', () => {\n        expect(countLetters(\"12345\")).toBe(0);\n    });\n\n    test('should return 6 for the string \"abc 123 xyz!\"', () => {\n        expect(countLetters(\"abc 123 xyz!\")).toBe(6);\n    });\n\n    test('should return 0 for an empty string', () => {\n        expect(countLetters(\"\")).toBe(0);\n    });\n\n    test('should return 3 for the string \"A1B2C3!@#\"', () => {\n        expect(countLetters(\"A1B2C3!@#\")).toBe(3);\n    });\n\n    test('should return 5 for a string with mixed case \"AbCdE\"', () => {\n        expect(countLetters(\"AbCdE\")).toBe(5);\n    });\n\n    test('should return 8 for a string with special characters \"Hello@2024!\"', () => {\n        expect(countLetters(\"Hello@2024!\")).toBe(5);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 318,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js",
    "question_type": "Program input code",
    "summary": "count the number of numbers in a string\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}",
        "test_code": "// Jest test cases for countNumbers function\ndescribe('countNumbers', () => {\n    test('should return the correct count for a string with multiple numbers', () => {\n        const result = countNumbers('There are 123 numbers in this string.');\n        expect(result).toBe(3); // '123' contains three numeric characters\n    });\n\n    test('should return 0 for a string with no numbers', () => {\n        const result = countNumbers('No numbers here!');\n        expect(result).toBe(0); // No numeric characters in 'No numbers here!'\n    });\n\n    test('should return the correct count for a string with mixed characters', () => {\n        const result = countNumbers('Room 101 and Room 102');\n        expect(result).toBe(6); // '101' and '102' together contain six numeric characters\n    });\n\n    test('should return the correct count for a string with only numbers', () => {\n        const result = countNumbers('1234567890');\n        expect(result).toBe(10); // '1234567890' contains ten numeric characters\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countNumbers('');\n        expect(result).toBe(0); // An empty string contains no numeric characters\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 319,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js",
    "question_type": "Program input code",
    "summary": "count the number of dashes in a string\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}",
        "test_code": "describe('countDashes', () => {\n    test('should return 0 for a string with no dashes', () => {\n        const result = countDashes('hello world');\n        expect(result).toBe(0); // 'hello world' contains no dashes\n    });\n\n    test('should return 1 for a string with one dash', () => {\n        const result = countDashes('hello-world');\n        expect(result).toBe(1); // 'hello-world' contains one dash\n    });\n\n    test('should return 4 for a string with multiple dashes', () => {\n        const result = countDashes('a-b-c-d-e');\n        expect(result).toBe(4); // 'a-b-c-d-e' contains four dashes\n    });\n\n    test('should return 2 for a string with dashes at the beginning and end', () => {\n        const result = countDashes('-start-end-');\n        expect(result).toBe(3); // '-start-end-' contains two dashes\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countDashes('');\n        expect(result).toBe(0); // An empty string contains no dashes\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 320,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "cifra\\83917c840ea8c82df69df0db3d4b3b154746bd02\\script.js",
    "question_type": "Program input code",
    "summary": "calculate the average of an array of numbers\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}",
        "test_code": "describe('getArrayAverage', () => {\n    test('should return the average of an array of positive integers', () => {\n        const result = getArrayAverage([1, 2, 3, 4, 5]);\n        expect(result).toBe(3); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    });\n\n    test('should return the average of an array with negative numbers', () => {\n        const result = getArrayAverage([-1, -2, -3, -4, -5]);\n        expect(result).toBe(-3); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    });\n\n    test('should return the average of an array with mixed positive and negative numbers', () => {\n        const result = getArrayAverage([1, -1, 2, -2, 3, -3]);\n        expect(result).toBe(0); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    });\n\n    test('should handle an empty array (edge case)', () => {\n        const result = getArrayAverage([]);\n        expect(result).toBeNaN(); // Division by zero, expected model_answer_result is NaN\n    });\n\n    test('should return the single element when the array contains one item', () => {\n        const result = getArrayAverage([7]);\n        expect(result).toBe(7); // The average of [7] is 7\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 322,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "PrepPilot\\987ec93ebff6fbf7ec7b17c9500546f8c87861eb\\app\\static\\javascript\\auth_util.js",
    "question_type": "User interface",
    "summary": "verify that a string is a valid email address\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}",
        "test_code": "describe('isValidEmail', () => {\n    test('should return true for a valid simple email', () => {\n        const result = isValidEmail('test@example.com');\n        expect(result).toBe(true); // 'test@example.com' is a valid email\n    });\n\n    test('should return true for a valid email with subdomain', () => {\n        const result = isValidEmail('user@mail.example.com');\n        expect(result).toBe(true); // 'user@mail.example.com' is a valid email\n    });\n\n    test('should return false for an email missing the @ symbol', () => {\n        const result = isValidEmail('invalid-email.com');\n        expect(result).toBe(false); // 'invalid-email.com' is missing the @ symbol\n    });\n\n    test('should return false for an email missing the domain part', () => {\n        const result = isValidEmail('user@.com');\n        expect(result).toBe(false); // 'user@.com' is missing a valid domain name\n    });\n\n    test('should return false for an email with spaces', () => {\n        const result = isValidEmail('user name@example.com');\n        expect(result).toBe(false); // 'user name@example.com' contains spaces\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 323,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "PrepPilot\\987ec93ebff6fbf7ec7b17c9500546f8c87861eb\\app\\static\\javascript\\auth_util.js",
    "question_type": "User interface",
    "summary": "verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n",
        "test_code": "describe('isValidUsername', () => {\n    test('should return true for a valid username with letters, numbers, and underscores', () => {\n        const result = isValidUsername('user_123');\n        expect(result).toBe(true); // 'user_123' is a valid username\n    });\n\n    test('should return true for a valid username with only letters', () => {\n        const result = isValidUsername('username');\n        expect(result).toBe(true); // 'username' is a valid username\n    });\n\n    test('should return false for a username with special characters', () => {\n        const result = isValidUsername('user-name');\n        expect(result).toBe(false); // 'user-name' contains a hyphen\n    });\n\n    test('should return false for a username with spaces', () => {\n        const result = isValidUsername('user name');\n        expect(result).toBe(false); // 'user name' contains spaces\n    });\n\n    test('should return true for a valid username with only numbers', () => {\n        const result = isValidUsername('12345');\n        expect(result).toBe(true); // '12345' is a valid username\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 326,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "cider\\ce18e81fa2b1f3921adc5c6cd47c93c3038e43d3\\website\\lib\\time-difference.js",
    "question_type": "Data processing and transformation",
    "summary": "Calculates the time difference between a given date and the current date, returning how many days, hours, and minutes elapsed between the two times",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: days,\n *         hours: remainingHours,\n *         minutes: remainingMinutes,\n * }\n */\nfunction calculateTimeDifference(givenDate) {\n}",
        "test_code": "describe('calculateTimeDifference', () => {\n    test('should return correct time difference for a date in the past', () => {\n        const pastDate = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000 - 5 * 60 * 1000); // 3 days and 5 minutes ago\n        const result = calculateTimeDifference(pastDate);\n        expect(result).toEqual({ days: 3, hours: 0, minutes: 5 });\n    });\n\n    test('should return correct time difference for a date that is exactly now', () => {\n        const now = new Date();\n        const result = calculateTimeDifference(now);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date just seconds ago', () => {\n        const justNow = new Date(Date.now() - 45 * 1000); // 45 seconds ago\n        const result = calculateTimeDifference(justNow);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n\n    test('should return correct time difference for a date with only hours difference', () => {\n        const hoursAgo = new Date(Date.now() - 7 * 60 * 60 * 1000); // 7 hours ago\n        const result = calculateTimeDifference(hoursAgo);\n        expect(result).toEqual({ days: 0, hours: 7, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date with hours and minutes difference', () => {\n        const hoursAndMinutesAgo = new Date(Date.now() - (1 * 24 * 60 * 60 * 1000 + 3 * 60 * 1000)); // 1 day and 3 minutes ago\n        const result = calculateTimeDifference(hoursAndMinutesAgo);\n        expect(result).toEqual({ days: 1, hours: 0, minutes: 3 });\n    });\n\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: days,\n *         hours: remainingHours,\n *         minutes: remainingMinutes,\n * }\n */\nfunction calculateTimeDifference(givenDate) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 447,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "IUM-TWEB\\b63d3b147923370e5578b6521c62b4f75da9ba3b\\Solution\\Main\\public\\javascripts\\club_valutation.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Calculate age based on the birth date string entered by the user\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculate age based on the birth date string entered by the user.Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns {string|number}\n */\nfunction calculateAge(birthDateString) {\n}\n",
        "test_code": "describe('calculateAge', () => {\n    test('calculates age correctly for a birth date in the past', () => {\n        expect(calculateAge('2000-01-01')).toBe(new Date().getFullYear() - 2000);\n    });\n\n    test('calculates age correctly for a birth date in the long past', () => {\n        expect(calculateAge('1000-01-01')).toBe(new Date().getFullYear() - 1000);\n    });\n\n\n    test('calculates age correctly for a birth date today', () => {\n        const today = new Date().toISOString().split('T')[0]; // Get today's date in YYYY-MM-DD format\n        expect(calculateAge(today)).toBe(0);\n    });\n\n\n    test('calculates age correctly for a person born yesterday', () => {\n        const yesterday = new Date();\n        yesterday.setDate(yesterday.getDate() - 1); // Set to yesterday\n        const birthDateString = yesterday.toISOString().split('T')[0];\n        expect(calculateAge(birthDateString)).toBe(0);\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Calculate age based on the birth date string entered by the user.Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns {string|number}\n */\nfunction calculateAge(birthDateString) {\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 449,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "InstaBot\\f13614f5d1e21fe97c4379f2f3173f0e8bb39053\\Handlers\\DMHandler.js\n",
    "question_type": "Algorithm and data structure",
    "summary": "Convert Buffer to Base64 encoding",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input) {\n}",
        "test_code": "describe('Base64 Encoding Tests', () => {\n    test('Convert simple string to Base64', () => {\n        expect(convertToBase64(\"Hello, World!\")).toBe(\"SGVsbG8sIFdvcmxkIQ==\");\n    });\n\n    test('Convert empty string to Base64', () => {\n        expect(convertToBase64(\"\")).toBe(\"\");\n    });\n\n    test('Convert string with spaces to Base64', () => {\n        expect(convertToBase64(\"Test String with Spaces\")).toBe(\"VGVzdCBTdHJpbmcgd2l0aCBTcGFjZXM=\");\n    });\n\n    test('Convert string with special characters to Base64', () => {\n        expect(convertToBase64(\"Special characters: @#&*()\")).toBe(\"U3BlY2lhbCBjaGFyYWN0ZXJzOiBAIyYqKCk=\");\n    });\n\n    test('Convert string with non-ASCII characters to Base64', () => {\n        expect(convertToBase64(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\")).toBe(\"5L2g5aW977yM5LiW55WM77yB\");\n    });\n\n    test('Convert long string to Base64', () => {\n        const longString = \"This is a very long string that exceeds normal lengths for testing purposes.\";\n        expect(convertToBase64(longString)).toBe(\"VGhpcyBpcyBhIHZlcnkgbG9uZyBzdHJpbmcgdGhhdCBleGNlZWRzIG5vcm1hbCBsZW5ndGhzIGZvciB0ZXN0aW5nIHB1cnBvc2VzLg==\");\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 450,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "nimbase\\7ea48fafa204b418412efbc0bb9418504ecbf72f\\frontend\\src\\pages\\signup.jsx\n",
    "question_type": "Data processing and transformation",
    "summary": "Check whether the password string meets format requirements: contains at least one number.\nContain at least one lowercase letter.\nContain at least one uppercase letter.\nThe value contains at least 8 characters. Contains at least one punctuation mark",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password) {\n}",
        "test_code": "describe('Password Validator Tests', () => {\n    test('Valid password', () => {\n        expect(isValidPassword(\"Password1!\")).toBe(true);\n    });\n\n    test('Password without a number', () => {\n        expect(isValidPassword(\"Password!\")).toBe(false);\n    });\n\n    test('Password without an uppercase letter', () => {\n        expect(isValidPassword(\"password1!\")).toBe(false);\n    });\n\n    test('Password without a lowercase letter', () => {\n        expect(isValidPassword(\"PASSWORD1!\")).toBe(false);\n    });\n\n    test('Password without a punctuation mark', () => {\n        expect(isValidPassword(\"Password1\")).toBe(false);\n    });\n\n    test('Password shorter than 8 characters', () => {\n        expect(isValidPassword(\"Pass1!\")).toBe(false);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 528,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "xinjs-ui\\5f02678148c0b8e4f2af7e78776a913e1a6d9394\\docs.js\n",
    "question_type": "File operations and I/O operation",
    "summary": "Searches for Markdown files in the specified directory and returns the path of the files as an array\n",
    "language_version_list": {
      "python": {
        "code_signature": "const fs = require('fs');\nconst path = require('path');\n\n/**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir) {\n}",
        "test_code": "const fs = require('fs');\nconst path = require('path');\n\njest.mock('fs');\n\ndescribe('findMarkdownFiles', () => {\n    beforeEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('should return an empty array for an empty directory', () => {\n        fs.readdirSync.mockReturnValue([]);\n        fs.statSync.mockImplementation(() => ({isDirectory: () => false}));\n\n        const result = findMarkdownFiles('emptyDir');\n        expect(result).toEqual([]);\n    });\n\n    test('should return an array with one Markdown file', () => {\n        fs.readdirSync.mockReturnValue(['file1.md']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md']);\n    });\n\n    test('should return an array with multiple Markdown files in the same directory', () => {\n        fs.readdirSync.mockReturnValue(['file1.md', 'file2.md']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md', 'dir\\\\file2.md']);\n    });\n\n\n    test('should return Markdown files while ignoring non-Markdown files', () => {\n        fs.readdirSync.mockReturnValue(['file1.txt', 'file2.md', 'file3.doc']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file2.md']);\n    });\n\n\n    test('should handle a directory with only non-Markdown files', () => {\n        fs.readdirSync.mockReturnValue(['file1.txt', 'file2.doc']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual([]);\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\nconst path = require('path');\n\n/**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 529,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "xinjs-ui\\5f02678148c0b8e4f2af7e78776a913e1a6d9394\\docs.js\n",
    "question_type": "File operations and I/O operation",
    "summary": "Converts the  data object to JSON format and saves it to the specified file path\n",
    "language_version_list": {
      "python": {
        "code_signature": "const fs = require('fs');\n\n/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data, outputFilePath) {\n}",
        "test_code": "describe('saveAsJSON', () => {\n    const mockFilePath = 'test.json';\n    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();\n    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n\n    afterEach(() => {\n        // Clean up after each test\n        jest.clearAllMocks();\n        if (fs.existsSync(mockFilePath)) {\n            fs.unlinkSync(mockFilePath); // Remove test file if it exists\n        }\n    });\n\n    test('should save valid object to JSON file', () => {\n        const data = {name: \"Alice\", age: 25};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should handle empty object', () => {\n        const data = {};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save nested object to JSON file', () => {\n        const data = {user: {name: \"Bob\", age: 30}, active: true};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save array of objects to JSON file', () => {\n        const data = [\n            {product: {id: 1, name: \"Laptop\", price: 999.99}, inStock: true},\n            {product: {id: 2, name: \"Phone\", price: 499.99}, inStock: false}\n        ];\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save object with mixed data types to JSON file', () => {\n        const data = {title: \"Shopping List\", items: [\"Milk\", \"Eggs\", \"Bread\"], total: 3.50, completed: false};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save deeply nested object to JSON file', () => {\n        const data = {\n            company: {\n                name: \"TechCorp\",\n                employees: [\n                    {\n                        id: 1,\n                        name: \"Alice\",\n                        role: \"Developer\",\n                        contact: {email: \"alice@techcorp.com\", phone: \"123-456-7890\"}\n                    },\n                    {id: 2, name: \"Bob\", role: \"Designer\", contact: {email: \"bob@techcorp.com\", phone: \"098-765-4321\"}}\n                ]\n            },\n            established: 2010\n        };\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n});\n",
        "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\n\n/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data, outputFilePath) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 530,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "clrb-edition_tracker\\d40531e4d2dd5d324f69591176352ccd14808d8b\\src\\main\\resources\\static\\js\\main.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Creates a matrix with the specified number of rows and columns,\nfilled with the given initial value.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows, columns, initialValue) {\n}",
        "test_code": "describe('createMatrix', () => {\n    test('should create a 2x2 matrix filled with zeros', () => {\n        const result = createMatrix(2, 2, 0);\n        expect(result).toEqual([[0, 0], [0, 0]]);\n    });\n\n    test('should create a 3x3 matrix filled with ones', () => {\n        const result = createMatrix(3, 3, 1);\n        expect(result).toEqual([[1, 1, 1], [1, 1, 1], [1, 1, 1]]);\n    });\n\n    test('should create a 4x5 matrix filled with a string', () => {\n        const result = createMatrix(4, 5, 'test');\n        expect(result).toEqual([\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n        ]);\n    });\n\n    test('should create a 0x0 matrix', () => {\n        const result = createMatrix(0, 0, null);\n        expect(result).toEqual([]);\n    });\n\n    test('should create a 1x1 matrix with a boolean', () => {\n        const result = createMatrix(1, 1, true);\n        expect(result).toEqual([[true]]);\n    });\n    test('should create a 5x5 matrix filled with negative numbers', () => {\n        const result = createMatrix(5, 5, -1);\n        expect(result).toEqual([\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n        ]);\n    });\n\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows, columns, initialValue) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 532,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\554f86a5e9de09730cafe86ec9d27e131bb86600\\utilities-string.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Counts the occurrences of consecutive identical letters in a given string.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString) {\n}",
        "test_code": "describe('countLetterChanges', () => {\n    test('should count consecutive letters correctly', () => {\n        const result = countLetterChanges(\"aaabbcdeee\");\n        expect(result).toEqual([3, 2, 1, 1, 3]);\n    });\n\n    test('should return an array with one count for a single character', () => {\n        const result = countLetterChanges(\"a\");\n        expect(result).toEqual([1]);\n    });\n\n    test('should return counts for a string with no consecutive letters', () => {\n        const result = countLetterChanges(\"abcdef\");\n        expect(result).toEqual([1, 1, 1, 1, 1, 1]);\n    });\n\n    test('should handle a string with only identical letters', () => {\n        const result = countLetterChanges(\"rrrrrr\");\n        expect(result).toEqual([6]);\n    });\n\n    test('should handle a long string with random letters', () => {\n        const result = countLetterChanges(\"xxxyyyzzzaaaab\");\n        expect(result).toEqual([3, 3, 3, 4, 1]);\n    });\n\n    test('should handle numeric characters in the string', () => {\n        const result = countLetterChanges(\"1122334455\");\n        expect(result).toEqual([2, 2, 2, 2, 2]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 533,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Using-Konduktiva-With-MIDI\\554f86a5e9de09730cafe86ec9d27e131bb86600\\utilities-string.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Shuffles the characters in a given string randomly.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString) {\n}",
        "test_code": "describe('shuffleString', () => {\n    test('should return a string of the same length as the input', () => {\n        const input = \"abcdef\";\n        const result = shuffleString(input);\n        expect(result.length).toBe(input.length);\n    });\n\n    test('should shuffle the characters in the string', () => {\n        const input = \"hello\";\n        const result = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n\n    test('should return an empty string when given an empty string', () => {\n        const input = \"\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"\"); // Should return an empty string\n    });\n\n    test('should handle a single character string', () => {\n        const input = \"a\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"a\"); // Should return the same single character\n    });\n\n    test('should handle strings with identical characters', () => {\n        const input = \"aaaaa\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"aaaaa\"); // Should return the same string\n    });\n\n    test('should return a shuffled string for longer strings', () => {\n        const input = \"abcdefghijklmnopqrstuvwxyz\";\n        const result = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n        expect(result.length).toBe(input.length); // Length should be the same\n    });\n\n    test('should return the same string if all characters are the same', () => {\n        const input = \"111111\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"111111\"); // Should return the same string\n    });\n\n    test('should shuffle a string containing special characters', () => {\n        const input = \"a!@#$%^&*()_+\";\n        const result = shuffleString(input);\n        expect(result.length).toBe(input.length); // Length should be the same\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 534,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n",
    "question_type": "Algorithm and data structure",
    "summary": "Removes the first occurrence of a specified element from an array.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array} array - The array from which to remove the element.\n * @param {*} element - The element to remove from the array.\n * @returns {Array} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray(array, element) {\n\n}",
        "test_code": "describe('removeElementInArray', () => {\n    test('returns the original array when the element is not found', () => {\n        const result = removeElementInArray([1, 2, 3, 4], 5);\n        expect(result).toEqual([1, 2, 3, 4]);\n    });\n\n\n    test('handles an empty array correctly', () => {\n        const result = removeElementInArray([], 1);\n        expect(result).toEqual([]);\n    });\n\n    test('removes an element from an array of objects', () => {\n        const obj1 = {id: 1};\n        const obj2 = {id: 2};\n        const obj3 = {id: 3};\n        const result = removeElementInArray([obj1, obj2, obj3], obj2);\n        expect(result).toEqual([obj1, obj3]);\n    });\n\n    test('does not modify the original array', () => {\n        const originalArray = [1, 2, 3];\n        const result = removeElementInArray(originalArray, 2);\n        expect(originalArray).toEqual([1, 2, 3]);\n        expect(result).toEqual([1, 3]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array} array - The array from which to remove the element.\n * @param {*} element - The element to remove from the array.\n * @returns {Array} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray(array, element) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 535,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Compresses an HTML string by removing unnecessary whitespace,\nincluding newlines, tabs, and extra spaces,\nwhile preserving the structure of the HTML.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html) {\n}",
        "test_code": "describe('compressHtml', () => {\n    it('should remove newlines and tabs', () => {\n        const input = `\n            <div>\n                <p>Test paragraph.</p>\n            </div>\n        `;\n        const expectedOutput = '<div><p>Test paragraph.</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should replace multiple spaces with a single space', () => {\n        const input = '<div>    <p>     Test with     multiple spaces.   </p></div>';\n        const expectedOutput = '<div><p> Test with multiple spaces. </p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should remove spaces between HTML tags', () => {\n        const input = '<div> <p>Test</p> </div>';\n        const expectedOutput = '<div><p>Test</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle empty input', () => {\n        const input = '';\n        const expectedOutput = '';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle HTML with only spaces and newlines', () => {\n        const input = `\n            <div>      \n            </div>\n        `;\n        const expectedOutput = '<div></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 536,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Gets the current date formatted as 'Month Day, Year'.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate() {\n}",
        "test_code": "describe('getDate', () => {\n    // Mock the Date object to control the current date for testing\n    const mockDate = new Date('2024-10-01T00:00:00Z');\n\n    beforeAll(() => {\n        // Mock the global Date object\n        jest.spyOn(global, 'Date').mockImplementation(() => mockDate);\n    });\n\n    afterAll(() => {\n        // Restore the original Date object\n        global.Date.mockRestore();\n    });\n\n    test('returns date in \"Month Day, Year\" format', () => {\n        const result = getDate();\n        expect(result).toBe('October 1, 2024');\n    });\n\n    test('returns correct year', () => {\n        const result = getDate();\n        expect(result).toMatch(/2024/);\n    });\n\n    test('returns correct month', () => {\n        const result = getDate();\n        expect(result).toMatch(/October/);\n    });\n\n    test('returns correct day', () => {\n        const result = getDate();\n        expect(result).toMatch(/1/);\n    });\n\n\n    test('returns date as a string', () => {\n        const result = getDate();\n        expect(typeof result).toBe('string');\n    });\n\n    test('does not return undefined', () => {\n        const result = getDate();\n        expect(result).not.toBeUndefined();\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate() {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 537,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "Bing-Chat-History\\a9b013bc573b42d867b0ad23e884928947a0c167\\src\\pages\\js\\utility.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Gets the current time formatted as 'hh:mm AM/PM'.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime() {\n}",
        "test_code": "describe('getTime', () => {\n    const mockDate = (dateString) => {\n        const date = new Date(dateString);\n        jest.spyOn(global, 'Date').mockImplementation(() => date);\n    };\n\n    afterEach(() => {\n        jest.restoreAllMocks();\n    });\n\n    test('should return a string', () => {\n        mockDate('2024-10-01T10:30:00'); // Mocking a specific date and time\n        const result = getTime();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a formatted time string including AM/PM', () => {\n        mockDate('2024-10-01T15:45:00'); // 3:45 PM\n        const result = getTime();\n        expect(result).toMatch(/^\\d{1,2}:\\d{2} (AM|PM)$/);\n    });\n\n    test('should return the correct time during AM hours', () => {\n        mockDate('2024-10-01T08:15:00'); // 8:15 AM\n        const result = getTime();\n        expect(result).toBe('8:15 AM');\n    });\n\n    test('should return the correct time during PM hours', () => {\n        mockDate('2024-10-01T17:20:00'); // 5:20 PM\n        const result = getTime();\n        expect(result).toBe('5:20 PM');\n    });\n\n    test('should return \"12:00 AM\" at midnight', () => {\n        mockDate('2024-10-01T00:00:00'); // 12:00 AM\n        const result = getTime();\n        expect(result).toBe('12:00 AM');\n    });\n\n    test('should return \"12:00 PM\" at noon', () => {\n        mockDate('2024-10-01T12:00:00'); // 12:00 PM\n        const result = getTime();\n        expect(result).toBe('12:00 PM');\n    });\n\n    test('should handle single-digit minutes correctly', () => {\n        mockDate('2024-10-01T09:05:00'); // 9:05 AM\n        const result = getTime();\n        expect(result).toBe('9:05 AM');\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime() {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 538,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "utilsNodeJs\\8bd1fec924b2b1141b47c2a10911ed8035002918\\src\\Sorter.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Sorts an array of objects alphabetically based on a specified field.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Sorts an array of objects alphabetically based on a specified field.\n *\n * @param {Array} array - The array of objects to sort.\n * @param {String} field - The field of the objects to sort by.\n * @param {Boolean} ascending - If true, sort in ascending order; if false, sort in descending order.\n * @returns {Array} - The sorted array of objects.\n */\nfunction sortByField(array, field, ascending = true) {\n}",
        "test_code": "describe('sortByField', () => {\n    const data = [\n        {name: 'John', age: 25},\n        {name: 'Alice', age: 30},\n        {name: 'Bob', age: 22},\n        {name: 'Charlie', age: 28},\n    ];\n\n    test('should sort by name in ascending order', () => {\n        const sorted = sortByField(data, 'name', true);\n        expect(sorted).toEqual([\n            {name: 'Alice', age: 30},\n            {name: 'Bob', age: 22},\n            {name: 'Charlie', age: 28},\n            {name: 'John', age: 25},\n        ]);\n    });\n\n    test('should sort by name in descending order', () => {\n        const sorted = sortByField(data, 'name', false);\n        expect(sorted).toEqual([\n            {name: 'John', age: 25},\n            {name: 'Charlie', age: 28},\n            {name: 'Bob', age: 22},\n            {name: 'Alice', age: 30},\n        ]);\n    });\n\n    test('should sort by age in ascending order', () => {\n        const sorted = sortByField(data, 'age', true);\n        expect(sorted).toEqual([\n            {name: 'Bob', age: 22},\n            {name: 'John', age: 25},\n            {name: 'Charlie', age: 28},\n            {name: 'Alice', age: 30},\n        ]);\n    });\n\n    test('should sort by age in descending order', () => {\n        const sorted = sortByField(data, 'age', false);\n        expect(sorted).toEqual([\n            {name: 'Alice', age: 30},\n            {name: 'Charlie', age: 28},\n            {name: 'John', age: 25},\n            {name: 'Bob', age: 22},\n        ]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of objects alphabetically based on a specified field.\n *\n * @param {Array} array - The array of objects to sort.\n * @param {String} field - The field of the objects to sort by.\n * @param {Boolean} ascending - If true, sort in ascending order; if false, sort in descending order.\n * @returns {Array} - The sorted array of objects.\n */\nfunction sortByField(array, field, ascending = true) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 540,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "contrast-color-picker\\f66d5be01d5eb6727d4a4d7c3705fbb2cdbe0659\\site\\lib\\getCombos.js\n",
    "question_type": "Algorithm and data structure",
    "summary": "Generates all unique combinations of pairs from an array.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array} array - The input array from which combinations are generated.\n * @returns {Array} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs(array) {\n}",
        "test_code": "describe('generateUniquePairs', () => {\n    test('generates unique pairs from an array with three elements', () => {\n        const items = ['A', 'B', 'C'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['B', 'C']\n        ]);\n    });\n\n    test('generates unique pairs from an array with two elements', () => {\n        const items = ['A', 'B'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([['A', 'B']]);\n    });\n\n    test('returns an empty array when the input array is empty', () => {\n        const items = [];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n    test('returns an empty array when the input array has one element', () => {\n        const items = ['A'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n\n    test('handles an array with different types of elements', () => {\n        const items = [1, 'A', { key: 'value' }];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            [1, 'A'],\n            [1, { key: 'value' }],\n            ['A', { key: 'value' }]\n        ]);\n    });\n\n    test('generates pairs from an array with more than three elements', () => {\n        const items = ['A', 'B', 'C', 'D'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['A', 'D'],\n            ['B', 'C'],\n            ['B', 'D'],\n            ['C', 'D']\n        ]);\n    });\n\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array} array - The input array from which combinations are generated.\n * @returns {Array} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs(array) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 541,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "gptlint\\5f32e707ba3eb796c0d1e969a1f121ec8736e1ef\\fixtures\\evals\\prefer-loose-array-bounds-checks-in-loops\\incorrect\\944c32ed.js",
    "question_type": "Data processing and transformation",
    "summary": "Filters elements from an array based on a qualification function.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Filters elements from an array based on a qualification function.\n *\n * @param {Array} unfilteredArray - The array to filter.\n * @param {Function} isQualified - The function that determines if an element qualifies.\n * @returns {Array} - A new array containing the elements that qualify.\n */\nfunction filterArray(unfilteredArray, isQualified) {\n}",
        "test_code": "describe('filterArray', () => {\n    // Qualification function that checks if a number is greater than 10\n    const isGreaterThanTen = (num) => num > 10;\n\n    test('filters out numbers less than or equal to 10', () => {\n        const unfilteredArray = [5, 12, 3, 18, 7, 10, 15];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([12, 18, 15]);\n    });\n\n    test('returns an empty array when all elements are disqualified', () => {\n        const unfilteredArray = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array when all elements are qualified', () => {\n        const unfilteredArray = [11, 12, 15, 20];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([11, 12, 15, 20]);\n    });\n\n    test('handles an empty array input', () => {\n        const unfilteredArray = [];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('filters out strings based on length', () => {\n        const isLongerThanThreeChars = (str) => str.length > 3;\n        const unfilteredArray = ['a', 'ab', 'abc', 'abcd', 'abcde'];\n        const result = filterArray(unfilteredArray, isLongerThanThreeChars);\n        expect(result).toEqual(['abcd', 'abcde']);\n    });\n\n    test('correctly filters an array with mixed types', () => {\n        const isString = (item) => typeof item === 'string';\n        const unfilteredArray = [1, 'hello', true, 'world', null];\n        const result = filterArray(unfilteredArray, isString);\n        expect(result).toEqual(['hello', 'world']);\n    });\n\n    test('filters based on an object property', () => {\n        const hasValueGreaterThanFive = (obj) => obj.value > 5;\n        const unfilteredArray = [{ value: 3 }, { value: 5 }, { value: 7 }];\n        const result = filterArray(unfilteredArray, hasValueGreaterThanFive);\n        expect(result).toEqual([{ value: 7 }]);\n    });\n\n    test('returns an empty array when no qualifying function is provided', () => {\n        const unfilteredArray = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, () => false); // Always returns false\n        expect(result).toEqual([]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Filters elements from an array based on a qualification function.\n *\n * @param {Array} unfilteredArray - The array to filter.\n * @param {Function} isQualified - The function that determines if an element qualifies.\n * @returns {Array} - A new array containing the elements that qualify.\n */\nfunction filterArray(unfilteredArray, isQualified) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 542,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "gptlint\\e7dde3d4fc94b7f543bd7fd21f3ba2543665a5a1\\fixtures\\evals\\prefer-early-return\\correct\\c9cdf147.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Calculate the corresponding discount based on the given price and the actual price paid\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice, actualPrice) {\n}",
        "test_code": "describe('calculateDiscount', () => {\n    test('should return 25.00% discount for original price of 100 and actual price of 75', () => {\n        expect(calculateDiscount(100, 75)).toBe(25.00);\n    });\n\n    test('should return 0.00% discount for original price of 50 and actual price of 50', () => {\n        expect(calculateDiscount(50, 50)).toBe(0.00);\n    });\n\n    test('should return 100.00% discount for original price of 100 and actual price of 0', () => {\n        expect(calculateDiscount(100, 0)).toBe(100.00);\n    });\n\n    test('should return 50.00% discount for original price of 200 and actual price of 100', () => {\n        expect(calculateDiscount(200, 100)).toBe(50.00);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice, actualPrice) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 543,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "gptlint\\e7dde3d4fc94b7f543bd7fd21f3ba2543665a5a1\\fixtures\\evals\\prefer-early-return\\correct\\6038a5f3.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Increment the entered number. For non-positive numbers (less than or equal to 0), return the original value directly, and for positive numbers, return the value plus 1.\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num) {\n}",
        "test_code": "describe('incrementNumber', () => {\n    test('should return 6 when input is 5', () => {\n        expect(incrementNumber(5)).toBe(6);\n    });\n\n    test('should return 0 when input is 0', () => {\n        expect(incrementNumber(0)).toBe(0);\n    });\n\n    test('should return -3 when input is -3', () => {\n        expect(incrementNumber(-3)).toBe(-3);\n    });\n\n    test('should return 1 when input is 0.5', () => {\n        expect(incrementNumber(0.5)).toBe(1.5);\n    });\n\n    test('should return 1 when input is 1', () => {\n        expect(incrementNumber(1)).toBe(2);\n    });\n\n    test('should return -1 when input is -1', () => {\n        expect(incrementNumber(-1)).toBe(-1);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 544,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "gptlint\\5f32e707ba3eb796c0d1e969a1f121ec8736e1ef\\fixtures\\evals\\prefer-loose-array-bounds-checks-in-loops\\correct\\ef70f678.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Filter out all even numbers from the original array data",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array) {\n}",
        "test_code": "describe('filterOutEvenNumbers', () => {\n    test('removes all even numbers from the array', () => {\n        const inputArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray = [];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if all numbers are odd', () => {\n        const inputArray = [1, 3, 5, 7, 9];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array if all numbers are even', () => {\n        const inputArray = [2, 4, 6, 8, 10];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed positive and negative numbers', () => {\n        const inputArray = [-3, -2, -1, 0, 1, 2, 3];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([-3, -1, 1, 3]);\n    });\n\n    test('handles large numbers and zero correctly', () => {\n        const inputArray = [0, 1000000000, 1000000001, 1000000002, 1000000003];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1000000001, 1000000003]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 545,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "gptlint\\5f32e707ba3eb796c0d1e969a1f121ec8736e1ef\\fixtures\\evals\\prefer-loose-array-bounds-checks-in-loops\\correct\\9a91a8b7.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Iterate through the array of elements until the first null is encountered, returning the array before the null is encountered",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array} array - The array to iterate through.\n * @returns {Array} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array) {\n}",
        "test_code": "\ndescribe('elementsBeforeNull', () => {\n    test('returns elements before the first null', () => {\n        const inputArray = ['element1', 'element2', null, 'element3', 'element4'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2']);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray = [];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if there is no null', () => {\n        const inputArray = ['element1', 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2', 'element3']);\n    });\n\n    test('returns an empty array if the first element is null', () => {\n        const inputArray = [null, 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed types with null', () => {\n        const inputArray = [1, 'text', null, true, false];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([1, 'text']);\n    });\n\n    test('handles an array with only null', () => {\n        const inputArray = [null];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array} array - The array to iterate through.\n * @returns {Array} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 559,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "RISUCONT/90ca283a3a7be193fed6186eb072b37cd9734519/expander.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Check whether a file name is a cpp language header file",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName) {\n}",
        "test_code": "describe('isCppHeaderFile', () => {\n    test('returns true for a .h file', () => {\n        expect(isCppHeaderFile('example.h')).toBe(true);\n    });\n\n    test('returns true for a .hpp file', () => {\n        expect(isCppHeaderFile('example.hpp')).toBe(true);\n    });\n\n\n\n    test('returns false for a non-header file extension', () => {\n        expect(isCppHeaderFile('example.txt')).toBe(false);\n    });\n\n    test('returns false for a file without an extension', () => {\n        expect(isCppHeaderFile('example')).toBe(false);\n    });\n\n    test('returns false for a .c file', () => {\n        expect(isCppHeaderFile('example.c')).toBe(false);\n    });\n\n});\n",
        "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 560,
    "code_type": "method",
    "original_language": "javascript",
    "file_path": "RISUCONT/90ca283a3a7be193fed6186eb072b37cd9734519/expander.js\n",
    "question_type": "Data processing and transformation",
    "summary": "Gets the line number in the content at the specified index.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content, index) {\n}",
        "test_code": "describe('getLineNumber', () => {\n    test('returns 1 for the first character', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0)).toBe(1);\n    });\n\n    test('returns 1 for the last character of the first line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5)).toBe(1);\n    });\n\n    test('returns 3 for the last character of the third line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18)).toBe(3);\n    });\n\n    test('returns 1 for a single line string', () => {\n        expect(getLineNumber(\"Single line string\", 0)).toBe(1);\n    });\n\n    test('returns 3 for an index within a multiline string with trailing newlines', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15)).toBe(3);\n    });\n});",
        "prompt": "please write a javascript function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content, index) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 140,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "baby-diary\\bb057d82b387febd88092a48760e510a31f4e582\\src\\utils\\dateUtils.ts",
    "question_type": "Data processing and transformation",
    "summary": "calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}",
        "test_code": "describe('getTimeSinceBornUntilNow', () => {\n    beforeAll(() => {\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-23T15:45:00'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return the correct difference for a typical birth date', () => {\n        const birthDate = new Date('1990-05-15T10:30:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([34, 3, 8, 5, 15]); // Example output: 34 years, 3 months, 8 days, 5 hours, 15 minutes\n    });\n\n    test('should return the correct difference for a recent birth date', () => {\n        const birthDate = new Date('2024-08-20T12:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 3, 3, 45]); // 3 days, 3 hours, 45 minutes\n    });\n\n    test('should handle edge cases at the end of the year', () => {\n        const birthDate = new Date('2023-12-31T23:59:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 15, 46]); // 7 months, 22 days, 15 hours, 46 minutes\n    });\n\n\n    test('should handle birthdays earlier in the current month', () => {\n        const birthDate = new Date('2024-08-01T00:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 22, 15, 45]); // 22 days, 15 hours, 45 minutes\n    });\n\n    test('should handle birthdays later in the current year before the current month', () => {\n        const birthDate = new Date('2024-01-01T01:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 14, 45]); // 7 months, 22 days, 14 hours, 45 minutes\n    });\n\n    test('should handle birthdays in the previous month of the same year', () => {\n        const birthDate = new Date('2024-07-30T10:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 24, 5, 45]); // 24 days, 5 hours, 45 minutes\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 141,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "whiskerweb\\9a52b42647ff91ba28f974d5cdc29f6172fe1c81\\src\\engine\\HelperFunctions\\compareArrays.ts",
    "question_type": "Algorithm and data structure",
    "summary": "implement a generic compareArrays function that compares the elements of two arrays to each other",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array<T>} arr1 - The first array to compare. Elements can be of any type T.\n * @param {Array<T>} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @template T - The type of the elements in the arrays.\n *\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n}",
        "test_code": "describe('compareArrays', () => {\n    test('should return true for identical arrays with same order', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return true for identical arrays with different order', () => {\n        const arr1 = [3, 2, 1];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return false for arrays with different elements', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [4, 5, 6];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return false for arrays with different lengths', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return true for arrays with duplicate elements but same unique set', () => {\n        const arr1 = [1, 1, 2, 3, 3];\n        const arr2 = [3, 2, 1, 1];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array<T>} arr1 - The first array to compare. Elements can be of any type T.\n * @param {Array<T>} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @template T - The type of the elements in the arrays.\n *\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 142,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "scouting-app-2024\\c83197ba3adfb9a8c604255361df47ae3023e145\\client\\src\\lib\\camelCaseConvert.ts",
    "question_type": "Program input code",
    "summary": "convert a string with hump nomenclature to a string with spaces and capitalize the initial letter\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n}",
        "test_code": "describe('convertCamelCaseToSentence', () => {\n    test('should convert a simple camelCase string to a sentence', () => {\n        const input = \"thisIsTest\";\n        const expectedOutput = \"This is test\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle single word starting with lowercase', () => {\n        const input = \"example\";\n        const expectedOutput = \"Example\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a camelCase string with multiple uppercase letters', () => {\n        const input = \"thisIsAnExampleString\";\n        const expectedOutput = \"This is an example string\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a single uppercase letter', () => {\n        const input = \"aSingleUppercaseLetterX\";\n        const expectedOutput = \"A single uppercase letter x\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle an already capitalized string', () => {\n        const input = \"AlreadyCapitalized\";\n        const expectedOutput = \"Already capitalized\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 143,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "convert Arabic digits in the string to corresponding English digits\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}",
        "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('should convert Arabic numerals to English numerals', () => {\n        const input = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\";\n        const expectedOutput = \"1234567890\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should return the same string if there are no Arabic numerals', () => {\n        const input = \"Hello, World!\";\n        const expectedOutput = \"Hello, World!\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a mix of Arabic numerals and English characters', () => {\n        const input = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        const expectedOutput = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle empty string', () => {\n        const input = \"\";\n        const expectedOutput = \"\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a string with mixed Arabic and English numerals', () => {\n        const input = \"The number is \u0663\u0665\u0666 and 789.\";\n        const expectedOutput = \"The number is 356 and 789.\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 144,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Converts a string containing Arabic numbers to a floating point number",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value: string): string {\n}",
        "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('converts single Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0661')).toBe('1');\n        expect(arabicToEnglishNumbers('\u0665')).toBe('5');\n        expect(arabicToEnglishNumbers('\u0669')).toBe('9');\n    });\n\n    test('converts a string of Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669')).toBe('0123456789');\n    });\n\n    test('handles strings with Arabic and English numerals mixed', () => {\n        expect(arabicToEnglishNumbers('\u0660\u066123\u06645')).toBe('012345');\n    });\n\n    test('leaves non-numeral characters unchanged', () => {\n        expect(arabicToEnglishNumbers('Hello World!')).toBe('Hello World!');\n        expect(arabicToEnglishNumbers('2022-\u0662\u0660\u0662\u0663')).toBe('2022-2023');\n    });\n\n    test('works with full sentences that include Arabic numerals', () => {\n        expect(arabicToEnglishNumbers('The year is \u0662\u0660\u0662\u0664!')).toBe('The year is 2024!');\n    });\n\n    test('handles empty strings correctly', () => {\n        expect(arabicToEnglishNumbers('')).toBe('');\n    });\n\n    test('processes Arabic numerals in a complex mixed context', () => {\n        expect(arabicToEnglishNumbers('Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661')).toBe('Price: 500$ and Date: 2023-12-01');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value: string): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 145,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Format a number as a string representation of the specified currency. It uses the given locale and currencyCode to generate string output that matches the currency format for that locale.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nfunction formatCurrency(\n    value: number,\n    currencyCode: string,\n    locale: string = \"en-US\"\n): string {\n}",
        "test_code": "describe('formatCurrency function tests', () => {\n    test('should format currency in US dollars', () => {\n        const value = 1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '\\$1,234.56'; // Expected format for USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in Euro', () => {\n        const value = 1234.56;\n        const currencyCode = 'EUR';\n        const locale = 'en-US';\n        const expectedOutput = '\u20ac1,234.56'; // Expected format for EUR\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in British Pound', () => {\n        const value = 1234.56;\n        const currencyCode = 'GBP';\n        const locale = 'en-GB';\n        const expectedOutput = '\u00a31,234.56'; // Expected format for GBP\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency with a negative value', () => {\n        const value = -1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '-\\$1,234.56'; // Expected format for negative USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should handle zero value correctly', () => {\n        const value = 0;\n        const currencyCode = 'JPY';\n        const locale = 'en-JP';\n        const expectedOutput = '\u00a50'; // Expected format for JPY (no decimals)\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nfunction formatCurrency(\n    value: number,\n    currencyCode: string,\n    locale: string = \"en-US\"\n): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 146,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "fintrack\\e39079007a57d383b978833e4a7dd24d82329457\\src\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Format the number of bytes as a human-readable file size string. It displays file sizes in different units and decimal places depending on the options provided.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the model_answer_result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n",
        "test_code": "describe('formatBytes', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        const result = formatBytes(0);\n        expect(['0 B','0 Byte']).toContain(result)\n    });\n\n    test('should return \"2.0 KB\" for 2048 bytes', () => {\n        const result = formatBytes(2048);\n        expect(['2 KB','2.0 KB']).toContain(result)\n    });\n\n    test('should return \"2.0 KiB\" for 2048 bytes with sizeType \"accurate\"', () => {\n        const result = formatBytes(2048, { sizeType: \"accurate\" });\n        expect(['2 KiB','2.0 Kib']).toContain(result)\n    });\n\n    test('should return \"5.0 MB\" for 5242880 bytes', () => {\n        const result = formatBytes(5242880);\n         expect(['5 MB','5.0 MB']).toContain(result)\n    });\n\n    test('should return \"5.00 MiB\" for 5242880 bytes with 2 decimal places and sizeType \"accurate\"', () => {\n        const result = formatBytes(5242880, { decimals: 2, sizeType: \"accurate\" });\n        expect(result).toBe('5.00 MiB');\n    });\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the model_answer_result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 147,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "factor\\fa8fdc17e29935d1be565650e19fef1cf7d107d8\\src\\util\\webauthn.ts",
    "question_type": "Network requests and API call",
    "summary": "Converts the ArrayBuffer object to a string",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n",
        "test_code": "describe('arrayBufferToString', () => {\n    test('should return an empty string for an empty ArrayBuffer', () => {\n        const buffer1 = new ArrayBuffer(0);\n        const result = arrayBufferToString(buffer1);\n        expect(result).toBe(''); // Expected: \"\"\n    });\n\n    test('should return \"A\" for a buffer containing the character \"A\"', () => {\n        const buffer2 = new TextEncoder().encode(\"A\").buffer;\n        const result = arrayBufferToString(buffer2);\n        expect(result).toBe('A'); // Expected: \"A\"\n    });\n\n    test('should return \"Hello\" for a buffer containing the string \"Hello\"', () => {\n        const buffer3 = new TextEncoder().encode(\"Hello\").buffer;\n        const result = arrayBufferToString(buffer3);\n        expect(result).toBe('Hello'); // Expected: \"Hello\"\n    });\n\n        test('should return the correct string for a buffer containing multiple characters', () => {\n        const buffer4 = new TextEncoder().encode(\"Hello, World!\").buffer;\n        const result = arrayBufferToString(buffer4);\n        expect(result).toBe('Hello, World!'); // Expected: \"Hello, World!\"\n    });\n\n\n    test('should not modify the input buffer', () => {\n        const input = \"Test input\";\n        const buffer8 = new TextEncoder().encode(input).buffer;\n        arrayBufferToString(buffer8);\n        const result = new TextDecoder().decode(buffer8);\n        expect(result).toBe(input); // Check if the buffer content remains unchanged\n    });\n\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 148,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "factor\\fa8fdc17e29935d1be565650e19fef1cf7d107d8\\src\\util\\webauthn.ts",
    "question_type": "Network requests and API call",
    "summary": "Converts a base64-encoded string to an ArrayBuffer. An ArrayBuffer is a generic, fixed-length buffer of raw binary data that is commonly used to represent binary data.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n",
        "test_code": "describe('base64ToArrayBuffer function', () => {\n    // Test Case 1\n    test('should decode \"SGVsbG8sIFdvcmxkIQ==\" to \"Hello, World!\"', () => {\n        const base64 = \"SGVsbG8sIFdvcmxkIQ==\";\n        const expected = \"Hello, World!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 2\n    test('should decode \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\" to \"Some text with sparing and working!\"', () => {\n        const base64 = \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\";\n        const expected = \"Some text with sparing and working!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 3\n    test('should decode \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\" to \"Base64 encoding is a common log For binary question\"', () => {\n        const base64 = \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\";\n        const expected = \"Base64 encoding is a commonlog For binary data\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 4\n    test('should decode \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\" to \"Give me along a path to complete start page.\"', () => {\n        const base64 = \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\";\n        const expected = \"Give me along a path to complete start page.\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 149,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "color-editor\\faf5fa2f8292bbcf8e6267ec4d524e99cb0f52ec\\src\\Helper.ts",
    "question_type": "Data processing and transformation",
    "summary": "Code implementation for converting HSL color values \u200b\u200bto RGB color values",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts an HSL color value to RGB.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param hue The hue of the color (0-360)\n * @param saturation The saturation of the color (0-1)\n * @param lightness The lightness of the color (0-1)\n * @return An object containing the red, green, and blue channels.\n */\nfunction hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n}",
        "test_code": "describe('hslToRgb', () => {\n    test('Converts black (0% lightness)', () => {\n        expect(hslToRgb(0, 0, 0)).toEqual({ r: 0, g: 0, b: 0 });\n    });\n\n    test('Converts white (100% lightness)', () => {\n        expect(hslToRgb(0, 0, 1)).toEqual({ r: 255, g: 255, b: 255 });\n    });\n\n    test('Converts red (hue at 0)', () => {\n        expect(hslToRgb(0, 1, 0.5)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n\n    test('Converts green (hue at 120)', () => {\n        expect(hslToRgb(120, 1, 0.5)).toEqual({ r: 0, g: 255, b: 0 });\n    });\n\n    test('Converts blue (hue at 240)', () => {\n        expect(hslToRgb(240, 1, 0.5)).toEqual({ r: 0, g: 0, b: 255 });\n    });\n\n\n    test('Handles edge case with maximum hue (360 equivalent to 0)', () => {\n        expect(hslToRgb(360, 1, 0.5)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts an HSL color value to RGB.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param hue The hue of the color (0-360)\n * @param saturation The saturation of the color (0-1)\n * @param lightness The lightness of the color (0-1)\n * @return An object containing the red, green, and blue channels.\n */\nfunction hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 150,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "color-editor\\faf5fa2f8292bbcf8e6267ec4d524e99cb0f52ec\\src\\Helper.ts",
    "question_type": "Data processing and transformation",
    "summary": "Convert RGB colors to and from hexadecimal color format.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n",
        "test_code": "describe('rgbToHex and hexToRgb', () => {\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert RGB to HEX', () => {\n        const rgb = { r: 255, g: 99, b: 71 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#ff6347'); // Expected HEX code for RGB(255, 99, 71)\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert HEX to RGB', () => {\n        const hex = '#ff6347';\n        const result = hexToRgb(hex);\n        expect(result).toEqual({ r: 255, g: 99, b: 71 }); // Expected RGB object for HEX #ff6347\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should handle invalid RGB components gracefully', () => {\n        const rgb = { r: 300, g: -10, b: 128 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#12c-a80'); // Invalid values (300, -10) should be clamped to \"00\", valid value should convert to \"80\"\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should return null for invalid HEX strings', () => {\n        const invalidHex = '#ggg123';\n        const result = hexToRgb(invalidHex);\n        expect(result).toBeNull(); // Invalid HEX code should return null\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u8fb9\u754c\u503c\n    test('should handle boundary values in RGB correctly', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#000000'); // Boundary RGB(0, 0, 0) should convert to #000000\n\n        const rgbWhite = { r: 255, g: 255, b: 255 };\n        const resultWhite = rgbToHex(rgbWhite);\n        expect(resultWhite).toBe('#ffffff'); // Boundary RGB(255, 255, 255) should convert to #ffffff\n    });\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 151,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "color-editor\\faf5fa2f8292bbcf8e6267ec4d524e99cb0f52ec\\src\\Helper.ts",
    "question_type": "Data processing and transformation",
    "summary": "Convert RGB color values \u200b\u200bto HSL color values",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nfunction rgbToHsl({r, g, b}: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n",
        "test_code": "describe('rgbToHsl', () => {\n    test('should convert basic RGB values correctly (red)', () => {\n        const rgb = { r: 255, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 100, l: 50 });\n    });\n\n    test('should handle grayscale values (middle gray)', () => {\n        const rgb = { r: 128, g: 128, b: 128 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 50 });\n    });\n\n    test('should handle edge cases (white color)', () => {\n        const rgb = { r: 255, g: 255, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 100 });\n    });\n\n    test('should handle edge cases (black color)', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 0 });\n    });\n\n    // Additional tests\n    test('should handle vibrant green', () => {\n        const rgb = { r: 0, g: 255, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 120, s: 100, l: 50 });\n    });\n\n    test('should handle deep blue', () => {\n        const rgb = { r: 0, g: 0, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 240, s: 100, l: 50 });\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nfunction rgbToHsl({r, g, b}: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 152,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "BibiGPT-v1\\25753bb3f719a0f4c1b39bd136e2ec0d3eeae99d\\utils\\formatSummary.ts",
    "question_type": "Data processing and transformation",
    "summary": "Converts each character in the input string to the corresponding \"mathematical sans serif italic\" character.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}",
        "test_code": "describe('convertToMathematicalSansSerifItalic', () => {\n    test('should return an empty string when input is an empty string', () => {\n        const input = '';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe(''); // Edge case: empty string\n    });\n\n    test('should correctly convert all uppercase and lowercase letters to mathematical sans-serif italic', () => {\n        const input = 'HelloWorld';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc6f\ud835\udc86\ud835\udc8d\ud835\udc8d\ud835\udc90\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8d\ud835\udc85'); // Basic logic: mixed case\n    });\n\n    test('should leave characters unchanged if they have no corresponding mathematical sans-serif italic equivalent', () => {\n        const input = '12345!@#';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udfe3\ud835\udfe4\ud835\udfe5\ud835\udfe6\ud835\udfe7!@#'); // Basic logic: numbers with special characters\n    });\n\n    test('should handle input with a mix of convertible and non-convertible characters', () => {\n        const input = 'Math123!';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc74\ud835\udc82\ud835\udc95\ud835\udc89\ud835\udfe3\ud835\udfe4\ud835\udfe5!'); // Basic logic: mix of letters, numbers, and special characters\n    });\n\n    test('should handle edge case where input is at the boundary of supported characters', () => {\n        const input = 'A0z9';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc68\ud835\udfe2\ud835\udc9b\ud835\udfeb'); // Boundary values: 'A', '0', 'z', '9'\n    });\n});\n\n\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 153,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "abais\\2947d0d885332e9151001cc86b383ce3297439d5\\utils\\userIdGenerator.ts",
    "question_type": "Data processing and transformation",
    "summary": "The input hash buffer is compressed into a number letter string of length no less than 5",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}",
        "test_code": "// @ts-ignore\nconst crypto = require('crypto');\n\ndescribe('compressHash', () => {\n\n    test('should return a string of length 5', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result.length).toBe(5);\n    });\n\n    test('should return different strings for different inputs', () => {\n        // @ts-ignore\n        const hash1 = crypto.createHash('sha256').update('test1').digest();\n        // @ts-ignore\n        const hash2 = crypto.createHash('sha256').update('test2').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash1);\n        // @ts-ignore\n        const result2 = compressHash(hash2);\n        expect(result1).not.toBe(result2);\n    });\n\n    test('should return a consistent model_answer_result for the same input', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash);\n        // @ts-ignore\n        const result2 = compressHash(hash);\n        expect(result1).toBe(result2);\n    });\n\n    test('should handle a hash of all zeros', () => {\n        const hash = Buffer.alloc(32, 0); // 32 bytes of zeros\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n\n    test('should handle a hash of all ones', () => {\n        const hash = Buffer.alloc(32, 255); // 32 bytes of 0xFF (255 in decimal)\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 154,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "wxt-examples\\9d5e5c96539ca297544c3daf698a1ba6272ea3b1\\scripts\\parse-git-diff.ts",
    "question_type": "Data processing and transformation",
    "summary": "Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes",
    "language_version_list": {
      "python": {
        "code_signature": "// Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}",
        "test_code": "describe('parseGitDiff', () => {\n\n    test('should parse a simple file addition', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/file.txt`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].newFileMode).toBe('100644');\n    });\n\n    test('should parse a simple file deletion', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\ndeleted file mode 100644\nindex e69de29..0000000\n--- a/file.txt\n+++ /dev/null`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].deletedFileMode).toBe('100644');\n    });\n\n    test('should parse a file modification with changes', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nindex e69de29..d95f3ad 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -0,0 +1 @@\n+Hello World`;\n\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n\n        expect(result).toHaveLength(1); // Ensure only one file diff is parsed\n        expect(result[0].oldPath).toBe('file.txt'); // Validate old file path\n        expect(result[0].newPath).toBe('file.txt'); // Validate new file path\n        expect(result[0].index).toBe('e69de29..d95f3ad'); // Validate index value\n        expect(result[0].changes).toEqual([\n            {code: \"--- a/file.txt\"}, // Validate old file path line\n            {code: \"+++ b/file.txt\"}, // Validate new file path line\n            {diff: '@@ -0,0 +1 @@'},  // Validate diff header\n            {code: '+Hello World'}     // Validate code addition\n        ]); // Validate changes array\n    });\n\n    test('should handle multiple file diffs', () => {\n        const diffText = `diff --git a/file1.txt b/file1.txt\nindex e69de29..d95f3ad 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -0,0 +1 @@\n+Hello World\ndiff --git a/file2.txt b/file2.txt\nindex 0a1b2c3..d4e5f6a 100644\n--- a/file2.txt\n+++ b/file2.txt\n@@ -1 +1 @@\n-Hello\n+Hi`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(2);\n        expect(result[0].oldPath).toBe('file1.txt');\n        expect(result[1].oldPath).toBe('file2.txt');\n    });\n\n    test('should return an empty array for empty diff text', () => {\n        // @ts-ignore\n        const result = parseGitDiff('');\n        expect(result).toEqual([]);\n    });\n\n});",
        "prompt": "please write a typescript function , the function signature as below // Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 155,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "chen-overflow\\01a7eec2df2579a0fa553407c62525fb86ef70c4\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Computes the difference between the specified date and the current time, returning it in a human-readable way",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}",
        "test_code": "describe('getTimestamp', () => {\n    test('should return \"1 second ago\" for a date 1 second ago', () => {\n        const oneSecondAgo = new Date(new Date().getTime() - 1000); // 1 second ago\n        // @ts-ignore\n        expect(getTimestamp(oneSecondAgo)).toBe('1 second ago');\n    });\n\n    test('should return \"5 minutes ago\" for a date 5 minutes ago', () => {\n        const fiveMinutesAgo = new Date(new Date().getTime() - 5 * 60 * 1000); // 5 minutes ago\n        // @ts-ignore\n        expect(getTimestamp(fiveMinutesAgo)).toBe('5 minutes ago');\n    });\n\n    test('should return \"2 hours ago\" for a date 2 hours ago', () => {\n        const twoHoursAgo = new Date(new Date().getTime() - 2 * 60 * 60 * 1000); // 2 hours ago\n        // @ts-ignore\n        expect(getTimestamp(twoHoursAgo)).toBe('2 hours ago');\n    });\n\n    test('should return \"3 days ago\" for a date 3 days ago', () => {\n        const threeDaysAgo = new Date(new Date().getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        // @ts-ignore\n        expect(getTimestamp(threeDaysAgo)).toBe('3 days ago');\n    });\n\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 156,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "chen-overflow\\01a7eec2df2579a0fa553407c62525fb86ef70c4\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\"",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}",
        "test_code": "describe('formatNumber', () => {\n    test('should format numbers greater than or equal to 1,000,000 with \"M\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(1500000)).toBe('1.5M');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n\n    test('should format numbers greater than or equal to 1,000 but less than 1,000,000 with \"K\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(2500)).toBe('2.5K');\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n    });\n\n    test('should return the number as a string if it is less than 1,000', () => {\n        // @ts-ignore\n        expect(formatNumber(999)).toBe('999');\n        // @ts-ignore\n        expect(formatNumber(500)).toBe('500');\n    });\n\n\n    test('should handle edge cases like exactly 1,000 or 1,000,000', () => {\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 157,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes: number): string {\n\n}",
        "test_code": "describe('bytesToSize', () => {\n\n    test('should convert bytes to KB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1024)).toBe('1.00 KB');\n        // @ts-ignore\n        expect(bytesToSize(2048)).toBe('2.00 KB');\n    });\n\n    test('should convert bytes to MB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1048576)).toBe('1.00 MB');\n        // @ts-ignore\n        expect(bytesToSize(2097152)).toBe('2.00 MB');\n    });\n\n    test('should convert bytes to GB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1073741824)).toBe('1.00 GB');\n        // @ts-ignore\n        expect(bytesToSize(2147483648)).toBe('2.00 GB');\n    });\n\n    test('should convert bytes to TB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1099511627776)).toBe('1.00 TB');\n        // @ts-ignore\n        expect(bytesToSize(2199023255552)).toBe('2.00 TB');\n    });\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes: number): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 158,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Extract the file extension and return it if it exists. If not, an empty string is returned",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name: string): string {\n}",
        "test_code": "describe('getFileExtension', () => {\n    test('should return the file extension for a standard file', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.txt')).toBe('txt');\n    });\n\n    test('should return an empty string for files without an extension', () => {\n        // @ts-ignore\n        expect(getFileExtension('example')).toBe('');\n    });\n\n    test('should handle files with multiple dots', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.with.many.dots.jpg')).toBe('jpg');\n    });\n\n    test('should return an empty string for filenames that end with a dot', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.')).toBe('');\n    });\n\n    test('should correctly handle case sensitivity', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.JPG')).toBe('JPG');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name: string): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 159,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Removes the extension of the given filename and returns the remainder",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name: string): string {}",
        "test_code": "describe('removeFileExtension', () => {\n    test('should remove the file extension from a standard file', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.txt')).toBe('document');\n    });\n\n    test('should return the original filename for files without an extension', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document')).toBe('document');\n    });\n\n    test('should handle files with multiple dots correctly', () => {\n        // @ts-ignore\n        expect(removeFileExtension('my.file.with.many.extensions.pdf')).toBe('my.file.with.many.extensions');\n    });\n\n    test('should return the original filename if it ends with a dot', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.')).toBe('document');\n    });\n\n    test('should correctly handle filenames with dots in directory names', () => {\n        // @ts-ignore\n        expect(removeFileExtension('path.to/my.file.txt')).toBe('path.to/my.file');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name: string): string {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 160,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "Morphify\\b42b6a8fde75e1e26e4fb43a000f720a111ce4e1\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Compress the part of the file name before the file extension, and if the part exceeds the specified maximum length, replace the excess with***\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName: string, maxLength: number = 18): string {\n}",
        "test_code": "describe('compressFilename', () => {\n    test('should return the filename unchanged if under max length', () => {\n        expect(compressFilename('file.txt', 10)).toBe('file.txt');\n    });\n\n    test('should truncate and append *** if filename exceeds max length', () => {\n        expect(compressFilename('verylongfilename.txt', 10)).toBe('verylongfi***.txt');\n    });\n\n\n    test('should preserve file extension after compression', () => {\n        expect(compressFilename('document.pdf', 5)).toBe('docum***.pdf');\n    });\n\n\n    test('should truncate and append *** if filename exceeds', () => {\n        expect(compressFilename('short.mp3', 2)).toBe('sh***.mp3');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName: string, maxLength: number = 18): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 161,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "conjure-extension\\cd7b718adce8d1b1536f8c1a51ee1f2de366ead3\\src\\option.ts",
    "question_type": "Algorithm and data structure",
    "summary": "Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}",
        "test_code": "describe('generateCombinations', () => {\n    test('generates combinations for a single key with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2, 3]]]);\n        const expected = [[1], [2], [3]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with single values', () => {\n        const map = new Map<string, number[]>([['a', [1]], ['b', [2]]]);\n        const expected = [[1, 2]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2]], ['b', [3, 4]]]);\n        const expected = [\n            [1, 3], [1, 4],\n            [2, 3], [2, 4]\n        ];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles an empty map', () => {\n        const map = new Map<string, number[]>();\n        const expected: number[][] = [[]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles keys with empty arrays as values', () => {\n        const map = new Map<string, number[]>([['a', []], ['b', [1, 2]]]);\n        const expected: number[][] = [];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 162,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts",
    "question_type": "Data processing and transformation",
    "summary": "Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}",
        "test_code": "describe('boolArrayToBinaryString', () => {\n    test('converts an array of all true values', () => {\n        const boolArray = [true, true, true];\n        const expected = '111';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array of all false values', () => {\n        const boolArray = [false, false, false];\n        const expected = '000';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array with a mix of true and false values', () => {\n        const boolArray = [true, false, true, false];\n        const expected = '1010';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles an empty array', () => {\n        const boolArray: boolean[] = [];\n        const expected = '';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles a single boolean value', () => {\n        const boolArray = [true];\n        const expected = '1';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 163,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts",
    "question_type": "Data processing and transformation",
    "summary": "Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}",
        "test_code": "describe('binaryStringToUint8Array', () => {\n    test('should convert a full byte binary string', () => {\n        const binaryStr = '11001010';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202]));\n    });\n\n    test('should convert multiple full byte binary strings', () => {\n        const binaryStr = '1100101011110000';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202, 240]));\n    });\n\n\n    test('should handle an empty binary string', () => {\n        const binaryStr = '';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([]));\n    });\n\n    test('should correctly convert binary string with leading zeros', () => {\n        const binaryStr = '00101101';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([45]));\n    });\n    test('should handle binary string with end padding of zeros', () => {\n    const binaryStr = '11001010000'; // should be treated as '11001010 00000000'\n    // @ts-ignore\n    const result = binaryStringToUint8Array(binaryStr);\n    expect(result).toEqual(new Uint8Array([202, 0]));\n});\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 164,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts",
    "question_type": "Data processing and transformation",
    "summary": "The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array: Uint8Array): string {\n}",
        "test_code": "describe('uint8ArrayToBase64', () => {\n    test('should convert an empty Uint8Array', () => {\n        const uint8Array = new Uint8Array([]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('');\n    });\n\n    test('should convert a Uint8Array with one byte', () => {\n        const uint8Array = new Uint8Array([255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('/w==');\n    });\n\n    test('should convert a Uint8Array with two bytes', () => {\n        const uint8Array = new Uint8Array([255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('//8=');\n    });\n\n    test('should convert a Uint8Array with three bytes', () => {\n        const uint8Array = new Uint8Array([255, 255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('////');\n    });\n\n    test('should convert a Uint8Array with four bytes', () => {\n        const uint8Array = new Uint8Array([72, 101, 108, 108]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('SGVsbA==');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array: Uint8Array): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 165,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "prague-meetup\\64b994944d07318affaa18c9c7485f98eb1a53ab\\src\\utils\\boolArrayCodec.ts",
    "question_type": "Data processing and transformation",
    "summary": "\nPlease convert a standard Base64 encoded string into a URL-safe Base64 encoded string. The steps include replacing \"+\" with \"-\", replacing \"/\" with \"_\", and removing the trailing \"=\" characters. The resulting string should be suitable for use in URLs.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}",
        "test_code": "describe('base64ToUrlSafe', () => {\n\n    test('should correctly convert a standard Base64 string to URL-safe format', () => {\n        const base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\");\n    });\n\n    test('should return an empty string when the input is an empty string', () => {\n        const base64 = \"\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"\");\n    });\n\n    test('should remove only the trailing \"=\" characters', () => {\n        const base64 = \"dGVzdA==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle strings without any characters that need replacement', () => {\n        const base64 = \"dGVzdA\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle a base64 string with multiple \"+\" and \"/\" characters', () => {\n        const base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"aGVsbG8rL3dvcmxkLw\");\n    });\n\n    test('should throw an error when input is not a string', () => {\n        expect(() => base64ToUrlSafe((null as unknown) as string)).toThrow(TypeError);\n    });\n\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 166,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "100DaysOfDSA\\2d9d6bcf6f6039595ab9661d8b75510c6f0044e9\\Easy\\744 Find Smallest Letter Greater Than Target.ts",
    "question_type": "Algorithm and data structure",
    "summary": "Write a function that uses a binary search algorithm to find and return the smallest letter in a sorted array that is larger than a given target letter. If the target letter is greater than or equal to all the letters in the array, return the first letter in the array.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}",
        "test_code": "describe('nextGreatestLetter', () => {\n\n    test('should return the first letter when target is greater than all letters in the array', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'j';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should return the next greatest letter for a typical input', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'a';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should handle the edge case where target is in between two letters', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('f'); // Expected output: 'f'\n    });\n\n    test('should return the first letter when the target is equal to the largest letter', () => {\n        const letters = ['a', 'b', 'c', 'd'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n    test('should return the correct letter when the array contains only one letter', () => {\n        const letters = ['a'];\n        const target = 'z';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 167,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "bit-test\\65606717613da465daf07518e73c78d936171217\\src\\index.ts",
    "question_type": "Program input code",
    "summary": "Write a function that determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer (ranging from 0 to 999) after removing the \".bit\" suffix. The function should involve removing the \".bit\" suffix, converting the remaining part to an integer, and using a regular expression to verify if it is a 3-digit number. The function should return a boolean indicating whether the string meets this criterion.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName: string): boolean {\n}",
        "test_code": "describe('assert999', () => {\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    test('should return true for a valid 3-digit number with \".bit\" suffix', () => {\n        const input = \"123.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string without the \".bit\" suffix.\n     * Expected to return false.\n     */\n    test('should return true for a valid 2-digit number with \".bit\" suffix', () => {\n        const input = \"12.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    test('should return false for a string with non-numeric characters after removing \".bit\"', () => {\n        const input = \"12a.bit\";\n        const result = assert999(input);\n        expect(result).toBe(false);\n    });\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the lower boundary value \"0.bit\"', () => {\n        const input = \"0.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the upper boundary value \"999.bit\"', () => {\n        const input = \"999.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n});\n\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName: string): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 168,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "pinstop\\6c8202202ae311c9078e1c70afa46cf492cdcb02\\src\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Please convert a date string into a relative time description. Based on the time difference between the current time and the input date, generate a string that represents the relative time, such as \"X days ago,\" \"X hours ago,\" \"X minutes ago,\" or \"X seconds ago.\" Ensure the output displays the time difference in a user-friendly manner.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a date string into a relative time description.\n * For example,now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString: string): string {\n\n}",
        "test_code": "describe('formatDate', () => {\n    beforeAll(() => {\n        // Set the system time to a fixed date for consistent testing\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-25T12:00:00'));\n    });\n\n    afterAll(() => {\n        // Restore the real system time after tests\n        jest.useRealTimers();\n    });\n\n    test('should return \"1 day ago\" for a date exactly one day before', () => {\n        const dateString = '2024-08-24T12:00:00';\n        const result = formatDate(dateString);\n        expect(['1 day ago', '24 hours ago']).toContain(result)\n    });\n\n    test('should return \"5 hours ago\" for a date 5 hours before the current time', () => {\n        const dateString = '2024-08-25T07:00:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('5 hours ago');\n    });\n\n    test('should return \"2 minutes ago\" for a date 2 minutes before the current time', () => {\n        const dateString = '2024-08-25T11:58:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('2 minutes ago');\n    });\n\n    test('should return \"just now\" for a date within the last second', () => {\n        const dateString = '2024-08-25T11:59:59';\n        const result = formatDate(dateString);\n        expect(['1 second ago', '1 seconds ago']).toContain(result)\n    });\n\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example,now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString: string): string {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 169,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "whiskerweb\\9a52b42647ff91ba28f974d5cdc29f6172fe1c81\\src\\engine\\HelperFunctions\\convertToRoman.ts",
    "question_type": "Algorithm and data structure",
    "summary": "Convert an Arabic numeral to a Roman numeral",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num: number): string {}",
        "test_code": "describe('convertToRoman', () => {\n\n    test('should return the correct Roman numeral for a typical number', () => {\n        const result = convertToRoman(1987);\n        expect(result).toBe('MCMLXXXVII'); // 1987 = M + CM + LXXX + VII\n    });\n\n    test('should return the correct Roman numeral for the minimum value (1)', () => {\n        const result = convertToRoman(1);\n        expect(result).toBe('I'); // 1 = I\n    });\n\n    test('should return the correct Roman numeral for a large number (3999)', () => {\n        const result = convertToRoman(3999);\n        expect(result).toBe('MMMCMXCIX'); // 3999 = MMM + CM + XC + IX\n    });\n\n    test('should return the correct Roman numeral for a number with different numeral repeats', () => {\n        const result = convertToRoman(1666);\n        expect(result).toBe('MDCLXVI'); // 1666 = M + D + CLX + VI\n    });\n\n    test('should return the correct Roman numeral for number with no 5s and 1s', () => {\n        const result = convertToRoman(2000);\n        expect(result).toBe('MM'); // 2000 = MM\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num: number): string {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 331,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "Organick_Food_Store\\2093856b6b11a157d85a9ce2680d48586192af5b\\lib\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Calculates  the final price after applying a discount to the original price.Both price and discount are expected as strings and should represent valid numbers.The discount should be a percentage value between 0 and 100.\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}",
        "test_code": "describe('calculateFinalPrice', () => {\n    test('should calculate the final price correctly with valid inputs', () => {\n        const result = calculateFinalPrice('200', '10');\n        expect(result).toBe(180);\n    });\n\n    test('should return the original price when the discount is 0%', () => {\n        const result = calculateFinalPrice('150', '0');\n        expect(result).toBe(150);\n    });\n\n    test('should return zero when the discount is 100%', () => {\n        const result = calculateFinalPrice('100', '100');\n        expect(result).toBe(0);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 334,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "us-holidays\\63a5374d589b1f20d79f2e30dc04ab23a13e23d2\\src\\year.ts",
    "question_type": "Data processing and transformation",
    "summary": "Calculate the date of Good Friday in a given year",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}",
        "test_code": "describe('calculateGoodFriday', () => {\n    it('should correctly calculate Good Friday for 2024', () => {\n        const result = calculateGoodFriday(2024);\n        expect(result.toDateString()).toBe('Fri Mar 29 2024');\n    });\n\n    it('should correctly calculate Good Friday for 2021', () => {\n        const result = calculateGoodFriday(2021);\n        expect(result.toDateString()).toBe('Fri Apr 02 2021');\n    });\n\n    it('should correctly calculate Good Friday for 2000', () => {\n        const result = calculateGoodFriday(2000);\n        expect(result.toDateString()).toBe('Fri Apr 21 2000');\n    });\n\n    it('should correctly calculate Good Friday for 2019', () => {\n        const result = calculateGoodFriday(2019);\n        expect(result.toDateString()).toBe('Fri Apr 19 2019');\n    });\n\n    it('should correctly calculate Good Friday for 1999', () => {\n        const result = calculateGoodFriday(1999);\n        expect(result.toDateString()).toBe('Fri Apr 02 1999');\n    });\n\n    it('should correctly calculate Good Friday for 1981', () => {\n        const result = calculateGoodFriday(1981);\n        expect(result.toDateString()).toBe('Fri Apr 17 1981');\n    });\n\n    it('should correctly calculate Good Friday for 1954', () => {\n        const result = calculateGoodFriday(1954);\n        expect(result.toDateString()).toBe('Fri Apr 16 1954');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 341,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "heavenfire\\68785b702cec5a3d92ad55339e3036d0315399cb\\javascript\\control_panel\\src\\utils.ts",
    "question_type": "Data processing and transformation",
    "summary": "Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str: string): number {\n}",
        "test_code": "describe('convertTimeHmsStringToMs', () => {\n    test('converts typical time string correctly (1h30m15s)', () => {\n        const result = convertTimeHmsStringToMs('1h30m15s');\n        expect(result).toBe(5415000);  // 1 hour + 30 minutes + 15 seconds in ms\n    });\n\n    test('correctly converts string with zero values (0h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('0h0m0s');\n        expect(result).toBe(0);  // 0 ms\n    });\n\n    test('converts maximum single digit values (9h59m59s)', () => {\n        const result = convertTimeHmsStringToMs('9h59m59s');\n        expect(result).toBe(35999000); // 9 hours + 59 minutes + 59 seconds in ms\n    });\n\n    test('handles large values (100h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('100h0m0s');\n        expect(result).toBe(360000000); // 100 hours in ms\n    });\n\n\n    test('correctly converts strings with leading zeros (01h01m01s)', () => {\n        const result = convertTimeHmsStringToMs('01h01m01s');\n        expect(result).toBe(3661000); // 1 hour + 1 minute + 1 second in ms\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str: string): number {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 342,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "portfolio\\88d051ebeb004653bfa6528297815bb2c764f9c1\\lib\\mdx\\title-parser.ts",
    "question_type": "Data processing and transformation",
    "summary": "Parses the Markdown string title, extracts the first-level title, second-level title, third-level title, and returns it in the form of a dictionary array",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown: string): { level1: string[]; level2: string[]; level3: string[] } {\n\n}\n",
        "test_code": "describe('parseMarkdownTitles', () => {\n    test('should extract first, second, and third level titles', () => {\n        const markdown = `\n        # Title 1\n        Content here.\n\n        ## Subtitle 1.1\n        More content.\n\n        ### Subsubtitle 1.1.1\n        Even more content.\n\n        # Title 2\n        Another content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n    test('should handle missing headers', () => {\n        const markdown = `\n        This is just some text without headers.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle only first-level headers', () => {\n        const markdown = `\n        # Only Title 1\n        Content without subtitles.\n        \n        # Only Title 2\n        More content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Only Title 1\", \"Only Title 2\"],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle mixed headers with empty lines', () => {\n        const markdown = `\n        # Title 1\n\n        ## Subtitle 1.1\n\n        Some content here.\n\n        ### Subsubtitle 1.1.1\n        \n        # Title 2\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n\n    test('should handle headers with special characters', () => {\n        const markdown = `\n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1 - Special Characters!\"],\n            level2: [\"Subtitle 1.1: The Beginning\"],\n            level3: [\"Subsubtitle 1.1.1 (Note)\"],\n        });\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown: string): { level1: string[]; level2: string[]; level3: string[] } {\n\n}\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 343,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "dotfiles\\7a8566b217a8d421fad073de95af292c7b4e9c07\\core\\utility\\deepEqual.ts",
    "question_type": "Algorithm and data structure",
    "summary": "Compare two objects for equal depth",
    "language_version_list": {
      "python": {
        "code_signature": "type AnyObject = { [key: string]: any };\n\n/**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1: AnyObject, obj2: AnyObject): boolean {\n}",
        "test_code": "describe('compareObjectsDepth function tests', () => {\n    test('should return true for equal depth and structure', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objB = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objB)).toBe(false); // Same structure\n    });\n\n    test('should return false for different structure (missing key)', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objC = { a: { b: { c: 3 } }, e: 4 };\n        expect(compareObjectsDepth(objA, objC)).toBe(false); // Different structure\n    });\n\n    test('should return false for different depth', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objD = { a: { b: 1 }, d: 2 };\n        expect(compareObjectsDepth(objA, objD)).toBe(false); // Different depth\n    });\n\n    test('should return false for non-object inputs', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objE = null;\n        expect(compareObjectsDepth(objA, objE)).toBe(false); // Non-object input\n    });\n\n    test('should return false for different types (number vs object)', () => {\n        const objA = { a: { b: 1 }, d: 2 };\n        const objF = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objF)).toBe(false); // Different types\n    });\n\n    test('should return true for identical empty objects', () => {\n        const objG = {};\n        const objH = {};\n        expect(compareObjectsDepth(objG, objH)).toBe(true); // Both are empty\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below type AnyObject = { [key: string]: any };\n\n/**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1: AnyObject, obj2: AnyObject): boolean {\n}",
        "addition_info": "type AnyObject = { [key: string]: any };"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 565,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "galaga\\9e8425f877a2a9b4f5764c934d6ae5db4e07474c\\src\\game\\waves\\paths\\PathFollower.ts\n",
    "question_type": "Algorithm and data structure",
    "summary": "Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.",
    "language_version_list": {
      "python": {
        "code_signature": "// Define the Coordinates type to represent a point in 2D space\ntype Coordinates = {\n    x: number;\n    y: number;\n};\n\n/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t: number, points: Coordinates[]): Coordinates {\n}",
        "test_code": "describe('getBezierPoint', () => {\n    // Test case 1: Test with a simple linear curve\n    test('should return the midpoint of two points', () => {\n        const points: Coordinates[] = [{ x: 0, y: 0 }, { x: 2, y: 2 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 2: Test with three points (quadratic curve)\n    test('should return the correct point on a quadratic B\u00e9zier curve', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 1, y: 2 },\n            { x: 2, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 3: Test with four points (cubic curve)\n    test('should return the correct point on a cubic B\u00e9zier curve', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 1, y: 3 },\n            { x: 3, y: 1 },\n            { x: 4, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 2, y: 1.5 });\n    });\n\n    // Test case 4: Test with single point (edge case)\n    test('should return the only point when there is a single control point', () => {\n        const points: Coordinates[] = [{ x: 5, y: 5 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n\n    // Test case 5: Test with extreme t value (0)\n    test('should return the first control point when t is 0', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(0, points);\n        expect(result).toEqual({ x: 0, y: 0 });\n    });\n\n    // Test case 6: Test with extreme t value (1)\n    test('should return the last control point when t is 1', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(1, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n\n});",
        "prompt": "please write a typescript function , the function signature as below // Define the Coordinates type to represent a point in 2D space\ntype Coordinates = {\n    x: number;\n    y: number;\n};\n\n/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t: number, points: Coordinates[]): Coordinates {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 566,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "whatsapp-clone\\8dc0cd4e5f5e2027a9e4efbce36495c365bfe185\\src\\lib\\utils.ts\n",
    "question_type": "Algorithm and data structure",
    "summary": "Checks if two timestamps correspond to the same day.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1: number, timestamp2: number): boolean {\n}",
        "test_code": "describe('isSameDay', () => {\n    test('should return false for timestamps on different days', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 2, 10, 0, 0)).getTime(); // October 2, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return true for timestamps on the same day but different times', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 12, 30, 0)).getTime(); // October 1, 2024, 12:30 PM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps on the same day in different time zones', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // UTC\n        const timestamp2 = new Date('2024-10-01T12:00:00+02:00').getTime(); // October 1, 2024, 12:00 PM UTC+2\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps at midnight on the same day', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // Same timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n\n    test('should return false for timestamps in different years', () => {\n        const timestamp1 = new Date(Date.UTC(2023, 9, 1, 10, 0, 0)).getTime(); // October 1, 2023, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return false for invalid timestamps', () => {\n        const timestamp1 = new Date('invalid').getTime(); // Invalid timestamp\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // Valid timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1: number, timestamp2: number): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 567,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "whatsapp-clone\\8dc0cd4e5f5e2027a9e4efbce36495c365bfe185\\src\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Returns a string of relative times, based on when the given message was created. If the message was created Today: Return \"Today\".\nIf the message was created Yesterday: return \"Yesterday\".\nIf the message was created within the past week but not today or yesterday: Return the corresponding day of the week.\nIf the message was created earlier than one week ago: Return the formatted date string",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate: Date): string {\n}",
        "test_code": "describe('getRelativeTime', () => {\n    beforeAll(() => {\n        // Mock the current date to ensure consistent test results\n        jest.useFakeTimers().setSystemTime(new Date('2024-10-01'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return \"Today\" for a message created today', () => {\n        const messageDate = new Date(); // Current date\n        expect(getRelativeTime(messageDate)).toBe(\"Today\");\n    });\n\n    test('should return \"Yesterday\" for a message created yesterday', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24); // Yesterday\n        expect(getRelativeTime(messageDate)).toBe(\"Yesterday\");\n    });\n\n    test('should return formatted date string for a message created 10 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 10); // 10 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/21\"); // Adjust based on the mock date\n    });\n\n    test('should return formatted date string for a message created 15 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 15); // 15 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/16\"); // Adjust based on the mock date\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate: Date): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 569,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "PandoraBCI\\45580dc8e1b1eba9e1dd4b2fc4d8856b895df4ff\\client\\src\\renderer\\src\\utils\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Compresses a string to ensure its length does not exceed the specified maximum length.\nIf the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input: string, maxLength: number = 18): string {\n}",
        "test_code": "describe('compressString', () => {\n    it('should return the original string if it is shorter than the max length', () => {\n        const input = \"Short string\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should return the original string if it is exactly equal to the max length', () => {\n        const input = \"Exactly 18 chars\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should truncate the string and append \"...\" if it exceeds the max length', () => {\n        const input = \"This is a long string that needs to be compressed.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This is a long ...\");\n    });\n\n    it('should truncate the string to maxLength - 3 and append \"...\" when maxLength is specified', () => {\n        const input = \"Another long string that is definitely too long.\";\n        const result = compressString(input, 25);\n        expect(result).toBe(\"Another long string th...\");\n    });\n\n    it('should use default max length of 18 if no maxLength is provided', () => {\n        const input = \"This string is way too long.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This string is ...\");\n    });\n\n    it('should return the original string if it is empty', () => {\n        const input = \"\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input: string, maxLength: number = 18): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 570,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "imaginify\\526564d880230c56d30baac6a9e9f7d9745f8efb\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Deeply merges two objects.\nIf properties are objects in both objects, they are recursively merged.\nIf a property exists in both objects but is not an object, the value from obj1 is used.",
    "language_version_list": {
      "python": {
        "code_signature": "type PlainObject = { [key: string]: any };\n\n/**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param obj1 - The first object to merge.\n * @param obj2 - The second object to merge.\n * @returns A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1: PlainObject, obj2: PlainObject | null | undefined): PlainObject => {\n}",
        "test_code": "describe('deepMergeObjects', () => {\n\n\n    test('handles null values in obj2', () => {\n        const obj1 = {a: 1, b: 2};\n        const obj2 = null;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('handles undefined values in obj2', () => {\n        const obj1 = {a: 1, b: 2};\n        const obj2 = undefined;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('merges deeply nested objects', () => {\n        const obj1 = {a: {b: {c: 1}}, d: 2};\n        const obj2 = {a: {b: {d: 3}}, e: 4};\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual({\n            \"a\": {\n                \"b\": {\n                    \"c\": 1\n                }\n            },\n            \"d\": 2\n        });\n    });\n\n    test('does not merge arrays but takes them from obj1', () => {\n    const obj1 = {a: [1, 2, 3]};\n    const obj2 = {a: [4, 5]};\n    const result = deepMergeObjects(obj1, obj2);\n    expect(result).toEqual({a: [1, 2, 3]}); // Should keep array from obj1\n});\n});",
        "prompt": "please write a typescript function , the function signature as below type PlainObject = { [key: string]: any };\n\n/**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param obj1 - The first object to merge.\n * @param obj2 - The second object to merge.\n * @returns A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1: PlainObject, obj2: PlainObject | null | undefined): PlainObject => {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 571,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "robotics-orin-gui\\4a94817a4b7996c1878b39b977d14f412f44c262\\src\\app\\coordinate-manager\\coordinate-manager.component.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Checks whether the string conforms to the latitude and longitude identification specification",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord: string): boolean {\n}",
        "test_code": "describe('isValidCoordinate', () => {\n    test('valid latitude with direction', () => {\n        const coord = \"45.123N\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid latitude without direction', () => {\n        const coord = \"90.0\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude with direction', () => {\n        const coord = \"180.0E\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude without direction', () => {\n        const coord = \"-120.456\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n\n    test('invalid longitude exceeding range', () => {\n        const coord = \"-200.5\";\n        expect(isValidCoordinate(coord)).toBe(false);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord: string): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 572,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "llm-functions\\df7bdff7ab44093528b213b391698f00b7d0232e\\packages\\llm-functions\\src\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Merges two arrays of objects, updating items in the first array with items\nfrom the second array based on a unique identifier. If an ID exists in both\narrays, the item from the second array will replace the one in the first.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate<O>(\n    arr1: Array<O>,\n    arr2: Array<O>,\n    getId: (item: O) => string\n): Array<O> {\n}",
        "test_code": "interface Item {\n    id: string;\n    name: string;\n}\n\ndescribe('mergeOrUpdate', () => {\n    test('merges two arrays with unique items', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ]);\n    });\n\n    test('updates existing items when IDs match', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n\n    test('handles empty arrays', () => {\n        const arr1: Item[] = [];\n        const arr2: Item[] = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([]);\n    });\n\n    test('merges with an empty first array', () => {\n        const arr1: Item[] = [];\n        const arr2: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('merges with an empty second array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the first array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '1', name: 'Duplicate Item 1' } // Duplicate ID\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Duplicate Item 1' }, // Last occurrence takes precedence\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the second array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Item 2' },\n            { id: '2', name: 'Duplicate Item 2' } // Duplicate ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Duplicate Item 2' } // Last occurrence takes precedence\n        ]);\n    });\n\n    test('merges arrays with mixed unique and duplicate IDs', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '1', name: 'New Item 1' } // Updated item with same ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'New Item 1' }, // Updated\n            { id: '2', name: 'Updated Item 2' }, // Updated\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate<O>(\n    arr1: Array<O>,\n    arr2: Array<O>,\n    getId: (item: O) => string\n): Array<O> {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 575,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "zooma-web-app\\d356bce6089cd221aae683e40251c24166cbc5ff\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Formats the thread count into a user-friendly string.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {\n}",
        "test_code": "describe('formatThreadCount', () => {\n    test('should return \"01 Thread\" for a count of 1', () => {\n        expect(formatThreadCount(1)).toBe(\"01 Thread\");\n    });\n\n    test('should return \"05 Threads\" for a count of 5', () => {\n        expect(formatThreadCount(5)).toBe(\"05 Threads\");\n    });\n\n    test('should return \"10 Threads\" for a count of 10', () => {\n        expect(formatThreadCount(10)).toBe(\"10 Threads\");\n    });\n\n    test('should return \"99 Threads\" for a count of 99', () => {\n        expect(formatThreadCount(99)).toBe(\"99 Threads\");\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 576,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "TOFI\\5cb1997367d0a61c7f01764b81452a14a29b988e\\banking-app\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Hides the sensitive part of a bank account number with 17 characters only show the last 4 characters.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 number only show the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not longer than 17 characters.\n */\nfunction hideBankAccount(account: string): string {\n}",
        "test_code": "describe('hideBankAccount', () => {\n    test('should return \"****4567\" for an account number of \"12345678901234567\"', () => {\n        expect(hideBankAccount('12345678901234567')).toBe('****4567');\n    });\n\n    test('should return \"****6543\" for an account number of \"98765432109876543\"', () => {\n        expect(hideBankAccount('98765432109876543')).toBe('****6543');\n    });\n\n    test('should return \"****1100\" for an account number of \"11111111111111100\"', () => {\n        expect(hideBankAccount('11111111111111100')).toBe('****1100');\n    });\n\n    test('should throw an error for an account number shorter than 17 characters', () => {\n        expect(() => hideBankAccount('1234567890123456')).toThrow();\n    });\n\n    test('should throw an error for an account number longer than 17 characters', () => {\n        expect(() => hideBankAccount('123456789012345678')).toThrow();\n    });\n\n    test('should throw an error for an account number with 0 characters', () => {\n        expect(() => hideBankAccount('')).toThrow();\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 number only show the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not longer than 17 characters.\n */\nfunction hideBankAccount(account: string): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 577,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "TellUs-A-Social-Media-App\\2b53050016fc355d319d74fef9223965707a820f\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Formats the post count into a human-readable string.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count: number): string {\n}",
        "test_code": "describe('formatPostCount', () => {\n    test('should return \"01 Post\" for count of 1', () => {\n        expect(formatPostCount(1)).toBe('01 Post');\n    });\n\n    test('should return \"02 Posts\" for count of 2', () => {\n        expect(formatPostCount(2)).toBe('02 Posts');\n    });\n\n    test('should return \"10 Posts\" for count of 10', () => {\n        expect(formatPostCount(10)).toBe('10 Posts');\n    });\n\n    test('should return \"99 Posts\" for count of 99', () => {\n        expect(formatPostCount(99)).toBe('99 Posts');\n    });\n\n    test('should return \"05 Posts\" for count of 5', () => {\n        expect(formatPostCount(5)).toBe('05 Posts');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count: number): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 578,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Detects whether the string is KEBAB_CASE",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input: string): boolean {\n}",
        "test_code": "describe('isKebabCase', () => {\n    test('should return true for a valid kebab-case string', () => {\n        expect(isKebabCase('kebab-case')).toBe(true);\n    });\n\n    test('should return true for a valid kebab-case string with multiple words', () => {\n        expect(isKebabCase('this-is-a-valid-kebab-case')).toBe(true);\n    });\n\n    test('should return false for a string with uppercase letters', () => {\n        expect(isKebabCase('Kebab-Case')).toBe(false);\n    });\n\n    test('should return false for a string with consecutive hyphens', () => {\n        expect(isKebabCase('kebab--case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isKebabCase('')).toBe(false);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input: string): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 581,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "HASH\\596ee9a6b87e3c1f2c8fb53bef44e3ffbf93e238\\client\\app\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Abbreviates a number to a string with a suffix based on its magnitude.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude.suffix [\"\", \"k\", \"M\", \"B\", \"T\"] 1000 is k,1000000 is M,1000000000 is B\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number: number): string {\n}",
        "test_code": "describe('abbreviateNumber', () => {\n    test('should return the same number for values less than 1000', () => {\n        expect(abbreviateNumber(999)).toBe('999');\n    });\n\n    test('should return \"1k\" for 1000', () => {\n        const result= abbreviateNumber(1000)\n        expect(['1k', '1.0k']).toContain(result);\n    });\n\n    test('should return \"1.5k\" for 1500', () => {\n        expect(abbreviateNumber(1500)).toBe('1.5k');\n    });\n\n    test('should return \"1M\" for 1 million', () => {\n        const result = abbreviateNumber(1000000);\n        expect(['1M', '1.0M']).toContain(result);\n    });\n\n    test('should return \"25M\" for 25 million', () => {\n        expect(abbreviateNumber(25000000)).toBe('25M');\n    });\n\n    test('should return \"1B\" for 1 billion', () => {\n        const result = abbreviateNumber(1000000000)\n        expect(['1B', '1.0B']).toContain(result);\n    });\n\n    test('should return \"1.2T\" for 1.2 trillion', () => {\n        expect(abbreviateNumber(1234567890123)).toBe('1.2T');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude.suffix [\"\", \"k\", \"M\", \"B\", \"T\"] 1000 is k,1000000 is M,1000000000 is B\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number: number): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 582,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "mern-events-app\\3a9933e0d2a81c578954b7c804063b7d739c12ad\\src\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Converts the parameter dictionary to the query parameter in the url",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Record<string, any>} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params: Record<string, any>): string {\n}",
        "test_code": "describe('toQueryString', () => {\n\n    test('should convert a simple object to a query string', () => {\n        const params = {search: 'test', page: 1, size: 10};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=test&page=1&size=10');\n    });\n\n\n    test('should encode special characters in the query string', () => {\n        const params = {search: 'hello world', filter: 'price < \\$50'};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=hello%20world&filter=price%20%3C%20%2450');\n    });\n\n    test('should handle empty string values', () => {\n        const params = {search: '', page: 1};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=&page=1');\n    });\n\n    test('should handle boolean values', () => {\n        const params = {isActive: true, isVerified: false};\n        const result = toQueryString(params);\n        expect(result).toBe('?isActive=true&isVerified=false');\n    });\n});\n",
        "prompt": "please write a typescript function , the function signature as below /**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Record<string, any>} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params: Record<string, any>): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 583,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "mern-events-app\\3a9933e0d2a81c578954b7c804063b7d739c12ad\\src\\lib\\utils.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Removes the parameters in the url query based on the given key",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url: string, key: string): string {\n}",
        "test_code": "describe('removeQueryParam', () => {\n    test('should remove an existing parameter from the URL', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should not modify the URL if the parameter does not exist', () => {\n        const url = 'https://example.com?page=1&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should return the original URL if there are no query parameters', () => {\n        const url = 'https://example.com';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n\n    test('should remove multiple occurrences of a parameter', () => {\n        const url = 'https://example.com?page=1&filter=red&filter=blue';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1');\n    });\n\n    test('should handle encoded characters in the parameter', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=hello%20world';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1&sort=asc');\n    });\n\n    test('should handle the case when the parameter is the only one in the URL', () => {\n        const url = 'https://example.com?sort=asc';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url: string, key: string): string {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 584,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Detects whether the string is KEBAB_CASE",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input: string): boolean {\n}",
        "test_code": "describe('isPascalCase', () => {\n    test('should return true for a valid PascalCase string', () => {\n        expect(isPascalCase('PascalCase')).toBe(true);\n    });\n\n    test('should return true for a valid PascalCase string with multiple words', () => {\n        expect(isPascalCase('PascalCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with a lowercase letter', () => {\n        expect(isPascalCase('pascalCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isPascalCase('Pascal_case')).toBe(false);\n    });\n\n    test('should return false for a string that is empty', () => {\n        expect(isPascalCase('')).toBe(false);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input: string): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 585,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n",
    "question_type": "Data processing and transformation",
    "summary": " Detects whether the string is in CAMEL_CASE.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input: string): boolean {\n}",
        "test_code": "describe('isCamelCase', () => {\n    test('should return true for a valid camelCase string', () => {\n        expect(isCamelCase('camelCase')).toBe(true);\n    });\n\n    test('should return true for a valid camelCase string with multiple words', () => {\n        expect(isCamelCase('camelCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isCamelCase('CamelCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isCamelCase('camel_case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isCamelCase('')).toBe(false);\n    });\n\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input: string): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 586,
    "code_type": "method",
    "original_language": "typescript",
    "file_path": "js-analyzer\\a9fd8d479f54079cb5ea24cf15d163a33e9bca5e\\src\\common\\constants\\index.ts\n",
    "question_type": "Data processing and transformation",
    "summary": "Detects whether the string is in SNAKE_CASE.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input: string): boolean {\n}",
        "test_code": "describe('isSnakeCase', () => {\n    test('should return true for a valid snake_case string', () => {\n        expect(isSnakeCase('snake_case')).toBe(true);\n    });\n\n    test('should return true for a valid snake_case string with multiple words', () => {\n        expect(isSnakeCase('snake_case_example')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isSnakeCase('Snake_Case')).toBe(false);\n    });\n\n    test('should return false for a string with mixed case letters', () => {\n        expect(isSnakeCase('snakeCASE')).toBe(false);\n    });\n\n    test('should return false for a string with numbers', () => {\n        expect(isSnakeCase('snake_case_123')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isSnakeCase('')).toBe(false);\n    });\n});",
        "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input: string): boolean {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 170,
    "code_type": "method",
    "original_language": "java",
    "file_path": "composum-AI\\2256cb29fb0dac57a3252a6e319f3869eae9bc87\\backend\\base\\src\\main\\java\\com\\composum\\ai\\backend\\base\\service\\chat\\impl\\HtmlToMarkdownConverter.java",
    "question_type": "Data processing and transformation",
    "summary": "convert the HTML string to the corresponding MarkDown formatted text. HTML tags that support conversion include a, strong, code, em, p, br, u, ul, li, ol\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\npublic static String convert(String html) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.real.temp.*;\n\npublic class Tester {\n\n    @Test\n    public void testSimpleLineBreak() {\n        String input = \"Hello<br>World\";\n        String expectedOutput = \"Hello\\nWorld\";\n        assertEquals(expectedOutput, Answer.convert(input));\n    }\n\n\n    @Test\n    public void testStrongTags() {\n        String input = \"This is <strong>important</strong> text.\";\n        String expectedOutput = \"This is **important** text.\";\n        assertEquals(expectedOutput, Answer.convert(input));\n    }\n\n    @Test\n    public void testEmphasisTags() {\n        String input = \"This is <em>emphasized</em> text.\";\n        String expectedOutput = \"This is *emphasized* text.\";\n        assertEquals(expectedOutput, Answer.convert(input));\n    }\n\n    @Test\n    public void testUnorderedList() {\n        String input = \"<ul><li>Item 1</li><li>Item 2</li></ul>\";\n        String expectedOutput = \"* Item 1\\n* Item 2\";\n        assertEquals(expectedOutput, Answer.convert(input));\n    }\n\n    @Test\n    public void testAnchorTags() {\n        String input = \"Check this link: <a href=\\\"http://example.com\\\">Example</a>.\";\n        String expectedOutput = \"Check this link: [Example](http://example.com).\";\n        assertEquals(expectedOutput, Answer.convert(input));\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Converts a string containing HTML to a Markdown-formatted string.\n *\n * 1. Line breaks (<br> or <br/>): Replaced with newline characters.\n * 2. Paragraphs (<p> and </p>): Opening <p> tags are removed, while closing\n *    </p> tags are replaced with two newline characters to separate paragraphs.\n * 3. Strong emphasis (<strong> and </strong>): Replaced with double asterisks (**).\n * 4. Italics (<em> and </em>): Replaced with single asterisks (*).\n * 5. Underlined text (<u> and </u>): Replaced with single asterisks (*)\n *    as underlining is not supported in Markdown.\n * 6. Code snippets (<code> and </code>): Replaced with backticks (`).\n * 7. Unordered lists (<ul> and </ul>): Opening and closing tags are removed.\n * 8. Ordered lists (<ol> and </ol>): Opening and closing tags are removed.\n * 9. List items (<li>): Opening <li> tags are replaced with an asterisk followed\n *    by a space, while closing </li> tags are replaced with a newline character.\n * 10. Hyperlinks (<a href=\"...\">...</a>): Replaced with the Markdown format\n *     [text](URL), where \"text\" is the anchor text and \"URL\" is the link target.\n *\n * @param html The input string containing HTML content.\n * @return A string formatted in Markdown, reflecting the input HTML structure.\n */\npublic static String convert(String html) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 173,
    "code_type": "method",
    "original_language": "java",
    "file_path": "Figura\\46108431382ac91ed18971693adcfaff18c388bd\\common\\src\\main\\java\\org\\figuramc\\figura\\utils\\MathUtils.java",
    "question_type": "Algorithm and data structure",
    "summary": "Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\n\nimport org.real.temp.*;\npublic class Tester {\n\n    @Test\n    public void testCubicBezier_t0() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.0;\n        double[] expected = {0.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t1() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 1.0;\n        double[] expected = {1.0, 0.0};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t0_5() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {0.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_midPoint() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {1.0, 1.0};\n        double[] p2 = {2.0, 1.0};\n        double[] p3 = {3.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {1.5, 0.75};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_arbitraryT() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 2.0};\n        double[] p2 = {2.0, 2.0};\n        double[] p3 = {2.0, 0.0};\n        double t = 0.75;\n        double[] expected = {1.6875, 1.125};\n        assertArrayEquals(expected, Answer.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n,package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 174,
    "code_type": "method",
    "original_language": "java",
    "file_path": "Figura\\46108431382ac91ed18971693adcfaff18c388bd\\common\\src\\main\\java\\org\\figuramc\\figura\\utils\\MathUtils.java",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a function using the secant method that takes a B\u00e9zier curve and a target x-value as inputs and returns the parameter t where the B\u00e9zier curve reaches the specified x-value.",
    "language_version_list": {
      "python": {
        "code_signature": " /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses a numerical method (Newton's method) to iteratively\n * approach the value of `t` where the B\u00e9zier curve intersects with the\n * vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\npublic static double findTForX(double targetX, double p0, double p1, double p2) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.real.temp.*;\n\n\npublic class Tester {\n    // Tolerance level for floating-point comparisons\n    private static final double TOLERANCE = 1e-6;\n\n    @Test\n    public void testFindTForX_AtStart() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 0.0;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.0, t, TOLERANCE);\n    }\n\n    @Test\n    public void testFindTForX_AtEnd() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 1.0;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(1.0, t, TOLERANCE);\n    }\n\n    @Test\n    public void testFindTForX_MidCurve() {\n        double p0 = 0.0;\n        double p1 = 0.5;\n        double p2 = 1.0;\n        double targetX = 0.25;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.25, t, TOLERANCE);\n    }\n\n\n    @Test\n    public void testFindTForX_NearMidCurve() {\n        double p0 = 0.0;\n        double p1 = 1.0;\n        double p2 = 2.0;\n        double targetX = 1.5;\n\n        double t = Answer.findTForX(targetX, p0, p1, p2);\n        assertEquals(0.75, t, TOLERANCE);\n    }\n\n}\n",
        "prompt": "please write a java function , the function signature as below  /**\n * Finds the parameter `t` corresponding to a given x-coordinate `targetX`\n * on a quadratic B\u00e9zier curve defined by control points p0, p1, and p2.\n * The function uses a numerical method (Newton's method) to iteratively\n * approach the value of `t` where the B\u00e9zier curve intersects with the\n * vertical line at `targetX`.\n *\n * @param targetX The x-coordinate for which we want to find the corresponding\n *                parameter `t` on the B\u00e9zier curve.\n * @param p0 The first control point of the B\u00e9zier curve, representing the\n *            starting point.\n * @param p1 The second control point of the B\u00e9zier curve, affecting the curve's\n *            shape.\n * @param p2 The third control point of the B\u00e9zier curve, representing the\n *            ending point.\n * @return The parameter `t` (in the range [0, 1]) for which the B\u00e9zier curve\n *         evaluated at `t` is closest to `targetX`. If no precise value is\n *         found within the specified tolerance and iterations, the function\n *         returns the best approximation.\n */\npublic static double findTForX(double targetX, double p0, double p1, double p2) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 175,
    "code_type": "method",
    "original_language": "java",
    "file_path": "netbeansPython\\21fefd66851624a3dd19abdb69f575526ab5c7e3\\src\\main\\java\\org\\netbeans\\modules\\python\\actions\\PythonFixIndentAction.java",
    "question_type": "Data processing and transformation",
    "summary": "Task Requirements: Develop a Python code indentation correction tool. This tool should process the input Python code line by line, adjusting the leading spaces or tabs according to indentation rules to ensure correct indentation levels. The specific rules include: automatically increasing the indentation level for subsequent lines when encountering a colon at the end of a line (such as in function definitions, conditional statements, loops, etc.), and decreasing the indentation level when the code structure requires it. The tool should return the corrected code as a string, ensuring that the code logic remains consistent.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Fixes the indentation of a block of code represented as a string.\n * The function processes the input code line by line, adjusting the\n * indentation level based on specific keywords and constructs.\n *\n * @param code A string containing the code whose indentation needs to be fixed.\n * @return A string with the corrected indentation for the given code.\n */\npublic static String fixIndentation(String code) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.real.temp.*;\n\npublic class Tester {\n    @Test\n    public void testBasicIndentation() {\n        String code =\n                \"def example_function():\\n\" +\n                        \"print(\\\"Hello, world!\\\")\\n\" +\n                        \"if True:\\n\" +\n                        \"print(\\\"True branch\\\")\\n\" +\n                        \"else:\\n\" +\n                        \"print(\\\"False branch\\\")\\n\" +\n                        \"return\\n\";\n\n        String expected =\n                \"def example_function():\\n\" +\n                        \"    print(\\\"Hello, world!\\\")\\n\" +\n                        \"    if True:\\n\" +\n                        \"        print(\\\"True branch\\\")\\n\" +\n                        \"    else:\\n\" +\n                        \"        print(\\\"False branch\\\")\\n\" +\n                        \"    return\\n\";\n\n        String actual = Answer.fixIndentation(code);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testEmptyLines() {\n        String code =\n                \"def example_function():\\n\" +\n                        \"\\n\" +\n                        \"print(\\\"Hello, world!\\\")\\n\" +\n                        \"\\n\" +\n                        \"if True:\\n\" +\n                        \"print(\\\"True branch\\\")\\n\" +\n                        \"return\\n\";\n\n        String expected =\n                \"def example_function():\\n\" +\n                        \"\\n\" +\n                        \"    print(\\\"Hello, world!\\\")\\n\" +\n                        \"\\n\" +\n                        \"    if True:\\n\" +\n                        \"        print(\\\"True branch\\\")\\n\" +\n                        \"    return\\n\";\n\n        String actual = Answer.fixIndentation(code);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testMultipleStatements() {\n        String code =\n                \"def example_function():\\n\" +\n                        \"print(\\\"Hello, world!\\\")\\n\" +\n                        \"if True:\\n\" +\n                        \"print(\\\"True branch\\\")\\n\" +\n                        \"print(\\\"Still in True branch\\\")\\n\" +\n                        \"return\\n\";\n\n        String expected =\n                \"def example_function():\\n\" +\n                        \"    print(\\\"Hello, world!\\\")\\n\" +\n                        \"    if True:\\n\" +\n                        \"        print(\\\"True branch\\\")\\n\" +\n                        \"        print(\\\"Still in True branch\\\")\\n\" +\n                        \"    return\\n\";\n\n        String actual = Answer.fixIndentation(code);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testNestedBlocks() {\n        String code =\n                \"def example_function():\\n\" +\n                        \"if True:\\n\" +\n                        \"if False:\\n\" +\n                        \"print(\\\"False branch\\\")\\n\" +\n                        \"else:\\n\" +\n                        \"print(\\\"Else branch\\\")\\n\" +\n                        \"return\\n\";\n\n        String expected =\n                \"def example_function():\\n\" +\n                        \"    if True:\\n\" +\n                        \"        if False:\\n\" +\n                        \"            print(\\\"False branch\\\")\\n\" +\n                        \"        else:\\n\" +\n                        \"            print(\\\"Else branch\\\")\\n\" +\n                        \"        return\\n\";\n\n        String actual = Answer.fixIndentation(code);\n        assertEquals(expected, actual);\n    }\n\n    @Test\n    public void testNoIndentationNeeded() {\n        String code =\n                \"def example_function():\\n\" +\n                        \"    print(\\\"Already correct\\\")\\n\" +\n                        \"    if True:\\n\" +\n                        \"        print(\\\"No change needed\\\")\\n\";\n\n        String expected = code; // Already correctly indented\n\n        String actual = Answer.fixIndentation(code);\n        assertEquals(expected, actual);\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Fixes the indentation of a block of code represented as a string.\n * The function processes the input code line by line, adjusting the\n * indentation level based on specific keywords and constructs.\n *\n * @param code A string containing the code whose indentation needs to be fixed.\n * @return A string with the corrected indentation for the given code.\n */\npublic static String fixIndentation(String code) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 176,
    "code_type": "method",
    "original_language": "java",
    "file_path": "home-work\\a8e0d049688c59fe67ae27dcd9d4f3f656888c91\\src\\KNearestNeighbors.java",
    "question_type": "Algorithm and data structure",
    "summary": "Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\nclass Point {\n    double x, y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distanceTo(Point other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n}\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n\nimport org.real.temp.*;\n\npublic class Tester {\n    @Test\n    public void testFindKNearestNeighbors_SimpleCase() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(3, 4),\n                new Answer.Point(1, -1),\n                new Answer.Point(5, 2)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 2;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Answer.Point(1, 2)));\n        assertTrue(containsPoint(result, new Answer.Point(3, 4)));\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_ExactMatch() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(2, 2),\n                new Answer.Point(3, 3)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 1;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(1, result.length);\n        assertEquals(2.0, result[0].x, 0.001);\n        assertEquals(2.0, result[0].y, 0.001);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_LargerK() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(1, 2),\n                new Answer.Point(3, 4),\n                new Answer.Point(1, -1),\n                new Answer.Point(5, 2)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 5;  // k is larger than the number of points\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(4, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_EmptyPoints() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {};\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 3;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(0, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_AllPointsEquidistant() {\n        Answer knn = new Answer();\n        Answer.Point[] points = {\n                new Answer.Point(2, 3),\n                new Answer.Point(3, 2),\n                new Answer.Point(1, 2),\n                new Answer.Point(2, 1)\n        };\n        Answer.Point queryPoint = new Answer.Point(2, 2);\n        int k = 2;\n\n        Answer.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Answer.Point(2, 3)));\n        assertTrue(containsPoint(result, new Answer.Point(3, 2)));\n    }\n\n    private boolean containsPoint(Answer.Point[] points, Answer.Point point) {\n        for (Answer.Point p : points) {\n            if (Math.abs(p.x - point.x) < 0.001 && Math.abs(p.y - point.y) < 0.001) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\nclass Point {\n    double x, y;\n\n    public Point(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public double distanceTo(Point other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n}\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 177,
    "code_type": "method",
    "original_language": "java",
    "file_path": "HBV501G\\821afc5fc1b0082388f558deb2cbfcaf4af6a000\\Backend\\src\\main\\java\\hbv501g\\Utils\\PasswordUtils.java",
    "question_type": "Security",
    "summary": "Generates a 16-byte random salt value and hashes the password with that salt value and the SHA-256 hash algorithm",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport org.real.temp.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n\npublic class Tester {\n\n    /**\n     * Test that the hashPasswordWithSalt method returns a byte array with the correct length.\n     * The length should be 48 bytes (16 bytes of salt + 32 bytes of SHA-256 hash).\n     */\n    @Test\n    public void testHashPasswordWithSaltLength() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Answer.hashPasswordWithSalt(password);\n\n        // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        assertEquals(48, result.length, \"The combined salt and hashed password length should be 48 bytes.\");\n    }\n\n    /**\n     * Test that the salt is correctly generated and included in the hash result.\n     * The first 16 bytes of the result should represent the salt.\n     */\n    @Test\n    public void testSaltIsIncludedInResult() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Answer.hashPasswordWithSalt(password);\n\n        byte[] salt = Arrays.copyOfRange(result, 0, 16);\n\n        assertNotNull(salt, \"Salt should not be null.\");\n        assertEquals(16, salt.length, \"Salt length should be 16 bytes.\");\n    }\n\n    /**\n     * Test that two different passwords produce different hashes, even with the same salt.\n     */\n    @Test\n    public void testDifferentPasswordsProduceDifferentHashes() throws NoSuchAlgorithmException {\n        String password1 = \"password123\";\n        String password2 = \"password456\";\n\n        byte[] hash1 = Answer.hashPasswordWithSalt(password1);\n        byte[] hash2 = Answer.hashPasswordWithSalt(password2);\n\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"Different passwords should produce different hashes.\");\n    }\n\n    /**\n     * Test that the same password produces different hashes when hashed with different salts.\n     */\n    @Test\n    public void testSamePasswordDifferentSalts() throws NoSuchAlgorithmException {\n        String password = \"password123\";\n\n        byte[] hash1 = Answer.hashPasswordWithSalt(password);\n        byte[] hash2 = Answer.hashPasswordWithSalt(password);\n\n        // The salt is generated randomly, so the hashes should be different.\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"The same password should produce different hashes with different salts.\");\n    }\n\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 178,
    "code_type": "method",
    "original_language": "java",
    "file_path": "MatchScope\\b5dcea6053f21d5ece686f03f5006e224e6aa1d1\\src\\main\\java\\com\\matchscope\\Utils.java",
    "question_type": "Algorithm and data structure",
    "summary": "Find the longest non-decreasing subsequence in the given list.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.real.temp.*;public class Tester {\n    @Test\n    public void testNonDecreasingSequence() {\n        int[] nums = {5, 7, 4, 8, 6, 10, 2, 11};\n        List<Integer> expected = Arrays.asList(5, 7, 8, 10, 11);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllIncreasing() {\n        int[] nums = {1, 2, 3, 4, 5};\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllDecreasing() {\n        int[] nums = {5, 4, 3, 2, 1};\n        List<Integer> expected = Arrays.asList(5);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testSingleElement() {\n        int[] nums = {10};\n        List<Integer> expected = Arrays.asList(10);\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testEmptyArray() {\n        int[] nums = {};\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Answer.findLongestNonDecreasingSubsequence(nums));\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 179,
    "code_type": "method",
    "original_language": "java",
    "file_path": "Learning-Tomorrow\\0c232e5e92928c528dc4e4ef09a3e024b69d3cc0\\LearningTomorrow\\LearningTomorrowEditor\\LTEditor.java",
    "question_type": "File operations and I/O operation",
    "summary": "Copies all files and subdirectories in a directory to the specified directory",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.real.temp.*;\npublic class Tester {\n    private File sourceDir;\n    private File targetDir;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        sourceDir = new File(\"testSourceDir\");\n        targetDir = new File(\"testTargetDir\");\n\n        if (!sourceDir.exists()) {\n            sourceDir.mkdir();\n        }\n\n        if (!targetDir.exists()) {\n            targetDir.mkdir();\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        deleteDirectory(sourceDir);\n        deleteDirectory(targetDir);\n    }\n\n    /**\n     * Test copying an empty directory.\n     */\n    @Test\n    public void testCopyEmptyDirectory() throws IOException {\n        Answer.copyDirectory(sourceDir, targetDir);\n        assertTrue(targetDir.exists(), \"Target directory should exist after copying.\");\n        assertTrue(targetDir.isDirectory(), \"Target directory should be a directory.\");\n        assertEquals(0, targetDir.listFiles().length, \"Target directory should be empty.\");\n    }\n\n    /**\n     * Test copying a directory with files.\n     */\n    @Test\n    public void testCopyDirectoryWithFiles() throws IOException {\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(copiedFile.exists(), \"File should be copied to target directory.\");\n        assertEquals(testFile.length(), copiedFile.length(), \"File size should be the same after copying.\");\n    }\n\n    /**\n     * Test handling of non-existent source directory.\n     */\n    @Test\n    public void testNonExistentSourceDirectory() {\n        File nonExistentDir = new File(\"nonExistentDir\");\n        assertThrows(Exception.class, () ->\n                Answer.copyDirectory(nonExistentDir, targetDir), \"Expected exception for non-existent source directory.\");\n    }\n\n    /**\n     * Test copying a directory with subdirectories.\n     */\n    @Test\n    public void testCopyDirectoryWithSubdirectories() throws IOException {\n        File subDir = new File(sourceDir, \"subDir\");\n        subDir.mkdir();\n        File testFile = new File(subDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedSubDir = new File(targetDir, \"subDir\");\n        File copiedFile = new File(copiedSubDir, \"testFile.txt\");\n\n        assertTrue(copiedSubDir.exists(), \"Subdirectory should be copied to target directory.\");\n        assertTrue(copiedFile.exists(), \"File within subdirectory should be copied to target directory.\");\n    }\n\n    /**\n     * Test overwriting files in the target directory.\n     */\n    @Test\n    public void testOverwriteFileInTargetDirectory() throws IOException {\n        // Create a source file with some content\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.writeString(testFile.toPath(), \"Source content\");\n\n        // Create a target file with different content\n        File targetFile = new File(targetDir, \"testFile.txt\");\n        Files.writeString(targetFile.toPath(), \"Target content\");\n\n        // Copy the directory, which should overwrite the target file\n        Answer.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(copiedFile.exists(), \"File should be copied to target directory.\");\n\n        // Check that the content of the file is now the same as the source file\n        String copiedContent = Files.readString(copiedFile.toPath());\n        assertEquals(\"Source content\", copiedContent, \"File in target directory should be overwritten with source content.\");\n    }\n\n\n    /**\n     * Helper method to delete a directory and its contents.\n     *\n     * @param dir The directory to delete.\n     */\n    private void deleteDirectory(File dir) {\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    deleteDirectory(file);\n                } else {\n                    file.delete();\n                }\n            }\n        }\n        dir.delete();\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 180,
    "code_type": "method",
    "original_language": "java",
    "file_path": "Java-Granulator\\01568ae1599ea327aae81bdd2e3ee9f1cac53d8a\\src\\model\\LoudnessDensity.java",
    "question_type": "Data processing and transformation",
    "summary": "Implement binary search to find the target or the location closest to the target in the sorted array",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.real.temp.*;\npublic class Tester{\n    /**\n     * Test when the target is present in the array.\n     */\n    @Test\n    public void testTargetPresent() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 7;\n        int result = Answer.binarySearchClosest(array, target);\n        assertEquals(3, result, \"Target should be found at index 3.\");\n    }\n\n    /**\n     * Test when the target is not present and the closest element is smaller.\n     */\n    @Test\n    public void testClosestElementSmaller() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 6;\n        int result = Answer.binarySearchClosest(array, target);\n        assertEquals(2, result, \"Closest element should be 5 at index 2.\");\n    }\n\n    /**\n     * Test when the target is not present and the closest element is larger.\n     */\n    @Test\n    public void testClosestElementLarger() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 8;\n        int result = Answer.binarySearchClosest(array, target);\n        assertEquals(3, result, \"Closest element should be 7 at index 3.\");\n    }\n\n    /**\n     * Test when the target is smaller than all elements in the array.\n     */\n    @Test\n    public void testTargetSmallerThanAll() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 0;\n        int result = Answer.binarySearchClosest(array, target);\n        assertEquals(0, result, \"Closest element should be 1 at index 0.\");\n    }\n\n    /**\n     * Test when the target is larger than all elements in the array.\n     */\n    @Test\n    public void testTargetLargerThanAll() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 12;\n        int result = Answer.binarySearchClosest(array, target);\n        assertEquals(5, result, \"Closest element should be 11 at index 5.\");\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 181,
    "code_type": "method",
    "original_language": "java",
    "file_path": "QRelcome\\d457c56ed9c5c0cad368182cbff2c6006bae3d52\\app\\src\\main\\java\\com\\example\\qrelcome\\CacheUUID.java",
    "question_type": "File operations and I/O operation",
    "summary": "Read the file content specified in the file path and return it as a byte array",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nimport org.real.temp.*;\npublic class Tester {\n\n    private File testFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        testFile = new File(\"testFile.txt\");\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(\"Test content\".getBytes());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    /**\n     * Test reading a file that exists and has content.\n     */\n    @Test\n    public void testReadFileWithContent() throws IOException {\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"Test content\", new String(content), \"The file content should match the expected string.\");\n    }\n\n    /**\n     * Test reading an empty file.\n     */\n    @Test\n    public void testReadEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n\n        byte[] content = Answer.readFileToByteArray(emptyFile.getAbsolutePath());\n        assertEquals(0, content.length, \"The content of an empty file should be a byte array of length 0.\");\n\n        emptyFile.delete();\n    }\n\n    /**\n     * Test reading a file that does not exist.\n     */\n    @Test\n    public void testReadNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(Exception.class, () -> {\n            Answer.readFileToByteArray(nonExistentFilePath);\n        }, \"Reading a non-existent file should throw an IllegalArgumentException.\");\n    }\n\n    /**\n     * Test reading a file with special characters in its content.\n     */\n    @Test\n    public void testReadFileWithSpecialCharacters() throws IOException {\n        String specialContent = \"Special content: !@#$%^&*()_+\";\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(specialContent.getBytes());\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(specialContent, new String(content), \"The file content should match the special characters string.\");\n    }\n\n    /**\n     * Test reading a large file.\n     */\n    @Test\n    public void testReadLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(largeContent);\n        }\n\n        byte[] content = Answer.readFileToByteArray(testFile.getAbsolutePath());\n        assertArrayEquals(largeContent, content, \"The content of the large file should match the expected byte array.\");\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 182,
    "code_type": "method",
    "original_language": "java",
    "file_path": "FileCopy\\8f7bd14ff5438f29ba22cdb615e1e5ab8c1d7f82\\src\\FileCopy.java",
    "question_type": "Configuration and deployment",
    "summary": "Use a buffer stream to copy the contents of one file to another and measure the time it takes to complete the operation",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.real.temp.*;\n\npublic class Tester {\n    private File sourceFile;\n    private File destinationFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        sourceFile = new File(\"testSourceFile.txt\");\n        destinationFile = new File(\"testDestinationFile.txt\");\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(\"This is a test file content.\".getBytes());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (sourceFile.exists()) {\n            sourceFile.delete();\n        }\n        if (destinationFile.exists()) {\n            destinationFile.delete();\n        }\n    }\n\n    /**\n     * Test copying a file with content.\n     */\n    @Test\n    public void testCopyFileWithContent() throws IOException {\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match.\");\n        assertTrue(timeTaken >= 0, \"Time taken should be non-negative.\");\n    }\n\n    /**\n     * Test copying an empty file.\n     */\n    @Test\n    public void testCopyEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n        File destinationEmptyFile = new File(\"destinationEmptyFile.txt\");\n\n        long timeTaken = Answer.copyFileWithBufferedStream(emptyFile.getAbsolutePath(), destinationEmptyFile.getAbsolutePath());\n        assertTrue(destinationEmptyFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(0, destinationEmptyFile.length(), \"Empty file should have length 0.\");\n        assertTrue(timeTaken >= 0, \"Time taken should be non-negative.\");\n\n        emptyFile.delete();\n        destinationEmptyFile.delete();\n    }\n\n    /**\n     * Test copying a non-existent source file.\n     */\n    @Test\n    public void testCopyNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(IOException.class, () -> {\n            Answer.copyFileWithBufferedStream(nonExistentFilePath, destinationFile.getAbsolutePath());\n        }, \"Copying a non-existent file should throw an IOException.\");\n    }\n\n    /**\n     * Test copying a file to an existing destination file (overwriting).\n     */\n    @Test\n    public void testCopyFileOverwrite() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(destinationFile)) {\n            fos.write(\"Old content\".getBytes());\n        }\n\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match after overwriting.\");\n        assertTrue(timeTaken > 0, \"Time taken should be greater than 0.\");\n    }\n\n    /**\n     * Test copying a large file.\n     */\n    @Test\n    public void testCopyLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(largeContent);\n        }\n\n        long timeTaken = Answer.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match.\");\n        assertTrue(timeTaken > 0, \"Time taken should be greater than 0.\");\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 348,
    "code_type": "method",
    "original_language": "java",
    "file_path": "isu\\6a0922ef2d920cc48d0b1e37fd5138fa0de3aaec\\ComS417\\Assignment2\\PrimeNumberFinder.java",
    "question_type": "Algorithm and data structure",
    "summary": "Find all primes in a given range and calculate the sum of those primes",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n",
        "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport org.real.temp.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    @Test\n    public void testFindPrimesInRange() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11);\n        assertEquals(expected, Answer.findPrimes(1, 12), \"Check primes between 1 and 12\");\n    }\n\n    @Test\n    public void testFindPrimesSinglePrime() {\n        List<Integer> expected = Arrays.asList(29);\n        assertEquals(expected, Answer.findPrimes(29, 29), \"Check single prime number\");\n    }\n\n    @Test\n    public void testFindPrimesInBigRange() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n        assertEquals(expected, Answer.findPrimes(1, 100), \"Check primes between 1 and 100\");\n    }\n\n    @Test\n    public void testFindPrimesNoPrimes() {\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Answer.findPrimes(0, 1), \"Check range with no primes\");\n    }\n\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n,package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 349,
    "code_type": "method",
    "original_language": "java",
    "file_path": "windowkill-Phase2\\2e450fa8ef7fb7a072cf85bfe77151cdb6461702\\src\\main\\java\\controller\\Utils.java",
    "question_type": "Algorithm and data structure",
    "summary": "Generates all possible combinations of elements from a list of lists, where each combination consists of\npicking exactly one element from each list in the input list of lists. This method is useful for generating\nproduct variations, scenarios in decision-making tools, or any other context where all possible combinations\nof a set of options need to be explored.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n    @Test\n    public void testEmptyInput() {\n        Answer generator = new Answer();\n        List<List<String>> input = new ArrayList<>();\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with empty input\");\n    }\n\n    @Test\n    public void testSingleEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(new ArrayList<>());\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single empty list\");\n    }\n\n    @Test\n    public void testSingleNonEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(Arrays.asList(\"a\", \"b\", \"c\"));\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\"), Arrays.asList(\"b\"), Arrays.asList(\"c\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single non-empty list\");\n    }\n\n    @Test\n    public void testMultipleLists() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\", \"1\"), Arrays.asList(\"a\", \"2\"),\n                Arrays.asList(\"b\", \"1\"), Arrays.asList(\"b\", \"2\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with multiple lists\");\n    }\n\n    @Test\n    public void testInputContainingEmptyList() {\n        Answer generator = new Answer();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                new ArrayList<>(),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with an input that contains an empty list\");\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 350,
    "code_type": "method",
    "original_language": "java",
    "file_path": "security-network\\5aebcdc86d82596f5907812f248533c41b528ba8\\src\\main\\java\\com\\dauphine\\security\\tp4\\CMAC.java",
    "question_type": "Security",
    "summary": "Converts a byte array into its corresponding hexadecimal string representation.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {}",
        "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class Tester {\n    @Test\n    void testEmptyByteArray() {\n        byte[] input = new byte[0];\n        assertEquals(\"\", Answer.byteArrayToHexString(input), \"Empty array should return empty string\");\n    }\n\n    @Test\n    void testSingleByte() {\n        byte[] input = {0x0F}; // 15 in decimal\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"0F\") || result.equals(\"0f\"));\n    }\n\n    @Test\n    void testMultipleBytes() {\n        byte[] input = {0x01, 0x0A, (byte) 0xFF};\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"010aff\") || result.equals(\"010AFF\"));\n    }\n\n    @Test\n    void testZeroBytes() {\n        byte[] input = {0x00, 0x00, 0x00};\n        assertEquals(\"000000\", Answer.byteArrayToHexString(input), \"Zero bytes should be converted to '000000'\");\n    }\n\n    @Test\n    void testNegativeBytes() {\n        byte[] input = {(byte) 0x80, (byte) 0xFF}; // 128 and 255 in signed byte representation\n        String result = Answer.byteArrayToHexString(input);\n        assertTrue(result.equals(\"80FF\") || result.equals(\"80ff\"));\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 351,
    "code_type": "method",
    "original_language": "java",
    "file_path": "FiguraParser\\46108431382ac91ed18971693adcfaff18c388bd\\common\\src\\main\\java\\org\\figuramc\\figura\\utils\\MathUtils.java",
    "question_type": "Algorithm and data structure",
    "summary": "Calculates the value of a cubic Bezier curve at a given parameter t.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t  The parameter value between 0 and 1 that represents a position along the curve.\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @param p3 The fourth control point, typically where the curve ends.\n * @return The point on the Bezier curve corresponding to the parameter t.\n */\npublic static double bezier(double t, double p0, double p1, double p2, double p3) {}",
        "test_code": "package org.real.temp;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class Tester {\n    @Test\n    void testBezierAtStart() {\n        assertEquals(1.0, Answer.bezier(0, 1, 3, 3, 1), \"Bezier at t=0 should return the first control point p0\");\n    }\n\n    @Test\n    void testBezierAtEnd() {\n        assertEquals(1.0, Answer.bezier(1, 1, 3, 3, 1), \"Bezier at t=1 should return the last control point p3\");\n    }\n\n    @Test\n    void testBezierAtMiddle() {\n        double expected = 1.0 * 0.125 + 3 * 0.375 + 3 * 0.375 + 1 * 0.125; // Calculate manually for t=0.5\n        assertEquals(expected, Answer.bezier(0.5, 1, 3, 3, 1), 0.001, \"Bezier at t=0.5 should return the correct middle value\");\n    }\n\n\n    @Test\n    void testBezierWithIdenticalControlPoints() {\n        assertEquals(2.0, Answer.bezier(0.5, 2, 2, 2, 2), \"Bezier with all control points the same should return that value\");\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t  The parameter value between 0 and 1 that represents a position along the curve.\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @param p3 The fourth control point, typically where the curve ends.\n * @return The point on the Bezier curve corresponding to the parameter t.\n */\npublic static double bezier(double t, double p0, double p1, double p2, double p3) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 352,
    "code_type": "method",
    "original_language": "java",
    "file_path": "security-network\\5aebcdc86d82596f5907812f248533c41b528ba8\\src\\main\\java\\com\\dauphine\\security\\tp4\\CCM.java",
    "question_type": "Data processing and transformation",
    "summary": "Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n in a readable format, especially in networking, cryptography, and systems programming. ",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    @Test\n    void testNormalHexString() {\n        String hex = \"1a3f\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should correctly convert a normal hex string\");\n    }\n\n    @Test\n    void testOddLengthHexString() {\n        String hex = \"123\";\n        byte[] expected = { (byte) 0x01, (byte) 0x23 };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should handle odd-length hex strings by prepending zero\");\n    }\n\n    @Test\n    void testEmptyString() {\n        String hex = \"\";\n        byte[] expected = new byte[0];\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should return an empty array for an empty string\");\n    }\n\n    @Test\n    void testHexStringWithUppercase() {\n        String hex = \"1A3F\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Answer.hexStringToByteArray(hex), \"Should correctly handle hex strings with uppercase letters\");\n    }\n\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 608,
    "code_type": "method",
    "original_language": "java",
    "file_path": "COSC10\\720f7e2fc0a6f94a1e0392c60f8ac658dc1fbf59\\Practice Problems\\final practice problem solutoins\\ChatServerCommunicator.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Checks whether the given string is a valid email address.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Checks whether the given string is a valid email address.\n *\n * @param email the string to be checked\n * @return true if the string is a valid email address, false otherwise\n */\npublic static boolean isValidEmail(String email) {}",
        "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testValidEmail1() {\n        assertTrue(Answer.isValidEmail(\"example@test.com\"), \"Valid email should return true\");\n    }\n\n    @Test\n    public void testValidEmail2() {\n        assertTrue(Answer.isValidEmail(\"user.name+tag+sorting@example.com\"), \"Valid email should return true\");\n    }\n\n    @Test\n    public void testValidEmail3() {\n        assertTrue(Answer.isValidEmail(\"user@subdomain.example.com\"), \"Valid email with subdomain should return true\");\n    }\n\n    @Test\n    public void testInvalidEmail1() {\n        assertFalse(Answer.isValidEmail(\"invalid-email@.com\"), \"Invalid email should return false\");\n    }\n\n    @Test\n    public void testInvalidEmail2() {\n        assertFalse(Answer.isValidEmail(\"invalid@domain@domain.com\"), \"Invalid email should return false\");\n    }\n\n\n    @Test\n    public void testNullEmail() {\n        assertFalse(Answer.isValidEmail(null), \"Null email should return false\");\n    }\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Checks whether the given string is a valid email address.\n *\n * @param email the string to be checked\n * @return true if the string is a valid email address, false otherwise\n */\npublic static boolean isValidEmail(String email) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 609,
    "code_type": "method",
    "original_language": "java",
    "file_path": "LeetCode\\2c44ee9d58710b2f54edf36d8e033534805f2077\\TwoSum\\src\\Main.java\n",
    "question_type": "Algorithm and data structure",
    "summary": "Given an integer array nums and an integer target value target, find the two integers in the array whose sum is the target value target and return their array subscripts\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums   the input array of integers\n * @param target the target sum value\n * @return an array containing the indices of the two numbers\n * @throws IllegalArgumentException if no such indices are found\n */\npublic int[] twoSum(int[] nums, int target) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n\n    private final Answer answer = new Answer();\n\n    @Test\n    public void testValidPair() {\n        int[] nums = {2, 7, 11, 15};\n        int target = 9;\n        int[] expected = {0, 1}; // 2 + 7 = 9\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        int[] nums = {-1, -2, -3, -4, -5};\n        int target = -8;\n        int[] expected = {2, 4}; // -3 + -5 = -8\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testZeroSum() {\n        int[] nums = {0, 4, 3, 0};\n        int target = 0;\n        int[] expected = {0, 3}; // 0 + 0 = 0\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testNoSolution() {\n        int[] nums = {1, 2, 3, 4, 5};\n        int target = 10;\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            answer.twoSum(nums, target);\n        });\n        assertEquals(\"No two sum solution\", exception.getMessage());\n    }\n\n    @Test\n    public void testSameNumberTwice() {\n        int[] nums = {3, 3};\n        int target = 6;\n        int[] expected = {0, 1}; // 3 + 3 = 6\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n\n    @Test\n    public void testLargeNumbers() {\n        int[] nums = {Integer.MAX_VALUE, Integer.MIN_VALUE, 0, 1};\n        int target = 1;\n        int[] expected = {2, 3}; // 0 + 1 = 1\n        assertArrayEquals(expected, answer.twoSum(nums, target));\n    }\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Finds two indices of numbers in the array that sum up to the target value.\n *\n * @param nums   the input array of integers\n * @param target the target sum value\n * @return an array containing the indices of the two numbers\n * @throws IllegalArgumentException if no such indices are found\n */\npublic int[] twoSum(int[] nums, int target) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 610,
    "code_type": "method",
    "original_language": "java",
    "file_path": "jt-cmsi662\\8fef04ff1a2d5550d7dfb806db52a9b4a5c48881\\homework-2\\java\\SimpleShoppingCart.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n *\n * @return obj hashcode\n */\n@Override\npublic int hashCode() {}",
        "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport org.junit.jupiter.api.Test;\n\nclass Tester {\n\n    @Test\n    void testHashCode_SameNameAndAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 25);\n        assertEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be equal for the same name and age.\");\n    }\n\n    @Test\n    void testHashCode_DifferentName() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Bob\", 25);\n        assertNotEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be different for different names.\");\n    }\n\n    @Test\n    void testHashCode_DifferentAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 30);\n        assertNotEquals(answer1.hashCode(), answer2.hashCode(), \"Hash codes should be different for different ages.\");\n    }\n\n    @Test\n    void testEquals_SameReference() {\n        Answer answer = new Answer(\"Alice\", 25);\n        assertTrue(answer.equals(answer), \"An object should be equal to itself.\");\n    }\n\n    @Test\n    void testEquals_SameNameAndAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 25);\n        assertTrue(answer1.equals(answer2), \"Two answers with the same name and age should be equal.\");\n    }\n\n    @Test\n    void testEquals_DifferentName() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Bob\", 25);\n        assertFalse(answer1.equals(answer2), \"Two answers with different names should not be equal.\");\n    }\n\n    @Test\n    void testEquals_DifferentAge() {\n        Answer answer1 = new Answer(\"Alice\", 25);\n        Answer answer2 = new Answer(\"Alice\", 30);\n        assertFalse(answer1.equals(answer2), \"Two answers with different ages should not be equal.\");\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Rewrite the hashcode method in the content part of the class so that its hashcode is related to the name and age fields in the class\n *\n * @return obj hashcode\n */\n@Override\npublic int hashCode() {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 611,
    "code_type": "method",
    "original_language": "java",
    "file_path": "chatty-backend\\9b990df69c3f62b1ec6794731a6360451fe57573\\src\\main\\java\\net\\nocpiun\\chatty\\utils\\UniqueID.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n *\n * @return random string\n */\npublic static String generateRandomString() {}",
        "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    @Test\n    public void testLength() {\n        String randomString = Answer.generateRandomString();\n        assertEquals(25, randomString.length(), \"The generated string length should be 25.\");\n    }\n\n    @Test\n    public void testContainsUpperCase() {\n        String randomString = Answer.generateRandomString();\n        assertTrue(randomString.chars().anyMatch(Character::isUpperCase),\n                \"The generated string should contain at least one uppercase letter.\");\n    }\n\n    @Test\n    public void testContainsLowerCase() {\n        String randomString = Answer.generateRandomString();\n        assertTrue(randomString.chars().anyMatch(Character::isLowerCase),\n                \"The generated string should contain at least one lowercase letter.\");\n    }\n\n    @Test\n    public void testRandomness() {\n        String string1 = Answer.generateRandomString();\n        String string2 = Answer.generateRandomString();\n        assertNotEquals(string1, string2, \"Two generated strings should not be the same.\");\n    }\n\n    @Test\n    public void testMultipleGenerations() {\n        int numTests = 100;\n        boolean hasUpperCase = false;\n        boolean hasLowerCase = false;\n\n        for (int i = 0; i < numTests; i++) {\n            String randomString = Answer.generateRandomString();\n            hasUpperCase |= randomString.chars().anyMatch(Character::isUpperCase);\n            hasLowerCase |= randomString.chars().anyMatch(Character::isLowerCase);\n        }\n\n        assertTrue(hasUpperCase, \"At least one generated string should contain an uppercase letter.\");\n        assertTrue(hasLowerCase, \"At least one generated string should contain a lowercase letter.\");\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Generates a random string of length 25 and must contain both upper case letters (A-Z) and lower case letters (a-z)\n *\n * @return random string\n */\npublic static String generateRandomString() {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 612,
    "code_type": "method",
    "original_language": "java",
    "file_path": "HoldemEvaluator\\cb722a5471f2ac667e86c947e5061f2f9436d936\\ReplaceStringInAllJavaFiles.java\n",
    "question_type": "File operations and I/O operation",
    "summary": "Find and replace text in the specified file\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Finds and replaces text in a specified file.\n *\n * @param filePath      the path to the file\n * @param searchString  the string to search for\n * @param replaceString the string to replace with\n * @throws IOException if an I/O error occurs reading from the file or writing to the file\n */\npublic static void findAndReplaceInFile(Path filePath, String searchString, String replaceString) throws IOException {}",
        "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.real.temp.Answer;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\n\npublic class Tester {\n\n    // Test case 1: Basic find and replace\n    @Test\n    public void testFindAndReplaceBasic(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello Java\", \"Goodbye Java\"), result);\n    }\n\n    // Test case 2: No occurrences of the search string\n    @Test\n    public void testFindAndReplaceNoOccurrences(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"Python\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello World\", \"Goodbye World\"), result);\n    }\n\n    // Test case 3: Multiple occurrences in a single line\n    @Test\n    public void testFindAndReplaceMultipleOccurrences(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello Java Java\", \"Goodbye Java\"), result);\n    }\n\n    // Test case 4: Replace with an empty string\n    @Test\n    public void testFindAndReplaceWithEmptyString(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"Hello World\", \"Goodbye World\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"Hello \", \"Goodbye \"), result);\n    }\n\n    // Test case 5: Empty file\n    @Test\n    public void testFindAndReplaceEmptyFile(@TempDir Path tempDir) throws IOException {\n        Path filePath = tempDir.resolve(\"testfile.txt\");\n        Files.write(filePath, List.of(\"\"));\n\n        Answer.findAndReplaceInFile(filePath, \"World\", \"Java\");\n\n        List<String> result = Files.readAllLines(filePath);\n        assertEquals(List.of(\"\"), result);\n    }\n\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Finds and replaces text in a specified file.\n *\n * @param filePath      the path to the file\n * @param searchString  the string to search for\n * @param replaceString the string to replace with\n * @throws IOException if an I/O error occurs reading from the file or writing to the file\n */\npublic static void findAndReplaceInFile(Path filePath, String searchString, String replaceString) throws IOException {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 614,
    "code_type": "method",
    "original_language": "java",
    "file_path": "ArtemisTasks\\98db65f7d7f1e4e742047509c357f10877444215\\AdventuinParty\\pgdp\\adventuin\\AdventuinParty.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Accept a list containing multiple integer values, calculate the difference from the previous data for each item of data, get a difference array, and calculate the average difference value\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param numbers a list of integers\n * @return the average difference, or 0 if there are fewer than 2 integers\n */\npublic static double calculateAverageDifference(List<Integer> numbers) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateAverageDifference_PositiveIntegers() {\n        List<Integer> numbers = List.of(10, 20, 30, 40);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 10.0;\n        assertEquals(expected, result, \"The average difference should be 10.0\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_MixedPositiveAndNegative() {\n        List<Integer> numbers = List.of(-10, 0, 10, 20);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 10.0;\n        assertEquals(expected, result, \"The average difference should be 10.0\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_SameValues() {\n        List<Integer> numbers = List.of(5, 5, 5, 5);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;\n        assertEquals(expected, result, \"The average difference should be 0.0 as all values are the same\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_SingleElement() {\n        List<Integer> numbers = List.of(100);\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;  // Not enough data to calculate differences\n        assertEquals(expected, result, \"The average difference should be 0.0 for a single element list\");\n    }\n\n    @Test\n    public void testCalculateAverageDifference_EmptyList() {\n        List<Integer> numbers = List.of();\n        double result = Answer.calculateAverageDifference(numbers);\n        double expected = 0.0;  // Not enough data to calculate differences\n        assertEquals(expected, result, \"The average difference should be 0.0 for an empty list\");\n    }\n\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Calculates the average difference between consecutive integers in the provided list.\n *\n * @param numbers a list of integers\n * @return the average difference, or 0 if there are fewer than 2 integers\n */\npublic static double calculateAverageDifference(List<Integer> numbers) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 615,
    "code_type": "method",
    "original_language": "java",
    "file_path": "plantify\\8492e569496c820b6d2249ec1838439748954505\\plantifybackend\\src\\main\\java\\be\\kdg\\integration\\plantifybackend\\Util\\MovingAverage.java\n",
    "question_type": "Algorithm and data structure",
    "summary": "Calculates the average of a set of integer lists over a specified period\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values The list of integers from which to calculate the average.\n * @param period The number of last elements to include in the average calculation.\n * @return The average of the last 'period' integers, or Double.NaN if the input list\n *         does not contain enough elements or if the period is invalid (<= 0).\n */\npublic static double calculate(List<Integer> values, int period) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Tester {\n\n    @Test\n    public void testCalculateWithValidInput() {\n        List<Integer> values = Arrays.asList(1, 2, 3, 4, 5);\n        int period = 3;\n        double expected = 4.0; // (3 + 4 + 5) / 3\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithAllSameValues() {\n        List<Integer> values = Arrays.asList(5, 5, 5, 5, 5);\n        int period = 5;\n        double expected = 5.0; // (5 + 5 + 5 + 5 + 5) / 5\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithSingleValue() {\n        List<Integer> values = Arrays.asList(10);\n        int period = 1;\n        double expected = 10.0; // (10) / 1\n        assertEquals(expected, Answer.calculate(values, period));\n    }\n\n    @Test\n    public void testCalculateWithInsufficientValues() {\n        List<Integer> values = Arrays.asList(1, 2);\n        int period = 3;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n\n    @Test\n    public void testCalculateWithEmptyList() {\n        List<Integer> values = Arrays.asList();\n        int period = 1;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n\n    @Test\n    public void testCalculateWithNegativePeriod() {\n        List<Integer> values = Arrays.asList(1, 2, 3, 4, 5);\n        int period = -1;\n        assertTrue(Double.isNaN(Answer.calculate(values, period))); // Expecting NaN\n    }\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Calculates the average of the last 'period' integers in the given list of values.\n *\n * @param values The list of integers from which to calculate the average.\n * @param period The number of last elements to include in the average calculation.\n * @return The average of the last 'period' integers, or Double.NaN if the input list\n *         does not contain enough elements or if the period is invalid (<= 0).\n */\npublic static double calculate(List<Integer> values, int period) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 616,
    "code_type": "method",
    "original_language": "java",
    "file_path": "airbyte\\480a43b9ab758e130832186116df78242b6086e2\\airbyte-integrations\\bases\\base-java\\src\\main\\java\\io\\airbyte\\integrations\\destination_async\\AirbyteFileUtils.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Converts a size in bytes to a human-readable string representation.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\npublic static String byteCountToDisplaySize(final long sizeInBytes) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Objects;\n\nimport static junit.framework.TestCase.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class Tester {\n\n    /**\n     * Test the byteCountToDisplaySize function with various inputs.\n     */\n\n    @Test\n    public void testZeroBytes() {\n        // Test case for 0 bytes\n        long input = 0L;\n        String expected = \"0 bytes\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testBytesLessThanKB() {\n        // Test case for bytes less than 1KB\n        long input = 500L;\n        String expected = \"500 bytes\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testExactlyOneKB() {\n        // Test case for exactly 1KB\n        long input = 1024L;\n        assertTrue(Objects.equals(Answer.byteCountToDisplaySize(input), \"1 KB\") || Objects.equals(Answer.byteCountToDisplaySize(input), \"1.00 KB\"));\n    }\n\n    @Test\n    public void testBetweenKBAndMB() {\n        // Test case for a size between 1KB and 1MB\n        long input = 5000L;\n        String expected = \"4.88 KB\";\n        assertEquals(expected, Answer.byteCountToDisplaySize(input));\n    }\n\n    @Test\n    public void testExactlyOneMB() {\n        // Test case for exactly 1MB\n        long input = 1048576L; // 1024 * 1024\n        assertTrue(Objects.equals(Answer.byteCountToDisplaySize(input), \"1 MB\") || Objects.equals(Answer.byteCountToDisplaySize(input), \"1.00 MB\"));\n    }\n\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Converts a size in bytes to a human-readable string representation.\n *\n * @param sizeInBytes The size in bytes to convert.\n * @return A string representation of the size in an appropriate unit (bytes, KB, MB, GB, TB).\n */\npublic static String byteCountToDisplaySize(final long sizeInBytes) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 617,
    "code_type": "method",
    "original_language": "java",
    "file_path": "MakDan_project\\f6fdf07f3a1df20cbf2e1cdd4ebd4622e76486e5\\src\\main\\java\\com\\example\\makdan_project\\Main.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Parse the JSON file and store the parsed content using MAP\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Parses a JSON file and stores its contents in a Map.\n *\n * @param filePath the path to the JSON file to be parsed. The file must exist and contain valid JSON.\n *                 The path should be a fully qualified path or relative to the current working directory.\n * @return a Map<String, Object> containing the key-value pairs parsed from the JSON file. If the JSON\n *         file is empty or contains only simple key-value pairs without nested structures, the resulting\n *         Map will be correspondingly simple. The function returns an empty Map if the file is empty.\n * @throws FileNotFoundException if the specified file does not exist or cannot be opened. This exception\n *         is caught within the function and logged to the standard output, but it might be more appropriate\n *         in a real-world application to rethrow it or handle it in a way that informs the user more effectively.\n */\npublic static Map<String, Object> parseJsonFile(String filePath) {}",
        "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport org.junit.jupiter.api.Test;\nimport java.util.Map;\n\npublic class Tester {\n\n    @Test\n    public void testValidJson() throws IOException {\n        String jsonContent = \"{\\\"name\\\":\\\"John\\\", \\\"age\\\":30}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertEquals(\"John\", result.get(\"name\"));\n        assertEquals(30, result.get(\"age\"));\n    }\n\n    @Test\n    public void testEmptyJson() throws IOException {\n        String jsonContent = \"{}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertTrue(result.isEmpty());\n    }\n\n\n\n    @Test\n    public void testNullInput() {\n        assertThrows(NullPointerException.class, () -> Answer.parseJsonFile(null));\n    }\n\n    @Test\n    public void testNonJsonFile() throws IOException {\n        String notJsonContent = \"Hello, World!\";\n        Path path = Files.createTempFile(null, \".txt\");\n        Files.write(path, notJsonContent.getBytes());\n\n        assertThrows(Exception.class, () -> Answer.parseJsonFile(path.toString()));\n    }\n\n    @Test\n    public void testJsonWithArray() throws IOException {\n        String jsonContent = \"{\\\"names\\\":[\\\"John\\\", \\\"Doe\\\"]}\";\n        Path path = Files.createTempFile(null, \".json\");\n        Files.write(path, jsonContent.getBytes());\n\n        Map<String, Object> result = Answer.parseJsonFile(path.toString());\n        assertNotNull(result.get(\"names\"));\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Parses a JSON file and stores its contents in a Map.\n *\n * @param filePath the path to the JSON file to be parsed. The file must exist and contain valid JSON.\n *                 The path should be a fully qualified path or relative to the current working directory.\n * @return a Map<String, Object> containing the key-value pairs parsed from the JSON file. If the JSON\n *         file is empty or contains only simple key-value pairs without nested structures, the resulting\n *         Map will be correspondingly simple. The function returns an empty Map if the file is empty.\n * @throws FileNotFoundException if the specified file does not exist or cannot be opened. This exception\n *         is caught within the function and logged to the standard output, but it might be more appropriate\n *         in a real-world application to rethrow it or handle it in a way that informs the user more effectively.\n */\npublic static Map<String, Object> parseJsonFile(String filePath) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 623,
    "code_type": "method",
    "original_language": "java",
    "file_path": "PDB-Explorer\\8726fe10f68d42c55d23327f7dd4d0481af45b4d\\src\\main\\java\\pdbexplorer\\window\\ChartHandler.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Convert a Color object to its corresponding RGB color code string, formatted as a hexadecimal string\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Converts a Color object to its corresponding RGB color code string.\n *\n * @param color the Color object to convert\n * @return a hexadecimal string representing the RGB color code\n */\npublic static String toRGBCode(Color color) {}",
        "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport java.awt.Color;\n\npublic class Tester {\n\n    @Test\n    public void testToRGBCode_White() {\n        Color color = new Color(255, 255, 255); // White\n        String expected = \"#FFFFFF\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Black() {\n        Color color = new Color(0, 0, 0); // Black\n        String expected = \"#000000\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Red() {\n        Color color = new Color(255, 0, 0); // Red\n        String expected = \"#FF0000\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Green() {\n        Color color = new Color(0, 255, 0); // Green\n        String expected = \"#00FF00\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_Blue() {\n        Color color = new Color(0, 0, 255); // Blue\n        String expected = \"#0000FF\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testToRGBCode_CustomColor() {\n        Color color = new Color(255, 87, 51); // Custom Color\n        String expected = \"#FF5733\"; // Expected RGB Code\n        String result = Answer.toRGBCode(color);\n        assertEquals(expected, result);\n    }\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Converts a Color object to its corresponding RGB color code string.\n *\n * @param color the Color object to convert\n * @return a hexadecimal string representing the RGB color code\n */\npublic static String toRGBCode(Color color) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 625,
    "code_type": "method",
    "original_language": "java",
    "file_path": "idatg2003.gr13.chaosGame\\aae8f3b053cf80a30cbdfeb520c7f56ff571c9c0\\src\\main\\java\\modul\\chaosgameclasses\\ChaosGameFileHandler.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Read data from the file at the specified path, determine whether the string or integer or floating point number in each line of the file, and perform type conversion\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Reads data from a specified file and determines the type of each line.\n * The method processes each line of the file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param path the path to the file to be read. The file should exist and be accessible for reading.\n *\n * @return a list of Objects where each object can be an Integer, Float, or String,\n *         representing the converted values of each line in the file.\n *\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n *         This may happen if the file does not exist, or if the program lacks\n *         permissions to read the file.\n */\npublic List<Object> readDataFromFile(String path) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Tester {\n\n    private void createTestFile(String fileName, String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(fileName))) {\n            writer.write(content);\n        }\n    }\n\n    @Test\n    void testReadValidIntegers() throws IOException {\n        String filePath = \"valid_integers.txt\";\n        createTestFile(filePath, \"42\\n-7\\n0\\n100\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(42, result.get(0));\n        assertEquals(-7, result.get(1));\n        assertEquals(0, result.get(2));\n        assertEquals(100, result.get(3));\n    }\n\n    @Test\n    void testReadValidFloats() throws IOException {\n        String filePath = \"valid_floats.txt\";\n        createTestFile(filePath, \"3.14\\n-0.001\\n2.71828\\n0.0\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(3.14f, result.get(0));\n        assertEquals(-0.001f, result.get(1));\n        assertEquals(2.71828f, result.get(2));\n        assertEquals(0.0f, result.get(3));\n    }\n\n    @Test\n    void testReadMixedData() throws IOException {\n        String filePath = \"mixed_data.txt\";\n        createTestFile(filePath, \"Hello\\n42\\n3.14\\nWorld\\n-19.99\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(5, result.size());\n        assertEquals(\"Hello\", result.get(0));\n        assertEquals(42, result.get(1));\n        assertEquals(3.14f, result.get(2));\n        assertEquals(\"World\", result.get(3));\n        assertEquals(-19.99f, result.get(4));\n    }\n\n    @Test\n    void testReadEmptyFile() throws IOException {\n        String filePath = \"empty_file.txt\";\n        createTestFile(filePath, \"\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(0, result.size());\n    }\n\n    @Test\n    void testReadInvalidData() throws IOException {\n        String filePath = \"invalid_data.txt\";\n        createTestFile(filePath, \"Hello\\n42a\\n3.14.15\\nWorld!\\n\");\n\n        Answer answer = new Answer();\n        List<Object> result = answer.readDataFromFile(filePath);\n\n        assertEquals(4, result.size());\n        assertEquals(\"Hello\", result.get(0));\n        assertEquals(\"42a\", result.get(1));\n        assertEquals(\"3.14.15\", result.get(2));\n        assertEquals(\"World!\", result.get(3));\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Reads data from a specified file and determines the type of each line.\n * The method processes each line of the file and attempts to convert it\n * into either an integer, a floating-point number, or a string.\n *\n * @param path the path to the file to be read. The file should exist and be accessible for reading.\n *\n * @return a list of Objects where each object can be an Integer, Float, or String,\n *         representing the converted values of each line in the file.\n *\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n *         This may happen if the file does not exist, or if the program lacks\n *         permissions to read the file.\n */\npublic List<Object> readDataFromFile(String path) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 626,
    "code_type": "method",
    "original_language": "java",
    "file_path": "idatg2003.gr13.chaosGame\\aae8f3b053cf80a30cbdfeb520c7f56ff571c9c0\\src\\main\\java\\modul\\chaosgameclasses\\ChaosGameFileHandler.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Read the file under the specified path, process each line of the file, remove in-line comments (parts starting with #), remove line breaks, and return a list of the processed line contents.\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return A list of strings, each representing a processed line from the file.\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n */\npublic List<String> readFileAndProcessLines(String path) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass Tester {\n\n    private String testFilePath;\n\n    @BeforeEach\n    void setUp() throws IOException {\n        // Create a temporary file for testing\n        testFilePath = \"testFile.txt\";\n        File file = new File(testFilePath);\n        file.createNewFile();\n    }\n\n    // Helper method to write to the test file\n    private void writeToFile(String content) throws IOException {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(testFilePath))) {\n            writer.write(content);\n        }\n    }\n\n    @Test\n    void testNormalInput() throws IOException {\n        writeToFile(\"Line 1\\nLine 2 # Comment\\nLine 3\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    @Test\n    void testOnlyComments() throws IOException {\n        writeToFile(\"# This is a comment\\n# Another comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(), result);\n    }\n\n    @Test\n    void testEmptyLines() throws IOException {\n        writeToFile(\"Line 1\\n\\nLine 2\\n\\n\\nLine 3 # Comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    @Test\n    void testNoInlineComments() throws IOException {\n        writeToFile(\"Line 1\\nLine 2\\nLine 3\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Line 1\", \"Line 2\", \"Line 3\"), result);\n    }\n\n\n    @Test\n    void testOnlyNewLines() throws IOException {\n        writeToFile(\"\\n\\n\\n\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(), result);\n    }\n\n    @Test\n    void testMixedContent() throws IOException {\n        writeToFile(\"Valid line\\n# This is a comment\\nLine 2\\n# Another comment\\n\\nLine 3 # End of line comment\\n\");\n        List<String> result = readFileAndProcessLines(testFilePath);\n        assertEquals(List.of(\"Valid line\", \"Line 2\", \"Line 3\"), result);\n    }\n\n    // Cleanup after tests\n    @AfterEach\n    void tearDown() throws IOException {\n        Files.deleteIfExists(Paths.get(testFilePath));\n    }\n\n    // The method to be tested\n    public List<String> readFileAndProcessLines(String path) {\n        List<String> processedLines = new ArrayList<>();\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(path))) {\n            String line;\n\n            while ((line = reader.readLine()) != null) {\n                // Remove inline comments\n                line = line.split(\"#\")[0].trim();\n                // Only add non-empty lines to the list\n                if (!line.isEmpty()) {\n                    processedLines.add(line);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new IllegalArgumentException(\"Error reading file: \" + e.getMessage());\n        }\n\n        return processedLines;\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Reads a file from the specified path, processes each line to remove inline comments,\n * removes line breaks, and returns a list of the processed line contents.\n *\n * @param path The path to the file to be read.\n * @return A list of strings, each representing a processed line from the file.\n * @throws IllegalArgumentException if an I/O error occurs while reading the file.\n */\npublic List<String> readFileAndProcessLines(String path) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 628,
    "code_type": "method",
    "original_language": "java",
    "file_path": "idatg2003.gr13.chaosGame\\aae8f3b053cf80a30cbdfeb520c7f56ff571c9c0\\src\\main\\java\\modul\\chaosgameclasses\\ChaosGameFileHandler.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Modify a specific line in the specified file and update the content of the line based on the new value you enter\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Modifies a specific line in the given file.\n *\n * @param filePath the path of the file to be modified\n * @param lineNumber the line number to be modified (1-based index)\n * @param newValue the new value to update the line with\n * @throws IOException if an I/O error occurs\n */\npublic void modifyLineInFile(String filePath, int lineNumber, String newValue) throws IOException {}",
        "test_code": "{\n\n    private static final String TEST_FILE = \"testFile.txt\";\n    private Answer answer;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        answer = new Answer();\n        // Create a test file with initial content\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(TEST_FILE))) {\n            writer.write(\"Line 1\");\n            writer.newLine();\n            writer.write(\"Line 2\");\n            writer.newLine();\n            writer.write(\"Line 3\");\n            writer.newLine();\n        }\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        // Clean up the test file after each test\n        Files.deleteIfExists(Paths.get(TEST_FILE));\n    }\n\n    @Test\n    public void testModifyLine_Success() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 2, \"Updated Line 2\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Line 1\", reader.readLine());\n            assertEquals(\"Updated Line 2\", reader.readLine());\n            assertEquals(\"Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyFirstLine() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 1, \"Updated Line 1\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Updated Line 1\", reader.readLine());\n            assertEquals(\"Line 2\", reader.readLine());\n            assertEquals(\"Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyLastLine() throws IOException {\n        answer.modifyLineInFile(TEST_FILE, 3, \"Updated Line 3\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(TEST_FILE))) {\n            assertEquals(\"Line 1\", reader.readLine());\n            assertEquals(\"Line 2\", reader.readLine());\n            assertEquals(\"Updated Line 3\", reader.readLine());\n        }\n    }\n\n    @Test\n    public void testModifyNonExistentLine() {\n        assertThrows(Exception.class, () -> {\n            answer.modifyLineInFile(TEST_FILE, 4, \"Should Fail\");\n        });\n    }\n\n    @Test\n    public void testModifyNegativeLineNumber() {\n        assertThrows(Exception.class, () -> {\n            answer.modifyLineInFile(TEST_FILE, 0, \"Should Fail\");\n        });\n    }\n\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Modifies a specific line in the given file.\n *\n * @param filePath the path of the file to be modified\n * @param lineNumber the line number to be modified (1-based index)\n * @param newValue the new value to update the line with\n * @throws IOException if an I/O error occurs\n */\npublic void modifyLineInFile(String filePath, int lineNumber, String newValue) throws IOException {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 630,
    "code_type": "method",
    "original_language": "java",
    "file_path": "algorithms4-sedgewick-wayne\\c40be7fb47a38629e59de0af49871446ed0d1a79\\src\\main\\java\\com\\chao\\chapter2\\session1\\Exercise17_animation_chatGPT.java\n",
    "question_type": "Algorithm and data structure",
    "summary": "Implement insertion sorting\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Sorts an array of doubles in ascending order using the insertion sort algorithm.\n *\n * The insertion sort algorithm works by dividing the array into a sorted and an\n * unsorted portion. It iterates through the unsorted portion, taking one element\n * (the key) at a time and inserting it into its correct position in the sorted portion.\n *\n * @param arr the array of doubles to be sorted\n */\npublic static void insertionSort(double[] arr) {}",
        "test_code": "package org.real.temp;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class Tester {\n\n    // Test case 1: Basic unsorted array\n    @Test\n    public void testBasicUnsortedArray() {\n        double[] arr = {12.4, 11.2, 13.5, 5.6, 6.7};\n        double[] expected = {5.6, 6.7, 11.2, 12.4, 13.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 2: Already sorted array\n    @Test\n    public void testAlreadySortedArray() {\n        double[] arr = {1.1, 2.2, 3.3, 4.4, 5.5};\n        double[] expected = {1.1, 2.2, 3.3, 4.4, 5.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 3: Reverse sorted array\n    @Test\n    public void testReverseSortedArray() {\n        double[] arr = {5.5, 4.4, 3.3, 2.2, 1.1};\n        double[] expected = {1.1, 2.2, 3.3, 4.4, 5.5};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 4: Empty array\n    @Test\n    public void testEmptyArray() {\n        double[] arr = {};\n        double[] expected = {};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 5: Single element array\n    @Test\n    public void testSingleElementArray() {\n        double[] arr = {3.3};\n        double[] expected = {3.3};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 6: Array with duplicate values\n    @Test\n    public void testArrayWithDuplicates() {\n        double[] arr = {2.2, 3.3, 2.2, 1.1, 3.3};\n        double[] expected = {1.1, 2.2, 2.2, 3.3, 3.3};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n\n    // Test case 7: Large numbers\n    @Test\n    public void testLargeNumbers() {\n        double[] arr = {1e10, 1e9, 1e11, 1e8};\n        double[] expected = {1e8, 1e9, 1e10, 1e11};\n        Answer.insertionSort(arr);\n        assertArrayEquals(expected, arr);\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Sorts an array of doubles in ascending order using the insertion sort algorithm.\n *\n * The insertion sort algorithm works by dividing the array into a sorted and an\n * unsorted portion. It iterates through the unsorted portion, taking one element\n * (the key) at a time and inserting it into its correct position in the sorted portion.\n *\n * @param arr the array of doubles to be sorted\n */\npublic static void insertionSort(double[] arr) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 631,
    "code_type": "method",
    "original_language": "java",
    "file_path": "fun_with_csv\\55a95f94460e59513851a3458fee67016593e541\\misc\\SimpleCSVNioDemo.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Format a list of strings into a single-line string in CSV (comma-separated values) format and write it to a file\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings List of strings to be formatted into CSV.\n * @param filePath The file path where the CSV string should be written.\n */\npublic void writeCsvToFile(List<String> strings, String filePath) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.*;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Tester {\n    private Answer answer;\n    private final String testFilePath = \"test_output.csv\"; // Path for test output file\n\n    @BeforeEach\n    public void setUp() {\n        answer = new Answer(); // Create an instance of the Answer class\n    }\n\n    @AfterEach\n    public void tearDown() throws IOException {\n        // Delete the test file after each test\n        Path path = Paths.get(testFilePath);\n        if (Files.exists(path)) {\n            Files.delete(path);\n        }\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithMultipleStrings() {\n        List<String> data = List.of(\"Apple\", \"Banana\", \"Cherry\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple,Banana,Cherry\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithSingleString() {\n        List<String> data = List.of(\"Apple\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithEmptyList() {\n        List<String> data = List.of();\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file is empty\n        String content = readFile(testFilePath);\n        assertEquals(\"\", content);\n    }\n\n\n    @Test\n    public void testWriteCsvToFile_WithSpecialCharacters() {\n        List<String> data = List.of(\"Apple\", \"Banana, Cherry\", \"Date\");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple,Banana, Cherry,Date\", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithSpaces() {\n        List<String> data = List.of(\"Apple \", \" Banana\", \" Cherry \");\n        answer.writeCsvToFile(data, testFilePath);\n\n        // Assert the content of the file with spaces\n        String content = readFile(testFilePath);\n        assertEquals(\"Apple , Banana, Cherry \", content);\n    }\n\n    @Test\n    public void testWriteCsvToFile_WithFileOverwrite() {\n        // First write to the file\n        List<String> firstData = List.of(\"Apple\", \"Banana\");\n        answer.writeCsvToFile(firstData, testFilePath);\n\n        // Now overwrite with new data\n        List<String> secondData = List.of(\"Cherry\", \"Date\");\n        answer.writeCsvToFile(secondData, testFilePath);\n\n        // Assert that the file now contains the new data\n        String content = readFile(testFilePath);\n        assertEquals(\"Cherry,Date\", content);\n    }\n\n    // Helper method to read file content as a String\n    private String readFile(String filePath) {\n        try {\n            return Files.readString(Path.of(filePath));\n        } catch (IOException e) {\n            fail(\"Failed to read file: \" + e.getMessage());\n            return \"\";\n        }\n    }\n}",
        "prompt": "please write a java function , the function signature as below /**\n * Formats a list of strings into a single-line CSV string and writes it to a specified file.\n *\n * @param strings List of strings to be formatted into CSV.\n * @param filePath The file path where the CSV string should be written.\n */\npublic void writeCsvToFile(List<String> strings, String filePath) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 632,
    "code_type": "method",
    "original_language": "java",
    "file_path": "url2024lfa1\\99e03865c0ddc20b3013114077923975889f6da9\\02022024_ExpresionAritmeticaAArbol\\src\\ShuntingYard.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Parses a mathematical expression string, identifies its operators and operands, and stores them in a list\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Parses a mathematical expression string into a list of tokens.\n * This method identifies both operands (numbers) and operators (+, -, *, /, etc.) \n * in the provided expression, and returns them in a list format.\n *\n * @param expression The mathematical expression to be parsed, represented as a String.\n *                   The expression can contain integers, decimal numbers, \n *                   and standard arithmetic operators, as well as parentheses.\n * @return A List<String> containing the tokens identified in the expression. \n *         The list will include both operands and operators in the order they appear.\n */\npublic List<String> parseExpression(String expression) {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.util.List;\n\npublic class Tester {\n\n    private final Answer answer = new Answer();\n\n    @Test\n    public void testSimpleAddition() {\n        String expression = \"2 + 2\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"2\", \"+\", \"2\"), result);\n    }\n\n    @Test\n    public void testComplexExpression() {\n        String expression = \"3 + 5 * (2 - 8)\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"3\", \"+\", \"5\", \"*\", \"(\", \"2\", \"-\", \"8\", \")\"), result);\n    }\n\n    @Test\n    public void testNegativeNumbers() {\n        String expression = \"-1 + 4 - 5\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"-\", \"1\", \"+\", \"4\", \"-\", \"5\"), result);\n    }\n\n    @Test\n    public void testDecimals() {\n        String expression = \"3.5 + 2.1\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"3.5\", \"+\", \"2.1\"), result);\n    }\n\n    @Test\n    public void testOperatorsOnly() {\n        String expression = \"+ - * /\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"+\", \"-\", \"*\", \"/\"), result);\n    }\n\n    @Test\n    public void testEmptyExpression() {\n        String expression = \"\";\n        List<String> result = answer.parseExpression(expression);\n        assertTrue(result.isEmpty());\n    }\n\n    @Test\n    public void testSingleNumber() {\n        String expression = \"42\";\n        List<String> result = answer.parseExpression(expression);\n        assertEquals(List.of(\"42\"), result);\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Parses a mathematical expression string into a list of tokens.\n * This method identifies both operands (numbers) and operators (+, -, *, /, etc.) \n * in the provided expression, and returns them in a list format.\n *\n * @param expression The mathematical expression to be parsed, represented as a String.\n *                   The expression can contain integers, decimal numbers, \n *                   and standard arithmetic operators, as well as parentheses.\n * @return A List<String> containing the tokens identified in the expression. \n *         The list will include both operands and operators in the order they appear.\n */\npublic List<String> parseExpression(String expression) {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 633,
    "code_type": "method",
    "original_language": "java",
    "file_path": "fun_with_csv\\55a95f94460e59513851a3458fee67016593e541\\misc\\SimpleCSVNioDemo.java\n",
    "question_type": "Data processing and transformation",
    "summary": "Read the CSV file and parse each line into a list of strings\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath The path to the CSV file.\n * @return A list of string arrays, where each array represents a line from the CSV.\n * @throws IOException If there is an error reading the file.\n */\npublic List<List<String>> readCsv(String filePath) throws IOException {}",
        "test_code": "package org.real.temp;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\npublic class Tester {\n\n    private final Answer answer = new Answer();\n    private final String testFilePath = \"test.csv\";\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        // Create a temporary CSV file for testing\n        // Writing sample CSV content to the file\n        String sampleCsvContent = \"Name,Age,Location\\n\" +\n                \"Alice,30,New York\\n\" +\n                \"Bob,25,Los Angeles\\n\" +\n                \"Charlie,35,Chicago\\n\";\n        Files.write(Paths.get(testFilePath), sampleCsvContent.getBytes(), StandardOpenOption.CREATE);\n    }\n\n    @Test\n    public void testReadValidCsv() throws IOException {\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(4, result.size()); // 4 lines including the header\n        assertEquals(List.of(\"Name\", \"Age\", \"Location\"), result.get(0)); // Check header\n        assertEquals(List.of(\"Alice\", \"30\", \"New York\"), result.get(1));\n        assertEquals(List.of(\"Bob\", \"25\", \"Los Angeles\"), result.get(2));\n        assertEquals(List.of(\"Charlie\", \"35\", \"Chicago\"), result.get(3));\n    }\n\n    @Test\n    public void testReadEmptyCsv() throws IOException {\n        // Create an empty CSV file\n        Files.write(Paths.get(testFilePath), \"\".getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertTrue(result.isEmpty()); // Expecting an empty list\n    }\n\n\n    @Test\n    public void testReadCsvWithQuotes() throws IOException {\n        // Write CSV content with quoted fields\n        String contentWithQuotes = \"\\\"Name\\\",\\\"Age\\\",\\\"Location\\\"\\n\" +\n                \"\\\"Alice\\\",\\\"30\\\",\\\"New York\\\"\\n\" +\n                \"\\\"Bob\\\",\\\"25\\\",\\\"Los Angeles\\\"\\n\";\n        Files.write(Paths.get(testFilePath), contentWithQuotes.getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(3, result.size()); // 3 lines including the header\n        assertEquals(List.of(\"\\\"Name\\\"\", \"\\\"Age\\\"\", \"\\\"Location\\\"\"), result.get(0));\n    }\n\n    @Test\n    public void testReadInvalidCsvFile() {\n        // Attempt to read a non-existent file and assert that a FileNotFoundException is thrown\n        assertThrows(Exception.class, () -> {\n            answer.readCsv(\"non_existent_file.csv\");\n        });\n    }\n\n    @Test\n    public void testReadCsvWithDifferentDelimiters() throws IOException {\n        // Write CSV content with semicolons instead of commas\n        String contentWithSemicolons = \"Name;Age;Location\\n\" +\n                \"Alice;30;New York\\n\" +\n                \"Bob;25;Los Angeles\\n\";\n        Files.write(Paths.get(testFilePath), contentWithSemicolons.getBytes(), StandardOpenOption.TRUNCATE_EXISTING);\n        // Modify the readCsv function to handle semicolons if necessary.\n        List<List<String>> result = answer.readCsv(testFilePath);\n        assertEquals(3, result.size()); // Expecting 3 lines\n        assertEquals(List.of(\"Name;Age;Location\"), result.get(0));\n    }\n\n    // Clean up after tests (Optional)\n    @AfterEach\n    public void tearDown() throws IOException {\n        Files.deleteIfExists(Paths.get(testFilePath)); // Remove test file after tests\n    }\n}\n",
        "prompt": "please write a java function , the function signature as below /**\n * Reads a CSV file and parses each line into a list of strings.\n *\n * @param filePath The path to the CSV file.\n * @return A list of string arrays, where each array represents a line from the CSV.\n * @throws IOException If there is an error reading the file.\n */\npublic List<List<String>> readCsv(String filePath) throws IOException {},package is org.real.temp, class is Answer",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 183,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "cpp-raytracer\\cd33860cc5526fe95d6d60bed9a61340550acbb6\\Code\\cylinder.h",
    "question_type": "Algorithm and data structure",
    "summary": "Check whether the ray intersects the circle\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}",
        "test_code": "TEST_CASE(\"Ray-Circle Intersection Tests\") {\n    // Test Case 1: The ray intersects the circle at two points\n    {\n        Ray ray = {{0, 0}, {1, 1}}; // Origin at (0, 0), direction (1, 1)\n        Circle circle = {{3, 3}, 2}; // Circle center at (3, 3), radius 2\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 2: The ray is tangent to the circle (one intersection point)\n    {\n        Ray ray = {{2, 0}, {0, 1}}; // Origin at (2, 0), direction (0, 1)\n        Circle circle = {{2, 2}, 1}; // Circle center at (2, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 3: The ray starts inside the circle (one intersection point)\n    {\n        Ray ray = {{2, 2}, {1, 0}}; // Origin at (2, 2), direction (1, 0)\n        Circle circle = {{3, 2}, 1}; // Circle center at (3, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n    {\n        Ray ray = {{5, 5}, {1, 0}}; // Origin at (5, 5), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == false);\n    }\n\n    // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n    {\n        Ray ray = {{0, 3}, {1, 0}}; // Origin at (0, 3), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 6: The ray intersects the circle at one point when passing through the center\n    {\n        Ray ray = {{3, 0}, {0, 1}}; // Origin at (3, 0), direction (0, 1)\n        Circle circle = {{3, 3}, 3}; // Circle center at (3, 3), radius 3\n        REQUIRE(intersects(ray, circle) == true);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}",
        "addition_info": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 184,
    "code_type": "class",
    "original_language": "c&cpp",
    "file_path": "PokeGame\\e4b26a4a58b6d97599583435b49d4775f50b392b\\src\\data_structures\\priority_queue.c",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a priority queue and use the binary heap, or the maximum heap, as the underlying data structure\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};",
        "test_code": "TEST_CASE(\"Priority Queue - Test Cases\") {\n    PriorityQueue pq;\n\n    SECTION(\"Insert and access maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        REQUIRE(pq.top() == 30); // Ensure the max element is 30\n    }\n\n    SECTION(\"Remove maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        REQUIRE(pq.top() == 20); // Now the max should be 20\n        pq.pop(); // Remove 20\n        REQUIRE(pq.top() == 10); // Now the max should be 10\n    }\n\n    SECTION(\"Check empty queue\") {\n        REQUIRE(pq.isEmpty() == true); // Initially empty\n        pq.push(10);\n        REQUIRE(pq.isEmpty() == false); // Now not empty\n        pq.pop();\n        REQUIRE(pq.isEmpty() == true); // Back to empty\n    }\n\n    SECTION(\"Pop from empty queue\") {\n        REQUIRE_THROWS_AS(pq.pop(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Access top of empty queue\") {\n        REQUIRE_THROWS_AS(pq.top(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Maintain max-heap property\") {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        REQUIRE(pq.top() == 4); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        REQUIRE(pq.top() == 3); // Now max is 3\n\n        pq.push(5); // Add 5\n        REQUIRE(pq.top() == 5); // Ensure max is now 5\n    }\n}",
        "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 187,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "392finalproject\\adf6d029b89d69fb819729655e8580737e8ef132\\mergesort_serial.c",
    "question_type": "Algorithm and data structure",
    "summary": "implement merge sort algorithm\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}",
        "test_code": "TEST_CASE(\"Merge Sort Test Cases\", \"[merge_sort]\") {\n    SECTION(\"Sorting an empty array\") {\n        std::vector<int> empty_array = {};\n        merge_sort(empty_array, 0, empty_array.size() - 1);\n        REQUIRE(empty_array.empty() == true);\n    }\n\n    SECTION(\"Sorting a single element array\") {\n        std::vector<int> single_element = {1};\n        merge_sort(single_element, 0, single_element.size() - 1);\n        REQUIRE(single_element == std::vector<int>{1});\n    }\n\n    SECTION(\"Sorting a sorted array\") {\n        std::vector<int> sorted_array = {1, 2, 3, 4, 5};\n        merge_sort(sorted_array, 0, sorted_array.size() - 1);\n        REQUIRE(sorted_array == std::vector<int>{1, 2, 3, 2, 5});\n    }\n\n    SECTION(\"Sorting a reverse sorted array\") {\n        std::vector<int> reverse_sorted_array = {5, 4, 3, 2, 1};\n        merge_sort(reverse_sorted_array, 0, reverse_sorted_array.size() - 1);\n        REQUIRE(reverse_sorted_array == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Sorting an array with random integers\") {\n        std::vector<int> random_array = {38, 27, 43, 3, 9, 82, 10};\n        std::vector<int> expected_sorted_array = {3, 9, 10, 27, 38, 43, 82};\n        merge_sort(random_array, 0, random_array.size() - 1);\n        REQUIRE(random_array == expected_sorted_array);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 188,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "392finalproject\\adf6d029b89d69fb819729655e8580737e8ef132\\shellsort_serial.c",
    "question_type": "Algorithm and data structure",
    "summary": "implement a function that performs Shell sort on an array",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}",
        "test_code": "\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nTEST_CASE(\"Shell sort - Basic functionality\", \"[shellSort]\") {\n    SECTION(\"Test Case 1: Already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 2: Reverse sorted array\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 3: Array with duplicate elements\") {\n        std::vector<int> arr = {4, 2, 2, 4, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 4: Array with negative numbers\") {\n        std::vector<int> arr = {-3, -1, -4, -2, 0};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 5: Empty array\") {\n        std::vector<int> arr = {};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 189,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\utils\\base64.cpp",
    "question_type": "Data processing and transformation",
    "summary": "convert a byte array into a Base64 encoded string.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);",
        "test_code": "TEST_CASE(\"Base64 Encode Tests\") {\n\n    SECTION(\"Empty input should return empty string\") {\n        std::vector<unsigned char> input = {};\n        REQUIRE(base64_encode(input) == \"\");\n    }\n\n    SECTION(\"Encoding 'hello' should return 'aGVsbG8='\") {\n        std::vector<unsigned char> input = {'h', 'e', 'l', 'l', 'o'};\n        REQUIRE(base64_encode(input) == \"aGVsbG8=\");\n    }\n\n    SECTION(\"Encoding 'world' should return 'd29ybGQ='\") {\n        std::vector<unsigned char> input = {'w', 'o', 'r', 'l', 'd'};\n        REQUIRE(base64_encode(input) == \"d29ybGQ=\");\n    }\n\n    SECTION(\"Encoding 'foobar' should return 'Zm9vYmFy'\") {\n        std::vector<unsigned char> input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        REQUIRE(base64_encode(input) == \"Zm9vYmFy\");\n    }\n\n    SECTION(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\") {\n        std::vector<unsigned char> input = {'C', 'a', 't', 'c', 'h', '2'};\n        REQUIRE(base64_encode(input) == \"Q2F0Y2gy\");\n    }\n\n    SECTION(\"Encoding single byte 'A' should return 'QQ=='\") {\n        std::vector<unsigned char> input = {'A'};\n        REQUIRE(base64_encode(input) == \"QQ==\");\n    }\n\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 190,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp",
    "question_type": "Data processing and transformation",
    "summary": "parses a given hexadecimal string into its corresponding floating-point number and returns the float value.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}",
        "test_code": "TEST_CASE(\"Hexadecimal String to Float Conversion\", \"[hexStringToFloat]\") {\n\n    SECTION(\"Positive number: 40490FDB\") {\n        std::string hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Negative number: C0490FDB\") {\n        std::string hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Zero: 00000000\") {\n        std::string hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(0.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small positive number: 3F800000\") {\n        std::string hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(1.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small negative number: BF800000\") {\n        std::string hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-1.0f).epsilon(0.00001f));\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 191,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp",
    "question_type": "Data processing and transformation",
    "summary": "Convert a floating-point number to a hexadecimal string. The process involves interpreting the bit pattern of the floating-point number as an unsigned integer and then formatting this integer value as a hexadecimal string without any prefix (like 0x). The output string should be 8 characters long, with leading zeros added if necessary to meet this length requirement.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}",
        "test_code": "TEST_CASE(\"floatToHex tests\", \"[floatToHex]\") {\n    SECTION(\"Test with positive float 123.456\") {\n        float input = 123.456f;\n        std::string expected = \"42f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with negative float -123.456\") {\n        float input = -123.456f;\n        std::string expected = \"c2f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with zero\") {\n        float input = 0.0f;\n        std::string expected = \"00000000\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with small positive float 0.0001\") {\n        float input = 0.0001f;\n        std::string expected = \"38d1b717\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with large float 1e30\") {\n        float input = 1e30f;\n        std::string expected = \"7149f2ca\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 192,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp",
    "question_type": "Data processing and transformation",
    "summary": "Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}",
        "test_code": "TEST_CASE(\"hexStringToUnsignedInt converts hex string to unsigned int\", \"[hexStringToUnsignedInt]\") {\n\n    SECTION(\"Valid hex strings\") {\n        REQUIRE(hexStringToUnsignedInt(\"1A3F\") == 6719); // 1A3F in hex is 6719 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"FFFF\") == 65535); // FFFF in hex is 65535 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"0\") == 0); // 0 in hex is 0 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"7F\") == 127); // 7F in hex is 127 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"ABC123\") == 11256099); // ABC123 in hex is 11256099 in decimal\n    }\n\n    SECTION(\"Lowercase hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"abcd\") == 43981); // abcd in hex is 43981 in decimal\n    }\n\n    SECTION(\"Hex string with leading zeroes\") {\n        REQUIRE(hexStringToUnsignedInt(\"0001\") == 1); // 0001 in hex is 1 in decimal\n    }\n\n    SECTION(\"Empty hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"\") == 0); // Empty string should be treated as 0\n    }\n\n    SECTION(\"Mixed case hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"AbCdEf\") == 11259375); // AbCdEf in hex is 11259375 in decimal\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 193,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "rvfpm\\f0a335a1b8af4f653780ba542084bd9aa9edffc1\\work\\src\\in_TestFloat.cpp",
    "question_type": "Data processing and transformation",
    "summary": "Inverts the flag bits (the first five digits) of an unsigned integer to a hexadecimal string",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}",
        "test_code": "TEST_CASE(\"convFlags Test Cases\", \"[convFlags]\") {\n    REQUIRE(convFlags(0x0000001F) == \"FFFFFFE0\");\n\n    REQUIRE(convFlags(0x00000015) == \"FFFFFFEA\");\n\n    REQUIRE(convFlags(0xFFFFFFFF) == \"0\");\n\n    REQUIRE(convFlags(0x12345678) == \"EDCBA987\");\n\n    REQUIRE(convFlags(0x00000001) == \"FFFFFFFE\");\n\n    REQUIRE(convFlags(0x00000003) == \"FFFFFFFC\");\n\n    REQUIRE(convFlags(0x00000008) == \"FFFFFFF7\");\n\n    REQUIRE(convFlags(0xABCDEF01) == \"543210FE\");\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 194,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "exploring-CGO\\f73273080c90ce7d2114f4173d2674226885113e\\static\\gohello\\hello.c",
    "question_type": "Algorithm and data structure",
    "summary": "Returns a copy of the specified string via dynamic memory allocation",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}",
        "test_code": "\nTEST_CASE(\"return_string Test Cases\", \"[return_string]\") {\n    // Test Case 1: Copy a non-empty string\n    const char* original1 = \"Hello, World!\";\n    char* copy1 = return_string(original1);\n    REQUIRE(std::strcmp(copy1, original1) == 0);\n    delete[] copy1;\n\n    // Test Case 2: Copy an empty string\n    const char* original2 = \"\";\n    char* copy2 = return_string(original2);\n    REQUIRE(std::strcmp(copy2, original2) == 0);\n    delete[] copy2;\n\n    // Test Case 3: Copy a string with special characters\n    const char* original3 = \"C++ is fun! @#$%^&*()\";\n    char* copy3 = return_string(original3);\n    REQUIRE(std::strcmp(copy3, original3) == 0);\n    delete[] copy3;\n\n    // Test Case 4: Copy a single character string\n    const char* original4 = \"A\";\n    char* copy4 = return_string(original4);\n    REQUIRE(std::strcmp(copy4, original4) == 0);\n    delete[] copy4;\n\n    // Test Case 5: Passing a null pointer (should throw an exception)\n    REQUIRE_THROWS_AS(return_string(nullptr), std::invalid_argument);\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 195,
    "code_type": "class",
    "original_language": "c&cpp",
    "file_path": "Environmental-Sensing-BLE-Device-ESP32\\8cbf50eae8bb1aab64fcf3bac97cbf60761c641a\\src\\basic_stack.h",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a floating-point stack structure based on arrays",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};",
        "test_code": "TEST_CASE(\"stack_t Test Cases\", \"[stack_t]\") {\n    stack_t stack(10); // Provide capacity when creating the stack\n\n    // Test Case 1: Pushing and popping a single element\n    stack.push(3.14f);\n    REQUIRE(stack.pop() == Approx(3.14f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 2: Pushing multiple elements and checking peek\n    stack.push(1.23f);\n    stack.push(4.56f);\n    REQUIRE(stack.peek() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(1.23f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 3: Pop from an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.pop(), std::underflow_error);\n\n    // Test Case 4: Peek on an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.peek(), std::underflow_error);\n\n    // Test Case 5: Push elements until stack is full and attempt to push another element\n    stack_t fullStack(100); // Provide capacity when creating the stack\n    for (int i = 0; i < 100; ++i) {\n        fullStack.push(static_cast<float>(i) + 0.5f);\n    }\n    REQUIRE_THROWS_AS(fullStack.push(100.5f), std::overflow_error);\n}",
        "prompt": "please write a cpp class , the class signature as below /**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 196,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "learning\\5b9dc5c7470295980853b58c37c55d1350dc4480\\trv3wood\\assignment\\assignment5\\C2.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}",
        "test_code": "TEST_CASE(\"Sieve of Eratosthenes Test Cases\", \"[generatePrimes]\") {\n    // Test Case 1: Small limit (10)\n    std::vector<int> expected1 = {2, 3, 5, 7};\n    REQUIRE(generatePrimes(10) == expected1);\n\n    // Test Case 2: Prime limit (29)\n    std::vector<int> expected2 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(29) == expected2);\n\n    // Test Case 3: Non-prime limit (30)\n    std::vector<int> expected3 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(30) == expected3);\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    std::vector<int> expected4 = {2};\n    REQUIRE(generatePrimes(2) == expected4);\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    REQUIRE_THROWS_AS(generatePrimes(1), std::invalid_argument);\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 197,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "learning\\5b9dc5c7470295980853b58c37c55d1350dc4480\\trv3wood\\assignment\\assignment5\\C3.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Use list data structure to simulate Joseph rings to solve Joseph rings problem\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}",
        "test_code": "TEST_CASE(\"FindOrder Test Cases\", \"[findOrder]\") {\n    // Test Case 1: Minimum valid input with 2 players\n    REQUIRE(findOrder(2) == std::vector<int>{2, 1});\n\n    // Test Case 2: 3 players\n    REQUIRE(findOrder(3) == std::vector<int>{2, 3, 1});\n\n    // Test Case 3: 5 players\n    REQUIRE(findOrder(5) == std::vector<int>{2, 5, 3, 4, 1});\n\n    // Test Case 4: 7 players\n    REQUIRE(findOrder(7) == std::vector<int>{ 2, 5, 4, 1, 6, 7, 3});\n\n    // Test Case 5: 10 players\n    REQUIRE(findOrder(10) == std::vector<int>{ 2, 5, 10, 9, 7, 3, 4, 6, 8, 1});\n}\n",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 198,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "AOJ\\94f986991a57219ea2860ac8cf7992274b68db61\\alds1\\1d.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Calculate the maximum difference between any two elements in an array of integers, where the larger number must come after the smaller number (i.e., the subsequent element minus the previous element).",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}",
        "test_code": "TEST_CASE(\"General case\", \"[findMaxDifference]\") {\n    std::vector<int> l = {2, 3, 10, 6, 4, 8, 1};\n    REQUIRE(findMaxDifference(l) == 8);  // Maximum difference is 10 - 2 = 8\n}\n\n// Test case 2: Decreasing sequence\nTEST_CASE(\"Decreasing sequence\", \"[findMaxDifference]\") {\n    std::vector<int> l = {10, 9, 8, 7, 6, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference should be 0, as all differences are negative\n}\n\n// Test case 3: All elements the same\nTEST_CASE(\"All elements the same\", \"[findMaxDifference]\") {\n    std::vector<int> l = {5, 5, 5, 5, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference is 5 - 5 = 0\n}\n\n// Test case 4: Only two elements\nTEST_CASE(\"Only two elements\", \"[findMaxDifference]\") {\n    std::vector<int> l = {3, 8};\n    REQUIRE(findMaxDifference(l) == 5);  // Maximum difference is 8 - 3 = 5\n}\n\n// Test case 5: Only one element\nTEST_CASE(\"Single element\", \"[findMaxDifference]\") {\n    std::vector<int> l = {4};\n    REQUIRE(findMaxDifference(l) == 0);  // Only one element, no difference to calculate\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 200,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\api\\token_manager.cpp",
    "question_type": "Data processing and transformation",
    "summary": "Extracts the string contained in the first pair of braces {} from an input string\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}",
        "test_code": "TEST_CASE(\"Test cases for extractStringFromBraces function\") {\n\n    SECTION(\"Basic extraction\") {\n        std::string input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{data: \\\"value\\\"}\");\n    }\n\n    SECTION(\"No braces\") {\n        std::string input = \"This string has no braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n\n    SECTION(\"Only opening brace\") {\n        std::string input = \"This string has an opening brace { but no closing brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No closing brace found.\");\n    }\n\n    SECTION(\"Only closing brace\") {\n        std::string input = \"This string has a closing brace } but no opening brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n    SECTION(\"Multiple braces\") {\n        std::string input = \"First {first} and second {second} braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{first}\");\n    }\n\n    SECTION(\"Empty braces\") {\n        std::string input = \"This string has empty braces {} and some text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{}\");\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 202,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "RCMS\\334326745eb8419775c4a37cd6094e022768c703\\appendices\\sales and costs and ratings\u00a0 generation\\generateSalesCosts.h",
    "question_type": "Data processing and transformation",
    "summary": "Based on the given year and month, returns the number of days in that month",
    "language_version_list": {
      "python": {
        "code_signature": "#include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }",
        "test_code": "TEST_CASE(\"Leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2024, 2) == 29); // 2024 \u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 2: \u975e\u95f0\u5e74\u7684\u4e8c\u6708\u4efd\nTEST_CASE(\"Non-leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 2) == 28); // 2023 \u4e0d\u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 3: \u5927\u6708\u4efd\uff0831\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 31 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 1) == 31); // \u4e00\u6708\u4efd\u6709 31 \u5929\n    REQUIRE(getDaysInMonth(2023, 7) == 31); // \u4e03\u6708\u4efd\u6709 31 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 4: \u5c0f\u6708\u4efd\uff0830\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 30 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 4) == 30); // \u56db\u6708\u4efd\u6709 30 \u5929\n    REQUIRE(getDaysInMonth(2023, 11) == 30); // \u5341\u4e00\u6708\u4efd\u6709 30 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 5: \u65e0\u6548\u7684\u6708\u4efd\nTEST_CASE(\"Invalid month\", \"[getDaysInMonth]\") {\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 0), std::invalid_argument);  // \u6708\u4efd\u5c0f\u4e8e 1\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 13), std::invalid_argument); // \u6708\u4efd\u5927\u4e8e 12\n}",
        "prompt": "please write a cpp function , the function signature as below #include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 203,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "cp-data-algo\\4806008571d7248f876e185b6973e0f938bd899f\\ds\\ds00_reverse.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Reverse the order of elements in the vectorvwithin the specified range[a, b].",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}",
        "test_code": "TEST_CASE(\"Test reverseRange function\") {\n    SECTION(\"Reverse entire vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 0, 4);\n        std::vector<int> expected = {5, 4, 3, 2, 1};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse subrange in the middle\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8};\n        reverseRange(v, 2, 5);\n        std::vector<int> expected = {1, 2, 6, 5, 4, 3, 7, 8};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse a single element range\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 2, 2);\n        std::vector<int> expected = {1, 2, 3, 4, 5};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range with invalid indices\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, -1, 3);  // Invalid start index\n        std::vector<int> expected = {1, 2, 3, 4, 5}; // No change\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range at the end of the vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6};\n        reverseRange(v, 3, 5);\n        std::vector<int> expected = {1, 2, 3, 6, 5, 4};\n        REQUIRE(v == expected);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 204,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "bagconv\\260d097f17ba53dde36a8e5265b92aebdb78cdb6\\bagconv.cc",
    "question_type": "Data processing and transformation",
    "summary": "Split a string into multiple substrings based on spaces and return a vector containing these substrings.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}",
        "test_code": "TEST_CASE(\"splitString function\") {\n\n    SECTION(\"Split a regular sentence\") {\n        std::string input = \"Hello world from Catch2\";\n        std::vector<std::string> expected = {\"Hello\", \"world\", \"from\", \"Catch2\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Handle multiple spaces\") {\n        std::string input = \"Multiple   spaces between words\";\n        std::vector<std::string> expected = {\"Multiple\", \"spaces\", \"between\", \"words\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Single word input\") {\n        std::string input = \"Single\";\n        std::vector<std::string> expected = {\"Single\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Empty string input\") {\n        std::string input = \"\";\n        std::vector<std::string> expected = {};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"String with leading and trailing spaces\") {\n        std::string input = \"   Leading and trailing spaces   \";\n        std::vector<std::string> expected = {\"Leading\", \"and\", \"trailing\", \"spaces\"};\n        REQUIRE(splitString(input) == expected);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 205,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "bagconv\\260d097f17ba53dde36a8e5265b92aebdb78cdb6\\bagconv.cc",
    "question_type": "Algorithm and data structure",
    "summary": "Retrieve the current date and return it as a string in the \"YYYY-MM-DD\" format.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}",
        "test_code": "TEST_CASE(\"getCurrentDate function\") {\n\n    SECTION(\"Correct format YYYY-MM-DD\") {\n        std::string currentDate = getCurrentDate();\n        REQUIRE(currentDate.length() == 10);\n        REQUIRE(currentDate[4] == '-');\n        REQUIRE(currentDate[7] == '-');\n    }\n\n    SECTION(\"Returns correct year\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentYear = now->tm_year + 1900;\n\n        std::string currentDate = getCurrentDate();\n        std::string yearPart = currentDate.substr(0, 4);\n\n        REQUIRE(std::stoi(yearPart) == currentYear);\n    }\n\n    SECTION(\"Returns correct month\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentMonth = now->tm_mon + 1;\n\n        std::string currentDate = getCurrentDate();\n        std::string monthPart = currentDate.substr(5, 2);\n\n        REQUIRE(std::stoi(monthPart) == currentMonth);\n    }\n\n    SECTION(\"Returns correct day\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentDay = now->tm_mday;\n\n        std::string currentDate = getCurrentDate();\n        std::string dayPart = currentDate.substr(8, 2);\n\n        REQUIRE(std::stoi(dayPart) == currentDay);\n    }\n\n    SECTION(\"Consistency of output within the same second\") {\n        std::string firstCall = getCurrentDate();\n        std::string secondCall = getCurrentDate();\n        REQUIRE(firstCall == secondCall);\n    }\n}\n",
        "prompt": "please write a cpp function , the function signature as below /**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 206,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "Duke-ECE-551\\a8f52255e06d04d606aab7af4de5642a6592e5fc\\ece551\\070_circle\\circle.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}",
        "test_code": "TEST_CASE(\"Testing circleIntersectionArea function\") {\n    const double tolerance = 1e-5;\n\n    SECTION(\"No overlap, circles far apart\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"No overlap, circles just touching\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"One circle inside the other\") {\n        double area = circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of smaller circle\n    }\n\n    SECTION(\"Identical circles, full overlap\") {\n        double area = circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of one circle\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 207,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "CP_SOLUTION\\c08a2733c31ce5f3104a3d0c54323fde30d7e495\\Codeforces\\Round 903 (Div. 3)\\C_Perfect_Square.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}",
        "test_code": "TEST_CASE(\"Testing minChangesToSymmetric function\") {\n\n    SECTION(\"Already Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'b', 'e', 'f'},\n            {'c', 'f', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"One Change Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'c', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 2);\n    }\n\n    SECTION(\"All Different Elements\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'g', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 3);\n    }\n\n    SECTION(\"Large Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c', 'd'},\n            {'b', 'e', 'f', 'g'},\n            {'c', 'f', 'h', 'i'},\n            {'d', 'g', 'i', 'j'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"Multiple Changes Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'x', 'c', 'd'},\n            {'y', 'e', 'f', 'g'},\n            {'z', 'h', 'i', 'j'},\n            {'d', 'g', 'k', 'l'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 4);\n    }\n}\n",
        "prompt": "please write a cpp function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 208,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "cpsc464final\\4ee01b187d62db180d0cb2a1fe52070e999e523d\\hhalloc\\priority.c",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a priority queue",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Implement a priority queue\n */\nclass PriorityQueue {\npublic:\n    // Constructor\n    PriorityQueue() {}\n\n    // Function to insert a new element into the priority queue\n    void insert(int value) {\n\n    }\n\n    // Function to get and remove the minimum element from the priority queue\n    int extractMin() {\n\n    }\n\n    // Function to peek at the minimum element without removing it\n    int peekMin() const {\n\n    }\n\n    // Function to check if the priority queue is empty\n    bool isEmpty() const {\n\n    }\n\n    // Function to get the size of the priority queue\n    int size() const {\n\n    }\n\n    // Function to print the contents of the priority queue (for debugging purposes)\n    void print() const {\n\n    }\n};\n",
        "test_code": "// Test Case 1: Test insertion and extraction of the minimum element\nTEST_CASE(\"Insertion and extraction of minimum element\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Inserting elements into the priority queue\") {\n        pq.insert(5);\n        pq.insert(2);\n        pq.insert(8);\n        pq.insert(1);\n        pq.insert(3);\n\n        REQUIRE(pq.size() == 5);\n        REQUIRE(pq.peekMin() == 1);\n    }\n\n    SECTION(\"Extracting the minimum element\") {\n        pq.insert(5);\n        pq.insert(2);\n        pq.insert(8);\n        pq.insert(1);\n        pq.insert(3);\n\n        REQUIRE(pq.extractMin() == 1);\n        REQUIRE(pq.extractMin() == 2);\n        REQUIRE(pq.extractMin() == 3);\n        REQUIRE(pq.extractMin() == 5);\n        REQUIRE(pq.extractMin() == 8);\n        REQUIRE(pq.isEmpty() == true);\n    }\n}\n\n// Test Case 2: Test peekMin operation\nTEST_CASE(\"Peek minimum element\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Peeking at the minimum element without extraction\") {\n        pq.insert(10);\n        pq.insert(4);\n        pq.insert(15);\n\n        REQUIRE(pq.peekMin() == 4);\n        REQUIRE(pq.size() == 3); // Size should remain the same\n        REQUIRE(pq.peekMin() == 4); // Peek should not remove the element\n    }\n}\n\n// Test Case 3: Test edge case of extracting from an empty queue\nTEST_CASE(\"Extract from empty queue\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Attempting to extract from an empty queue should throw an exception\") {\n        REQUIRE_THROWS_AS(pq.extractMin(), std::runtime_error);\n    }\n}\n\n// Test Case 4: Test isEmpty function\nTEST_CASE(\"Check if the priority queue is empty\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Newly created queue should be empty\") {\n        REQUIRE(pq.isEmpty() == true);\n    }\n\n    SECTION(\"Queue should not be empty after insertion\") {\n        pq.insert(7);\n        REQUIRE(pq.isEmpty() == false);\n    }\n\n    SECTION(\"Queue should be empty after extracting all elements\") {\n        pq.insert(7);\n        pq.extractMin();\n        REQUIRE(pq.isEmpty() == true);\n    }\n}\n\n// Test Case 5: Test multiple insertions and order of extraction\nTEST_CASE(\"Multiple insertions and extraction order\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Inserting multiple elements and checking extraction order\") {\n        pq.insert(9);\n        pq.insert(4);\n        pq.insert(6);\n        pq.insert(1);\n        pq.insert(8);\n\n        std::vector<int> extractedElements;\n        while (!pq.isEmpty()) {\n            extractedElements.push_back(pq.extractMin());\n        }\n\n        std::vector<int> expectedOrder = {1, 4, 6, 8, 9};\n        REQUIRE(extractedElements == expectedOrder);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * Implement a priority queue\n */\nclass PriorityQueue {\npublic:\n    // Constructor\n    PriorityQueue() {}\n\n    // Function to insert a new element into the priority queue\n    void insert(int value) {\n\n    }\n\n    // Function to get and remove the minimum element from the priority queue\n    int extractMin() {\n\n    }\n\n    // Function to peek at the minimum element without removing it\n    int peekMin() const {\n\n    }\n\n    // Function to check if the priority queue is empty\n    bool isEmpty() const {\n\n    }\n\n    // Function to get the size of the priority queue\n    int size() const {\n\n    }\n\n    // Function to print the contents of the priority queue (for debugging purposes)\n    void print() const {\n\n    }\n};\n",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 209,
    "code_type": "class",
    "original_language": "c&cpp",
    "file_path": "DS_and_A\\9ebd32a0c8dae3e249dc17fa1def73fb70d34e32\\linked_lists\\singly_linked_list.c",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a linked list",
    "language_version_list": {
      "python": {
        "code_signature": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n",
        "test_code": "TEST_CASE(\"LinkedList operations\", \"[LinkedList]\") {\n\n    SECTION(\"Insertion at the head\") {\n        LinkedList list;\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 30 -> 20 -> 10 -> nullptr\n        REQUIRE(list.search(10) == true);\n        REQUIRE(list.search(20) == true);\n        REQUIRE(list.search(30) == true);\n        REQUIRE(list.search(40) == false);\n    }\n\n    SECTION(\"Insertion at the tail\") {\n        LinkedList list;\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 1 -> 2 -> 3 -> nullptr\n        REQUIRE(list.search(1) == true);\n        REQUIRE(list.search(2) == true);\n        REQUIRE(list.search(3) == true);\n        REQUIRE(list.search(4) == false);\n    }\n\n    SECTION(\"Deletion of elements\") {\n        LinkedList list;\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        std::ostringstream output;\n        list.printList(); // Expected: 15 -> 5 -> nullptr\n        REQUIRE(list.search(10) == false);\n        REQUIRE(list.search(15) == true);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(15);\n        list.printList(); // Expected: 5 -> nullptr\n        REQUIRE(list.search(15) == false);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(5);\n        list.printList(); // Expected: nullptr\n        REQUIRE(list.search(5) == false);\n    }\n\n    SECTION(\"Search functionality\") {\n        LinkedList list;\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        REQUIRE(list.search(100) == true);\n        REQUIRE(list.search(200) == true);\n        REQUIRE(list.search(300) == true);\n        REQUIRE(list.search(400) == false);\n    }\n\n    SECTION(\"Edge case: Empty list\") {\n        LinkedList list;\n\n        REQUIRE(list.search(1) == false);  // Searching in an empty list\n        list.deleteValue(1);               // Deleting from an empty list should not crash\n        std::ostringstream output;\n        list.printList();                  // Expected: nullptr (still empty)\n    }\n}",
        "prompt": "please write a cpp class , the class signature as below struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n",
        "addition_info": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 210,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "crimes\\8ae66212f64db45501a8f2e9d68d37411bf4ddc4\\tests\\c-sources\\fib.c",
    "question_type": "Algorithm and data structure",
    "summary": "Implement the Fibonacci sequence",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}",
        "test_code": "// Test function for iterative, recursive, and memoization Fibonacci\nTEST_CASE(\"Fibonacci sequence\", \"[fibonacci]\") {\n    // Test Case 1: Fibonacci of 0\n    SECTION(\"Fibonacci(0) should be 0\") {\n        REQUIRE(fibonacciRecursive(0) == 0);\n    }\n\n    // Test Case 2: Fibonacci of 1\n    SECTION(\"Fibonacci(1) should be 1\") {\n        REQUIRE(fibonacciRecursive(1) == 1);\n    }\n\n    // Test Case 3: Fibonacci of 5\n    SECTION(\"Fibonacci(5) should be 5\") {\n        REQUIRE(fibonacciRecursive(5) == 5);\n    }\n\n    // Test Case 4: Fibonacci of 10\n    SECTION(\"Fibonacci(10) should be 55\") {\n        REQUIRE(fibonacciRecursive(10) == 55);\n    }\n\n    // Test Case 5: Fibonacci of 20\n    SECTION(\"Fibonacci(20) should be 6765\") {\n        REQUIRE(fibonacciRecursive(20) == 6765);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 354,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "Raygun\\ff6c4d048ad83867b5397352599c2edcdb49ba5d\\src\\renderer\\math.h",
    "question_type": "Algorithm and data structure",
    "summary": "Calculates the Gaussian weight based on the difference in intensity and a color standard deviation. * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))",
    "language_version_list": {
      "python": {
        "code_signature": "#include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}",
        "test_code": "// Test cases for gaussianWeight function\nTEST_CASE(\"Gaussian Weight Calculation Tests\") {\n\n    SECTION(\"Zero Intensity Difference\") {\n        // When intensity difference is zero, weight should be 1\n        float intensity_diff = 0.0f;\n        float sigma_color = 1.0f; // arbitrary sigma value\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Intensity Difference\") {\n        // A positive intensity difference with a reasonable sigma\n        float intensity_diff = 2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Intensity Difference\") {\n        // A negative intensity difference should yield the same weight as positive\n        float intensity_diff = -2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Color\") {\n        // Test with a small sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 0.1f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Color\") {\n        // Test with a large sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 100.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 355,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "Raygun\\ff6c4d048ad83867b5397352599c2edcdb49ba5d\\src\\renderer\\math.h",
    "question_type": "Algorithm and data structure",
    "summary": "Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation. * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))",
    "language_version_list": {
      "python": {
        "code_signature": "#include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}",
        "test_code": "TEST_CASE(\"Spatial Weight Calculation Tests\") {\n\n    SECTION(\"Zero Spatial Difference\") {\n        // When spatial difference is zero, weight should be 1\n        float spatial_diff = 0.0f;\n        float sigma_space = 1.0f; // arbitrary sigma value\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Spatial Difference\") {\n        // A positive spatial difference with a reasonable sigma\n        float spatial_diff = 2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Spatial Difference\") {\n        // A negative spatial difference should yield the same weight as positive\n        float spatial_diff = -2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Space\") {\n        // Test with a small sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 0.1f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Space\") {\n        // Test with a large sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 100.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n}",
        "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 356,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "EpicPitfall\\d1587187ba41a5b64636bbe4b0de3832145a97d9\\src\\Core\\Rendering\\Renderer.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Implement bubble sort algorithm",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}",
        "test_code": "TEST_CASE(\"BubbleSort Test Cases\", \"[bubbleSort]\") {\n    // Test Case 1: Sorting an already sorted array\n    std::vector<int> arr1 = {1, 2, 3, 4, 5};\n    bubbleSort(arr1);\n    REQUIRE(arr1 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 2: Sorting a reverse sorted array\n    std::vector<int> arr2 = {5, 4, 3, 2, 1};\n    bubbleSort(arr2);\n    REQUIRE(arr2 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 3: Sorting an array with duplicate elements\n    std::vector<int> arr3 = {3, 1, 2, 3, 2};\n    bubbleSort(arr3);\n    REQUIRE(arr3 == std::vector<int>{1, 2, 2, 3, 3});\n\n    // Test Case 4: Sorting an array with a single element\n    std::vector<int> arr4 = {1};\n    bubbleSort(arr4);\n    REQUIRE(arr4 == std::vector<int>{1});\n\n    // Test Case 5: Sorting an empty array\n    std::vector<int> arr5 = {};\n    bubbleSort(arr5);\n    REQUIRE(arr5 == std::vector<int>{});\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 357,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "Algorithmen_und_Datenstrukturen\\60a962dd2f20252bbaaf03809bf8cca9be29cbe1\\ex_03\\searches\\main.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Implement hill sort",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}",
        "test_code": "// Helper function to check if the array is sorted\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases\nTEST_CASE(\"Hill Sort\") {\n    SECTION(\"Sort an already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array in reverse order\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with duplicate values\") {\n        std::vector<int> arr = {3, 1, 2, 3, 2};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with all identical values\") {\n        std::vector<int> arr = {1, 1, 1, 1, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an empty array\") {\n        std::vector<int> arr = {};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with one element\") {\n        std::vector<int> arr = {42};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort a large random array\") {\n        std::vector<int> arr = {3, 7, 2, 5, 1, 4, 6, 0, 9, 8};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 358,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "cpp-challenges\\9bd4a353ca153e7eeb3effda1fd866574d044ed4\\cpp-challenges\\1-test-driven-development\\1-test-driven-development.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}",
        "test_code": "TEST_CASE(\"sortNames Test Cases\", \"[sortNames]\") {\n    // Test Case 2: Same numbers, different names\n    vector<string> arr2 = {\"Alice10\", \"Charlie10\", \"Bob10\"};\n    vector<string> expected2 = {\"Alice10\", \"Bob10\", \"Charlie10\"};\n    REQUIRE(sortNames(arr2) == expected2);\n\n    // Test Case 3: Mixed case with different names and numbers\n    vector<string> arr3 = {\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"};\n    vector<string> expected3 = {\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"};\n    REQUIRE(sortNames(arr3) == expected3);\n\n    // Test Case 4: Single element\n    vector<string> arr4 = {\"Alice5\"};\n    vector<string> expected4 = {\"Alice5\"};\n    REQUIRE(sortNames(arr4) == expected4);\n\n    // Test Case 5: Empty array\n    vector<string> arr5 = {};\n    vector<string> expected5 = {};\n    REQUIRE(sortNames(arr5) == expected5);\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 359,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "parallel_repo\\527b162e693205f7bd7c8a680113cc71eb49d984\\r3\\code\\hello_integrators\\hello_trapezoidal.cpp",
    "question_type": "Algorithm and data structure",
    "summary": "Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}",
        "test_code": "TEST_CASE(\"TrapezoidalRule Test Cases\", \"[trapezoidal_rule]\") {\n    // Test Case 1: Integration of a constant function (f(x) = 1) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return 1.0; }, 0.0, 1.0, 100) == Approx(1.0).epsilon(1e-6));\n\n    // Test Case 2: Integration of a linear function (f(x) = x) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x; }, 0.0, 1.0, 100) == Approx(0.5).epsilon(1e-6));\n\n    // Test Case 3: Integration of a quadratic function (f(x) = x^2) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x * x; }, 0.0, 1.0, 1000) == Approx(1.0 / 3.0).epsilon(1e-6));\n\n    // Test Case 4: Integration of the sine function (f(x) = sin(x)) over [0, \u03c0]\n    REQUIRE(trapezoidal_rule([](double x) { return std::sin(x); }, 0.0, M_PI, 1000) == Approx(2.0).epsilon(1e-6));\n\n    // Test Case 5: Integration of an exponential function (f(x) = exp(x)) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return std::exp(x); }, 0.0, 1.0, 1000) == Approx(std::exp(1.0) - 1.0).epsilon(1e-6));\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 360,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "GraST\\524b8e82169dedbefd0646cb56f1e26d434cfb68\\src\\Utility.cc",
    "question_type": "Data processing and transformation",
    "summary": "Extracts the last part of a complete file path with the help of a path separator and returns it, or the original string if no separator is found",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}",
        "test_code": "TEST_CASE(\"getLastPartOfFilepath Test Cases\", \"[getLastPartOfFilepath]\") {\n    // Test Case 1: Unix-style path with '/'\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/file.txt\") == \"file.txt\");\n\n    // Test Case 2: Windows-style path with '\\\\'\n    REQUIRE(getLastPartOfFilepath(\"C:\\\\Users\\\\JohnDoe\\\\Documents\\\\file.txt\") == \"file.txt\");\n\n    // Test Case 3: Path without any separators (should return the original string)\n    REQUIRE(getLastPartOfFilepath(\"file.txt\") == \"file.txt\");\n\n    // Test Case 4: Path ending with a separator (should return an empty string)\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/\") == \"\");\n\n    // Test Case 5: Path with mixed separators (should return the last part after the last separator)\n    REQUIRE(getLastPartOfFilepath(\"C:/Users\\\\JohnDoe/Documents/file.txt\") == \"file.txt\");\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 361,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "parallel_repo\\527b162e693205f7bd7c8a680113cc71eb49d984\\r3\\code\\hello_integrators\\hello_simpson.cpp",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Computes the approximate integral of a function using Simpson's Rule.",
    "language_version_list": {
      "python": {
        "code_signature": "#include <stdexcept> // For std::invalid_argument\n/**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}",
        "test_code": "TEST_CASE(\"Simpson's Rule Tests\") {\n\n    SECTION(\"Basic Integral of x^2 from 0 to 1\") {\n        // The exact integral of f(x) = x^2 from 0 to 1 is 1/3\n        double result = simpsons_rule(0.0, 1.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Basic Integral of x^2 from 0 to 2\") {\n        // The exact integral of f(x) = x^2 from 0 to 2 is 8/3\n        double result = simpsons_rule(0.0, 2.0, 10);\n        REQUIRE(result == Approx(8.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Negative Integral of x^2 from -1 to 0\") {\n        // The exact integral of f(x) = x^2 from -1 to 0 is 1/3\n        double result = simpsons_rule(-1.0, 0.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Large Interval\") {\n        // Test with a larger interval from 0 to 10\n        double result = simpsons_rule(0.0, 10.0, 20);\n        // The exact integral from 0 to 10 of f(x) = x^2 is (10^3)/3 = 1000/3\n        REQUIRE(result == Approx(1000.0 / 3.0).epsilon(0.01));\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <stdexcept> // For std::invalid_argument\n/**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}",
        "addition_info": "double f(double x) {\n    return x * x;\n}"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 365,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "c-armyknife-lib\\5b1e037ea7625bf56f84c709e54089b33637d16b\\examples\\travel-mixed.c\n",
    "question_type": "Data processing and transformation",
    "summary": "calculate the day of the week the given date (year, month, day) is (Monday is represented by 1, Tuesday is represented by 2, and so on)\n",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}",
        "test_code": "TEST_CASE(\"Day of Week Calculation\", \"[day_of_week]\") {\n    REQUIRE(day_of_week(2024, 1, 1) == 1);  // January 1, 2024 is a Monday\n    REQUIRE(day_of_week(2023, 8, 29) == 2);  // August 29, 2023 is a Tuesday\n    REQUIRE(day_of_week(2022, 12, 25) == 7); // December 25, 2022 is a Sunday\n    REQUIRE(day_of_week(1989, 11, 9) == 4);  // November 9, 1989 is a Thursday\n    REQUIRE(day_of_week(2000, 2, 29) == 2);  // February 29, 2000 is a Tuesday\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 481,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "Cursos-DIO\\0fe8eb13955636e6d31750db30554fc94f48eef1\\ChatGPT Jogo da velha.cpp\n",
    "question_type": "User interface",
    "summary": "Prints a 3x3 game board to the console.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}",
        "test_code": "TEST_CASE(\"printBoard outputs correct format\", \"[printBoard]\") {\n    vector<vector<char>> board1 = {\n        {'X', 'O', 'X'},\n        {' ', 'X', 'O'},\n        {'O', ' ', ' '}\n    };\n\n    vector<vector<char>> board2 = {\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board3 = {\n        {'X', 'X', 'X'},\n        {'O', 'O', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board4 = {\n        {'O', 'O', 'O'},\n        {'X', 'X', 'X'},\n        {'X', 'O', ' '}\n    };\n\n    vector<vector<char>> board5 = {\n        {'X', ' ', ' '},\n        {' ', 'X', ' '},\n        {' ', ' ', 'X'}\n    };\n\n    vector<vector<char>> board6 = {\n        {' ', 'O', ' '},\n        {'O', ' ', 'O'},\n        {' ', 'O', ' '}\n    };\n\n    // Test case 1\n    SECTION(\"Test case 1\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf()); // Redirect cout to ostringstream\n\n        printBoard(board1);\n\n        cout.rdbuf(oldCoutBuffer); // Restore original cout\n        string expectedOutput = \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 2\n    SECTION(\"Test case 2\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board2);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 3\n    SECTION(\"Test case 3\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board3);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 4\n    SECTION(\"Test case 4\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board4);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 5\n    SECTION(\"Test case 5\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board5);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 6\n    SECTION(\"Test case 6\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board6);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 589,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\utils\\response_parser.cpp\n",
    "question_type": "Data processing and transformation",
    "summary": "Extracts the first complete JSON object from the given string\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}",
        "test_code": "TEST_CASE(\"extract_json returns an empty string for input without '{'\") {\n    std::string input = \"No braces here\";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json extracts a single JSON object\") {\n    std::string input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n    REQUIRE(extract_json(input) == \"{ \\\"key\\\": \\\"value\\\" }\");\n}\n\nTEST_CASE(\"extract_json handles nested JSON objects\") {\n    std::string input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n    REQUIRE(extract_json(input) == \"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\");\n}\n\nTEST_CASE(\"extract_json returns an empty string for unmatched braces\") {\n    std::string input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json returns the correct JSON when multiple braces are present\") {\n    std::string input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n    REQUIRE(extract_json(input) == \"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\");\n}\n\nTEST_CASE(\"extract_json extracts the first JSON object when multiple are present\") {\n    std::string input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n    REQUIRE(extract_json(input) == \"{ \\\"first\\\": \\\"value1\\\" }\");\n}",
        "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 590,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "wake_word\\d1495aa2811e7aae771cdff2fc4c63e14fc4a8ab\\firmware\\wake_word\\src\\utils\\response_parser.cpp\n",
    "question_type": "Data processing and transformation",
    "summary": "Parse the HTTP response string, obtain the request method, URL, and HTTP version number, store the information in a map and return it\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}",
        "test_code": "TEST_CASE(\"Valid POST request line\", \"[parse_http_request_line]\") {\n    std::string response = \"POST /api/data HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"POST\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/data\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"PUT request line\", \"[parse_http_request_line]\") {\n    std::string response = \"PUT /api/update HTTP/2.0\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"PUT\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/update\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/2.0\");\n}\n\nTEST_CASE(\"DELETE request line\", \"[parse_http_request_line]\") {\n    std::string response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"DELETE\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/delete\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"Malformed request line\", \"[parse_http_request_line]\") {\n    std::string response = \"INVALID REQUEST LINE\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info.empty());  // Expect empty result for malformed request\n}",
        "prompt": "please write a cpp function , the function signature as below #include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 591,
    "code_type": "class",
    "original_language": "c&cpp",
    "file_path": "stm32-pet-project\\747c4b041fd4cad83a66dde56c50128afa6c8392\\Core\\Inc\\colors.h\n",
    "question_type": "Program input code",
    "summary": "Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n",
        "test_code": "TEST_CASE(\"Color RGB Values\", \"[Color]\") {\n    Color color;\n\n    SECTION(\"Verify RGB values for Red\") {\n        auto rgb = color.getColor(Color::RED);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Green\") {\n        auto rgb = color.getColor(Color::GREEN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Blue\") {\n        auto rgb = color.getColor(Color::BLUE);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Yellow\") {\n        auto rgb = color.getColor(Color::YELLOW);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Magenta\") {\n        auto rgb = color.getColor(Color::MAGENTA);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Cyan\") {\n        auto rgb = color.getColor(Color::CYAN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for White\") {\n        auto rgb = color.getColor(Color::WHITE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Black\") {\n        auto rgb = color.getColor(Color::BLACK);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Orange\") {\n        auto rgb = color.getColor(Color::ORANGE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 165);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Purple\") {\n        auto rgb = color.getColor(Color::PURPLE);\n        REQUIRE(std::get<0>(rgb) == 128);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 128);\n    }\n\n    SECTION(\"Verify RGB values for Pink\") {\n        auto rgb = color.getColor(Color::PINK);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 192);\n        REQUIRE(std::get<2>(rgb) == 203);\n    }\n\n    SECTION(\"Verify RGB values for Brown\") {\n        auto rgb = color.getColor(Color::BROWN);\n        REQUIRE(std::get<0>(rgb) == 165);\n        REQUIRE(std::get<1>(rgb) == 42);\n        REQUIRE(std::get<2>(rgb) == 42);\n    }\n}",
        "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n",
        "addition_info": "#include <unordered_map>\n"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 592,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "NumericParser\\f35a211e3621db8db305869abfc527cb77acf66f\\NumericParser\\NumericParser.cpp\n",
    "question_type": "Algorithm and data structure",
    "summary": "Implement a simple mathematical operation function\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}",
        "test_code": "TEST_CASE(\"applyOp function tests\") {\n    SECTION(\"Addition\") {\n        REQUIRE(applyOp(3, 4, '+') == 7);\n        REQUIRE(applyOp(-1, -1, '+') == -2);\n    }\n\n    SECTION(\"Subtraction\") {\n        REQUIRE(applyOp(10, 5, '-') == 5);\n        REQUIRE(applyOp(5, 10, '-') == -5);\n    }\n\n    SECTION(\"Multiplication\") {\n        REQUIRE(applyOp(3, 4, '*') == 12);\n        REQUIRE(applyOp(-2, 5, '*') == -10);\n    }\n\n    SECTION(\"Division\") {\n        REQUIRE(applyOp(8, 4, '/') == 2);\n        REQUIRE(applyOp(5, 2, '/') == 2.5);\n        REQUIRE_THROWS_AS(applyOp(5, 0, '/'), std::invalid_argument);\n    }\n\n    SECTION(\"Exponentiation\") {\n        REQUIRE(applyOp(2, 3, '^') == 8);\n        REQUIRE(applyOp(9, 0.5, '^') == 3); // Square root of 9\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 594,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "SchedulingApp\\7f9d94ec8f967f0ff876ea589be8e63abc378212\\model\\src\\Project.cpp\n",
    "question_type": "Data processing and transformation",
    "summary": "Splits a comma-separated string into individual tokens.",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}",
        "test_code": "TEST_CASE(\"splitComma function tests\") {\n    std::vector<std::string> result;\n\n    SECTION(\"Basic comma-separated values\") {\n        splitComma(\"apple,banana,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Leading and trailing whitespace\") {\n        splitComma(\"  apple , banana , orange  \", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Multiple consecutive commas\") {\n        splitComma(\"apple,,banana,,,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Empty input string\") {\n        splitComma(\"\", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Only whitespace input\") {\n        splitComma(\"   \", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Trailing commas\") {\n        splitComma(\"apple,banana,orange,\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 595,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "RCMS\\334326745eb8419775c4a37cd6094e022768c703\\appendices\\sales and costs and ratings generation\\generateSalesCosts.h\n",
    "question_type": "Data processing and transformation",
    "summary": "Returns the number of days in a given month of a given year.",
    "language_version_list": {
      "python": {
        "code_signature": "/**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}",
        "test_code": "TEST_CASE(\"Test getDaysInMonth function\") {\n    SECTION(\"Regular months\") {\n        REQUIRE(getDaysInMonth(2023, 1) == 31); // January\n        REQUIRE(getDaysInMonth(2023, 3) == 31); // March\n        REQUIRE(getDaysInMonth(2023, 4) == 30); // April\n        REQUIRE(getDaysInMonth(2023, 5) == 31); // May\n        REQUIRE(getDaysInMonth(2023, 6) == 30); // June\n        REQUIRE(getDaysInMonth(2023, 7) == 31); // July\n        REQUIRE(getDaysInMonth(2023, 8) == 31); // August\n        REQUIRE(getDaysInMonth(2023, 9) == 30); // September\n        REQUIRE(getDaysInMonth(2023, 10) == 31); // October\n        REQUIRE(getDaysInMonth(2023, 11) == 30); // November\n        REQUIRE(getDaysInMonth(2023, 12) == 31); // December\n    }\n\n    SECTION(\"February in leap year\") {\n        REQUIRE(getDaysInMonth(2024, 2) == 29); // Leap year\n    }\n\n    SECTION(\"February in non-leap year\") {\n        REQUIRE(getDaysInMonth(2023, 2) == 28); // Non-leap year\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 597,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "DERCOASTER\\0d84c3aba95774285b343b1293d7f2239854789d\\rgb_effects.c\n",
    "question_type": "Algorithm and data structure",
    "summary": "According to the input hue value (hue), calculate the corresponding RGB color value (red, green, blue\uff09\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}",
        "test_code": "TEST_CASE(\"Hue to RGB Conversion Tests\") {\n    SECTION(\"Hue 0 (Red)\") {\n        auto [r, g, b] = hueToRGB(0);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 120 (Green)\") {\n        auto [r, g, b] = hueToRGB(120);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 240 (Blue)\") {\n        auto [r, g, b] = hueToRGB(240);\n        REQUIRE(r == 0);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 60 (Yellow)\") {\n        auto [r, g, b] = hueToRGB(60);\n        REQUIRE(r == 255);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 180 (Cyan)\") {\n        auto [r, g, b] = hueToRGB(180);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 300 (Magenta)\") {\n        auto [r, g, b] = hueToRGB(300);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n}",
        "prompt": "please write a cpp function , the function signature as below #include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 598,
    "code_type": "class",
    "original_language": "c&cpp",
    "file_path": "DS_and_A\\69073cb2fcf6d9282896a4586c435685edf96754\\queues\\queue.c\n",
    "question_type": "Algorithm and data structure",
    "summary": "Using linked list to realize the queue of head and tail Pointers",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};",
        "test_code": "// Test cases for the Queue class\nTEST_CASE(\"Queue Operations\", \"[Queue]\") {\n    Queue queue;\n\n    SECTION(\"Queue should be empty initially\") {\n        REQUIRE(queue.isEmpty() == true);\n    }\n\n    SECTION(\"Enqueue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        REQUIRE(queue.isEmpty() == false);\n        REQUIRE(queue.front() == 10); // Front element should be 10\n    }\n\n    SECTION(\"Dequeue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        int value = queue.dequeue();\n        REQUIRE(value == 10); // First dequeued element should be 10\n        REQUIRE(queue.front() == 20); // Now front should be 20\n    }\n\n    SECTION(\"Dequeue from an empty queue\") {\n        int value = queue.dequeue();\n        REQUIRE(value == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Front element of an empty queue\") {\n        int frontValue = queue.front();\n        REQUIRE(frontValue == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Queue should become empty after dequeuing all elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        REQUIRE(queue.isEmpty() == true); // Queue should be empty\n    }\n}",
        "prompt": "please write a cpp class , the class signature as below #include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};",
        "addition_info": "struct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};"
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 599,
    "code_type": "class",
    "original_language": "c&cpp",
    "file_path": "DS_and_A\\22c1517527aeaa06e6a2d5925dfd9ff93aa83a7c\\heap\\max_heap.c\n",
    "question_type": "Algorithm and data structure",
    "summary": "Implement large root heap",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}",
        "test_code": "TEST_CASE(\"MaxHeap Operations\", \"[MaxHeap]\") {\n    MaxHeap maxHeap;\n\n    SECTION(\"Initial state of the heap\") {\n        REQUIRE(maxHeap.isEmpty() == true);\n        REQUIRE(maxHeap.size() == 0);\n    }\n\n    SECTION(\"Insert elements into the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        REQUIRE(maxHeap.isEmpty() == false);\n        REQUIRE(maxHeap.size() == 3);\n        REQUIRE(maxHeap.getMax() == 20); // The maximum should be 20\n    }\n\n    SECTION(\"Extract maximum element from the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        int maxElement = maxHeap.extractMax();\n        REQUIRE(maxElement == 30); // The maximum extracted should be 30\n        REQUIRE(maxHeap.getMax() == 20); // The next maximum should be 20\n        REQUIRE(maxHeap.size() == 2); // Size should be 2 after extraction\n    }\n\n    SECTION(\"Heap should maintain max heap property after multiple operations\") {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        REQUIRE(maxHeap.getMax() == 30);\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        REQUIRE(maxHeap.getMax() == 25);\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        REQUIRE(maxHeap.getMax() == 20);\n\n        // The size of the heap should be 3 now\n        REQUIRE(maxHeap.size() == 3);\n    }\n}",
        "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 601,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "CS360-F23-ClassRepo\\9c9817fa040663280681503557ea09e578b97b85\\c-lang\\wordcount.c",
    "question_type": "Data processing and transformation",
    "summary": "Count the number of words in a string",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}",
        "test_code": "// Test cases\nTEST_CASE(\"Count words in various strings\") {\n    SECTION(\"Empty string\") {\n        REQUIRE(countWords(\"\") == 0);\n    }\n\n    SECTION(\"String with only spaces\") {\n        REQUIRE(countWords(\"     \") == 0);\n    }\n\n    SECTION(\"Single word\") {\n        REQUIRE(countWords(\"Hello\") == 1);\n    }\n\n    SECTION(\"Multiple words with single spaces\") {\n        REQUIRE(countWords(\"This is a test string\") == 5);\n    }\n\n    SECTION(\"Multiple spaces between words\") {\n        REQUIRE(countWords(\"This    is   a   test   string\") == 5);\n    }\n\n    SECTION(\"Leading and trailing spaces\") {\n        REQUIRE(countWords(\"   Hello world!   \") == 2);\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 603,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "c4yourself\\83ed77d1bcc0073d3a2f9e686af54cc19acef054\\GCC\\leapyear.c\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Test whether a year is a leap year or a normal year\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}",
        "test_code": "TEST_CASE(\"Leap Year Test Cases\") {\n    SECTION(\"Divisible by 4 but not by 100\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2024) == true); // 2024 is a leap year\n        REQUIRE(isLeapYear(2000) == true); // 2000 is a leap year (divisible by 400)\n        REQUIRE(isLeapYear(1996) == true); // 1996 is a leap year\n        REQUIRE(isLeapYear(2004) == true); // 2004 is a leap year\n    }\n\n    SECTION(\"Divisible by 100 but not by 400\") {\n        // Years that are not leap years\n        REQUIRE(isLeapYear(1900) == false); // 1900 is not a leap year\n        REQUIRE(isLeapYear(2100) == false); // 2100 is not a leap year\n        REQUIRE(isLeapYear(1800) == false); // 1800 is not a leap year\n    }\n\n    SECTION(\"Divisible by 400\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2400) == true); // 2400 is a leap year\n        REQUIRE(isLeapYear(1600) == true); // 1600 is a leap year\n    }\n\n    SECTION(\"Normal years\") {\n        // Years that are normal years\n        REQUIRE(isLeapYear(1997) == false); // 1997 is not a leap year\n        REQUIRE(isLeapYear(1998) == false); // 1998 is not a leap year\n        REQUIRE(isLeapYear(1999) == false); // 1999 is not a leap year\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 604,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "Duke-ECE-551\\a8f52255e06d04d606aab7af4de5642a6592e5fc\\ece551\\029_power_rec\\power.c\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Tail-recursive function to calculate x raised to the power y.",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}",
        "test_code": "\nTEST_CASE(\"Power function test cases\") {\n    SECTION(\"Base cases\") {\n        // Test 0^0, should return 1 (by convention)\n        REQUIRE(power_tail(0, 0) == 1);\n\n        // Test x^0 for any x, should return 1\n        REQUIRE(power_tail(5, 0) == 1);\n        REQUIRE(power_tail(12345, 0) == 1);\n    }\n\n    SECTION(\"Power of one\") {\n        // Test 1^y for any y, should return 1\n        REQUIRE(power_tail(1, 5) == 1);\n        REQUIRE(power_tail(1, 123) == 1);\n    }\n\n    SECTION(\"Power of zero\") {\n        // Test 0^y for any y > 0, should return 0\n        REQUIRE(power_tail(0, 5) == 0);\n        REQUIRE(power_tail(0, 100) == 0);\n    }\n\n    SECTION(\"Positive powers\") {\n        // Test some positive powers\n        REQUIRE(power_tail(2, 3) == 8);     // 2^3 = 8\n        REQUIRE(power_tail(3, 4) == 81);    // 3^4 = 81\n        REQUIRE(power_tail(5, 2) == 25);     // 5^2 = 25\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 605,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "Proyecto_Menu\\5372f90d1dd4ea6ca571346d75a1aebc92d24685\\Usuario.h\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "calculate BMI\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}",
        "test_code": "// Test case for valid inputs with expected BMI value\nTEST_CASE(\"Valid BMI calculations\") {\n    SECTION(\"Normal weight\") {\n        REQUIRE(calculateBMI(70, 1.75) == Approx(22.86).epsilon(0.01)); // 70 kg, 1.75 m\n    }\n\n    SECTION(\"Underweight\") {\n        REQUIRE(calculateBMI(50, 1.75) == Approx(16.33).epsilon(0.01)); // 50 kg, 1.75 m\n    }\n\n    SECTION(\"Overweight\") {\n        REQUIRE(calculateBMI(80, 1.75) == Approx(26.12).epsilon(0.01)); // 80 kg, 1.75 m\n    }\n\n    SECTION(\"Obesity\") {\n        REQUIRE(calculateBMI(100, 1.75) == Approx(32.65).epsilon(0.01)); // 100 kg, 1.75 m\n    }\n}\n\n// Test case for invalid inputs\nTEST_CASE(\"Invalid BMI calculations\") {\n    SECTION(\"Negative weight\") {\n        REQUIRE_THROWS_AS(calculateBMI(-70, 1.75), std::invalid_argument); // Negative weight\n    }\n\n    SECTION(\"Zero height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, 0), std::invalid_argument); // Zero height\n    }\n\n    SECTION(\"Negative height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, -1.75), std::invalid_argument); // Negative height\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  },
  {
    "task_id": 606,
    "code_type": "method",
    "original_language": "c&cpp",
    "file_path": "dit639_cyber_physical_systems_and_sytems_of_systems\\e113255e5a4ec2d23af399253a3e78e0e8636d15\\src\\AngularVelocityAngleCalculator.cpp\n",
    "question_type": "Scientific computation and numerical analysis",
    "summary": "Calculate the corresponding steering angle based on the given angular velocity\n",
    "language_version_list": {
      "python": {
        "code_signature": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}",
        "test_code": "TEST_CASE(\"Calculate Steering Angle Tests\") {\n    const double wheelbase = 2.5; // Setting wheelbase constant for all tests\n\n    SECTION(\"Normal case\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Zero speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 0.0;           // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Negative speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = -5.0;          // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Zero angular velocity\") {\n        double angularVelocity = 0.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = 0.0;   // Steering angle should be zero\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Large values\") {\n        double angularVelocity = 100.0; // radians/second\n        double speed = 1000.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"High angular velocity\") {\n        double angularVelocity = 10.0; // radians/second\n        double speed = 1.0;             // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n}",
        "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}",
        "addition_info": ""
      },
      "javascript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "typescript": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "c&cpp": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      },
      "java": {
        "code_signature": "",
        "test_code": "",
        "prompt": "",
        "addition_info": ""
      }
    }
  }
]