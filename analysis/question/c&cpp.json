[
  {
    "task_id": 187,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * implement merge sort algorithms\n *\n * @param arr Pointer to the first element of the array to be sorted.\n * @param n The number of elements in the array.\n * @return Always returns true to indicate successful sorting (can be modified to handle errors).\n */\nbool merge_sort(double *arr, int n) {}",
    "test_code": "TEST_CASE(\"Merge Sort Test Cases\", \"[merge_sort]\") {\n    SECTION(\"Sorting an empty array\") {\n        std::vector<int> empty_array = {};\n        mergeSort(empty_array, 0, empty_array.size() - 1);\n        REQUIRE(empty_array.empty() == true);\n    }\n\n    SECTION(\"Sorting a single element array\") {\n        std::vector<int> single_element = {1};\n        mergeSort(single_element, 0, single_element.size() - 1);\n        REQUIRE(single_element == std::vector<int>{1});\n    }\n\n    SECTION(\"Sorting a sorted array\") {\n        std::vector<int> sorted_array = {1, 2, 3, 4, 5};\n        mergeSort(sorted_array, 0, sorted_array.size() - 1);\n        REQUIRE(sorted_array == std::vector<int>{1, 2, 3, 2, 5});\n    }\n\n    SECTION(\"Sorting a reverse sorted array\") {\n        std::vector<int> reverse_sorted_array = {5, 4, 3, 2, 1};\n        mergeSort(reverse_sorted_array, 0, reverse_sorted_array.size() - 1);\n        REQUIRE(reverse_sorted_array == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Sorting an array with random integers\") {\n        std::vector<int> random_array = {38, 27, 43, 3, 9, 82, 10};\n        std::vector<int> expected_sorted_array = {3, 9, 10, 27, 38, 43, 82};\n        mergeSort(random_array, 0, random_array.size() - 1);\n        REQUIRE(random_array == expected_sorted_array);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * implement merge sort algorithms\n *\n * @param arr Pointer to the first element of the array to be sorted.\n * @param n The number of elements in the array.\n * @return Always returns true to indicate successful sorting (can be modified to handle errors).\n */\nbool merge_sort(double *arr, int n) {}"
  },
  {
    "task_id": 188,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}",
    "test_code": "\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nTEST_CASE(\"Shell sort - Basic functionality\", \"[shellSort]\") {\n    SECTION(\"Test Case 1: Already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 2: Reverse sorted array\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 3: Array with duplicate elements\") {\n        std::vector<int> arr = {4, 2, 2, 4, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 4: Array with negative numbers\") {\n        std::vector<int> arr = {-3, -1, -4, -2, 0};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 5: Empty array\") {\n        std::vector<int> arr = {};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}"
  },
  {
    "task_id": 189,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * convert a byte array into a Base64 encoded string.\n * @param data\n * @return\n */\nstd::string base64_encode(const std::vector<unsigned char>& data) {\n\n}",
    "test_code": "TEST_CASE(\"Base64 Encode Tests\") {\n\n    SECTION(\"Empty input should return empty string\") {\n        std::vector<unsigned char> input = {};\n        REQUIRE(base64_encode(input) == \"\");\n    }\n\n    SECTION(\"Encoding 'hello' should return 'aGVsbG8='\") {\n        std::vector<unsigned char> input = {'h', 'e', 'l', 'l', 'o'};\n        REQUIRE(base64_encode(input) == \"aGVsbG8=\");\n    }\n\n    SECTION(\"Encoding 'world' should return 'd29ybGQ='\") {\n        std::vector<unsigned char> input = {'w', 'o', 'r', 'l', 'd'};\n        REQUIRE(base64_encode(input) == \"d29ybGQ=\");\n    }\n\n    SECTION(\"Encoding 'foobar' should return 'Zm9vYmFy'\") {\n        std::vector<unsigned char> input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        REQUIRE(base64_encode(input) == \"Zm9vYmFy\");\n    }\n\n    SECTION(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\") {\n        std::vector<unsigned char> input = {'C', 'a', 't', 'c', 'h', '2'};\n        REQUIRE(base64_encode(input) == \"Q2F0Y2gy\");\n    }\n\n    SECTION(\"Encoding single byte 'A' should return 'QQ=='\") {\n        std::vector<unsigned char> input = {'A'};\n        REQUIRE(base64_encode(input) == \"QQ==\");\n    }\n\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * convert a byte array into a Base64 encoded string.\n * @param data\n * @return\n */\nstd::string base64_encode(const std::vector<unsigned char>& data) {\n\n}"
  },
  {
    "task_id": 190,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}",
    "test_code": "TEST_CASE(\"Hexadecimal String to Float Conversion\", \"[hexStringToFloat]\") {\n\n    SECTION(\"Positive number: 40490FDB\") {\n        std::string hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Negative number: C0490FDB\") {\n        std::string hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Zero: 00000000\") {\n        std::string hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(0.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small positive number: 3F800000\") {\n        std::string hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(1.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small negative number: BF800000\") {\n        std::string hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-1.0f).epsilon(0.00001f));\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}"
  },
  {
    "task_id": 191,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Convert a floating-point number to a hexadecimal string. The process involves interpreting the bit pattern of the floating-point number as an unsigned integer and then formatting this integer value as a hexadecimal string without any prefix (like 0x). The output string should be 8 characters long, with leading zeros added if necessary to meet this length requirement.\n * @param value\n * @return\n */\nstd::string floatToHex(float value) {\n\n}",
    "test_code": "TEST_CASE(\"floatToHex tests\", \"[floatToHex]\") {\n    SECTION(\"Test with positive float 123.456\") {\n        float input = 123.456f;\n        std::string expected = \"42f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with negative float -123.456\") {\n        float input = -123.456f;\n        std::string expected = \"c2f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with zero\") {\n        float input = 0.0f;\n        std::string expected = \"00000000\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with small positive float 0.0001\") {\n        float input = 0.0001f;\n        std::string expected = \"38d1b717\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with large float 1e30\") {\n        float input = 1e30f;\n        std::string expected = \"7149f2ca\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Convert a floating-point number to a hexadecimal string. The process involves interpreting the bit pattern of the floating-point number as an unsigned integer and then formatting this integer value as a hexadecimal string without any prefix (like 0x). The output string should be 8 characters long, with leading zeros added if necessary to meet this length requirement.\n * @param value\n * @return\n */\nstd::string floatToHex(float value) {\n\n}"
  },
  {
    "task_id": 192,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}",
    "test_code": "TEST_CASE(\"hexStringToUnsignedInt converts hex string to unsigned int\", \"[hexStringToUnsignedInt]\") {\n\n    SECTION(\"Valid hex strings\") {\n        REQUIRE(hexStringToUnsignedInt(\"1A3F\") == 6719); // 1A3F in hex is 6719 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"FFFF\") == 65535); // FFFF in hex is 65535 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"0\") == 0); // 0 in hex is 0 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"7F\") == 127); // 7F in hex is 127 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"ABC123\") == 11256099); // ABC123 in hex is 11256099 in decimal\n    }\n\n    SECTION(\"Lowercase hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"abcd\") == 43981); // abcd in hex is 43981 in decimal\n    }\n\n    SECTION(\"Hex string with leading zeroes\") {\n        REQUIRE(hexStringToUnsignedInt(\"0001\") == 1); // 0001 in hex is 1 in decimal\n    }\n\n    SECTION(\"Empty hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"\") == 0); // Empty string should be treated as 0\n    }\n\n    SECTION(\"Mixed case hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"AbCdEf\") == 11259375); // AbCdEf in hex is 11259375 in decimal\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}"
  },
  {
    "task_id": 193,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}",
    "test_code": "TEST_CASE(\"convFlags Test Cases\", \"[convFlags]\") {\n    // Test Case 1: All bits set (0xFFFFFFFF)\n    REQUIRE(convFlags(0xFFFFFFFF) == \"ffffffe0\");\n\n    // Test Case 2: No bits set (0x00000000)\n    REQUIRE(convFlags(0x00000000) == \"1f\");\n\n    // Test Case 3: Inverting first five bits only (0x0000001F)\n    REQUIRE(convFlags(0x0000001F) == \"0\");\n\n    // Test Case 4: Inverting first five bits of a random value (0x00000015)\n    REQUIRE(convFlags(0x00000015) == \"a\");\n\n    // Test Case 5: Inverting first five bits of a large number (0xFFFFFFE0)\n    REQUIRE(convFlags(0xFFFFFFE0) == \"ffffffff\");\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}"
  },
  {
    "task_id": 194,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}",
    "test_code": "\nTEST_CASE(\"return_string Test Cases\", \"[return_string]\") {\n    // Test Case 1: Copy a non-empty string\n    const char* original1 = \"Hello, World!\";\n    char* copy1 = return_string(original1);\n    REQUIRE(std::strcmp(copy1, original1) == 0);\n    delete[] copy1;\n\n    // Test Case 2: Copy an empty string\n    const char* original2 = \"\";\n    char* copy2 = return_string(original2);\n    REQUIRE(std::strcmp(copy2, original2) == 0);\n    delete[] copy2;\n\n    // Test Case 3: Copy a string with special characters\n    const char* original3 = \"C++ is fun! @#$%^&*()\";\n    char* copy3 = return_string(original3);\n    REQUIRE(std::strcmp(copy3, original3) == 0);\n    delete[] copy3;\n\n    // Test Case 4: Copy a single character string\n    const char* original4 = \"A\";\n    char* copy4 = return_string(original4);\n    REQUIRE(std::strcmp(copy4, original4) == 0);\n    delete[] copy4;\n\n    // Test Case 5: Passing a null pointer (should throw an exception)\n    REQUIRE_THROWS_AS(return_string(nullptr), std::invalid_argument);\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}"
  },
  {
    "task_id": 195,
    "code_type": "class",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};",
    "test_code": "TEST_CASE(\"stack_t Test Cases\", \"[stack_t]\") {\n    stack_t stack;\n\n    // Test Case 1: Pushing and popping a single element\n    stack.push(3.14f);\n    REQUIRE(stack.pop() == Approx(3.14f));\n    REQUIRE(stack.isEmpty() == true);\n\n    // Test Case 2: Pushing multiple elements and checking peek\n    stack.push(1.23f);\n    stack.push(4.56f);\n    REQUIRE(stack.peek() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(1.23f));\n    REQUIRE(stack.isEmpty() == true);\n\n    // Test Case 3: Pop from an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.pop(), std::underflow_error);\n\n    // Test Case 4: Peek on an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.peek(), std::underflow_error);\n\n    // Test Case 5: Push elements until stack is full and attempt to push another element\n    stack_t fullStack;\n    for (int i = 0; i < 100; ++i) {\n        fullStack.push(static_cast<float>(i) + 0.5f);\n    }\n    REQUIRE_THROWS_AS(fullStack.push(100.5f), std::overflow_error);\n}",
    "prompt": "please write a c&cpp class this class signature as below /**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};"
  },
  {
    "task_id": 196,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}",
    "test_code": "TEST_CASE(\"Sieve of Eratosthenes Test Cases\", \"[generatePrimes]\") {\n    // Test Case 1: Small limit (10)\n    std::vector<int> expected1 = {2, 3, 5, 7};\n    REQUIRE(generatePrimes(10) == expected1);\n\n    // Test Case 2: Prime limit (29)\n    std::vector<int> expected2 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(29) == expected2);\n\n    // Test Case 3: Non-prime limit (30)\n    std::vector<int> expected3 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(30) == expected3);\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    std::vector<int> expected4 = {2};\n    REQUIRE(generatePrimes(2) == expected4);\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    REQUIRE_THROWS_AS(generatePrimes(1), std::invalid_argument);\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}"
  },
  {
    "task_id": 197,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}",
    "test_code": "TEST_CASE(\"FindOrder Test Cases\", \"[findOrder]\") {\n    // Test Case 1: Minimum valid input with 2 players\n    REQUIRE(findOrder(2) == vector<int>{2, 1});\n\n    // Test Case 2: 3 players\n    REQUIRE(findOrder(3) == vector<int>{2, 3, 1});\n\n    // Test Case 3: 5 players\n    REQUIRE(findOrder(5) == vector<int>{2, 5, 4, 1, 3});\n\n    // Test Case 4: 7 players\n    REQUIRE(findOrder(7) == vector<int>{2, 5, 1, 6, 4, 7, 3});\n\n    // Test Case 5: 10 players\n    REQUIRE(findOrder(10) == vector<int>{2, 5, 8, 1, 6, 4, 7, 10, 3, 9});\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}"
  },
  {
    "task_id": 198,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}",
    "test_code": "TEST_CASE(\"General case\", \"[findMaxDifference]\") {\n    vector<int> l = {2, 3, 10, 6, 4, 8, 1};\n    REQUIRE(findMaxDifference(l) == 8);  // \u6700\u5927\u5dee\u503c\u662f 10 - 2 = 8\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 2: \u9012\u51cf\u5e8f\u5217\nTEST_CASE(\"Decreasing sequence\", \"[findMaxDifference]\") {\n    vector<int> l = {10, 9, 8, 7, 6, 5};\n    REQUIRE(findMaxDifference(l) == -1);  // \u6700\u5927\u5dee\u503c\u662f 9 - 10 = -1\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 3: \u5168\u90e8\u76f8\u540c\u5143\u7d20\nTEST_CASE(\"All elements the same\", \"[findMaxDifference]\") {\n    vector<int> l = {5, 5, 5, 5, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // \u6700\u5927\u5dee\u503c\u662f 5 - 5 = 0\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 4: \u53ea\u6709\u4e24\u4e2a\u5143\u7d20\nTEST_CASE(\"Only two elements\", \"[findMaxDifference]\") {\n    vector<int> l = {3, 8};\n    REQUIRE(findMaxDifference(l) == 5);  // \u6700\u5927\u5dee\u503c\u662f 8 - 3 = 5\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 5: \u53ea\u6709\u4e00\u4e2a\u5143\u7d20\nTEST_CASE(\"Single element\", \"[findMaxDifference]\") {\n    vector<int> l = {4};\n    REQUIRE(findMaxDifference(l) == numeric_limits<int>::min());  // \u53ea\u6709\u4e00\u4e2a\u5143\u7d20\uff0c\u65e0\u6cd5\u8ba1\u7b97\u5dee\u503c\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}"
  },
  {
    "task_id": 200,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * string token_manager::extract_json(const std::string& input)\n *\n * @param input json str\n * @return the extracted JSON object or an empty string\n */\nstring token_manager::extract_json(const std::string& input){}",
    "test_code": "TEST_CASE(\"JSON extraction tests\", \"[extract_json]\") {\n\n    SECTION(\"Basic JSON extraction\") {\n        std::string input = \"Here is a JSON: {\\\"key\\\": \\\"value\\\"} with text.\";\n        std::string expected = \"{\\\"key\\\": \\\"value\\\"}\";\n        REQUIRE(token_manager::extract_json(input) == expected);\n    }\n\n    SECTION(\"Nested braces JSON extraction\") {\n        std::string input = \"Prefix {\\\"outer\\\": {\\\"inner\\\": \\\"value\\\"}} Suffix\";\n        std::string expected = \"{\\\"outer\\\": {\\\"inner\\\": \\\"value\\\"}}\";\n        REQUIRE(token_manager::extract_json(input) == expected);\n    }\n\n    SECTION(\"No braces in input\") {\n        std::string input = \"No JSON here.\";\n        std::string expected = \"\";\n        REQUIRE(token_manager::extract_json(input) == expected);\n    }\n\n    SECTION(\"Only opening brace\") {\n        std::string input = \"Starts with a brace { but no closing one.\";\n        std::string expected = \"\";\n        REQUIRE(token_manager::extract_json(input) == expected);\n    }\n\n    SECTION(\"Only closing brace\") {\n        std::string input = \"Ends with a brace } but no opening one.\";\n        std::string expected = \"\";\n        REQUIRE(token_manager::extract_json(input) == expected);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * string token_manager::extract_json(const std::string& input)\n *\n * @param input json str\n * @return the extracted JSON object or an empty string\n */\nstring token_manager::extract_json(const std::string& input){}"
  },
  {
    "task_id": 203,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}",
    "test_code": "TEST_CASE(\"Test reverseRange function\") {\n    SECTION(\"Reverse entire vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 0, 4);\n        std::vector<int> expected = {5, 4, 3, 2, 1};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse subrange in the middle\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8};\n        reverseRange(v, 2, 5);\n        std::vector<int> expected = {1, 2, 6, 5, 4, 3, 7, 8};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse a single element range\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 2, 2);\n        std::vector<int> expected = {1, 2, 3, 4, 5};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range with invalid indices\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, -1, 3);  // Invalid start index\n        std::vector<int> expected = {1, 2, 3, 4, 5}; // No change\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range at the end of the vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6};\n        reverseRange(v, 3, 5);\n        std::vector<int> expected = {1, 2, 3, 6, 5, 4};\n        REQUIRE(v == expected);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}"
  },
  {
    "task_id": 204,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}",
    "test_code": "TEST_CASE(\"splitString function\") {\n\n    SECTION(\"Split a regular sentence\") {\n        std::string input = \"Hello world from Catch2\";\n        std::vector<std::string> expected = {\"Hello\", \"world\", \"from\", \"Catch2\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Handle multiple spaces\") {\n        std::string input = \"Multiple   spaces between words\";\n        std::vector<std::string> expected = {\"Multiple\", \"spaces\", \"between\", \"words\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Single word input\") {\n        std::string input = \"Single\";\n        std::vector<std::string> expected = {\"Single\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Empty string input\") {\n        std::string input = \"\";\n        std::vector<std::string> expected = {};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"String with leading and trailing spaces\") {\n        std::string input = \"   Leading and trailing spaces   \";\n        std::vector<std::string> expected = {\"Leading\", \"and\", \"trailing\", \"spaces\"};\n        REQUIRE(splitString(input) == expected);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}"
  },
  {
    "task_id": 205,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}",
    "test_code": "TEST_CASE(\"getCurrentDate function\") {\n\n    SECTION(\"Correct format YYYY-MM-DD\") {\n        std::string currentDate = getCurrentDate();\n        REQUIRE(currentDate.length() == 10);\n        REQUIRE(currentDate[4] == '-');\n        REQUIRE(currentDate[7] == '-');\n    }\n\n    SECTION(\"Returns correct year\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentYear = now->tm_year + 1900;\n\n        std::string currentDate = getCurrentDate();\n        std::string yearPart = currentDate.substr(0, 4);\n\n        REQUIRE(std::stoi(yearPart) == currentYear);\n    }\n\n    SECTION(\"Returns correct month\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentMonth = now->tm_mon + 1;\n\n        std::string currentDate = getCurrentDate();\n        std::string monthPart = currentDate.substr(5, 2);\n\n        REQUIRE(std::stoi(monthPart) == currentMonth);\n    }\n\n    SECTION(\"Returns correct day\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentDay = now->tm_mday;\n\n        std::string currentDate = getCurrentDate();\n        std::string dayPart = currentDate.substr(8, 2);\n\n        REQUIRE(std::stoi(dayPart) == currentDay);\n    }\n\n    SECTION(\"Consistency of output within the same second\") {\n        std::string firstCall = getCurrentDate();\n        std::string secondCall = getCurrentDate();\n        REQUIRE(firstCall == secondCall);\n    }\n}\n",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}"
  },
  {
    "task_id": 206,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}",
    "test_code": "TEST_CASE(\"Testing circleIntersectionArea function\") {\n    const double tolerance = 1e-5;\n\n    SECTION(\"No overlap, circles far apart\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"No overlap, circles just touching\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"Partial overlap\") {\n    double area = circleIntersectionArea(0.0, 0.0, 3.0, 4.0, 0.0, 3.0);\n    REQUIRE(area == Approx(6.19496).epsilon(tolerance)); // Updated expected value based on actual function output\n    }\n\n    SECTION(\"One circle inside the other\") {\n        double area = circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of smaller circle\n    }\n\n    SECTION(\"Identical circles, full overlap\") {\n        double area = circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of one circle\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}"
  },
  {
    "task_id": 207,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}",
    "test_code": "TEST_CASE(\"Testing minChangesToSymmetric function\") {\n\n    SECTION(\"Already Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'b', 'e', 'f'},\n            {'c', 'f', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"One Change Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'c', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 2);\n    }\n\n    SECTION(\"All Different Elements\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'g', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 3);\n    }\n\n    SECTION(\"Large Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c', 'd'},\n            {'b', 'e', 'f', 'g'},\n            {'c', 'f', 'h', 'i'},\n            {'d', 'g', 'i', 'j'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"Multiple Changes Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'x', 'c', 'd'},\n            {'y', 'e', 'f', 'g'},\n            {'z', 'h', 'i', 'j'},\n            {'d', 'g', 'k', 'l'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 4);\n    }\n}\n",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}"
  },
  {
    "task_id": 208,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Implement a priority queue\n */\nclass PriorityQueue {\npublic:\n    // Constructor\n    PriorityQueue() {}\n\n    // Function to insert a new element into the priority queue\n    void insert(int value) {\n\n    }\n\n    // Function to get and remove the minimum element from the priority queue\n    int extractMin() {\n\n    }\n\n    // Function to peek at the minimum element without removing it\n    int peekMin() const {\n\n    }\n\n    // Function to check if the priority queue is empty\n    bool isEmpty() const {\n\n    }\n\n    // Function to get the size of the priority queue\n    int size() const {\n\n    }\n\n    // Function to print the contents of the priority queue (for debugging purposes)\n    void print() const {\n\n    }\n};\n",
    "test_code": "// Test Case 1: Test insertion and extraction of the minimum element\nTEST_CASE(\"Insertion and extraction of minimum element\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Inserting elements into the priority queue\") {\n        pq.insert(5);\n        pq.insert(2);\n        pq.insert(8);\n        pq.insert(1);\n        pq.insert(3);\n\n        REQUIRE(pq.size() == 5);\n        REQUIRE(pq.peekMin() == 1);\n    }\n\n    SECTION(\"Extracting the minimum element\") {\n        pq.insert(5);\n        pq.insert(2);\n        pq.insert(8);\n        pq.insert(1);\n        pq.insert(3);\n\n        REQUIRE(pq.extractMin() == 1);\n        REQUIRE(pq.extractMin() == 2);\n        REQUIRE(pq.extractMin() == 3);\n        REQUIRE(pq.extractMin() == 5);\n        REQUIRE(pq.extractMin() == 8);\n        REQUIRE(pq.isEmpty() == true);\n    }\n}\n\n// Test Case 2: Test peekMin operation\nTEST_CASE(\"Peek minimum element\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Peeking at the minimum element without extraction\") {\n        pq.insert(10);\n        pq.insert(4);\n        pq.insert(15);\n\n        REQUIRE(pq.peekMin() == 4);\n        REQUIRE(pq.size() == 3); // Size should remain the same\n        REQUIRE(pq.peekMin() == 4); // Peek should not remove the element\n    }\n}\n\n// Test Case 3: Test edge case of extracting from an empty queue\nTEST_CASE(\"Extract from empty queue\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Attempting to extract from an empty queue should throw an exception\") {\n        REQUIRE_THROWS_AS(pq.extractMin(), std::runtime_error);\n    }\n}\n\n// Test Case 4: Test isEmpty function\nTEST_CASE(\"Check if the priority queue is empty\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Newly created queue should be empty\") {\n        REQUIRE(pq.isEmpty() == true);\n    }\n\n    SECTION(\"Queue should not be empty after insertion\") {\n        pq.insert(7);\n        REQUIRE(pq.isEmpty() == false);\n    }\n\n    SECTION(\"Queue should be empty after extracting all elements\") {\n        pq.insert(7);\n        pq.extractMin();\n        REQUIRE(pq.isEmpty() == true);\n    }\n}\n\n// Test Case 5: Test multiple insertions and order of extraction\nTEST_CASE(\"Multiple insertions and extraction order\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Inserting multiple elements and checking extraction order\") {\n        pq.insert(9);\n        pq.insert(4);\n        pq.insert(6);\n        pq.insert(1);\n        pq.insert(8);\n\n        std::vector<int> extractedElements;\n        while (!pq.isEmpty()) {\n            extractedElements.push_back(pq.extractMin());\n        }\n\n        std::vector<int> expectedOrder = {1, 4, 6, 8, 9};\n        REQUIRE(extractedElements == expectedOrder);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Implement a priority queue\n */\nclass PriorityQueue {\npublic:\n    // Constructor\n    PriorityQueue() {}\n\n    // Function to insert a new element into the priority queue\n    void insert(int value) {\n\n    }\n\n    // Function to get and remove the minimum element from the priority queue\n    int extractMin() {\n\n    }\n\n    // Function to peek at the minimum element without removing it\n    int peekMin() const {\n\n    }\n\n    // Function to check if the priority queue is empty\n    bool isEmpty() const {\n\n    }\n\n    // Function to get the size of the priority queue\n    int size() const {\n\n    }\n\n    // Function to print the contents of the priority queue (for debugging purposes)\n    void print() const {\n\n    }\n};\n"
  },
  {
    "task_id": 209,
    "code_type": "class",
    "code_language": "c&cpp",
    "code_signature": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n",
    "test_code": "TEST_CASE(\"LinkedList operations\", \"[LinkedList]\") {\n\n    SECTION(\"Insertion at the head\") {\n        LinkedList list;\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 30 -> 20 -> 10 -> nullptr\n        REQUIRE(list.search(10) == true);\n        REQUIRE(list.search(20) == true);\n        REQUIRE(list.search(30) == true);\n        REQUIRE(list.search(40) == false);\n    }\n\n    SECTION(\"Insertion at the tail\") {\n        LinkedList list;\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 1 -> 2 -> 3 -> nullptr\n        REQUIRE(list.search(1) == true);\n        REQUIRE(list.search(2) == true);\n        REQUIRE(list.search(3) == true);\n        REQUIRE(list.search(4) == false);\n    }\n\n    SECTION(\"Deletion of elements\") {\n        LinkedList list;\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        std::ostringstream output;\n        list.printList(); // Expected: 15 -> 5 -> nullptr\n        REQUIRE(list.search(10) == false);\n        REQUIRE(list.search(15) == true);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(15);\n        list.printList(); // Expected: 5 -> nullptr\n        REQUIRE(list.search(15) == false);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(5);\n        list.printList(); // Expected: nullptr\n        REQUIRE(list.search(5) == false);\n    }\n\n    SECTION(\"Search functionality\") {\n        LinkedList list;\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        REQUIRE(list.search(100) == true);\n        REQUIRE(list.search(200) == true);\n        REQUIRE(list.search(300) == true);\n        REQUIRE(list.search(400) == false);\n    }\n\n    SECTION(\"Edge case: Empty list\") {\n        LinkedList list;\n\n        REQUIRE(list.search(1) == false);  // Searching in an empty list\n        list.deleteValue(1);               // Deleting from an empty list should not crash\n        std::ostringstream output;\n        list.printList();                  // Expected: nullptr (still empty)\n    }\n}",
    "prompt": "please write a c&cpp class this class signature as below struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n"
  },
  {
    "task_id": 210,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}",
    "test_code": "// Test function for iterative, recursive, and memoization Fibonacci\nTEST_CASE(\"Fibonacci sequence\", \"[fibonacci]\") {\n    // Test Case 1: Fibonacci of 0\n    SECTION(\"Fibonacci(0) should be 0\") {\n        REQUIRE(fibonacciRecursive(0) == 0);\n    }\n\n    // Test Case 2: Fibonacci of 1\n    SECTION(\"Fibonacci(1) should be 1\") {\n        REQUIRE(fibonacciRecursive(1) == 1);\n    }\n\n    // Test Case 3: Fibonacci of 5\n    SECTION(\"Fibonacci(5) should be 5\") {\n        REQUIRE(fibonacciRecursive(5) == 5);\n    }\n\n    // Test Case 4: Fibonacci of 10\n    SECTION(\"Fibonacci(10) should be 55\") {\n        REQUIRE(fibonacciRecursive(10) == 55);\n    }\n\n    // Test Case 5: Fibonacci of 20\n    SECTION(\"Fibonacci(20) should be 6765\") {\n        REQUIRE(fibonacciRecursive(20) == 6765);\n    }\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}"
  },
  {
    "task_id": 356,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}",
    "test_code": "TEST_CASE(\"BubbleSort Test Cases\", \"[bubbleSort]\") {\n    // Test Case 1: Sorting an already sorted array\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    bubbleSort(arr1);\n    REQUIRE(arr1 == vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 2: Sorting a reverse sorted array\n    vector<int> arr2 = {5, 4, 3, 2, 1};\n    bubbleSort(arr2);\n    REQUIRE(arr2 == vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 3: Sorting an array with duplicate elements\n    vector<int> arr3 = {3, 1, 2, 3, 2};\n    bubbleSort(arr3);\n    REQUIRE(arr3 == vector<int>{1, 2, 2, 3, 3});\n\n    // Test Case 4: Sorting an array with a single element\n    vector<int> arr4 = {1};\n    bubbleSort(arr4);\n    REQUIRE(arr4 == vector<int>{1});\n\n    // Test Case 5: Sorting an empty array\n    vector<int> arr5 = {};\n    bubbleSort(arr5);\n    REQUIRE(arr5 == vector<int>{});\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}"
  },
  {
    "task_id": 357,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Implements a generic Hill sorting algorithm and returns a custom struct Sort_stats, including the algorithm name, array size, number of comparisons, and run time\n *\n * @tparam T The type of elements in the vector.\n * @param v A reference to the vector to be sorted.\n * @return A Sort_stats struct containing the sorting statistics.\n */\ntemplate <typename T>\nSort_stats shell_sort(vector<T>& v) {\n\t\n}",
    "test_code": "TEST_CASE(\"ShellSort Test Cases\", \"[shell_sort]\") {\n    // Test Case 1: Sorting an already sorted array\n    vector<int> arr1 = {1, 2, 3, 4, 5};\n    Sort_stats stats1 = shell_sort(arr1);\n    REQUIRE(arr1 == vector<int>{1, 2, 3, 4, 5});\n    REQUIRE(stats1.algorithm_name == \"Shell sort\");\n    REQUIRE(stats1.array_size == 5);\n    REQUIRE(stats1.comparisons > 0);\n    REQUIRE(stats1.run_time >= 0);\n\n    // Test Case 2: Sorting a reverse sorted array\n    vector<int> arr2 = {5, 4, 3, 2, 1};\n    Sort_stats stats2 = shell_sort(arr2);\n    REQUIRE(arr2 == vector<int>{1, 2, 3, 4, 5});\n    REQUIRE(stats2.algorithm_name == \"Shell sort\");\n    REQUIRE(stats2.array_size == 5);\n    REQUIRE(stats2.comparisons > 0);\n    REQUIRE(stats2.run_time >= 0);\n\n    // Test Case 3: Sorting an array with duplicate elements\n    vector<int> arr3 = {3, 1, 2, 3, 2};\n    Sort_stats stats3 = shell_sort(arr3);\n    REQUIRE(arr3 == vector<int>{1, 2, 2, 3, 3});\n    REQUIRE(stats3.algorithm_name == \"Shell sort\");\n    REQUIRE(stats3.array_size == 5);\n    REQUIRE(stats3.comparisons > 0);\n    REQUIRE(stats3.run_time >= 0);\n\n    // Test Case 4: Sorting an array with a single element\n    vector<int> arr4 = {1};\n    Sort_stats stats4 = shell_sort(arr4);\n    REQUIRE(arr4 == vector<int>{1});\n    REQUIRE(stats4.algorithm_name == \"Shell sort\");\n    REQUIRE(stats4.array_size == 1);\n    REQUIRE(stats4.comparisons == 0);  // No comparisons should be needed\n    REQUIRE(stats4.run_time >= 0);\n\n    // Test Case 5: Sorting an empty array\n    vector<int> arr5 = {};\n    Sort_stats stats5 = shell_sort(arr5);\n    REQUIRE(arr5 == vector<int>{});\n    REQUIRE(stats5.algorithm_name == \"Shell sort\");\n    REQUIRE(stats5.array_size == 0);\n    REQUIRE(stats5.comparisons == 0);  // No comparisons should be needed\n    REQUIRE(stats5.run_time >= 0);\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Implements a generic Hill sorting algorithm and returns a custom struct Sort_stats, including the algorithm name, array size, number of comparisons, and run time\n *\n * @tparam T The type of elements in the vector.\n * @param v A reference to the vector to be sorted.\n * @return A Sort_stats struct containing the sorting statistics.\n */\ntemplate <typename T>\nSort_stats shell_sort(vector<T>& v) {\n\t\n}"
  },
  {
    "task_id": 358,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}",
    "test_code": "TEST_CASE(\"sortNames Test Cases\", \"[sortNames]\") {\n    // Test Case 1: Simple case with different numbers\n    vector<string> arr1 = {\"Alice10\", \"Bob2\", \"Charlie7\"};\n    vector<string> expected1 = {\"Bob2\", \"Charlie7\", \"Alice10\"};\n    REQUIRE(sortNames(arr1) == expected1);\n\n    // Test Case 2: Same numbers, different names\n    vector<string> arr2 = {\"Alice10\", \"Charlie10\", \"Bob10\"};\n    vector<string> expected2 = {\"Alice10\", \"Bob10\", \"Charlie10\"};\n    REQUIRE(sortNames(arr2) == expected2);\n\n    // Test Case 3: Mixed case with different names and numbers\n    vector<string> arr3 = {\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"};\n    vector<string> expected3 = {\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"};\n    REQUIRE(sortNames(arr3) == expected3);\n\n    // Test Case 4: Single element\n    vector<string> arr4 = {\"Alice5\"};\n    vector<string> expected4 = {\"Alice5\"};\n    REQUIRE(sortNames(arr4) == expected4);\n\n    // Test Case 5: Empty array\n    vector<string> arr5 = {};\n    vector<string> expected5 = {};\n    REQUIRE(sortNames(arr5) == expected5);\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}"
  },
  {
    "task_id": 359,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}",
    "test_code": "\nTEST_CASE(\"TrapezoidalRule Test Cases\", \"[trapezoidal_rule]\") {\n    // Test Case 1: Integration of a constant function (f(x) = 1) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return 1.0; }, 0.0, 1.0, 100) == Approx(1.0).epsilon(1e-6));\n\n    // Test Case 2: Integration of a linear function (f(x) = x) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x; }, 0.0, 1.0, 100) == Approx(0.5).epsilon(1e-6));\n\n    // Test Case 3: Integration of a quadratic function (f(x) = x^2) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x * x; }, 0.0, 1.0, 1000) == Approx(1.0 / 3.0).epsilon(1e-6));\n\n    // Test Case 4: Integration of the sine function (f(x) = sin(x)) over [0, \u03c0]\n    REQUIRE(trapezoidal_rule([](double x) { return std::sin(x); }, 0.0, M_PI, 1000) == Approx(2.0).epsilon(1e-6));\n\n    // Test Case 5: Integration of an exponential function (f(x) = exp(x)) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return std::exp(x); }, 0.0, 1.0, 1000) == Approx(std::exp(1.0) - 1.0).epsilon(1e-6));\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}"
  },
  {
    "task_id": 360,
    "code_type": "method",
    "code_language": "c&cpp",
    "code_signature": "/**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}",
    "test_code": "TEST_CASE(\"getLastPartOfFilepath Test Cases\", \"[getLastPartOfFilepath]\") {\n    // Test Case 1: Unix-style path with '/'\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/file.txt\") == \"file.txt\");\n\n    // Test Case 2: Windows-style path with '\\\\'\n    REQUIRE(getLastPartOfFilepath(\"C:\\\\Users\\\\JohnDoe\\\\Documents\\\\file.txt\") == \"file.txt\");\n\n    // Test Case 3: Path without any separators (should return the original string)\n    REQUIRE(getLastPartOfFilepath(\"file.txt\") == \"file.txt\");\n\n    // Test Case 4: Path ending with a separator (should return an empty string)\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/\") == \"\");\n\n    // Test Case 5: Path with mixed separators (should return the last part after the last separator)\n    REQUIRE(getLastPartOfFilepath(\"C:/Users\\\\JohnDoe/Documents/file.txt\") == \"file.txt\");\n}",
    "prompt": "please write a c&cpp function the function signature as below /**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}"
  }
]