[
  {
    "task_id": 183,
    "code_type": "method",
    "code_signature": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Ray-Circle Intersection Tests\") {\n    // Test Case 1: The ray intersects the circle at two points\n    {\n        Ray ray = {{0, 0}, {1, 1}}; // Origin at (0, 0), direction (1, 1)\n        Circle circle = {{3, 3}, 2}; // Circle center at (3, 3), radius 2\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 2: The ray is tangent to the circle (one intersection point)\n    {\n        Ray ray = {{2, 0}, {0, 1}}; // Origin at (2, 0), direction (0, 1)\n        Circle circle = {{2, 2}, 1}; // Circle center at (2, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 3: The ray starts inside the circle (one intersection point)\n    {\n        Ray ray = {{2, 2}, {1, 0}}; // Origin at (2, 2), direction (1, 0)\n        Circle circle = {{3, 2}, 1}; // Circle center at (3, 2), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 4: The ray originates outside and goes away from the circle (no intersection)\n    {\n        Ray ray = {{5, 5}, {1, 0}}; // Origin at (5, 5), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == false);\n    }\n\n    // Test Case 5: The ray is parallel to the line connecting the center of the circle and is outside (no intersection)\n    {\n        Ray ray = {{0, 3}, {1, 0}}; // Origin at (0, 3), direction (1, 0)\n        Circle circle = {{3, 3}, 1}; // Circle center at (3, 3), radius 1\n        REQUIRE(intersects(ray, circle) == true);\n    }\n\n    // Test Case 6: The ray intersects the circle at one point when passing through the center\n    {\n        Ray ray = {{3, 0}, {0, 1}}; // Origin at (3, 0), direction (0, 1)\n        Circle circle = {{3, 3}, 3}; // Circle center at (3, 3), radius 3\n        REQUIRE(intersects(ray, circle) == true);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};\n\n/**\n * @brief Determines whether a ray intersects with a circle.\n *\n * This function checks if a given ray intersects with a specified circle\n * in a 2D space. It performs mathematical calculations to determine if\n * the ray, defined by its origin and direction, crosses the area of the\n * circle defined by its center and radius.\n *\n * @param ray The ray to be tested for intersection. It is assumed to\n * contain properties such as an origin point and a direction vector.\n * @param circle The circle to check for intersection. It is assumed to\n * contain properties such as a center point and a radius.\n *\n * @return true if the ray intersects the circle; false otherwise.\n */\nbool intersects(const Ray& ray, const Circle& circle) {}",
    "addition_info": "#include <iostream>\n#include <cmath>\n\nstruct Point {\n    float x, y;\n};\n\nstruct Ray {\n    Point origin;   // Starting point of the ray\n    Point direction; // Direction of the ray (should be normalized)\n};\n\nstruct Circle {\n    Point center; // Center of the circle\n    float radius; // Radius of the circle\n};"
  },
  {
    "task_id": 184,
    "code_type": "class",
    "code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Priority Queue - Test Cases\") {\n    PriorityQueue pq;\n\n    SECTION(\"Insert and access maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n        pq.push(15);\n\n        REQUIRE(pq.top() == 30); // Ensure the max element is 30\n    }\n\n    SECTION(\"Remove maximum element\") {\n        pq.push(10);\n        pq.push(20);\n        pq.push(5);\n        pq.push(30);\n\n        pq.pop(); // Remove 30\n        REQUIRE(pq.top() == 20); // Now the max should be 20\n        pq.pop(); // Remove 20\n        REQUIRE(pq.top() == 10); // Now the max should be 10\n    }\n\n    SECTION(\"Check empty queue\") {\n        REQUIRE(pq.isEmpty() == true); // Initially empty\n        pq.push(10);\n        REQUIRE(pq.isEmpty() == false); // Now not empty\n        pq.pop();\n        REQUIRE(pq.isEmpty() == true); // Back to empty\n    }\n\n    SECTION(\"Pop from empty queue\") {\n        REQUIRE_THROWS_AS(pq.pop(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Access top of empty queue\") {\n        REQUIRE_THROWS_AS(pq.top(), std::runtime_error); // Should throw an error\n    }\n\n    SECTION(\"Maintain max-heap property\") {\n        pq.push(3);\n        pq.push(1);\n        pq.push(4);\n        pq.push(2);\n\n        REQUIRE(pq.top() == 4); // Ensure max is 4\n\n        pq.pop(); // Remove 4\n        REQUIRE(pq.top() == 3); // Now max is 3\n\n        pq.push(5); // Add 5\n        REQUIRE(pq.top() == 5); // Ensure max is now 5\n    }\n}",
    "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass PriorityQueue {\nprivate:\n    std::vector<int> heap; // This will store the elements of the heap\n\n    // Helper function to get the index of the parent\n    int parent(int index) {}\n\n    // Helper function to get the index of the left child\n    int leftChild(int index) {}\n\n    // Helper function to get the index of the right child\n    int rightChild(int index) {}\n\n    // Helper function to swap two elements in the heap\n    void swap(int &a, int &b) {}\n\n    // Heapify up to maintain the max-heap property after insertion\n    void heapifyUp(int index) {}\n\n    // Heapify down to maintain the max-heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert an element into the priority queue\n    void push(int value) {}\n\n    // Remove the maximum element from the priority queue\n    void pop() {}\n\n    // Get the maximum element without removing it\n    int top() {}\n\n    // Check if the priority queue is empty\n    bool isEmpty() {}\n\n    // Get the size of the priority queue\n    int size() {}\n};",
    "addition_info": ""
  },
  {
    "task_id": 187,
    "code_type": "method",
    "code_signature": "/**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Merge Sort Test Cases\", \"[merge_sort]\") {\n    SECTION(\"Sorting an empty array\") {\n        std::vector<int> empty_array = {};\n        merge_sort(empty_array, 0, empty_array.size() - 1);\n        REQUIRE(empty_array.empty() == true);\n    }\n\n    SECTION(\"Sorting a single element array\") {\n        std::vector<int> single_element = {1};\n        merge_sort(single_element, 0, single_element.size() - 1);\n        REQUIRE(single_element == std::vector<int>{1});\n    }\n\n    SECTION(\"Sorting a sorted array\") {\n        std::vector<int> sorted_array = {1, 2, 3, 4, 5};\n        merge_sort(sorted_array, 0, sorted_array.size() - 1);\n        REQUIRE(sorted_array == std::vector<int>{1, 2, 3, 2, 5});\n    }\n\n    SECTION(\"Sorting a reverse sorted array\") {\n        std::vector<int> reverse_sorted_array = {5, 4, 3, 2, 1};\n        merge_sort(reverse_sorted_array, 0, reverse_sorted_array.size() - 1);\n        REQUIRE(reverse_sorted_array == std::vector<int>{1, 2, 3, 4, 5});\n    }\n\n    SECTION(\"Sorting an array with random integers\") {\n        std::vector<int> random_array = {38, 27, 43, 3, 9, 82, 10};\n        std::vector<int> expected_sorted_array = {3, 9, 10, 27, 38, 43, 82};\n        merge_sort(random_array, 0, random_array.size() - 1);\n        REQUIRE(random_array == expected_sorted_array);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a portion of an array using the merge sort algorithm.\n *\n *\n * @param arr A reference to a vector of integers that contains the\n *            elements to be sorted.\n * @param left The starting index of the portion of the array to be\n *             sorted.\n * @param right The ending index of the portion of the array to be\n *              sorted.\n */\nvoid merge_sort(std::vector<int>& arr, int left, int right) {}",
    "addition_info": ""
  },
  {
    "task_id": 188,
    "code_type": "method",
    "code_signature": "/**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}",
    "code_language": "c&cpp",
    "test_code": "\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nTEST_CASE(\"Shell sort - Basic functionality\", \"[shellSort]\") {\n    SECTION(\"Test Case 1: Already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 2: Reverse sorted array\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 3: Array with duplicate elements\") {\n        std::vector<int> arr = {4, 2, 2, 4, 1};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 4: Array with negative numbers\") {\n        std::vector<int> arr = {-3, -1, -4, -2, 0};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Test Case 5: Empty array\") {\n        std::vector<int> arr = {};\n        shellSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * implement a function that performs Shell sort on an array\n * @param arr\n */\nvoid shellSort(std::vector<int>& arr) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 189,
    "code_type": "method",
    "code_signature": "/**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Base64 Encode Tests\") {\n\n    SECTION(\"Empty input should return empty string\") {\n        std::vector<unsigned char> input = {};\n        REQUIRE(base64_encode(input) == \"\");\n    }\n\n    SECTION(\"Encoding 'hello' should return 'aGVsbG8='\") {\n        std::vector<unsigned char> input = {'h', 'e', 'l', 'l', 'o'};\n        REQUIRE(base64_encode(input) == \"aGVsbG8=\");\n    }\n\n    SECTION(\"Encoding 'world' should return 'd29ybGQ='\") {\n        std::vector<unsigned char> input = {'w', 'o', 'r', 'l', 'd'};\n        REQUIRE(base64_encode(input) == \"d29ybGQ=\");\n    }\n\n    SECTION(\"Encoding 'foobar' should return 'Zm9vYmFy'\") {\n        std::vector<unsigned char> input = {'f', 'o', 'o', 'b', 'a', 'r'};\n        REQUIRE(base64_encode(input) == \"Zm9vYmFy\");\n    }\n\n    SECTION(\"Encoding 'Catch2' should return 'Q2F0Y2gy'\") {\n        std::vector<unsigned char> input = {'C', 'a', 't', 'c', 'h', '2'};\n        REQUIRE(base64_encode(input) == \"Q2F0Y2gy\");\n    }\n\n    SECTION(\"Encoding single byte 'A' should return 'QQ=='\") {\n        std::vector<unsigned char> input = {'A'};\n        REQUIRE(base64_encode(input) == \"QQ==\");\n    }\n\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Encodes a byte array into a Base64 encoded string.\n *\n * This function takes a vector of unsigned char data as input and converts it\n * into a Base64 encoded string.\n *\n * @param data A vector of unsigned char representing the input data to be encoded.\n * @return A std::string containing the Base64 encoded representation of the input data.\n *\n */\nstd::string base64_encode(const std::vector<unsigned char>& data);",
    "addition_info": ""
  },
  {
    "task_id": 190,
    "code_type": "method",
    "code_signature": "/**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Hexadecimal String to Float Conversion\", \"[hexStringToFloat]\") {\n\n    SECTION(\"Positive number: 40490FDB\") {\n        std::string hexStr = \"40490FDB\"; // 3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Negative number: C0490FDB\") {\n        std::string hexStr = \"C0490FDB\"; // -3.14159 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-3.14159f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Zero: 00000000\") {\n        std::string hexStr = \"00000000\"; // 0.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(0.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small positive number: 3F800000\") {\n        std::string hexStr = \"3F800000\"; // 1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(1.0f).epsilon(0.00001f));\n    }\n\n    SECTION(\"Small negative number: BF800000\") {\n        std::string hexStr = \"BF800000\"; // -1.0 in float\n        float result = hexStringToFloat(hexStr);\n        REQUIRE(result == Approx(-1.0f).epsilon(0.00001f));\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * parses a given hexadecimal string into its corresponding floating-point number and returns the float value.\n * @param hexStr\n * @return\n */\nfloat hexStringToFloat(const std::string& hexStr) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 191,
    "code_type": "method",
    "code_signature": "/**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"floatToHex tests\", \"[floatToHex]\") {\n    SECTION(\"Test with positive float 123.456\") {\n        float input = 123.456f;\n        std::string expected = \"42f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with negative float -123.456\") {\n        float input = -123.456f;\n        std::string expected = \"c2f6e979\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with zero\") {\n        float input = 0.0f;\n        std::string expected = \"00000000\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with small positive float 0.0001\") {\n        float input = 0.0001f;\n        std::string expected = \"38d1b717\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n\n    SECTION(\"Test with large float 1e30\") {\n        float input = 1e30f;\n        std::string expected = \"7149f2ca\";\n        REQUIRE(floatToHex(input) == expected);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Converts a floating-point number to its hexadecimal representation.\n *\n * @param value The float value to be converted to hexadecimal.\n * @return A std::string containing the hexadecimal representation of the\n *         input float.\n *\n * @note The output string will be in lowercase hexadecimal format.\n */\nstd::string floatToHex(float value) {}",
    "addition_info": ""
  },
  {
    "task_id": 192,
    "code_type": "method",
    "code_signature": "/**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"hexStringToUnsignedInt converts hex string to unsigned int\", \"[hexStringToUnsignedInt]\") {\n\n    SECTION(\"Valid hex strings\") {\n        REQUIRE(hexStringToUnsignedInt(\"1A3F\") == 6719); // 1A3F in hex is 6719 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"FFFF\") == 65535); // FFFF in hex is 65535 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"0\") == 0); // 0 in hex is 0 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"7F\") == 127); // 7F in hex is 127 in decimal\n        REQUIRE(hexStringToUnsignedInt(\"ABC123\") == 11256099); // ABC123 in hex is 11256099 in decimal\n    }\n\n    SECTION(\"Lowercase hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"abcd\") == 43981); // abcd in hex is 43981 in decimal\n    }\n\n    SECTION(\"Hex string with leading zeroes\") {\n        REQUIRE(hexStringToUnsignedInt(\"0001\") == 1); // 0001 in hex is 1 in decimal\n    }\n\n    SECTION(\"Empty hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"\") == 0); // Empty string should be treated as 0\n    }\n\n    SECTION(\"Mixed case hex string\") {\n        REQUIRE(hexStringToUnsignedInt(\"AbCdEf\") == 11259375); // AbCdEf in hex is 11259375 in decimal\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * Convert a hexadecimal string representing an unsigned integer to its corresponding unsigned integer value.\n * @param hexString\n * @return\n */\nunsigned int hexStringToUnsignedInt(const std::string& hexString) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 193,
    "code_type": "method",
    "code_signature": "/**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"convFlags Test Cases\", \"[convFlags]\") {\n    REQUIRE(convFlags(0x0000001F) == \"FFFFFFE0\");\n\n    REQUIRE(convFlags(0x00000015) == \"FFFFFFEA\");\n\n    REQUIRE(convFlags(0xFFFFFFFF) == \"0\");\n\n    REQUIRE(convFlags(0x12345678) == \"EDCBA987\");\n\n    REQUIRE(convFlags(0x00000001) == \"FFFFFFFE\");\n\n    REQUIRE(convFlags(0x00000003) == \"FFFFFFFC\");\n\n    REQUIRE(convFlags(0x00000008) == \"FFFFFFF7\");\n\n    REQUIRE(convFlags(0xABCDEF01) == \"543210FE\");\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Invert the flag bits of an unsigned integer to a hexadecimal string. The number of bits is not complete by 0\n *\n * @param value The unsigned integer whose bits are to be inverted.\n * @return A std::string containing the hexadecimal representation of the inverted bits.\n */\nstd::string convFlags(unsigned int value) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 194,
    "code_type": "method",
    "code_signature": "/**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}",
    "code_language": "c&cpp",
    "test_code": "\nTEST_CASE(\"return_string Test Cases\", \"[return_string]\") {\n    // Test Case 1: Copy a non-empty string\n    const char* original1 = \"Hello, World!\";\n    char* copy1 = return_string(original1);\n    REQUIRE(std::strcmp(copy1, original1) == 0);\n    delete[] copy1;\n\n    // Test Case 2: Copy an empty string\n    const char* original2 = \"\";\n    char* copy2 = return_string(original2);\n    REQUIRE(std::strcmp(copy2, original2) == 0);\n    delete[] copy2;\n\n    // Test Case 3: Copy a string with special characters\n    const char* original3 = \"C++ is fun! @#$%^&*()\";\n    char* copy3 = return_string(original3);\n    REQUIRE(std::strcmp(copy3, original3) == 0);\n    delete[] copy3;\n\n    // Test Case 4: Copy a single character string\n    const char* original4 = \"A\";\n    char* copy4 = return_string(original4);\n    REQUIRE(std::strcmp(copy4, original4) == 0);\n    delete[] copy4;\n\n    // Test Case 5: Passing a null pointer (should throw an exception)\n    REQUIRE_THROWS_AS(return_string(nullptr), std::invalid_argument);\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns a copy of the specified string via dynamic memory allocation\n *\n * @param str The input C-string to be copied.\n * @return A pointer to the dynamically allocated copy of the input string.\n * @throws std::invalid_argument if the input string is null.\n */\nchar* return_string(const char* str) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 195,
    "code_type": "class",
    "code_signature": "/**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"stack_t Test Cases\", \"[stack_t]\") {\n    stack_t stack(10); // Provide capacity when creating the stack\n\n    // Test Case 1: Pushing and popping a single element\n    stack.push(3.14f);\n    REQUIRE(stack.pop() == Approx(3.14f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 2: Pushing multiple elements and checking peek\n    stack.push(1.23f);\n    stack.push(4.56f);\n    REQUIRE(stack.peek() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(4.56f));\n    REQUIRE(stack.pop() == Approx(1.23f));\n    REQUIRE(stack.is_empty() == true); // Change to is_empty\n\n    // Test Case 3: Pop from an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.pop(), std::underflow_error);\n\n    // Test Case 4: Peek on an empty stack (should throw an exception)\n    REQUIRE_THROWS_AS(stack.peek(), std::underflow_error);\n\n    // Test Case 5: Push elements until stack is full and attempt to push another element\n    stack_t fullStack(100); // Provide capacity when creating the stack\n    for (int i = 0; i < 100; ++i) {\n        fullStack.push(static_cast<float>(i) + 0.5f);\n    }\n    REQUIRE_THROWS_AS(fullStack.push(100.5f), std::overflow_error);\n}",
    "prompt": "please write a cpp class , the class signature as below /**\n * Implement a floating-point stack structure based on arrays\n *\n * This class provides basic stack operations including push, pop, peek, and checking if the stack is empty.\n * The stack is implemented using a fixed-size array. If the stack reaches its maximum capacity, no more elements\n * can be pushed onto it until space is freed by popping elements.\n */\nclass stack_t {\n\t\n};",
    "addition_info": ""
  },
  {
    "task_id": 196,
    "code_type": "method",
    "code_signature": "/**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Sieve of Eratosthenes Test Cases\", \"[generatePrimes]\") {\n    // Test Case 1: Small limit (10)\n    std::vector<int> expected1 = {2, 3, 5, 7};\n    REQUIRE(generatePrimes(10) == expected1);\n\n    // Test Case 2: Prime limit (29)\n    std::vector<int> expected2 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(29) == expected2);\n\n    // Test Case 3: Non-prime limit (30)\n    std::vector<int> expected3 = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    REQUIRE(generatePrimes(30) == expected3);\n\n    // Test Case 4: Limit of 2 (smallest prime)\n    std::vector<int> expected4 = {2};\n    REQUIRE(generatePrimes(2) == expected4);\n\n    // Test Case 5: Invalid limit (1, should throw an exception)\n    REQUIRE_THROWS_AS(generatePrimes(1), std::invalid_argument);\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Find all prime numbers that are less than or equal to limit using the Eichler sieve algorithm\n *\n * @param limit The upper bound (inclusive) for finding prime numbers.\n * @return A vector of integers containing all prime numbers less than or equal to the limit.\n * @throws std::invalid_argument if the limit is less than 2.\n */\nstd::vector<int> generatePrimes(int limit) {\n\t\n}",
    "addition_info": ""
  },
  {
    "task_id": 197,
    "code_type": "method",
    "code_signature": "/**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"FindOrder Test Cases\", \"[findOrder]\") {\n    // Test Case 1: Minimum valid input with 2 players\n    REQUIRE(findOrder(2) == std::vector<int>{2, 1});\n\n    // Test Case 2: 3 players\n    REQUIRE(findOrder(3) == std::vector<int>{2, 3, 1});\n\n    // Test Case 3: 5 players\n    REQUIRE(findOrder(5) == std::vector<int>{2, 5, 3, 4, 1});\n\n    // Test Case 4: 7 players\n    REQUIRE(findOrder(7) == std::vector<int>{ 2, 5, 4, 1, 6, 7, 3});\n\n    // Test Case 5: 10 players\n    REQUIRE(findOrder(10) == std::vector<int>{ 2, 5, 10, 9, 7, 3, 4, 6, 8, 1});\n}\n",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Simulate a game based on the order of prime numbers, using a circular linked list to represent the cyclic structure of players, and remove players one by one\n *\n * This function creates an instance of the PrimeGame class, which encapsulates the logic\n * for simulating the game. It then calls the findOrder method on the PrimeGame object\n * to determine and return the order in which players are removed based on the sequence of prime numbers.\n *\n * @param n The number of players in the game.\n * @return A vector of integers representing the order of players being removed from the ring.\n */\nvector<int> findOrder(int n) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 198,
    "code_type": "method",
    "code_signature": "/**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"General case\", \"[findMaxDifference]\") {\n    std::vector<int> l = {2, 3, 10, 6, 4, 8, 1};\n    REQUIRE(findMaxDifference(l) == 8);  // Maximum difference is 10 - 2 = 8\n}\n\n// Test case 2: Decreasing sequence\nTEST_CASE(\"Decreasing sequence\", \"[findMaxDifference]\") {\n    std::vector<int> l = {10, 9, 8, 7, 6, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference should be 0, as all differences are negative\n}\n\n// Test case 3: All elements the same\nTEST_CASE(\"All elements the same\", \"[findMaxDifference]\") {\n    std::vector<int> l = {5, 5, 5, 5, 5};\n    REQUIRE(findMaxDifference(l) == 0);  // Maximum difference is 5 - 5 = 0\n}\n\n// Test case 4: Only two elements\nTEST_CASE(\"Only two elements\", \"[findMaxDifference]\") {\n    std::vector<int> l = {3, 8};\n    REQUIRE(findMaxDifference(l) == 5);  // Maximum difference is 8 - 3 = 5\n}\n\n// Test case 5: Only one element\nTEST_CASE(\"Single element\", \"[findMaxDifference]\") {\n    std::vector<int> l = {4};\n    REQUIRE(findMaxDifference(l) == 0);  // Only one element, no difference to calculate\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Finds the maximum difference between elements in the array\n * such that the smaller element appears before the larger one.\n *\n * @param l A vector of integers containing the elements.\n * @return The maximum difference.\n */\nint findMaxDifference(const vector<int> &l) {}",
    "addition_info": ""
  },
  {
    "task_id": 200,
    "code_type": "method",
    "code_signature": "/**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Test cases for extractStringFromBraces function\") {\n\n    SECTION(\"Basic extraction\") {\n        std::string input = \"This is a sample text with some data {data: \\\"value\\\"} and more text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{data: \\\"value\\\"}\");\n    }\n\n    SECTION(\"No braces\") {\n        std::string input = \"This string has no braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n\n    SECTION(\"Only opening brace\") {\n        std::string input = \"This string has an opening brace { but no closing brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No closing brace found.\");\n    }\n\n    SECTION(\"Only closing brace\") {\n        std::string input = \"This string has a closing brace } but no opening brace.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"No opening brace found.\");\n    }\n    SECTION(\"Multiple braces\") {\n        std::string input = \"First {first} and second {second} braces.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{first}\");\n    }\n\n    SECTION(\"Empty braces\") {\n        std::string input = \"This string has empty braces {} and some text.\";\n        std::string result = extractStringFromBraces(input);\n        REQUIRE(result == \"{}\");\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the string contained in the first pair of braces `{}` from the input string.\n *\n * @param input The input string from which the braces content will be extracted.\n * @return A substring enclosed within the first pair of braces, or an error message if braces are missing.\n */\nstd::string extractStringFromBraces(const std::string& input) {}",
    "addition_info": ""
  },
  {
    "task_id": 202,
    "code_type": "method",
    "code_signature": "#include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2024, 2) == 29); // 2024 \u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 2: \u975e\u95f0\u5e74\u7684\u4e8c\u6708\u4efd\nTEST_CASE(\"Non-leap year February\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 2) == 28); // 2023 \u4e0d\u662f\u95f0\u5e74\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 3: \u5927\u6708\u4efd\uff0831\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 31 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 1) == 31); // \u4e00\u6708\u4efd\u6709 31 \u5929\n    REQUIRE(getDaysInMonth(2023, 7) == 31); // \u4e03\u6708\u4efd\u6709 31 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 4: \u5c0f\u6708\u4efd\uff0830\u5929\uff09\u7684\u60c5\u51b5\nTEST_CASE(\"Month with 30 days\", \"[getDaysInMonth]\") {\n    REQUIRE(getDaysInMonth(2023, 4) == 30); // \u56db\u6708\u4efd\u6709 30 \u5929\n    REQUIRE(getDaysInMonth(2023, 11) == 30); // \u5341\u4e00\u6708\u4efd\u6709 30 \u5929\n}\n\n// \u6d4b\u8bd5\u7528\u4f8b 5: \u65e0\u6548\u7684\u6708\u4efd\nTEST_CASE(\"Invalid month\", \"[getDaysInMonth]\") {\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 0), std::invalid_argument);  // \u6708\u4efd\u5c0f\u4e8e 1\n    REQUIRE_THROWS_AS(getDaysInMonth(2023, 13), std::invalid_argument); // \u6708\u4efd\u5927\u4e8e 12\n}",
    "prompt": "please write a cpp function , the function signature as below #include <stdexcept>\n/**\n * @brief Returns the number of days in a given month of a specific year.\n *\n * This function accounts for leap years when calculating the number of days in February.\n *\n * @param year The year for which to get the number of days in the month. This should be\n *             a valid integer representing a year (e.g., 2024).\n * @param month The month for which to get the number of days. It should be an integer\n *              between 1 and 12, where 1 corresponds to January and 12 to December.\n * @return The number of days in the specified month of the specified year.\n *\n */\n int getDaysInMonth(int year, int month){\n }",
    "addition_info": ""
  },
  {
    "task_id": 203,
    "code_type": "method",
    "code_signature": "/**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Test reverseRange function\") {\n    SECTION(\"Reverse entire vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 0, 4);\n        std::vector<int> expected = {5, 4, 3, 2, 1};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse subrange in the middle\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8};\n        reverseRange(v, 2, 5);\n        std::vector<int> expected = {1, 2, 6, 5, 4, 3, 7, 8};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse a single element range\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, 2, 2);\n        std::vector<int> expected = {1, 2, 3, 4, 5};\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range with invalid indices\") {\n        std::vector<int> v = {1, 2, 3, 4, 5};\n        reverseRange(v, -1, 3);  // Invalid start index\n        std::vector<int> expected = {1, 2, 3, 4, 5}; // No change\n        REQUIRE(v == expected);\n    }\n\n    SECTION(\"Reverse range at the end of the vector\") {\n        std::vector<int> v = {1, 2, 3, 4, 5, 6};\n        reverseRange(v, 3, 5);\n        std::vector<int> expected = {1, 2, 3, 6, 5, 4};\n        REQUIRE(v == expected);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * Reverse the order of elements in the vectorvwithin the specified range[a, b].\n *\n * @param v Reference to the vector of integers to be modified.\n * @param a The starting index of the range to be reversed.\n * @param b The ending index of the range to be reversed.\n */\nvoid reverseRange(std::vector<int>& v, int a, int b) {}",
    "addition_info": ""
  },
  {
    "task_id": 204,
    "code_type": "method",
    "code_signature": "/**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"splitString function\") {\n\n    SECTION(\"Split a regular sentence\") {\n        std::string input = \"Hello world from Catch2\";\n        std::vector<std::string> expected = {\"Hello\", \"world\", \"from\", \"Catch2\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Handle multiple spaces\") {\n        std::string input = \"Multiple   spaces between words\";\n        std::vector<std::string> expected = {\"Multiple\", \"spaces\", \"between\", \"words\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Single word input\") {\n        std::string input = \"Single\";\n        std::vector<std::string> expected = {\"Single\"};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"Empty string input\") {\n        std::string input = \"\";\n        std::vector<std::string> expected = {};\n        REQUIRE(splitString(input) == expected);\n    }\n\n    SECTION(\"String with leading and trailing spaces\") {\n        std::string input = \"   Leading and trailing spaces   \";\n        std::vector<std::string> expected = {\"Leading\", \"and\", \"trailing\", \"spaces\"};\n        REQUIRE(splitString(input) == expected);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * Split a string into multiple substrings based on spaces and return a vector containing these substrings.\n *\n * @param str The input string to be split into words.\n * @return A vector of strings, each representing a word from the input string. Returns an empty vector if the input string is empty or contains only spaces.\n */\nstd::vector<std::string> splitString(const std::string& str) {}",
    "addition_info": ""
  },
  {
    "task_id": 205,
    "code_type": "method",
    "code_signature": "/**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"getCurrentDate function\") {\n\n    SECTION(\"Correct format YYYY-MM-DD\") {\n        std::string currentDate = getCurrentDate();\n        REQUIRE(currentDate.length() == 10);\n        REQUIRE(currentDate[4] == '-');\n        REQUIRE(currentDate[7] == '-');\n    }\n\n    SECTION(\"Returns correct year\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentYear = now->tm_year + 1900;\n\n        std::string currentDate = getCurrentDate();\n        std::string yearPart = currentDate.substr(0, 4);\n\n        REQUIRE(std::stoi(yearPart) == currentYear);\n    }\n\n    SECTION(\"Returns correct month\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentMonth = now->tm_mon + 1;\n\n        std::string currentDate = getCurrentDate();\n        std::string monthPart = currentDate.substr(5, 2);\n\n        REQUIRE(std::stoi(monthPart) == currentMonth);\n    }\n\n    SECTION(\"Returns correct day\") {\n        std::time_t t = std::time(nullptr);\n        std::tm* now = std::localtime(&t);\n        int currentDay = now->tm_mday;\n\n        std::string currentDate = getCurrentDate();\n        std::string dayPart = currentDate.substr(8, 2);\n\n        REQUIRE(std::stoi(dayPart) == currentDay);\n    }\n\n    SECTION(\"Consistency of output within the same second\") {\n        std::string firstCall = getCurrentDate();\n        std::string secondCall = getCurrentDate();\n        REQUIRE(firstCall == secondCall);\n    }\n}\n",
    "prompt": "please write a cpp function , the function signature as below /**\n * Retrieves the current system date and formats it as a string in the format \"YYYY-MM-DD\".\n *\n * @return A string representing the current date in the format \"YYYY-MM-DD\".\n */\nstd::string getCurrentDate() {}",
    "addition_info": ""
  },
  {
    "task_id": 206,
    "code_type": "method",
    "code_signature": "/**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Testing circleIntersectionArea function\") {\n    const double tolerance = 1e-5;\n\n    SECTION(\"No overlap, circles far apart\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 10.0, 10.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"No overlap, circles just touching\") {\n        REQUIRE(circleIntersectionArea(0.0, 0.0, 3.0, 6.0, 0.0, 3.0) == Approx(0.0).epsilon(tolerance));\n    }\n\n    SECTION(\"One circle inside the other\") {\n        double area = circleIntersectionArea(0.0, 0.0, 5.0, 2.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of smaller circle\n    }\n\n    SECTION(\"Identical circles, full overlap\") {\n        double area = circleIntersectionArea(0.0, 0.0, 3.0, 0.0, 0.0, 3.0);\n        REQUIRE(area == Approx(28.2743).epsilon(tolerance)); // Area of one circle\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * calculate the intersection area of two circles. Each circle is defined by its center coordinates and radius.\n *\n * @param x1 The x-coordinate of the center of the first circle.\n * @param y1 The y-coordinate of the center of the first circle.\n * @param r1 The radius of the first circle.\n * @param x2 The x-coordinate of the center of the second circle.\n * @param y2 The y-coordinate of the center of the second circle.\n * @param r2 The radius of the second circle.\n * @return The area of the intersection between the two circles.\n */\ndouble circleIntersectionArea(double x1, double y1, double r1, double x2, double y2, double r2) {}",
    "addition_info": ""
  },
  {
    "task_id": 207,
    "code_type": "method",
    "code_signature": "/**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Testing minChangesToSymmetric function\") {\n\n    SECTION(\"Already Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'b', 'e', 'f'},\n            {'c', 'f', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"One Change Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'c', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 2);\n    }\n\n    SECTION(\"All Different Elements\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c'},\n            {'d', 'e', 'f'},\n            {'g', 'h', 'i'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 3);\n    }\n\n    SECTION(\"Large Symmetric Matrix\") {\n        vector<vector<char>> matrix = {\n            {'a', 'b', 'c', 'd'},\n            {'b', 'e', 'f', 'g'},\n            {'c', 'f', 'h', 'i'},\n            {'d', 'g', 'i', 'j'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 0);\n    }\n\n    SECTION(\"Multiple Changes Needed\") {\n        vector<vector<char>> matrix = {\n            {'a', 'x', 'c', 'd'},\n            {'y', 'e', 'f', 'g'},\n            {'z', 'h', 'i', 'j'},\n            {'d', 'g', 'k', 'l'}\n        };\n        REQUIRE(minChangesToSymmetric(matrix) == 4);\n    }\n}\n",
    "prompt": "please write a cpp function , the function signature as below /**\n * Convert a given square character matrix into a symmetric matrix and calculate the minimum number of character replacements required to achieve symmetry.\n *\n * @param matrix A reference to a 2D vector of characters representing the matrix to be analyzed.\n * @return The minimum number of element changes required to make the matrix symmetric.\n */\nint minChangesToSymmetric(vector<vector<char>>& matrix) {}",
    "addition_info": ""
  },
  {
    "task_id": 208,
    "code_type": "method",
    "code_signature": "/**\n * Implement a priority queue\n */\nclass PriorityQueue {\npublic:\n    // Constructor\n    PriorityQueue() {}\n\n    // Function to insert a new element into the priority queue\n    void insert(int value) {\n\n    }\n\n    // Function to get and remove the minimum element from the priority queue\n    int extractMin() {\n\n    }\n\n    // Function to peek at the minimum element without removing it\n    int peekMin() const {\n\n    }\n\n    // Function to check if the priority queue is empty\n    bool isEmpty() const {\n\n    }\n\n    // Function to get the size of the priority queue\n    int size() const {\n\n    }\n\n    // Function to print the contents of the priority queue (for debugging purposes)\n    void print() const {\n\n    }\n};\n",
    "code_language": "c&cpp",
    "test_code": "// Test Case 1: Test insertion and extraction of the minimum element\nTEST_CASE(\"Insertion and extraction of minimum element\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Inserting elements into the priority queue\") {\n        pq.insert(5);\n        pq.insert(2);\n        pq.insert(8);\n        pq.insert(1);\n        pq.insert(3);\n\n        REQUIRE(pq.size() == 5);\n        REQUIRE(pq.peekMin() == 1);\n    }\n\n    SECTION(\"Extracting the minimum element\") {\n        pq.insert(5);\n        pq.insert(2);\n        pq.insert(8);\n        pq.insert(1);\n        pq.insert(3);\n\n        REQUIRE(pq.extractMin() == 1);\n        REQUIRE(pq.extractMin() == 2);\n        REQUIRE(pq.extractMin() == 3);\n        REQUIRE(pq.extractMin() == 5);\n        REQUIRE(pq.extractMin() == 8);\n        REQUIRE(pq.isEmpty() == true);\n    }\n}\n\n// Test Case 2: Test peekMin operation\nTEST_CASE(\"Peek minimum element\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Peeking at the minimum element without extraction\") {\n        pq.insert(10);\n        pq.insert(4);\n        pq.insert(15);\n\n        REQUIRE(pq.peekMin() == 4);\n        REQUIRE(pq.size() == 3); // Size should remain the same\n        REQUIRE(pq.peekMin() == 4); // Peek should not remove the element\n    }\n}\n\n// Test Case 3: Test edge case of extracting from an empty queue\nTEST_CASE(\"Extract from empty queue\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Attempting to extract from an empty queue should throw an exception\") {\n        REQUIRE_THROWS_AS(pq.extractMin(), std::runtime_error);\n    }\n}\n\n// Test Case 4: Test isEmpty function\nTEST_CASE(\"Check if the priority queue is empty\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Newly created queue should be empty\") {\n        REQUIRE(pq.isEmpty() == true);\n    }\n\n    SECTION(\"Queue should not be empty after insertion\") {\n        pq.insert(7);\n        REQUIRE(pq.isEmpty() == false);\n    }\n\n    SECTION(\"Queue should be empty after extracting all elements\") {\n        pq.insert(7);\n        pq.extractMin();\n        REQUIRE(pq.isEmpty() == true);\n    }\n}\n\n// Test Case 5: Test multiple insertions and order of extraction\nTEST_CASE(\"Multiple insertions and extraction order\", \"[PriorityQueue]\") {\n    PriorityQueue pq;\n\n    SECTION(\"Inserting multiple elements and checking extraction order\") {\n        pq.insert(9);\n        pq.insert(4);\n        pq.insert(6);\n        pq.insert(1);\n        pq.insert(8);\n\n        std::vector<int> extractedElements;\n        while (!pq.isEmpty()) {\n            extractedElements.push_back(pq.extractMin());\n        }\n\n        std::vector<int> expectedOrder = {1, 4, 6, 8, 9};\n        REQUIRE(extractedElements == expectedOrder);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * Implement a priority queue\n */\nclass PriorityQueue {\npublic:\n    // Constructor\n    PriorityQueue() {}\n\n    // Function to insert a new element into the priority queue\n    void insert(int value) {\n\n    }\n\n    // Function to get and remove the minimum element from the priority queue\n    int extractMin() {\n\n    }\n\n    // Function to peek at the minimum element without removing it\n    int peekMin() const {\n\n    }\n\n    // Function to check if the priority queue is empty\n    bool isEmpty() const {\n\n    }\n\n    // Function to get the size of the priority queue\n    int size() const {\n\n    }\n\n    // Function to print the contents of the priority queue (for debugging purposes)\n    void print() const {\n\n    }\n};\n",
    "addition_info": ""
  },
  {
    "task_id": 209,
    "code_type": "class",
    "code_signature": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"LinkedList operations\", \"[LinkedList]\") {\n\n    SECTION(\"Insertion at the head\") {\n        LinkedList list;\n        list.insertAtHead(10);\n        list.insertAtHead(20);\n        list.insertAtHead(30);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 30 -> 20 -> 10 -> nullptr\n        REQUIRE(list.search(10) == true);\n        REQUIRE(list.search(20) == true);\n        REQUIRE(list.search(30) == true);\n        REQUIRE(list.search(40) == false);\n    }\n\n    SECTION(\"Insertion at the tail\") {\n        LinkedList list;\n        list.insertAtTail(1);\n        list.insertAtTail(2);\n        list.insertAtTail(3);\n\n        std::ostringstream output;\n        list.printList(); // Expected: 1 -> 2 -> 3 -> nullptr\n        REQUIRE(list.search(1) == true);\n        REQUIRE(list.search(2) == true);\n        REQUIRE(list.search(3) == true);\n        REQUIRE(list.search(4) == false);\n    }\n\n    SECTION(\"Deletion of elements\") {\n        LinkedList list;\n        list.insertAtHead(5);\n        list.insertAtHead(10);\n        list.insertAtHead(15);\n\n        list.deleteValue(10);\n        std::ostringstream output;\n        list.printList(); // Expected: 15 -> 5 -> nullptr\n        REQUIRE(list.search(10) == false);\n        REQUIRE(list.search(15) == true);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(15);\n        list.printList(); // Expected: 5 -> nullptr\n        REQUIRE(list.search(15) == false);\n        REQUIRE(list.search(5) == true);\n\n        list.deleteValue(5);\n        list.printList(); // Expected: nullptr\n        REQUIRE(list.search(5) == false);\n    }\n\n    SECTION(\"Search functionality\") {\n        LinkedList list;\n        list.insertAtTail(100);\n        list.insertAtTail(200);\n        list.insertAtTail(300);\n\n        REQUIRE(list.search(100) == true);\n        REQUIRE(list.search(200) == true);\n        REQUIRE(list.search(300) == true);\n        REQUIRE(list.search(400) == false);\n    }\n\n    SECTION(\"Edge case: Empty list\") {\n        LinkedList list;\n\n        REQUIRE(list.search(1) == false);  // Searching in an empty list\n        list.deleteValue(1);               // Deleting from an empty list should not crash\n        std::ostringstream output;\n        list.printList();                  // Expected: nullptr (still empty)\n    }\n}",
    "prompt": "please write a cpp class , the class signature as below struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n\n// LinkedList class definition\nclass LinkedList {\n    // Method to add a node at the beginning of the list\n    void insertAtHead(int value) {\n\n    }\n\n    // Method to add a node at the end of the list\n    void insertAtTail(int value) {\n\n    }\n\n    // Method to delete a node with a specific value\n    void deleteValue(int value) {\n\n    }\n\n    // Method to search for a value in the list\n    bool search(int value) {\n\n    }\n\n    // Method to print all elements in the list\n    void printList() {\n\n    }\n}\n",
    "addition_info": "struct Node {\n    int data;       // Data held by the node\n    Node* next;     // Pointer to the next node in the list\n\n    // Constructor to initialize a new node with given data\n    Node(int value) : data(value), next(nullptr) {}\n};\n"
  },
  {
    "task_id": 210,
    "code_type": "method",
    "code_signature": "/**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}",
    "code_language": "c&cpp",
    "test_code": "// Test function for iterative, recursive, and memoization Fibonacci\nTEST_CASE(\"Fibonacci sequence\", \"[fibonacci]\") {\n    // Test Case 1: Fibonacci of 0\n    SECTION(\"Fibonacci(0) should be 0\") {\n        REQUIRE(fibonacciRecursive(0) == 0);\n    }\n\n    // Test Case 2: Fibonacci of 1\n    SECTION(\"Fibonacci(1) should be 1\") {\n        REQUIRE(fibonacciRecursive(1) == 1);\n    }\n\n    // Test Case 3: Fibonacci of 5\n    SECTION(\"Fibonacci(5) should be 5\") {\n        REQUIRE(fibonacciRecursive(5) == 5);\n    }\n\n    // Test Case 4: Fibonacci of 10\n    SECTION(\"Fibonacci(10) should be 55\") {\n        REQUIRE(fibonacciRecursive(10) == 55);\n    }\n\n    // Test Case 5: Fibonacci of 20\n    SECTION(\"Fibonacci(20) should be 6765\") {\n        REQUIRE(fibonacciRecursive(20) == 6765);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * Implement the Fibonacci sequence\n *\n * @param n Which Fibonacci number to calculate.\n * @return int\n */\nint fibonacciRecursive(int n) {}",
    "addition_info": ""
  },
  {
    "task_id": 354,
    "code_type": "method",
    "code_signature": "#include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}",
    "code_language": "c&cpp",
    "test_code": "// Test cases for gaussianWeight function\nTEST_CASE(\"Gaussian Weight Calculation Tests\") {\n\n    SECTION(\"Zero Intensity Difference\") {\n        // When intensity difference is zero, weight should be 1\n        float intensity_diff = 0.0f;\n        float sigma_color = 1.0f; // arbitrary sigma value\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Intensity Difference\") {\n        // A positive intensity difference with a reasonable sigma\n        float intensity_diff = 2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Intensity Difference\") {\n        // A negative intensity difference should yield the same weight as positive\n        float intensity_diff = -2.0f;\n        float sigma_color = 2.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Color\") {\n        // Test with a small sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 0.1f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Color\") {\n        // Test with a large sigma value\n        float intensity_diff = 1.0f;\n        float sigma_color = 100.0f;\n        float expected_weight = exp(-(intensity_diff * intensity_diff) / (2 * sigma_color * sigma_color));\n        REQUIRE(gaussianWeight(intensity_diff, sigma_color) == Approx(expected_weight).epsilon(0.001));\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include the cmath library for the exp function\n\n/**\n * @brief Calculates the Gaussian weight based on the difference in intensity and a color standard deviation.\n *\n * The Gaussian weight is calculated using the formula:\n * weight = exp(- (intensity_diff^2) / (2 * sigma_color^2))\n *\n * @param intensity_diff The difference in intensity, which is used to compute the weight.\n * @param sigma_color The standard deviation for the color, affecting the spread of the weight.\n * @return The Gaussian weight as a float.\n */\ninline float gaussianWeight(float intensity_diff, float sigma_color) {}",
    "addition_info": ""
  },
  {
    "task_id": 355,
    "code_type": "method",
    "code_signature": "#include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Spatial Weight Calculation Tests\") {\n\n    SECTION(\"Zero Spatial Difference\") {\n        // When spatial difference is zero, weight should be 1\n        float spatial_diff = 0.0f;\n        float sigma_space = 1.0f; // arbitrary sigma value\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(1.0f).epsilon(0.001));\n    }\n\n    SECTION(\"Positive Spatial Difference\") {\n        // A positive spatial difference with a reasonable sigma\n        float spatial_diff = 2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Negative Spatial Difference\") {\n        // A negative spatial difference should yield the same weight as positive\n        float spatial_diff = -2.0f;\n        float sigma_space = 2.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Small Sigma Space\") {\n        // Test with a small sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 0.1f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n    SECTION(\"Large Sigma Space\") {\n        // Test with a large sigma value\n        float spatial_diff = 1.0f;\n        float sigma_space = 100.0f;\n        float expected_weight = exp(-(spatial_diff * spatial_diff) / (2 * sigma_space * sigma_space));\n        REQUIRE(spatialWeight(spatial_diff, sigma_space) == Approx(expected_weight).epsilon(0.001));\n    }\n\n}",
    "prompt": "please write a cpp function , the function signature as below #include <cmath> // Include cmath for the exp function\n\n/**\n * @brief Calculates the spatial weight based on the difference in spatial coordinates and a space standard deviation.\n *\n * The spatial weight is calculated using the formula:\n * weight = exp(- (spatial_diff^2) / (2 * sigma_space^2))\n *\n * @param spatial_diff The difference in spatial coordinates, which is used to compute the weight.\n * @param sigma_space The standard deviation for spatial distance, affecting the spread of the weight.\n * @return The spatial weight as a float.\n *\n */\ninline float spatialWeight(float spatial_diff, float sigma_space) {}",
    "addition_info": ""
  },
  {
    "task_id": 356,
    "code_type": "method",
    "code_signature": "/**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"BubbleSort Test Cases\", \"[bubbleSort]\") {\n    // Test Case 1: Sorting an already sorted array\n    std::vector<int> arr1 = {1, 2, 3, 4, 5};\n    bubbleSort(arr1);\n    REQUIRE(arr1 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 2: Sorting a reverse sorted array\n    std::vector<int> arr2 = {5, 4, 3, 2, 1};\n    bubbleSort(arr2);\n    REQUIRE(arr2 == std::vector<int>{1, 2, 3, 4, 5});\n\n    // Test Case 3: Sorting an array with duplicate elements\n    std::vector<int> arr3 = {3, 1, 2, 3, 2};\n    bubbleSort(arr3);\n    REQUIRE(arr3 == std::vector<int>{1, 2, 2, 3, 3});\n\n    // Test Case 4: Sorting an array with a single element\n    std::vector<int> arr4 = {1};\n    bubbleSort(arr4);\n    REQUIRE(arr4 == std::vector<int>{1});\n\n    // Test Case 5: Sorting an empty array\n    std::vector<int> arr5 = {};\n    bubbleSort(arr5);\n    REQUIRE(arr5 == std::vector<int>{});\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Implements the Bubble Sort algorithm.\n *\n * @param arr A reference to a vector of integers to be sorted.\n */\nvoid bubbleSort(std::vector<int>& arr) {\n\t\n}",
    "addition_info": ""
  },
  {
    "task_id": 357,
    "code_type": "method",
    "code_signature": "/**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}",
    "code_language": "c&cpp",
    "test_code": "// Helper function to check if the array is sorted\nbool isSorted(const std::vector<int>& arr) {\n    for (size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Test cases\nTEST_CASE(\"Hill Sort\") {\n    SECTION(\"Sort an already sorted array\") {\n        std::vector<int> arr = {1, 2, 3, 4, 5};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array in reverse order\") {\n        std::vector<int> arr = {5, 4, 3, 2, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with duplicate values\") {\n        std::vector<int> arr = {3, 1, 2, 3, 2};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with all identical values\") {\n        std::vector<int> arr = {1, 1, 1, 1, 1};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an empty array\") {\n        std::vector<int> arr = {};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort an array with one element\") {\n        std::vector<int> arr = {42};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n\n    SECTION(\"Sort a large random array\") {\n        std::vector<int> arr = {3, 7, 2, 5, 1, 4, 6, 0, 9, 8};\n        hillSort(arr);\n        REQUIRE(isSorted(arr) == true);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sorts a vector of integers using the Hill Sort (Shell Sort) algorithm.\n *\n * @param arr A reference to a vector of integers that will be sorted in-place.\n *\n */\nvoid hillSort(std::vector<int>& arr) {}",
    "addition_info": ""
  },
  {
    "task_id": 358,
    "code_type": "method",
    "code_signature": "/**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"sortNames Test Cases\", \"[sortNames]\") {\n    // Test Case 2: Same numbers, different names\n    vector<string> arr2 = {\"Alice10\", \"Charlie10\", \"Bob10\"};\n    vector<string> expected2 = {\"Alice10\", \"Bob10\", \"Charlie10\"};\n    REQUIRE(sortNames(arr2) == expected2);\n\n    // Test Case 3: Mixed case with different names and numbers\n    vector<string> arr3 = {\"Alice3\", \"Bob2\", \"Charlie3\", \"Bob1\"};\n    vector<string> expected3 = {\"Bob1\", \"Bob2\", \"Alice3\", \"Charlie3\"};\n    REQUIRE(sortNames(arr3) == expected3);\n\n    // Test Case 4: Single element\n    vector<string> arr4 = {\"Alice5\"};\n    vector<string> expected4 = {\"Alice5\"};\n    REQUIRE(sortNames(arr4) == expected4);\n\n    // Test Case 5: Empty array\n    vector<string> arr5 = {};\n    vector<string> expected5 = {};\n    REQUIRE(sortNames(arr5) == expected5);\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Sort the string array with the shape of \"name + number\" in ascending order. If the numbers are the same, sort by name in ascending order, and return the sorted array\n *\n * @param arr A reference to the vector of strings to be sorted.\n * @return A vector of strings sorted according to the rules described above.\n */\nvector<string> sortNames(vector<string> arr) {\n\t\n}",
    "addition_info": ""
  },
  {
    "task_id": 359,
    "code_type": "method",
    "code_signature": "/**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"TrapezoidalRule Test Cases\", \"[trapezoidal_rule]\") {\n    // Test Case 1: Integration of a constant function (f(x) = 1) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return 1.0; }, 0.0, 1.0, 100) == Approx(1.0).epsilon(1e-6));\n\n    // Test Case 2: Integration of a linear function (f(x) = x) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x; }, 0.0, 1.0, 100) == Approx(0.5).epsilon(1e-6));\n\n    // Test Case 3: Integration of a quadratic function (f(x) = x^2) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return x * x; }, 0.0, 1.0, 1000) == Approx(1.0 / 3.0).epsilon(1e-6));\n\n    // Test Case 4: Integration of the sine function (f(x) = sin(x)) over [0, \u03c0]\n    REQUIRE(trapezoidal_rule([](double x) { return std::sin(x); }, 0.0, M_PI, 1000) == Approx(2.0).epsilon(1e-6));\n\n    // Test Case 5: Integration of an exponential function (f(x) = exp(x)) over [0, 1]\n    REQUIRE(trapezoidal_rule([](double x) { return std::exp(x); }, 0.0, 1.0, 1000) == Approx(std::exp(1.0) - 1.0).epsilon(1e-6));\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculate the integral approximation of a given function on a given interval [a,b] using the trapezoidal rule of numerical integration\n *\n * @param func The function to integrate, represented as a std::function<double(double)>.\n * @param a The lower bound of the integration interval.\n * @param b The upper bound of the integration interval.\n * @param n The number of subintervals to use in the approximation (more intervals yield higher accuracy).\n * @return The approximate value of the integral over the interval [a, b].\n */\ndouble trapezoidal_rule(const std::function<double(double)>& func, double a, double b, int n) {\n\t\n}",
    "addition_info": ""
  },
  {
    "task_id": 360,
    "code_type": "method",
    "code_signature": "/**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"getLastPartOfFilepath Test Cases\", \"[getLastPartOfFilepath]\") {\n    // Test Case 1: Unix-style path with '/'\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/file.txt\") == \"file.txt\");\n\n    // Test Case 2: Windows-style path with '\\\\'\n    REQUIRE(getLastPartOfFilepath(\"C:\\\\Users\\\\JohnDoe\\\\Documents\\\\file.txt\") == \"file.txt\");\n\n    // Test Case 3: Path without any separators (should return the original string)\n    REQUIRE(getLastPartOfFilepath(\"file.txt\") == \"file.txt\");\n\n    // Test Case 4: Path ending with a separator (should return an empty string)\n    REQUIRE(getLastPartOfFilepath(\"/home/user/documents/\") == \"\");\n\n    // Test Case 5: Path with mixed separators (should return the last part after the last separator)\n    REQUIRE(getLastPartOfFilepath(\"C:/Users\\\\JohnDoe/Documents/file.txt\") == \"file.txt\");\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Extracts the last part of a complete file path with the help of a separator and returns it, or the original string if no separator is found\n *\n * @param filePath The complete file path as a string.\n * @return The last part of the file path after the last separator, or the original string if no separator is found.\n */\nstd::string getLastPartOfFilepath(const std::string& filePath) {\n\t\n}",
    "addition_info": ""
  },
  {
    "task_id": 361,
    "code_type": "method",
    "code_signature": "#include <stdexcept> // For std::invalid_argument\n/**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Simpson's Rule Tests\") {\n\n    SECTION(\"Basic Integral of x^2 from 0 to 1\") {\n        // The exact integral of f(x) = x^2 from 0 to 1 is 1/3\n        double result = simpsons_rule(0.0, 1.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Basic Integral of x^2 from 0 to 2\") {\n        // The exact integral of f(x) = x^2 from 0 to 2 is 8/3\n        double result = simpsons_rule(0.0, 2.0, 10);\n        REQUIRE(result == Approx(8.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Negative Integral of x^2 from -1 to 0\") {\n        // The exact integral of f(x) = x^2 from -1 to 0 is 1/3\n        double result = simpsons_rule(-1.0, 0.0, 10);\n        REQUIRE(result == Approx(1.0 / 3.0).epsilon(0.01));\n    }\n\n    SECTION(\"Large Interval\") {\n        // Test with a larger interval from 0 to 10\n        double result = simpsons_rule(0.0, 10.0, 20);\n        // The exact integral from 0 to 10 of f(x) = x^2 is (10^3)/3 = 1000/3\n        REQUIRE(result == Approx(1000.0 / 3.0).epsilon(0.01));\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <stdexcept> // For std::invalid_argument\n/**\n * @brief Computes the approximate integral of a function using Simpson's Rule.\n *\n * Simpson's Rule is a method for numerical integration that approximates the integral of a function\n * over an interval by fitting parabolas. This function divides the interval [a, b] into n subintervals\n * and calculates the weighted sum of the function values at specific points.\n *\n * @param a The lower limit of integration.\n * @param b The upper limit of integration.\n * @param n The number of subintervals (must be even).\n * @return The approximate value of the integral.\n *\n * @throws std::invalid_argument If n is not positive or if it is not even.\n */\ndouble simpsons_rule(double a, double b, int n) {}",
    "addition_info": "double f(double x) {\n    return x * x;\n}"
  },
  {
    "task_id": 365,
    "code_type": "method",
    "code_signature": "/**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Day of Week Calculation\", \"[day_of_week]\") {\n    REQUIRE(day_of_week(2024, 1, 1) == 1);  // January 1, 2024 is a Monday\n    REQUIRE(day_of_week(2023, 8, 29) == 2);  // August 29, 2023 is a Tuesday\n    REQUIRE(day_of_week(2022, 12, 25) == 7); // December 25, 2022 is a Sunday\n    REQUIRE(day_of_week(1989, 11, 9) == 4);  // November 9, 1989 is a Thursday\n    REQUIRE(day_of_week(2000, 2, 29) == 2);  // February 29, 2000 is a Tuesday\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Calculates the day of the week for a given date.\n *\n * @param year The year of the date (e.g., 2024).\n * @param month The month of the date (1 = January, 2 = February, ..., 12 = December).\n * @param day The day of the month (1 to 31, depending on the month).\n * \n * @return An integer representing the day of the week:\n *         - 1 for Monday\n *         - 2 for Tuesday\n *         - 3 for Wednesday\n *         - 4 for Thursday\n *         - 5 for Friday\n *         - 6 for Saturday\n *         - 7 for Sunday\n */\nint day_of_week(int year, int month, int day) {}",
    "addition_info": ""
  },
  {
    "task_id": 481,
    "code_type": "method",
    "code_signature": "/**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"printBoard outputs correct format\", \"[printBoard]\") {\n    vector<vector<char>> board1 = {\n        {'X', 'O', 'X'},\n        {' ', 'X', 'O'},\n        {'O', ' ', ' '}\n    };\n\n    vector<vector<char>> board2 = {\n        {' ', ' ', ' '},\n        {' ', ' ', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board3 = {\n        {'X', 'X', 'X'},\n        {'O', 'O', ' '},\n        {' ', ' ', ' '}\n    };\n\n    vector<vector<char>> board4 = {\n        {'O', 'O', 'O'},\n        {'X', 'X', 'X'},\n        {'X', 'O', ' '}\n    };\n\n    vector<vector<char>> board5 = {\n        {'X', ' ', ' '},\n        {' ', 'X', ' '},\n        {' ', ' ', 'X'}\n    };\n\n    vector<vector<char>> board6 = {\n        {' ', 'O', ' '},\n        {'O', ' ', 'O'},\n        {' ', 'O', ' '}\n    };\n\n    // Test case 1\n    SECTION(\"Test case 1\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf()); // Redirect cout to ostringstream\n\n        printBoard(board1);\n\n        cout.rdbuf(oldCoutBuffer); // Restore original cout\n        string expectedOutput = \"-------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 2\n    SECTION(\"Test case 2\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board2);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 3\n    SECTION(\"Test case 3\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board3);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X | X | X | \\n-------------\\n| O | O |   | \\n-------------\\n|   |   |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 4\n    SECTION(\"Test case 4\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board4);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| O | O | O | \\n-------------\\n| X | X | X | \\n-------------\\n| X | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 5\n    SECTION(\"Test case 5\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board5);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n| X |   |   | \\n-------------\\n|   | X |   | \\n-------------\\n|   |   | X | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n\n    // Test case 6\n    SECTION(\"Test case 6\") {\n        ostringstream output;\n        streambuf* oldCoutBuffer = cout.rdbuf(output.rdbuf());\n\n        printBoard(board6);\n\n        cout.rdbuf(oldCoutBuffer);\n        string expectedOutput = \"-------------\\n|   | O |   | \\n-------------\\n| O |   | O | \\n-------------\\n|   | O |   | \\n-------------\\n\";\n        REQUIRE(output.str() == expectedOutput);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Prints a 3x3 game board to the console.\n *\n * This function takes a 2D vector representing a game board and prints\n * it in a formatted manner, displaying the contents of each cell.\n * The board is assumed to be a square of size 3x3, and each cell can\n * contain either a character representing a player's move ('X' or 'O')\n * or an empty space (' ').\n *\n * The output format includes a row of dashes to separate the rows of\n * the board, and each cell is enclosed within vertical bars.\n * The function does not return any value.\n *\n * @param board A 2D vector of characters, where each character represents\n *              the state of a cell in the game board. The board must be\n *              of size 3x3, and each character can be 'X', 'O', or ' '.\n * For example:\n *      input: [['X', 'O', 'X'],\n *              [' ', 'X', 'O'],\n *              ['O', ' ', ' ']]\n *      output: -------------\\n| X | O | X | \\n-------------\\n|   | X | O | \\n-------------\\n| O |   |   | \\n-------------\\n\n */\nvoid printBoard(const vector<vector<char>>& board) {}",
    "addition_info": ""
  },
  {
    "task_id": 589,
    "code_type": "method",
    "code_signature": "#include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"extract_json returns an empty string for input without '{'\") {\n    std::string input = \"No braces here\";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json extracts a single JSON object\") {\n    std::string input = \"Here is some text before { \\\"key\\\": \\\"value\\\" } and some text after.\";\n    REQUIRE(extract_json(input) == \"{ \\\"key\\\": \\\"value\\\" }\");\n}\n\nTEST_CASE(\"extract_json handles nested JSON objects\") {\n    std::string input = \"Some text { \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } } more text.\";\n    REQUIRE(extract_json(input) == \"{ \\\"outer\\\": { \\\"inner\\\": \\\"value\\\" } }\");\n}\n\nTEST_CASE(\"extract_json returns an empty string for unmatched braces\") {\n    std::string input = \"Here is an incomplete JSON { \\\"key\\\": \\\"value\\\" \";\n    REQUIRE(extract_json(input) == \"\");\n}\n\nTEST_CASE(\"extract_json returns the correct JSON when multiple braces are present\") {\n    std::string input = \"Start { { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }} end.\";\n    REQUIRE(extract_json(input) == \"{ { \\\"key\\\": \\\"value\\\" } and some other text { \\\"another\\\": \\\"object\\\" }}\");\n}\n\nTEST_CASE(\"extract_json extracts the first JSON object when multiple are present\") {\n    std::string input = \"Text before { \\\"first\\\": \\\"value1\\\" } text in between { \\\"second\\\": \\\"value2\\\" }\";\n    REQUIRE(extract_json(input) == \"{ \\\"first\\\": \\\"value1\\\" }\");\n}",
    "prompt": "please write a cpp function , the function signature as below #include <string>\n\n/**\n * Extracts the first complete JSON object from a given string.\n *\n * The function looks for the first occurrence of an opening curly brace '{'\n * and searches for the corresponding closing curly brace '}'. It tracks\n * the balance of braces to ensure that the JSON object is complete.\n *\n * If a complete JSON object is found, it returns the substring that\n * represents that object. If no opening brace is found or if the braces\n * are unbalanced (i.e., incomplete), it returns an empty string.\n *\n * @param response The input string from which to extract the JSON object.\n * @return A string containing the first complete JSON object, or an\n *         empty string if no complete object is found.\n */\nstd::string extract_json(const std::string& response) {}",
    "addition_info": ""
  },
  {
    "task_id": 590,
    "code_type": "method",
    "code_signature": "#include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Valid POST request line\", \"[parse_http_request_line]\") {\n    std::string response = \"POST /api/data HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"POST\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/data\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"PUT request line\", \"[parse_http_request_line]\") {\n    std::string response = \"PUT /api/update HTTP/2.0\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"PUT\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/update\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/2.0\");\n}\n\nTEST_CASE(\"DELETE request line\", \"[parse_http_request_line]\") {\n    std::string response = \"DELETE /api/delete HTTP/1.1\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info[\"method\"] == \"DELETE\");\n    REQUIRE(parsed_info[\"url\"] == \"/api/delete\");\n    REQUIRE(parsed_info[\"http_version\"] == \"HTTP/1.1\");\n}\n\nTEST_CASE(\"Malformed request line\", \"[parse_http_request_line]\") {\n    std::string response = \"INVALID REQUEST LINE\\r\\n\";\n    auto parsed_info = parse_http_request_line(response);\n\n    REQUIRE(parsed_info.empty());  // Expect empty result for malformed request\n}",
    "prompt": "please write a cpp function , the function signature as below #include <string>\n#include <map>\n#include <sstream>\n\n/**\n * @brief Parses the first line of an HTTP request response string.\n *\n * This function extracts the HTTP method, request URL, and HTTP version\n * from the given response string. The first line of the response should\n * be formatted as \"METHOD URL HTTP/VERSION\", followed by a CRLF sequence\n * (carriage return and line feed). If the first line does not conform\n * to this format, the function will return an empty map.\n *\n * @param response A string containing the HTTP response. It is expected\n *                 to start with a request line that includes the method,\n *                 URL, and HTTP version, ending with CRLF (\"\\r\\n\").\n *\n * @return A map containing three key-value pairs:\n *         - \"method\": The HTTP method (e.g., GET, POST).\n *         - \"url\": The requested URL (e.g., /index.html).\n *         - \"http_version\": The HTTP version (e.g., HTTP/1.1).\n *         If the request line is malformed or empty, the map may contain\n *         empty strings or be empty.\n *\n * @note The function does not validate the correctness of the HTTP method,\n *       URL, or version; it only parses the input string.\n */\nstd::map<std::string, std::string> parse_http_request_line(const std::string& response){}",
    "addition_info": ""
  },
  {
    "task_id": 591,
    "code_type": "class",
    "code_signature": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Color RGB Values\", \"[Color]\") {\n    Color color;\n\n    SECTION(\"Verify RGB values for Red\") {\n        auto rgb = color.getColor(Color::RED);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Green\") {\n        auto rgb = color.getColor(Color::GREEN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Blue\") {\n        auto rgb = color.getColor(Color::BLUE);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Yellow\") {\n        auto rgb = color.getColor(Color::YELLOW);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Magenta\") {\n        auto rgb = color.getColor(Color::MAGENTA);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Cyan\") {\n        auto rgb = color.getColor(Color::CYAN);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for White\") {\n        auto rgb = color.getColor(Color::WHITE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 255);\n        REQUIRE(std::get<2>(rgb) == 255);\n    }\n\n    SECTION(\"Verify RGB values for Black\") {\n        auto rgb = color.getColor(Color::BLACK);\n        REQUIRE(std::get<0>(rgb) == 0);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Orange\") {\n        auto rgb = color.getColor(Color::ORANGE);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 165);\n        REQUIRE(std::get<2>(rgb) == 0);\n    }\n\n    SECTION(\"Verify RGB values for Purple\") {\n        auto rgb = color.getColor(Color::PURPLE);\n        REQUIRE(std::get<0>(rgb) == 128);\n        REQUIRE(std::get<1>(rgb) == 0);\n        REQUIRE(std::get<2>(rgb) == 128);\n    }\n\n    SECTION(\"Verify RGB values for Pink\") {\n        auto rgb = color.getColor(Color::PINK);\n        REQUIRE(std::get<0>(rgb) == 255);\n        REQUIRE(std::get<1>(rgb) == 192);\n        REQUIRE(std::get<2>(rgb) == 203);\n    }\n\n    SECTION(\"Verify RGB values for Brown\") {\n        auto rgb = color.getColor(Color::BROWN);\n        REQUIRE(std::get<0>(rgb) == 165);\n        REQUIRE(std::get<1>(rgb) == 42);\n        REQUIRE(std::get<2>(rgb) == 42);\n    }\n}",
    "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <string>\n#include <unordered_map>\n\n/**\n* Please write a class that contains RGB representations of, RED, GREEN, BLUE, YELLOW, MAGENTA, CYAN, WHITE, BLACK, ORANGE, PURPLE, PINK, BROWN, which can be obtained directly by the function\n/\nclass Color {\npublic:\n    enum ColorName {\n        RED,\n        GREEN,\n        BLUE,\n        YELLOW,\n        MAGENTA,\n        CYAN,\n        WHITE,\n        BLACK,\n        ORANGE,\n        PURPLE,\n        PINK,\n        BROWN\n    };\n\n    // Constructor\n    Color() {\n        initializeColors();\n    }\n\n    // Function to get the RGB value of a color by its name\n    std::tuple<int, int, int> getColor(ColorName colorName) {}\n\n    // Function to get the color name as a string\n    std::string getColorName(ColorName colorName) {}\n\nprivate:\n    // A map to store the RGB values of the colors\n    std::unordered_map<ColorName, std::tuple<int, int, int>> colors;\n\n    // Function to initialize the colors\n    void initializeColors() {}\n};\n",
    "addition_info": "#include <unordered_map>\n"
  },
  {
    "task_id": 592,
    "code_type": "method",
    "code_signature": "#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"applyOp function tests\") {\n    SECTION(\"Addition\") {\n        REQUIRE(applyOp(3, 4, '+') == 7);\n        REQUIRE(applyOp(-1, -1, '+') == -2);\n    }\n\n    SECTION(\"Subtraction\") {\n        REQUIRE(applyOp(10, 5, '-') == 5);\n        REQUIRE(applyOp(5, 10, '-') == -5);\n    }\n\n    SECTION(\"Multiplication\") {\n        REQUIRE(applyOp(3, 4, '*') == 12);\n        REQUIRE(applyOp(-2, 5, '*') == -10);\n    }\n\n    SECTION(\"Division\") {\n        REQUIRE(applyOp(8, 4, '/') == 2);\n        REQUIRE(applyOp(5, 2, '/') == 2.5);\n        REQUIRE_THROWS_AS(applyOp(5, 0, '/'), std::invalid_argument);\n    }\n\n    SECTION(\"Exponentiation\") {\n        REQUIRE(applyOp(2, 3, '^') == 8);\n        REQUIRE(applyOp(9, 0.5, '^') == 3); // Square root of 9\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Performs a mathematical operation on two operands.\n *\n * This function takes two double values and an operator character, and performs\n * the specified arithmetic operation. Supported operations include addition,\n * subtraction, multiplication, division, and exponentiation.\n *\n * @param a The first operand (double).\n * @param b The second operand (double).\n * @param op A character representing the operation to perform:\n *            '+' for addition,\n *            '-' for subtraction,\n *            '*' for multiplication,\n *            '/' for division,\n *            '^' for exponentiation.\n *\n * @return The result of the operation as a double.\n *\n * @throws std::invalid_argument if the operator is not recognized or if\n *         there is an attempt to divide by zero.\n */\ndouble applyOp(double a, double b, char op) {}",
    "addition_info": ""
  },
  {
    "task_id": 594,
    "code_type": "method",
    "code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"splitComma function tests\") {\n    std::vector<std::string> result;\n\n    SECTION(\"Basic comma-separated values\") {\n        splitComma(\"apple,banana,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Leading and trailing whitespace\") {\n        splitComma(\"  apple , banana , orange  \", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Multiple consecutive commas\") {\n        splitComma(\"apple,,banana,,,orange\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n\n    SECTION(\"Empty input string\") {\n        splitComma(\"\", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Only whitespace input\") {\n        splitComma(\"   \", result);\n        REQUIRE(result.size() == 0);\n    }\n\n    SECTION(\"Trailing commas\") {\n        splitComma(\"apple,banana,orange,\", result);\n        REQUIRE(result.size() == 3);\n        REQUIRE(result[0] == \"apple\");\n        REQUIRE(result[1] == \"banana\");\n        REQUIRE(result[2] == \"orange\");\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <algorithm> // for std::remove_if\n/**\n * @brief Splits a comma-separated string into individual tokens.\n *\n * This function takes a string containing comma-separated values, trims\n * leading and trailing whitespace from each token, and stores the non-empty\n * tokens in the provided vector.\n *\n * @param str The input string to be split, which may contain leading and\n *            trailing whitespace around the tokens.\n * @param vect A reference to a vector of strings where the resulting tokens\n *             will be stored. The vector will be cleared before storing\n *             the new tokens.\n */\nvoid splitComma(const std::string& str, std::vector<std::string>& vect) {}",
    "addition_info": ""
  },
  {
    "task_id": 595,
    "code_type": "method",
    "code_signature": "/**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Test getDaysInMonth function\") {\n    SECTION(\"Regular months\") {\n        REQUIRE(getDaysInMonth(2023, 1) == 31); // January\n        REQUIRE(getDaysInMonth(2023, 3) == 31); // March\n        REQUIRE(getDaysInMonth(2023, 4) == 30); // April\n        REQUIRE(getDaysInMonth(2023, 5) == 31); // May\n        REQUIRE(getDaysInMonth(2023, 6) == 30); // June\n        REQUIRE(getDaysInMonth(2023, 7) == 31); // July\n        REQUIRE(getDaysInMonth(2023, 8) == 31); // August\n        REQUIRE(getDaysInMonth(2023, 9) == 30); // September\n        REQUIRE(getDaysInMonth(2023, 10) == 31); // October\n        REQUIRE(getDaysInMonth(2023, 11) == 30); // November\n        REQUIRE(getDaysInMonth(2023, 12) == 31); // December\n    }\n\n    SECTION(\"February in leap year\") {\n        REQUIRE(getDaysInMonth(2024, 2) == 29); // Leap year\n    }\n\n    SECTION(\"February in non-leap year\") {\n        REQUIRE(getDaysInMonth(2023, 2) == 28); // Non-leap year\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below /**\n * @brief Returns the number of days in a given month of a given year.\n *\n * This function accounts for leap years when determining the number of\n * days in February. It throws an exception if the month is invalid.\n *\n * @param year The year to check (should be a positive integer).\n * @param month The month to check (1 for January, 12 for December).\n * @return int The number of days in the specified month of the specified year.\n * @throws std::invalid_argument If the month is not between 1 and 12.\n */\nint getDaysInMonth(int year, int month) {}",
    "addition_info": ""
  },
  {
    "task_id": 597,
    "code_type": "method",
    "code_signature": "#include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Hue to RGB Conversion Tests\") {\n    SECTION(\"Hue 0 (Red)\") {\n        auto [r, g, b] = hueToRGB(0);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 120 (Green)\") {\n        auto [r, g, b] = hueToRGB(120);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 240 (Blue)\") {\n        auto [r, g, b] = hueToRGB(240);\n        REQUIRE(r == 0);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 60 (Yellow)\") {\n        auto [r, g, b] = hueToRGB(60);\n        REQUIRE(r == 255);\n        REQUIRE(g == 255);\n        REQUIRE(b == 0);\n    }\n\n    SECTION(\"Hue 180 (Cyan)\") {\n        auto [r, g, b] = hueToRGB(180);\n        REQUIRE(r == 0);\n        REQUIRE(g == 255);\n        REQUIRE(b == 255);\n    }\n\n    SECTION(\"Hue 300 (Magenta)\") {\n        auto [r, g, b] = hueToRGB(300);\n        REQUIRE(r == 255);\n        REQUIRE(g == 0);\n        REQUIRE(b == 255);\n    }\n\n}",
    "prompt": "please write a cpp function , the function signature as below #include <tuple>\n#include <cmath>\n\n/**\n * Converts a hue value to its corresponding RGB color values.\n *\n * @param hue A float representing the hue angle in degrees,\n *            expected to be in the range [0, 360).\n *\n * @return A tuple containing three integers representing the\n *         RGB color components in the range [0, 255]. The\n *         first element is the red component, the second\n *         element is the green component, and the third element\n *         is the blue component.\n */\nstd::tuple<int, int, int> hueToRGB(float hue) {}",
    "addition_info": ""
  },
  {
    "task_id": 598,
    "code_type": "class",
    "code_signature": "#include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};",
    "code_language": "c&cpp",
    "test_code": "// Test cases for the Queue class\nTEST_CASE(\"Queue Operations\", \"[Queue]\") {\n    Queue queue;\n\n    SECTION(\"Queue should be empty initially\") {\n        REQUIRE(queue.isEmpty() == true);\n    }\n\n    SECTION(\"Enqueue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        REQUIRE(queue.isEmpty() == false);\n        REQUIRE(queue.front() == 10); // Front element should be 10\n    }\n\n    SECTION(\"Dequeue elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n\n        int value = queue.dequeue();\n        REQUIRE(value == 10); // First dequeued element should be 10\n        REQUIRE(queue.front() == 20); // Now front should be 20\n    }\n\n    SECTION(\"Dequeue from an empty queue\") {\n        int value = queue.dequeue();\n        REQUIRE(value == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Front element of an empty queue\") {\n        int frontValue = queue.front();\n        REQUIRE(frontValue == -1); // Should indicate that the queue is empty\n    }\n\n    SECTION(\"Queue should become empty after dequeuing all elements\") {\n        queue.enqueue(10);\n        queue.enqueue(20);\n\n        queue.dequeue(); // Remove 10\n        queue.dequeue(); // Remove 20\n\n        REQUIRE(queue.isEmpty() == true); // Queue should be empty\n    }\n}",
    "prompt": "please write a cpp class , the class signature as below #include <iostream>\n\n// Node structure for linked list\nstruct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};\n\n// Queue class\nclass Queue {\nprivate:\n    Node* head; // Pointer to the front of the queue\n    Node* tail; // Pointer to the end of the queue\n\npublic:\n    // Constructor to initialize the queue\n    Queue() : head(nullptr), tail(nullptr) {}\n\n    // Destructor to clean up the queue\n    ~Queue() {\n        while (!isEmpty()) {\n            dequeue();\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() const {}\n\n    // Function to add an element to the end of the queue\n    void enqueue(int value) {}\n\n    // Function to remove and return the front element of the queue\n    int dequeue() {}\n\n    // Function to get the front element without removing it\n    int front() const {}\n};",
    "addition_info": "struct Node {\n    int data;      // Data value of the node\n    Node* next;    // Pointer to the next node in the linked list\n\n    Node(int val) : data(val), next(nullptr) {} // Constructor to initialize the node\n};"
  },
  {
    "task_id": 599,
    "code_type": "class",
    "code_signature": "#include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"MaxHeap Operations\", \"[MaxHeap]\") {\n    MaxHeap maxHeap;\n\n    SECTION(\"Initial state of the heap\") {\n        REQUIRE(maxHeap.isEmpty() == true);\n        REQUIRE(maxHeap.size() == 0);\n    }\n\n    SECTION(\"Insert elements into the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(20);\n        maxHeap.insert(5);\n\n        REQUIRE(maxHeap.isEmpty() == false);\n        REQUIRE(maxHeap.size() == 3);\n        REQUIRE(maxHeap.getMax() == 20); // The maximum should be 20\n    }\n\n    SECTION(\"Extract maximum element from the heap\") {\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n\n        int maxElement = maxHeap.extractMax();\n        REQUIRE(maxElement == 30); // The maximum extracted should be 30\n        REQUIRE(maxHeap.getMax() == 20); // The next maximum should be 20\n        REQUIRE(maxHeap.size() == 2); // Size should be 2 after extraction\n    }\n\n    SECTION(\"Heap should maintain max heap property after multiple operations\") {\n        maxHeap.insert(15);\n        maxHeap.insert(10);\n        maxHeap.insert(30);\n        maxHeap.insert(20);\n        maxHeap.insert(25);\n\n        // Current max should be 30\n        REQUIRE(maxHeap.getMax() == 30);\n\n        maxHeap.extractMax(); // Remove 30\n        // After removal, the new max should be 25\n        REQUIRE(maxHeap.getMax() == 25);\n\n        maxHeap.extractMax(); // Remove 25\n        // After removal, the new max should be 20\n        REQUIRE(maxHeap.getMax() == 20);\n\n        // The size of the heap should be 3 now\n        REQUIRE(maxHeap.size() == 3);\n    }\n}",
    "prompt": "please write a cpp class , the class signature as below #include <iostream>\n#include <vector>\n#include <stdexcept>\n\nclass MaxHeap {\nprivate:\n    std::vector<int> heap; // Vector to store heap elements\n\n    // Helper function to maintain the max heap property\n    void heapifyUp(int index) {}\n\n    // Helper function to maintain the max heap property after deletion\n    void heapifyDown(int index) {}\n\npublic:\n    // Insert a new element into the heap\n    void insert(int value) {}\n\n    // Remove and return the maximum element from the heap\n    int extractMax() {}\n\n    // Get the maximum element without removing it\n    int getMax() const {}\n\n    // Check if the heap is empty\n    bool isEmpty() const {}\n\n    // Get the size of the heap\n    size_t size() const {}\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 601,
    "code_type": "method",
    "code_signature": "#include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}",
    "code_language": "c&cpp",
    "test_code": "// Test cases\nTEST_CASE(\"Count words in various strings\") {\n    SECTION(\"Empty string\") {\n        REQUIRE(countWords(\"\") == 0);\n    }\n\n    SECTION(\"String with only spaces\") {\n        REQUIRE(countWords(\"     \") == 0);\n    }\n\n    SECTION(\"Single word\") {\n        REQUIRE(countWords(\"Hello\") == 1);\n    }\n\n    SECTION(\"Multiple words with single spaces\") {\n        REQUIRE(countWords(\"This is a test string\") == 5);\n    }\n\n    SECTION(\"Multiple spaces between words\") {\n        REQUIRE(countWords(\"This    is   a   test   string\") == 5);\n    }\n\n    SECTION(\"Leading and trailing spaces\") {\n        REQUIRE(countWords(\"   Hello world!   \") == 2);\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <sstream>\n#include <string>\n\n/**\n * @brief Counts the number of words in a given string.\n *\n * A word is defined as a sequence of characters separated by whitespace.\n * This function handles leading and trailing whitespace, as well as\n * multiple spaces between words.\n *\n * @param str The input string in which words are to be counted.\n * @return int The count of words in the input string.\n */\nint countWords(const std::string &str) {}",
    "addition_info": ""
  },
  {
    "task_id": 603,
    "code_type": "method",
    "code_signature": "#include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Leap Year Test Cases\") {\n    SECTION(\"Divisible by 4 but not by 100\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2024) == true); // 2024 is a leap year\n        REQUIRE(isLeapYear(2000) == true); // 2000 is a leap year (divisible by 400)\n        REQUIRE(isLeapYear(1996) == true); // 1996 is a leap year\n        REQUIRE(isLeapYear(2004) == true); // 2004 is a leap year\n    }\n\n    SECTION(\"Divisible by 100 but not by 400\") {\n        // Years that are not leap years\n        REQUIRE(isLeapYear(1900) == false); // 1900 is not a leap year\n        REQUIRE(isLeapYear(2100) == false); // 2100 is not a leap year\n        REQUIRE(isLeapYear(1800) == false); // 1800 is not a leap year\n    }\n\n    SECTION(\"Divisible by 400\") {\n        // Years that are leap years\n        REQUIRE(isLeapYear(2400) == true); // 2400 is a leap year\n        REQUIRE(isLeapYear(1600) == true); // 1600 is a leap year\n    }\n\n    SECTION(\"Normal years\") {\n        // Years that are normal years\n        REQUIRE(isLeapYear(1997) == false); // 1997 is not a leap year\n        REQUIRE(isLeapYear(1998) == false); // 1998 is not a leap year\n        REQUIRE(isLeapYear(1999) == false); // 1999 is not a leap year\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Checks if a given year is a leap year.\n *\n * @param year The year to check.\n * @return True if the year is a leap year, false otherwise.\n */\nbool isLeapYear(int year) {}",
    "addition_info": ""
  },
  {
    "task_id": 604,
    "code_type": "method",
    "code_signature": "#include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}",
    "code_language": "c&cpp",
    "test_code": "\nTEST_CASE(\"Power function test cases\") {\n    SECTION(\"Base cases\") {\n        // Test 0^0, should return 1 (by convention)\n        REQUIRE(power_tail(0, 0) == 1);\n\n        // Test x^0 for any x, should return 1\n        REQUIRE(power_tail(5, 0) == 1);\n        REQUIRE(power_tail(12345, 0) == 1);\n    }\n\n    SECTION(\"Power of one\") {\n        // Test 1^y for any y, should return 1\n        REQUIRE(power_tail(1, 5) == 1);\n        REQUIRE(power_tail(1, 123) == 1);\n    }\n\n    SECTION(\"Power of zero\") {\n        // Test 0^y for any y > 0, should return 0\n        REQUIRE(power_tail(0, 5) == 0);\n        REQUIRE(power_tail(0, 100) == 0);\n    }\n\n    SECTION(\"Positive powers\") {\n        // Test some positive powers\n        REQUIRE(power_tail(2, 3) == 8);     // 2^3 = 8\n        REQUIRE(power_tail(3, 4) == 81);    // 3^4 = 81\n        REQUIRE(power_tail(5, 2) == 25);     // 5^2 = 25\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <iostream>\n\n/**\n * @brief Tail-recursive function to calculate x raised to the power y.\n *\n * This function uses tail recursion to compute x^y.\n *\n * @param x The base, a non-negative integer.\n * @param y The exponent, a non-negative integer.\n * @param acc The accumulator to hold the intermediate result.\n *\n * @return The result of x raised to the power of y.\n */\nunsigned power_tail(unsigned x, unsigned y, unsigned acc = 1) {}",
    "addition_info": ""
  },
  {
    "task_id": 605,
    "code_type": "method",
    "code_signature": "#include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}",
    "code_language": "c&cpp",
    "test_code": "// Test case for valid inputs with expected BMI value\nTEST_CASE(\"Valid BMI calculations\") {\n    SECTION(\"Normal weight\") {\n        REQUIRE(calculateBMI(70, 1.75) == Approx(22.86).epsilon(0.01)); // 70 kg, 1.75 m\n    }\n\n    SECTION(\"Underweight\") {\n        REQUIRE(calculateBMI(50, 1.75) == Approx(16.33).epsilon(0.01)); // 50 kg, 1.75 m\n    }\n\n    SECTION(\"Overweight\") {\n        REQUIRE(calculateBMI(80, 1.75) == Approx(26.12).epsilon(0.01)); // 80 kg, 1.75 m\n    }\n\n    SECTION(\"Obesity\") {\n        REQUIRE(calculateBMI(100, 1.75) == Approx(32.65).epsilon(0.01)); // 100 kg, 1.75 m\n    }\n}\n\n// Test case for invalid inputs\nTEST_CASE(\"Invalid BMI calculations\") {\n    SECTION(\"Negative weight\") {\n        REQUIRE_THROWS_AS(calculateBMI(-70, 1.75), std::invalid_argument); // Negative weight\n    }\n\n    SECTION(\"Zero height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, 0), std::invalid_argument); // Zero height\n    }\n\n    SECTION(\"Negative height\") {\n        REQUIRE_THROWS_AS(calculateBMI(70, -1.75), std::invalid_argument); // Negative height\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <stdexcept>\n\n/**\n * @brief Calculates the Body Mass Index (BMI) based on weight and height.\n *\n * The BMI is calculated using the formula:\n *\n *      BMI = weight (kg) / (height (m) * height (m))\n *\n * @param weight The weight of the individual in kilograms.\n * @param height The height of the individual in meters.\n *\n * @return The calculated BMI value as a double.\n *\n * @throws std::invalid_argument if weight or height is less than or equal to zero,\n *                                since these values must be positive.\n */\ndouble calculateBMI(double weight, double height) {}",
    "addition_info": ""
  },
  {
    "task_id": 606,
    "code_type": "method",
    "code_signature": "#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}",
    "code_language": "c&cpp",
    "test_code": "TEST_CASE(\"Calculate Steering Angle Tests\") {\n    const double wheelbase = 2.5; // Setting wheelbase constant for all tests\n\n    SECTION(\"Normal case\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Zero speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = 0.0;           // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Negative speed\") {\n        double angularVelocity = 1.0; // radians/second\n        double speed = -5.0;          // meters/second\n        REQUIRE_THROWS_AS(calculateSteeringAngle(angularVelocity, speed, wheelbase), std::invalid_argument);\n    }\n\n    SECTION(\"Zero angular velocity\") {\n        double angularVelocity = 0.0; // radians/second\n        double speed = 10.0;          // meters/second\n        double expectedAngle = 0.0;   // Steering angle should be zero\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"Large values\") {\n        double angularVelocity = 100.0; // radians/second\n        double speed = 1000.0;          // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n\n    SECTION(\"High angular velocity\") {\n        double angularVelocity = 10.0; // radians/second\n        double speed = 1.0;             // meters/second\n        double expectedAngle = atan((angularVelocity * wheelbase) / speed);\n        REQUIRE(calculateSteeringAngle(angularVelocity, speed, wheelbase) == Approx(expectedAngle));\n    }\n}",
    "prompt": "please write a cpp function , the function signature as below #include <iostream>\n#include <cmath>\n#include <stdexcept>\n\n/**\n * @brief Calculates the steering angle based on the given angular velocity, speed, and wheelbase.\n *\n * The function uses the relationship between angular velocity, speed, and the steering angle\n * to determine the appropriate steering angle required for the vehicle to achieve the desired\n * angular velocity. The formula used is:\n *\n *      \u03c9 = (v / L) * tan(\u03b4)\n *\n * Rearranging gives us:\n *\n *      \u03b4 = atan((\u03c9 * L) / v)\n *\n * @param angularVelocity The angular velocity of the vehicle in radians per second.\n * @param speed The forward speed of the vehicle in meters per second.\n * @param wheelbase The distance between the front and rear axles of the vehicle in meters.\n *\n * @return The steering angle in radians.\n *\n * @throws std::invalid_argument if speed is less than or equal to zero,\n *                                since the vehicle cannot move at zero or negative speed.\n */\ndouble calculateSteeringAngle(double angularVelocity, double speed, double wheelbase) {}",
    "addition_info": ""
  }
]