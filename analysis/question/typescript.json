[
  {
    "task_id": 140,
    "code_type": "method",
    "code_signature": "/**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('getTimeSinceBornUntilNow', () => {\n    beforeAll(() => {\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-23T15:45:00'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return the correct difference for a typical birth date', () => {\n        const birthDate = new Date('1990-05-15T10:30:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([34, 3, 8, 5, 15]); // Example output: 34 years, 3 months, 8 days, 5 hours, 15 minutes\n    });\n\n    test('should return the correct difference for a recent birth date', () => {\n        const birthDate = new Date('2024-08-20T12:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 3, 3, 45]); // 3 days, 3 hours, 45 minutes\n    });\n\n    test('should handle edge cases at the end of the year', () => {\n        const birthDate = new Date('2023-12-31T23:59:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 15, 46]); // 7 months, 22 days, 15 hours, 46 minutes\n    });\n\n\n    test('should handle birthdays earlier in the current month', () => {\n        const birthDate = new Date('2024-08-01T00:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 22, 15, 45]); // 22 days, 15 hours, 45 minutes\n    });\n\n    test('should handle birthdays later in the current year before the current month', () => {\n        const birthDate = new Date('2024-01-01T01:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 14, 45]); // 7 months, 22 days, 14 hours, 45 minutes\n    });\n\n    test('should handle birthdays in the previous month of the same year', () => {\n        const birthDate = new Date('2024-07-30T10:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 24, 5, 45]); // 24 days, 5 hours, 45 minutes\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 141,
    "code_type": "method",
    "code_signature": "/**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array<T>} arr1 - The first array to compare. Elements can be of any type T.\n * @param {Array<T>} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @template T - The type of the elements in the arrays.\n *\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('compareArrays', () => {\n    test('should return true for identical arrays with same order', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return true for identical arrays with different order', () => {\n        const arr1 = [3, 2, 1];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return false for arrays with different elements', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [4, 5, 6];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return false for arrays with different lengths', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return true for arrays with duplicate elements but same unique set', () => {\n        const arr1 = [1, 1, 2, 3, 3];\n        const arr2 = [3, 2, 1, 1];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Compares two arrays to determine if they contain the same unique elements, irrespective of order.\n *\n * @param {Array<T>} arr1 - The first array to compare. Elements can be of any type T.\n * @param {Array<T>} arr2 - The second array to compare. Elements should be of the same type as the first array.\n * @returns {boolean} - Returns true if both arrays contain the same unique elements, otherwise returns false.\n *\n * @template T - The type of the elements in the arrays.\n *\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n}",
    "addition_info": ""
  },
  {
    "task_id": 142,
    "code_type": "method",
    "code_signature": "/**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('convertCamelCaseToSentence', () => {\n    test('should convert a simple camelCase string to a sentence', () => {\n        const input = \"thisIsTest\";\n        const expectedOutput = \"This is test\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle single word starting with lowercase', () => {\n        const input = \"example\";\n        const expectedOutput = \"Example\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a camelCase string with multiple uppercase letters', () => {\n        const input = \"thisIsAnExampleString\";\n        const expectedOutput = \"This is an example string\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a single uppercase letter', () => {\n        const input = \"aSingleUppercaseLetterX\";\n        const expectedOutput = \"A single uppercase letter x\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle an already capitalized string', () => {\n        const input = \"AlreadyCapitalized\";\n        const expectedOutput = \"Already capitalized\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts a camelCase string to a format with the first letter capitalized and spaces between words.\n * For example:\n *      input: \"thisIsTest\"\n *      output: \"This is test\"\n *\n * @param input The camelCase string to be converted.\n * @returns The converted string with spaces and initial capitalization.\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 143,
    "code_type": "method",
    "code_signature": "/**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('should convert Arabic numerals to English numerals', () => {\n        const input = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\";\n        const expectedOutput = \"1234567890\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should return the same string if there are no Arabic numerals', () => {\n        const input = \"Hello, World!\";\n        const expectedOutput = \"Hello, World!\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a mix of Arabic numerals and English characters', () => {\n        const input = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        const expectedOutput = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle empty string', () => {\n        const input = \"\";\n        const expectedOutput = \"\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a string with mixed Arabic and English numerals', () => {\n        const input = \"The number is \u0663\u0665\u0666 and 789.\";\n        const expectedOutput = \"The number is 356 and 789.\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 144,
    "code_type": "method",
    "code_signature": "/**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value: string): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('converts single Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0661')).toBe('1');\n        expect(arabicToEnglishNumbers('\u0665')).toBe('5');\n        expect(arabicToEnglishNumbers('\u0669')).toBe('9');\n    });\n\n    test('converts a string of Arabic numerals to English', () => {\n        expect(arabicToEnglishNumbers('\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669')).toBe('0123456789');\n    });\n\n    test('handles strings with Arabic and English numerals mixed', () => {\n        expect(arabicToEnglishNumbers('\u0660\u066123\u06645')).toBe('012345');\n    });\n\n    test('leaves non-numeral characters unchanged', () => {\n        expect(arabicToEnglishNumbers('Hello World!')).toBe('Hello World!');\n        expect(arabicToEnglishNumbers('2022-\u0662\u0660\u0662\u0663')).toBe('2022-2023');\n    });\n\n    test('works with full sentences that include Arabic numerals', () => {\n        expect(arabicToEnglishNumbers('The year is \u0662\u0660\u0662\u0664!')).toBe('The year is 2024!');\n    });\n\n    test('handles empty strings correctly', () => {\n        expect(arabicToEnglishNumbers('')).toBe('');\n    });\n\n    test('processes Arabic numerals in a complex mixed context', () => {\n        expect(arabicToEnglishNumbers('Price: \u0665\u0660\u0660$ and Date: \u0662\u0660\u0662\u0663-\u0661\u0662-\u0660\u0661')).toBe('Price: 500$ and Date: 2023-12-01');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts Arabic numerals in a string to English numerals.\n * This function iterates over each character in the input string, replacing Arabic numerals (\u0660-\u0669)\n * with their corresponding English numerals (0-9) while leaving other characters unchanged.\n * For example:\n *      input: \u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\n *      output: 012345678\n *\n * @param {string} value - The string containing Arabic numerals to be converted.\n * @returns {string} The converted string with Arabic numerals replaced by English numerals.\n */\nfunction arabicToEnglishNumbers(value: string): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 145,
    "code_type": "method",
    "code_signature": "/**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nfunction formatCurrency(\n    value: number,\n    currencyCode: string,\n    locale: string = \"en-US\"\n): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('formatCurrency function tests', () => {\n    test('should format currency in US dollars', () => {\n        const value = 1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '\\$1,234.56'; // Expected format for USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in Euro', () => {\n        const value = 1234.56;\n        const currencyCode = 'EUR';\n        const locale = 'en-US';\n        const expectedOutput = '\u20ac1,234.56'; // Expected format for EUR\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency in British Pound', () => {\n        const value = 1234.56;\n        const currencyCode = 'GBP';\n        const locale = 'en-GB';\n        const expectedOutput = '\u00a31,234.56'; // Expected format for GBP\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should format currency with a negative value', () => {\n        const value = -1234.56;\n        const currencyCode = 'USD';\n        const locale = 'en-US';\n        const expectedOutput = '-\\$1,234.56'; // Expected format for negative USD\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n\n    test('should handle zero value correctly', () => {\n        const value = 0;\n        const currencyCode = 'JPY';\n        const locale = 'en-JP';\n        const expectedOutput = '\u00a50'; // Expected format for JPY (no decimals)\n        expect(formatCurrency(value, currencyCode, locale)).toBe(expectedOutput);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Formats a number as currency according to the specified locale and currency code.\n *\n * @param value - The numerical value to be formatted.\n * @param currencyCode - The currency code (e.g., \"USD\", \"EUR\").\n * @param locale - The locale string (e.g., \"en-US\", \"fr-FR\"). Default is \"en-US\".\n * @returns The formatted currency string.\n */\nfunction formatCurrency(\n    value: number,\n    currencyCode: string,\n    locale: string = \"en-US\"\n): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 146,
    "code_type": "method",
    "code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the model_answer_result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n",
    "code_language": "typescript",
    "test_code": "describe('formatBytes', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        const result = formatBytes(0);\n        expect(['0 B','0 Byte']).toContain(result)\n    });\n\n    test('should return \"2.0 KB\" for 2048 bytes', () => {\n        const result = formatBytes(2048);\n        expect(['2 KB','2.0 KB']).toContain(result)\n    });\n\n    test('should return \"2.0 KiB\" for 2048 bytes with sizeType \"accurate\"', () => {\n        const result = formatBytes(2048, { sizeType: \"accurate\" });\n        expect(['2 KiB','2.0 Kib']).toContain(result)\n    });\n\n    test('should return \"5.0 MB\" for 5242880 bytes', () => {\n        const result = formatBytes(5242880);\n         expect(['5 MB','5.0 MB']).toContain(result)\n    });\n\n    test('should return \"5.00 MiB\" for 5242880 bytes with 2 decimal places and sizeType \"accurate\"', () => {\n        const result = formatBytes(5242880, { decimals: 2, sizeType: \"accurate\" });\n        expect(result).toBe('5.00 MiB');\n    });\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the model_answer_result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n",
    "addition_info": ""
  },
  {
    "task_id": 147,
    "code_type": "method",
    "code_signature": "/**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n",
    "code_language": "typescript",
    "test_code": "describe('arrayBufferToString', () => {\n    test('should return an empty string for an empty ArrayBuffer', () => {\n        const buffer1 = new ArrayBuffer(0);\n        const result = arrayBufferToString(buffer1);\n        expect(result).toBe(''); // Expected: \"\"\n    });\n\n    test('should return \"A\" for a buffer containing the character \"A\"', () => {\n        const buffer2 = new TextEncoder().encode(\"A\").buffer;\n        const result = arrayBufferToString(buffer2);\n        expect(result).toBe('A'); // Expected: \"A\"\n    });\n\n    test('should return \"Hello\" for a buffer containing the string \"Hello\"', () => {\n        const buffer3 = new TextEncoder().encode(\"Hello\").buffer;\n        const result = arrayBufferToString(buffer3);\n        expect(result).toBe('Hello'); // Expected: \"Hello\"\n    });\n\n        test('should return the correct string for a buffer containing multiple characters', () => {\n        const buffer4 = new TextEncoder().encode(\"Hello, World!\").buffer;\n        const result = arrayBufferToString(buffer4);\n        expect(result).toBe('Hello, World!'); // Expected: \"Hello, World!\"\n    });\n\n\n    test('should not modify the input buffer', () => {\n        const input = \"Test input\";\n        const buffer8 = new TextEncoder().encode(input).buffer;\n        arrayBufferToString(buffer8);\n        const result = new TextDecoder().decode(buffer8);\n        expect(result).toBe(input); // Check if the buffer content remains unchanged\n    });\n\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n",
    "addition_info": ""
  },
  {
    "task_id": 148,
    "code_type": "method",
    "code_signature": "/**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n",
    "code_language": "typescript",
    "test_code": "describe('base64ToArrayBuffer function', () => {\n    // Test Case 1\n    test('should decode \"SGVsbG8sIFdvcmxkIQ==\" to \"Hello, World!\"', () => {\n        const base64 = \"SGVsbG8sIFdvcmxkIQ==\";\n        const expected = \"Hello, World!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 2\n    test('should decode \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\" to \"Some text with sparing and working!\"', () => {\n        const base64 = \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\";\n        const expected = \"Some text with sparing and working!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 3\n    test('should decode \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\" to \"Base64 encoding is a common log For binary question\"', () => {\n        const base64 = \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\";\n        const expected = \"Base64 encoding is a commonlog For binary data\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 4\n    test('should decode \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\" to \"Give me along a path to complete start page.\"', () => {\n        const base64 = \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\";\n        const expected = \"Give me along a path to complete start page.\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 149,
    "code_type": "method",
    "code_signature": "/**\n * Converts an HSL color value to RGB.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param hue The hue of the color (0-360)\n * @param saturation The saturation of the color (0-1)\n * @param lightness The lightness of the color (0-1)\n * @return An object containing the red, green, and blue channels.\n */\nfunction hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n}",
    "code_language": "typescript",
    "test_code": "describe('hslToRgb', () => {\n    test('Converts black (0% lightness)', () => {\n        expect(hslToRgb(0, 0, 0)).toEqual({ r: 0, g: 0, b: 0 });\n    });\n\n    test('Converts white (100% lightness)', () => {\n        expect(hslToRgb(0, 0, 1)).toEqual({ r: 255, g: 255, b: 255 });\n    });\n\n    test('Converts red (hue at 0)', () => {\n        expect(hslToRgb(0, 1, 0.5)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n\n    test('Converts green (hue at 120)', () => {\n        expect(hslToRgb(120, 1, 0.5)).toEqual({ r: 0, g: 255, b: 0 });\n    });\n\n    test('Converts blue (hue at 240)', () => {\n        expect(hslToRgb(240, 1, 0.5)).toEqual({ r: 0, g: 0, b: 255 });\n    });\n\n\n    test('Handles edge case with maximum hue (360 equivalent to 0)', () => {\n        expect(hslToRgb(360, 1, 0.5)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts an HSL color value to RGB.\n * Assumes h, s, and l are contained in the set [0, 1] and\n * returns r, g, and b in the set [0, 255].\n *\n * @param hue The hue of the color (0-360)\n * @param saturation The saturation of the color (0-1)\n * @param lightness The lightness of the color (0-1)\n * @return An object containing the red, green, and blue channels.\n */\nfunction hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n}",
    "addition_info": ""
  },
  {
    "task_id": 150,
    "code_type": "method",
    "code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n",
    "code_language": "typescript",
    "test_code": "describe('rgbToHex and hexToRgb', () => {\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert RGB to HEX', () => {\n        const rgb = { r: 255, g: 99, b: 71 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#ff6347'); // Expected HEX code for RGB(255, 99, 71)\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert HEX to RGB', () => {\n        const hex = '#ff6347';\n        const result = hexToRgb(hex);\n        expect(result).toEqual({ r: 255, g: 99, b: 71 }); // Expected RGB object for HEX #ff6347\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should handle invalid RGB components gracefully', () => {\n        const rgb = { r: 300, g: -10, b: 128 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#12c-a80'); // Invalid values (300, -10) should be clamped to \"00\", valid value should convert to \"80\"\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should return null for invalid HEX strings', () => {\n        const invalidHex = '#ggg123';\n        const result = hexToRgb(invalidHex);\n        expect(result).toBeNull(); // Invalid HEX code should return null\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u8fb9\u754c\u503c\n    test('should handle boundary values in RGB correctly', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#000000'); // Boundary RGB(0, 0, 0) should convert to #000000\n\n        const rgbWhite = { r: 255, g: 255, b: 255 };\n        const resultWhite = rgbToHex(rgbWhite);\n        expect(resultWhite).toBe('#ffffff'); // Boundary RGB(255, 255, 255) should convert to #ffffff\n    });\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 151,
    "code_type": "method",
    "code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nfunction rgbToHsl({r, g, b}: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n",
    "code_language": "typescript",
    "test_code": "describe('rgbToHsl', () => {\n    test('should convert basic RGB values correctly (red)', () => {\n        const rgb = { r: 255, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 100, l: 50 });\n    });\n\n    test('should handle grayscale values (middle gray)', () => {\n        const rgb = { r: 128, g: 128, b: 128 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 50 });\n    });\n\n    test('should handle edge cases (white color)', () => {\n        const rgb = { r: 255, g: 255, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 100 });\n    });\n\n    test('should handle edge cases (black color)', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 0 });\n    });\n\n    // Additional tests\n    test('should handle vibrant green', () => {\n        const rgb = { r: 0, g: 255, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 120, s: 100, l: 50 });\n    });\n\n    test('should handle deep blue', () => {\n        const rgb = { r: 0, g: 0, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 240, s: 100, l: 50 });\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nfunction rgbToHsl({r, g, b}: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 152,
    "code_type": "method",
    "code_signature": "/**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('convertToMathematicalSansSerifItalic', () => {\n    test('should return an empty string when input is an empty string', () => {\n        const input = '';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe(''); // Edge case: empty string\n    });\n\n    test('should correctly convert all uppercase and lowercase letters to mathematical sans-serif italic', () => {\n        const input = 'HelloWorld';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc6f\ud835\udc86\ud835\udc8d\ud835\udc8d\ud835\udc90\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8d\ud835\udc85'); // Basic logic: mixed case\n    });\n\n    test('should leave characters unchanged if they have no corresponding mathematical sans-serif italic equivalent', () => {\n        const input = '12345!@#';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udfe3\ud835\udfe4\ud835\udfe5\ud835\udfe6\ud835\udfe7!@#'); // Basic logic: numbers with special characters\n    });\n\n    test('should handle input with a mix of convertible and non-convertible characters', () => {\n        const input = 'Math123!';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc74\ud835\udc82\ud835\udc95\ud835\udc89\ud835\udfe3\ud835\udfe4\ud835\udfe5!'); // Basic logic: mix of letters, numbers, and special characters\n    });\n\n    test('should handle edge case where input is at the boundary of supported characters', () => {\n        const input = 'A0z9';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc68\ud835\udfe2\ud835\udc9b\ud835\udfeb'); // Boundary values: 'A', '0', 'z', '9'\n    });\n});\n\n\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 153,
    "code_type": "method",
    "code_signature": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}",
    "code_language": "typescript",
    "test_code": "// @ts-ignore\nconst crypto = require('crypto');\n\ndescribe('compressHash', () => {\n\n    test('should return a string of length 5', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result.length).toBe(5);\n    });\n\n    test('should return different strings for different inputs', () => {\n        // @ts-ignore\n        const hash1 = crypto.createHash('sha256').update('test1').digest();\n        // @ts-ignore\n        const hash2 = crypto.createHash('sha256').update('test2').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash1);\n        // @ts-ignore\n        const result2 = compressHash(hash2);\n        expect(result1).not.toBe(result2);\n    });\n\n    test('should return a consistent model_answer_result for the same input', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash);\n        // @ts-ignore\n        const result2 = compressHash(hash);\n        expect(result1).toBe(result2);\n    });\n\n    test('should handle a hash of all zeros', () => {\n        const hash = Buffer.alloc(32, 0); // 32 bytes of zeros\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n\n    test('should handle a hash of all ones', () => {\n        const hash = Buffer.alloc(32, 255); // 32 bytes of 0xFF (255 in decimal)\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 154,
    "code_type": "method",
    "code_signature": "// Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('parseGitDiff', () => {\n\n    test('should parse a simple file addition', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/file.txt`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].newFileMode).toBe('100644');\n    });\n\n    test('should parse a simple file deletion', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\ndeleted file mode 100644\nindex e69de29..0000000\n--- a/file.txt\n+++ /dev/null`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].deletedFileMode).toBe('100644');\n    });\n\n    test('should parse a file modification with changes', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nindex e69de29..d95f3ad 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -0,0 +1 @@\n+Hello World`;\n\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n\n        expect(result).toHaveLength(1); // Ensure only one file diff is parsed\n        expect(result[0].oldPath).toBe('file.txt'); // Validate old file path\n        expect(result[0].newPath).toBe('file.txt'); // Validate new file path\n        expect(result[0].index).toBe('e69de29..d95f3ad'); // Validate index value\n        expect(result[0].changes).toEqual([\n            {code: \"--- a/file.txt\"}, // Validate old file path line\n            {code: \"+++ b/file.txt\"}, // Validate new file path line\n            {diff: '@@ -0,0 +1 @@'},  // Validate diff header\n            {code: '+Hello World'}     // Validate code addition\n        ]); // Validate changes array\n    });\n\n    test('should handle multiple file diffs', () => {\n        const diffText = `diff --git a/file1.txt b/file1.txt\nindex e69de29..d95f3ad 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -0,0 +1 @@\n+Hello World\ndiff --git a/file2.txt b/file2.txt\nindex 0a1b2c3..d4e5f6a 100644\n--- a/file2.txt\n+++ b/file2.txt\n@@ -1 +1 @@\n-Hello\n+Hi`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(2);\n        expect(result[0].oldPath).toBe('file1.txt');\n        expect(result[1].oldPath).toBe('file2.txt');\n    });\n\n    test('should return an empty array for empty diff text', () => {\n        // @ts-ignore\n        const result = parseGitDiff('');\n        expect(result).toEqual([]);\n    });\n\n});",
    "prompt": "please write a typescript function , the function signature as below // Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 155,
    "code_type": "method",
    "code_signature": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('getTimestamp', () => {\n    test('should return \"1 second ago\" for a date 1 second ago', () => {\n        const oneSecondAgo = new Date(new Date().getTime() - 1000); // 1 second ago\n        // @ts-ignore\n        expect(getTimestamp(oneSecondAgo)).toBe('1 second ago');\n    });\n\n    test('should return \"5 minutes ago\" for a date 5 minutes ago', () => {\n        const fiveMinutesAgo = new Date(new Date().getTime() - 5 * 60 * 1000); // 5 minutes ago\n        // @ts-ignore\n        expect(getTimestamp(fiveMinutesAgo)).toBe('5 minutes ago');\n    });\n\n    test('should return \"2 hours ago\" for a date 2 hours ago', () => {\n        const twoHoursAgo = new Date(new Date().getTime() - 2 * 60 * 60 * 1000); // 2 hours ago\n        // @ts-ignore\n        expect(getTimestamp(twoHoursAgo)).toBe('2 hours ago');\n    });\n\n    test('should return \"3 days ago\" for a date 3 days ago', () => {\n        const threeDaysAgo = new Date(new Date().getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        // @ts-ignore\n        expect(getTimestamp(threeDaysAgo)).toBe('3 days ago');\n    });\n\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 156,
    "code_type": "method",
    "code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('formatNumber', () => {\n    test('should format numbers greater than or equal to 1,000,000 with \"M\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(1500000)).toBe('1.5M');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n\n    test('should format numbers greater than or equal to 1,000 but less than 1,000,000 with \"K\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(2500)).toBe('2.5K');\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n    });\n\n    test('should return the number as a string if it is less than 1,000', () => {\n        // @ts-ignore\n        expect(formatNumber(999)).toBe('999');\n        // @ts-ignore\n        expect(formatNumber(500)).toBe('500');\n    });\n\n\n    test('should handle edge cases like exactly 1,000 or 1,000,000', () => {\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 157,
    "code_type": "method",
    "code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes: number): string {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('bytesToSize', () => {\n\n    test('should convert bytes to KB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1024)).toBe('1.00 KB');\n        // @ts-ignore\n        expect(bytesToSize(2048)).toBe('2.00 KB');\n    });\n\n    test('should convert bytes to MB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1048576)).toBe('1.00 MB');\n        // @ts-ignore\n        expect(bytesToSize(2097152)).toBe('2.00 MB');\n    });\n\n    test('should convert bytes to GB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1073741824)).toBe('1.00 GB');\n        // @ts-ignore\n        expect(bytesToSize(2147483648)).toBe('2.00 GB');\n    });\n\n    test('should convert bytes to TB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1099511627776)).toBe('1.00 TB');\n        // @ts-ignore\n        expect(bytesToSize(2199023255552)).toBe('2.00 TB');\n    });\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\nfunction bytesToSize(bytes: number): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 158,
    "code_type": "method",
    "code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name: string): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('getFileExtension', () => {\n    test('should return the file extension for a standard file', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.txt')).toBe('txt');\n    });\n\n    test('should return an empty string for files without an extension', () => {\n        // @ts-ignore\n        expect(getFileExtension('example')).toBe('');\n    });\n\n    test('should handle files with multiple dots', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.with.many.dots.jpg')).toBe('jpg');\n    });\n\n    test('should return an empty string for filenames that end with a dot', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.')).toBe('');\n    });\n\n    test('should correctly handle case sensitivity', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.JPG')).toBe('JPG');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\nfunction getFileExtension(file_name: string): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 159,
    "code_type": "method",
    "code_signature": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name: string): string {}",
    "code_language": "typescript",
    "test_code": "describe('removeFileExtension', () => {\n    test('should remove the file extension from a standard file', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.txt')).toBe('document');\n    });\n\n    test('should return the original filename for files without an extension', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document')).toBe('document');\n    });\n\n    test('should handle files with multiple dots correctly', () => {\n        // @ts-ignore\n        expect(removeFileExtension('my.file.with.many.extensions.pdf')).toBe('my.file.with.many.extensions');\n    });\n\n    test('should return the original filename if it ends with a dot', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.')).toBe('document');\n    });\n\n    test('should correctly handle filenames with dots in directory names', () => {\n        // @ts-ignore\n        expect(removeFileExtension('path.to/my.file.txt')).toBe('path.to/my.file');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\nfunction removeFileExtension(file_name: string): string {}",
    "addition_info": ""
  },
  {
    "task_id": 160,
    "code_type": "method",
    "code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName: string, maxLength: number = 18): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('compressFilename', () => {\n    test('should return the filename unchanged if under max length', () => {\n        expect(compressFilename('file.txt', 10)).toBe('file.txt');\n    });\n\n    test('should truncate and append *** if filename exceeds max length', () => {\n        expect(compressFilename('verylongfilename.txt', 10)).toBe('verylongfi***.txt');\n    });\n\n\n    test('should preserve file extension after compression', () => {\n        expect(compressFilename('document.pdf', 5)).toBe('docum***.pdf');\n    });\n\n\n    test('should truncate and append *** if filename exceeds', () => {\n        expect(compressFilename('short.mp3', 2)).toBe('sh***.mp3');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n * For example:\n *      compressFilename('verylongfilename.txt', 10) output: verylongfi***.txt\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\nfunction compressFileName(fileName: string, maxLength: number = 18): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 161,
    "code_type": "method",
    "code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('generateCombinations', () => {\n    test('generates combinations for a single key with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2, 3]]]);\n        const expected = [[1], [2], [3]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with single values', () => {\n        const map = new Map<string, number[]>([['a', [1]], ['b', [2]]]);\n        const expected = [[1, 2]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2]], ['b', [3, 4]]]);\n        const expected = [\n            [1, 3], [1, 4],\n            [2, 3], [2, 4]\n        ];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles an empty map', () => {\n        const map = new Map<string, number[]>();\n        const expected: number[][] = [[]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles keys with empty arrays as values', () => {\n        const map = new Map<string, number[]>([['a', []], ['b', [1, 2]]]);\n        const expected: number[][] = [];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 162,
    "code_type": "method",
    "code_signature": "/**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('boolArrayToBinaryString', () => {\n    test('converts an array of all true values', () => {\n        const boolArray = [true, true, true];\n        const expected = '111';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array of all false values', () => {\n        const boolArray = [false, false, false];\n        const expected = '000';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array with a mix of true and false values', () => {\n        const boolArray = [true, false, true, false];\n        const expected = '1010';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles an empty array', () => {\n        const boolArray: boolean[] = [];\n        const expected = '';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles a single boolean value', () => {\n        const boolArray = [true];\n        const expected = '1';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 163,
    "code_type": "method",
    "code_signature": "/**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('binaryStringToUint8Array', () => {\n    test('should convert a full byte binary string', () => {\n        const binaryStr = '11001010';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202]));\n    });\n\n    test('should convert multiple full byte binary strings', () => {\n        const binaryStr = '1100101011110000';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202, 240]));\n    });\n\n\n    test('should handle an empty binary string', () => {\n        const binaryStr = '';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([]));\n    });\n\n    test('should correctly convert binary string with leading zeros', () => {\n        const binaryStr = '00101101';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([45]));\n    });\n    test('should handle binary string with end padding of zeros', () => {\n    const binaryStr = '11001010000'; // should be treated as '11001010 00000000'\n    // @ts-ignore\n    const result = binaryStringToUint8Array(binaryStr);\n    expect(result).toEqual(new Uint8Array([202, 0]));\n});\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary question.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 164,
    "code_type": "method",
    "code_signature": "/**\n * The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array: Uint8Array): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('uint8ArrayToBase64', () => {\n    test('should convert an empty Uint8Array', () => {\n        const uint8Array = new Uint8Array([]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('');\n    });\n\n    test('should convert a Uint8Array with one byte', () => {\n        const uint8Array = new Uint8Array([255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('/w==');\n    });\n\n    test('should convert a Uint8Array with two bytes', () => {\n        const uint8Array = new Uint8Array([255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('//8=');\n    });\n\n    test('should convert a Uint8Array with three bytes', () => {\n        const uint8Array = new Uint8Array([255, 255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('////');\n    });\n\n    test('should convert a Uint8Array with four bytes', () => {\n        const uint8Array = new Uint8Array([72, 101, 108, 108]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('SGVsbA==');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * The Unit8 array is converted into 4 Base64 characters as a group of 3 bytes for processing, and the output of less than 3 is filled with =, and the resulting Base64 string is returned\n *\n * @param {Uint8Array} uint8Array - The Uint8Array to be converted.\n * @returns {string} - The resulting Base64-encoded string.\n */\nfunction uint8ArrayToBase64(uint8Array: Uint8Array): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 165,
    "code_type": "method",
    "code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('base64ToUrlSafe', () => {\n\n    test('should correctly convert a standard Base64 string to URL-safe format', () => {\n        const base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\");\n    });\n\n    test('should return an empty string when the input is an empty string', () => {\n        const base64 = \"\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"\");\n    });\n\n    test('should remove only the trailing \"=\" characters', () => {\n        const base64 = \"dGVzdA==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle strings without any characters that need replacement', () => {\n        const base64 = \"dGVzdA\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle a base64 string with multiple \"+\" and \"/\" characters', () => {\n        const base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"aGVsbG8rL3dvcmxkLw\");\n    });\n\n    test('should throw an error when input is not a string', () => {\n        expect(() => base64ToUrlSafe((null as unknown) as string)).toThrow(TypeError);\n    });\n\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 166,
    "code_type": "method",
    "code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('nextGreatestLetter', () => {\n\n    test('should return the first letter when target is greater than all letters in the array', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'j';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should return the next greatest letter for a typical input', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'a';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should handle the edge case where target is in between two letters', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('f'); // Expected output: 'f'\n    });\n\n    test('should return the first letter when the target is equal to the largest letter', () => {\n        const letters = ['a', 'b', 'c', 'd'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n    test('should return the correct letter when the array contains only one letter', () => {\n        const letters = ['a'];\n        const target = 'z';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 167,
    "code_type": "method",
    "code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName: string): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('assert999', () => {\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    test('should return true for a valid 3-digit number with \".bit\" suffix', () => {\n        const input = \"123.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string without the \".bit\" suffix.\n     * Expected to return false.\n     */\n    test('should return true for a valid 2-digit number with \".bit\" suffix', () => {\n        const input = \"12.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    test('should return false for a string with non-numeric characters after removing \".bit\"', () => {\n        const input = \"12a.bit\";\n        const result = assert999(input);\n        expect(result).toBe(false);\n    });\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the lower boundary value \"0.bit\"', () => {\n        const input = \"0.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the upper boundary value \"999.bit\"', () => {\n        const input = \"999.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n});\n\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.removes the \".bit\" suffix, checks if the remaining part is a number and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nfunction assert999(bitName: string): boolean {\n}",
    "addition_info": ""
  },
  {
    "task_id": 168,
    "code_type": "method",
    "code_signature": "/**\n * Converts a date string into a relative time description.\n * For example,now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString: string): string {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('formatDate', () => {\n    beforeAll(() => {\n        // Set the system time to a fixed date for consistent testing\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-25T12:00:00'));\n    });\n\n    afterAll(() => {\n        // Restore the real system time after tests\n        jest.useRealTimers();\n    });\n\n    test('should return \"1 day ago\" for a date exactly one day before', () => {\n        const dateString = '2024-08-24T12:00:00';\n        const result = formatDate(dateString);\n        expect(['1 day ago', '24 hours ago']).toContain(result)\n    });\n\n    test('should return \"5 hours ago\" for a date 5 hours before the current time', () => {\n        const dateString = '2024-08-25T07:00:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('5 hours ago');\n    });\n\n    test('should return \"2 minutes ago\" for a date 2 minutes before the current time', () => {\n        const dateString = '2024-08-25T11:58:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('2 minutes ago');\n    });\n\n    test('should return \"just now\" for a date within the last second', () => {\n        const dateString = '2024-08-25T11:59:59';\n        const result = formatDate(dateString);\n        expect(['1 second ago', '1 seconds ago']).toContain(result)\n    });\n\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts a date string into a relative time description.\n * For example,now time 2024-08-25T12:00:00\n *      input: 2024-08-24T12:00:00 output 1 day ago\n *      input: 2024-08-25T07:00:00 output: 5 hours ago\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nfunction formatDate(dateString: string): string {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 169,
    "code_type": "method",
    "code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num: number): string {}",
    "code_language": "typescript",
    "test_code": "describe('convertToRoman', () => {\n\n    test('should return the correct Roman numeral for a typical number', () => {\n        const result = convertToRoman(1987);\n        expect(result).toBe('MCMLXXXVII'); // 1987 = M + CM + LXXX + VII\n    });\n\n    test('should return the correct Roman numeral for the minimum value (1)', () => {\n        const result = convertToRoman(1);\n        expect(result).toBe('I'); // 1 = I\n    });\n\n    test('should return the correct Roman numeral for a large number (3999)', () => {\n        const result = convertToRoman(3999);\n        expect(result).toBe('MMMCMXCIX'); // 3999 = MMM + CM + XC + IX\n    });\n\n    test('should return the correct Roman numeral for a number with different numeral repeats', () => {\n        const result = convertToRoman(1666);\n        expect(result).toBe('MDCLXVI'); // 1666 = M + D + CLX + VI\n    });\n\n    test('should return the correct Roman numeral for number with no 5s and 1s', () => {\n        const result = convertToRoman(2000);\n        expect(result).toBe('MM'); // 2000 = MM\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nfunction convertToRoman(num: number): string {}",
    "addition_info": ""
  },
  {
    "task_id": 331,
    "code_type": "method",
    "code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('calculateFinalPrice', () => {\n    test('should calculate the final price correctly with valid inputs', () => {\n        const result = calculateFinalPrice('200', '10');\n        expect(result).toBe(180);\n    });\n\n    test('should return the original price when the discount is 0%', () => {\n        const result = calculateFinalPrice('150', '0');\n        expect(result).toBe(150);\n    });\n\n    test('should return zero when the discount is 100%', () => {\n        const result = calculateFinalPrice('100', '100');\n        expect(result).toBe(0);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 334,
    "code_type": "method",
    "code_signature": "/**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}",
    "code_language": "typescript",
    "test_code": "describe('calculateGoodFriday', () => {\n    it('should correctly calculate Good Friday for 2024', () => {\n        const result = calculateGoodFriday(2024);\n        expect(result.toDateString()).toBe('Fri Mar 29 2024');\n    });\n\n    it('should correctly calculate Good Friday for 2021', () => {\n        const result = calculateGoodFriday(2021);\n        expect(result.toDateString()).toBe('Fri Apr 02 2021');\n    });\n\n    it('should correctly calculate Good Friday for 2000', () => {\n        const result = calculateGoodFriday(2000);\n        expect(result.toDateString()).toBe('Fri Apr 21 2000');\n    });\n\n    it('should correctly calculate Good Friday for 2019', () => {\n        const result = calculateGoodFriday(2019);\n        expect(result.toDateString()).toBe('Fri Apr 19 2019');\n    });\n\n    it('should correctly calculate Good Friday for 1999', () => {\n        const result = calculateGoodFriday(1999);\n        expect(result.toDateString()).toBe('Fri Apr 02 1999');\n    });\n\n    it('should correctly calculate Good Friday for 1981', () => {\n        const result = calculateGoodFriday(1981);\n        expect(result.toDateString()).toBe('Fri Apr 17 1981');\n    });\n\n    it('should correctly calculate Good Friday for 1954', () => {\n        const result = calculateGoodFriday(1954);\n        expect(result.toDateString()).toBe('Fri Apr 16 1954');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * calculate the date of Good Friday in a given year\n * For example:\n *      input: 2024\n *      output: Fri Mar 29 2024\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 341,
    "code_type": "method",
    "code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str: string): number {\n}",
    "code_language": "typescript",
    "test_code": "describe('convertTimeHmsStringToMs', () => {\n    test('converts typical time string correctly (1h30m15s)', () => {\n        const result = convertTimeHmsStringToMs('1h30m15s');\n        expect(result).toBe(5415000);  // 1 hour + 30 minutes + 15 seconds in ms\n    });\n\n    test('correctly converts string with zero values (0h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('0h0m0s');\n        expect(result).toBe(0);  // 0 ms\n    });\n\n    test('converts maximum single digit values (9h59m59s)', () => {\n        const result = convertTimeHmsStringToMs('9h59m59s');\n        expect(result).toBe(35999000); // 9 hours + 59 minutes + 59 seconds in ms\n    });\n\n    test('handles large values (100h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('100h0m0s');\n        expect(result).toBe(360000000); // 100 hours in ms\n    });\n\n\n    test('correctly converts strings with leading zeros (01h01m01s)', () => {\n        const result = convertTimeHmsStringToMs('01h01m01s');\n        expect(result).toBe(3661000); // 1 hour + 1 minute + 1 second in ms\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nfunction convertTimeHmsStringToMs(str: string): number {\n}",
    "addition_info": ""
  },
  {
    "task_id": 342,
    "code_type": "method",
    "code_signature": "/**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown: string): { level1: string[]; level2: string[]; level3: string[] } {\n\n}\n",
    "code_language": "typescript",
    "test_code": "describe('parseMarkdownTitles', () => {\n    test('should extract first, second, and third level titles', () => {\n        const markdown = `\n        # Title 1\n        Content here.\n\n        ## Subtitle 1.1\n        More content.\n\n        ### Subsubtitle 1.1.1\n        Even more content.\n\n        # Title 2\n        Another content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n    test('should handle missing headers', () => {\n        const markdown = `\n        This is just some text without headers.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle only first-level headers', () => {\n        const markdown = `\n        # Only Title 1\n        Content without subtitles.\n        \n        # Only Title 2\n        More content.\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Only Title 1\", \"Only Title 2\"],\n            level2: [],\n            level3: [],\n        });\n    });\n\n    test('should handle mixed headers with empty lines', () => {\n        const markdown = `\n        # Title 1\n\n        ## Subtitle 1.1\n\n        Some content here.\n\n        ### Subsubtitle 1.1.1\n        \n        # Title 2\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1\", \"Title 2\"],\n            level2: [\"Subtitle 1.1\"],\n            level3: [\"Subsubtitle 1.1.1\"],\n        });\n    });\n\n\n    test('should handle headers with special characters', () => {\n        const markdown = `\n        # Title 1 - Special Characters!\n        ## Subtitle 1.1: The Beginning\n        ### Subsubtitle 1.1.1 (Note)\n        `;\n        const result = parseMarkdownTitles(markdown);\n        expect(result).toEqual({\n            level1: [\"Title 1 - Special Characters!\"],\n            level2: [\"Subtitle 1.1: The Beginning\"],\n            level3: [\"Subsubtitle 1.1.1 (Note)\"],\n        });\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Parses markdown text to extract titles of different levels.\n *\n * This function takes a string of markdown content as input and returns an\n * object containing arrays of titles categorized by their level:\n * level 1 (H1), level 2 (H2), and level 3 (H3).\n *\n * @param markdown - A string containing markdown formatted text.\n * @returns An object with three properties: level1, level2, and level3,\n *          each holding an array of corresponding titles found in the markdown.\n */\nfunction parseMarkdownTitles(markdown: string): { level1: string[]; level2: string[]; level3: string[] } {\n\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 343,
    "code_type": "method",
    "code_signature": "type AnyObject = { [key: string]: any };\n\n/**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1: AnyObject, obj2: AnyObject): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('compareObjectsDepth function tests', () => {\n    test('should return true for equal depth and structure', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objB = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objB)).toBe(false); // Same structure\n    });\n\n    test('should return false for different structure (missing key)', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objC = { a: { b: { c: 3 } }, e: 4 };\n        expect(compareObjectsDepth(objA, objC)).toBe(false); // Different structure\n    });\n\n    test('should return false for different depth', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objD = { a: { b: 1 }, d: 2 };\n        expect(compareObjectsDepth(objA, objD)).toBe(false); // Different depth\n    });\n\n    test('should return false for non-object inputs', () => {\n        const objA = { a: { b: { c: 1 } }, d: 2 };\n        const objE = null;\n        expect(compareObjectsDepth(objA, objE)).toBe(false); // Non-object input\n    });\n\n    test('should return false for different types (number vs object)', () => {\n        const objA = { a: { b: 1 }, d: 2 };\n        const objF = { a: { b: { c: 3 } }, d: 4 };\n        expect(compareObjectsDepth(objA, objF)).toBe(false); // Different types\n    });\n\n    test('should return true for identical empty objects', () => {\n        const objG = {};\n        const objH = {};\n        expect(compareObjectsDepth(objG, objH)).toBe(true); // Both are empty\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below type AnyObject = { [key: string]: any };\n\n/**\n * Compares two objects to determine if they have the same depth and structure.\n *\n * @param obj1 - The first object to compare.\n * @param obj2 - The second object to compare.\n * @returns True if the objects have equal depth, otherwise false.\n */\nfunction compareObjectsDepth(obj1: AnyObject, obj2: AnyObject): boolean {\n}",
    "addition_info": "type AnyObject = { [key: string]: any };"
  },
  {
    "task_id": 565,
    "code_type": "method",
    "code_signature": "// Define the Coordinates type to represent a point in 2D space\ntype Coordinates = {\n    x: number;\n    y: number;\n};\n\n/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t: number, points: Coordinates[]): Coordinates {\n}",
    "code_language": "typescript",
    "test_code": "describe('getBezierPoint', () => {\n    // Test case 1: Test with a simple linear curve\n    test('should return the midpoint of two points', () => {\n        const points: Coordinates[] = [{ x: 0, y: 0 }, { x: 2, y: 2 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 2: Test with three points (quadratic curve)\n    test('should return the correct point on a quadratic B\u00e9zier curve', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 1, y: 2 },\n            { x: 2, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 1, y: 1 });\n    });\n\n    // Test case 3: Test with four points (cubic curve)\n    test('should return the correct point on a cubic B\u00e9zier curve', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 1, y: 3 },\n            { x: 3, y: 1 },\n            { x: 4, y: 0 }\n        ];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 2, y: 1.5 });\n    });\n\n    // Test case 4: Test with single point (edge case)\n    test('should return the only point when there is a single control point', () => {\n        const points: Coordinates[] = [{ x: 5, y: 5 }];\n        const result = getBezierPoint(0.5, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n\n    // Test case 5: Test with extreme t value (0)\n    test('should return the first control point when t is 0', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(0, points);\n        expect(result).toEqual({ x: 0, y: 0 });\n    });\n\n    // Test case 6: Test with extreme t value (1)\n    test('should return the last control point when t is 1', () => {\n        const points: Coordinates[] = [\n            { x: 0, y: 0 },\n            { x: 5, y: 5 }\n        ];\n        const result = getBezierPoint(1, points);\n        expect(result).toEqual({ x: 5, y: 5 });\n    });\n\n});",
    "prompt": "please write a typescript function , the function signature as below // Define the Coordinates type to represent a point in 2D space\ntype Coordinates = {\n    x: number;\n    y: number;\n};\n\n/**\n * Recursively calculates a point on a B\u00e9zier curve using De Casteljau's algorithm.\n *\n * @param t - A value between 0 and 1 representing the interpolation parameter.\n * @param points - An array of control points defining the B\u00e9zier curve.\n * @returns The calculated Coordinates at the given parameter t.\n */\nfunction getBezierPoint(t: number, points: Coordinates[]): Coordinates {\n}",
    "addition_info": ""
  },
  {
    "task_id": 566,
    "code_type": "method",
    "code_signature": "/**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1: number, timestamp2: number): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('isSameDay', () => {\n    test('should return false for timestamps on different days', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 2, 10, 0, 0)).getTime(); // October 2, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return true for timestamps on the same day but different times', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 12, 30, 0)).getTime(); // October 1, 2024, 12:30 PM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps on the same day in different time zones', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // UTC\n        const timestamp2 = new Date('2024-10-01T12:00:00+02:00').getTime(); // October 1, 2024, 12:00 PM UTC+2\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n    test('should return true for timestamps at midnight on the same day', () => {\n        const timestamp1 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // October 1, 2024, 12:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 0, 0, 0)).getTime(); // Same timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(true);\n    });\n\n\n    test('should return false for timestamps in different years', () => {\n        const timestamp1 = new Date(Date.UTC(2023, 9, 1, 10, 0, 0)).getTime(); // October 1, 2023, 10:00 AM UTC\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // October 1, 2024, 10:00 AM UTC\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n\n    test('should return false for invalid timestamps', () => {\n        const timestamp1 = new Date('invalid').getTime(); // Invalid timestamp\n        const timestamp2 = new Date(Date.UTC(2024, 9, 1, 10, 0, 0)).getTime(); // Valid timestamp\n        expect(isSameDay(timestamp1, timestamp2)).toBe(false);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Checks if two timestamps correspond to the same day.\n *\n * @param timestamp1 - The first timestamp to compare.\n * @param timestamp2 - The second timestamp to compare.\n * @returns True if both timestamps are on the same day, false otherwise.\n */\nfunction isSameDay(timestamp1: number, timestamp2: number): boolean {\n}",
    "addition_info": ""
  },
  {
    "task_id": 567,
    "code_type": "method",
    "code_signature": "/**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate: Date): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('getRelativeTime', () => {\n    beforeAll(() => {\n        // Mock the current date to ensure consistent test results\n        jest.useFakeTimers().setSystemTime(new Date('2024-10-01'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return \"Today\" for a message created today', () => {\n        const messageDate = new Date(); // Current date\n        expect(getRelativeTime(messageDate)).toBe(\"Today\");\n    });\n\n    test('should return \"Yesterday\" for a message created yesterday', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24); // Yesterday\n        expect(getRelativeTime(messageDate)).toBe(\"Yesterday\");\n    });\n\n    test('should return formatted date string for a message created 10 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 10); // 10 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/21\"); // Adjust based on the mock date\n    });\n\n    test('should return formatted date string for a message created 15 days ago', () => {\n        const messageDate = new Date(Date.now() - 1000 * 60 * 60 * 24 * 15); // 15 days ago\n        expect(getRelativeTime(messageDate)).toBe(\"2024/09/16\"); // Adjust based on the mock date\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Returns a string representing the relative time since the given message was created.\n *\n * - If the message was created today, it returns \"Today\".\n * - If the message was created yesterday, it returns \"Yesterday\".\n * - If the message was created within the past week (but not today or yesterday),\n *   it returns the corresponding day of the week (e.g., \"Monday\").\n * - If the message was created earlier than one week ago, it returns a formatted date string\n *   (e.g., \"YYYY/MM/DD\").\n *\n * @param messageDate - The date when the message was created. This should be a valid Date object.\n * @returns A string indicating the relative time from the current date to the message creation date.\n */\nfunction getRelativeTime(messageDate: Date): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 569,
    "code_type": "method",
    "code_signature": "/**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input: string, maxLength: number = 18): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('compressString', () => {\n    it('should return the original string if it is shorter than the max length', () => {\n        const input = \"Short string\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should return the original string if it is exactly equal to the max length', () => {\n        const input = \"Exactly 18 chars\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n\n    it('should truncate the string and append \"...\" if it exceeds the max length', () => {\n        const input = \"This is a long string that needs to be compressed.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This is a long ...\");\n    });\n\n    it('should truncate the string to maxLength - 3 and append \"...\" when maxLength is specified', () => {\n        const input = \"Another long string that is definitely too long.\";\n        const result = compressString(input, 25);\n        expect(result).toBe(\"Another long string th...\");\n    });\n\n    it('should use default max length of 18 if no maxLength is provided', () => {\n        const input = \"This string is way too long.\";\n        const result = compressString(input);\n        expect(result).toBe(\"This string is ...\");\n    });\n\n    it('should return the original string if it is empty', () => {\n        const input = \"\";\n        const result = compressString(input);\n        expect(result).toBe(input);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Compresses a string to ensure its length does not exceed the specified maximum length.\n * If the string exceeds the maximum length, it truncates the string and appends an ellipsis (\"...\").\n *\n * @param input - The string to be compressed.\n * @param maxLength - The maximum allowed length of the string (default is 18).\n * @returns A compressed string that does not exceed the specified length.\n */\nfunction compressString(input: string, maxLength: number = 18): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 570,
    "code_type": "method",
    "code_signature": "type PlainObject = { [key: string]: any };\n\n/**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param obj1 - The first object to merge.\n * @param obj2 - The second object to merge.\n * @returns A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1: PlainObject, obj2: PlainObject | null | undefined): PlainObject => {\n}",
    "code_language": "typescript",
    "test_code": "describe('deepMergeObjects', () => {\n\n\n    test('handles null values in obj2', () => {\n        const obj1 = {a: 1, b: 2};\n        const obj2 = null;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('handles undefined values in obj2', () => {\n        const obj1 = {a: 1, b: 2};\n        const obj2 = undefined;\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual(obj1); // Should return obj1\n    });\n\n    test('merges deeply nested objects', () => {\n        const obj1 = {a: {b: {c: 1}}, d: 2};\n        const obj2 = {a: {b: {d: 3}}, e: 4};\n        const result = deepMergeObjects(obj1, obj2);\n        expect(result).toEqual({\n            \"a\": {\n                \"b\": {\n                    \"c\": 1\n                }\n            },\n            \"d\": 2\n        });\n    });\n\n    test('does not merge arrays but takes them from obj1', () => {\n    const obj1 = {a: [1, 2, 3]};\n    const obj2 = {a: [4, 5]};\n    const result = deepMergeObjects(obj1, obj2);\n    expect(result).toEqual({a: [1, 2, 3]}); // Should keep array from obj1\n});\n});",
    "prompt": "please write a typescript function , the function signature as below type PlainObject = { [key: string]: any };\n\n/**\n * Deeply merges two objects.\n * If properties are objects in both objects, they are recursively merged.\n * If a property exists in both objects but is not an object, the value from obj1 is used.\n *\n * @param obj1 - The first object to merge.\n * @param obj2 - The second object to merge.\n * @returns A new object that is the result of the merge.\n */\nconst deepMergeObjects = (obj1: PlainObject, obj2: PlainObject | null | undefined): PlainObject => {\n}",
    "addition_info": ""
  },
  {
    "task_id": 571,
    "code_type": "method",
    "code_signature": "/**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord: string): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('isValidCoordinate', () => {\n    test('valid latitude with direction', () => {\n        const coord = \"45.123N\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid latitude without direction', () => {\n        const coord = \"90.0\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude with direction', () => {\n        const coord = \"180.0E\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n    test('valid longitude without direction', () => {\n        const coord = \"-120.456\";\n        expect(isValidCoordinate(coord)).toBe(true);\n    });\n\n\n    test('invalid longitude exceeding range', () => {\n        const coord = \"-200.5\";\n        expect(isValidCoordinate(coord)).toBe(false);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Checks if the string conforms to the latitude and longitude identification specification.\n *\n * @param coord - The coordinate string to check (can be latitude or longitude).\n * @returns A boolean indicating whether the coordinate is valid.\n */\nfunction isValidCoordinate(coord: string): boolean {\n}",
    "addition_info": ""
  },
  {
    "task_id": 572,
    "code_type": "method",
    "code_signature": "/**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate<O>(\n    arr1: Array<O>,\n    arr2: Array<O>,\n    getId: (item: O) => string\n): Array<O> {\n}",
    "code_language": "typescript",
    "test_code": "interface Item {\n    id: string;\n    name: string;\n}\n\ndescribe('mergeOrUpdate', () => {\n    test('merges two arrays with unique items', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '4', name: 'Item 4' }\n        ]);\n    });\n\n    test('updates existing items when IDs match', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n\n    test('handles empty arrays', () => {\n        const arr1: Item[] = [];\n        const arr2: Item[] = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([]);\n    });\n\n    test('merges with an empty first array', () => {\n        const arr1: Item[] = [];\n        const arr2: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('merges with an empty second array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the first array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '1', name: 'Duplicate Item 1' } // Duplicate ID\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Item 2' }\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Duplicate Item 1' }, // Last occurrence takes precedence\n            { id: '2', name: 'Item 2' }\n        ]);\n    });\n\n    test('handles duplicate IDs in the second array', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Item 2' },\n            { id: '2', name: 'Duplicate Item 2' } // Duplicate ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Duplicate Item 2' } // Last occurrence takes precedence\n        ]);\n    });\n\n    test('merges arrays with mixed unique and duplicate IDs', () => {\n        const arr1: Item[] = [\n            { id: '1', name: 'Item 1' },\n            { id: '2', name: 'Item 2' }\n        ];\n        const arr2: Item[] = [\n            { id: '2', name: 'Updated Item 2' },\n            { id: '3', name: 'Item 3' },\n            { id: '1', name: 'New Item 1' } // Updated item with same ID\n        ];\n\n        const result = mergeOrUpdate(arr1, arr2, item => item.id);\n        expect(result).toEqual([\n            { id: '1', name: 'New Item 1' }, // Updated\n            { id: '2', name: 'Updated Item 2' }, // Updated\n            { id: '3', name: 'Item 3' }\n        ]);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Merges two arrays of objects, updating items in the first array with items\n * from the second array based on a unique identifier. If an ID exists in both\n * arrays, the item from the second array will replace the one in the first.\n *\n * @param arr1 - The first array of objects to merge.\n * @param arr2 - The second array of objects to merge, which may update\n *               items in the first array.\n * @param getId - A function that takes an object and returns its unique ID\n *                as a string, used to identify items for merging.\n * @returns An array of merged objects, including all unique items from both\n *          input arrays, with updates applied from the second array.\n */\nfunction mergeOrUpdate<O>(\n    arr1: Array<O>,\n    arr2: Array<O>,\n    getId: (item: O) => string\n): Array<O> {\n}",
    "addition_info": ""
  },
  {
    "task_id": 575,
    "code_type": "method",
    "code_signature": "/**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {\n}",
    "code_language": "typescript",
    "test_code": "describe('formatThreadCount', () => {\n    test('should return \"01 Thread\" for a count of 1', () => {\n        expect(formatThreadCount(1)).toBe(\"01 Thread\");\n    });\n\n    test('should return \"05 Threads\" for a count of 5', () => {\n        expect(formatThreadCount(5)).toBe(\"05 Threads\");\n    });\n\n    test('should return \"10 Threads\" for a count of 10', () => {\n        expect(formatThreadCount(10)).toBe(\"10 Threads\");\n    });\n\n    test('should return \"99 Threads\" for a count of 99', () => {\n        expect(formatThreadCount(99)).toBe(\"99 Threads\");\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Formats the thread count into a user-friendly string.\n * For example:\n *      input: 3 output: 03 Threads\n *      input: 1 output: 01 Thread\n *\n * @param {number} count - The number of threads.\n * @returns {string} - A formatted string indicating the number of threads.\n */\nfunction formatThreadCount(count) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 576,
    "code_type": "method",
    "code_signature": "/**\n * Hides the sensitive part of a bank account number with 17 number only show the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not longer than 17 characters.\n */\nfunction hideBankAccount(account: string): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('hideBankAccount', () => {\n    test('should return \"****4567\" for an account number of \"12345678901234567\"', () => {\n        expect(hideBankAccount('12345678901234567')).toBe('****4567');\n    });\n\n    test('should return \"****6543\" for an account number of \"98765432109876543\"', () => {\n        expect(hideBankAccount('98765432109876543')).toBe('****6543');\n    });\n\n    test('should return \"****1100\" for an account number of \"11111111111111100\"', () => {\n        expect(hideBankAccount('11111111111111100')).toBe('****1100');\n    });\n\n    test('should throw an error for an account number shorter than 17 characters', () => {\n        expect(() => hideBankAccount('1234567890123456')).toThrow();\n    });\n\n    test('should throw an error for an account number longer than 17 characters', () => {\n        expect(() => hideBankAccount('123456789012345678')).toThrow();\n    });\n\n    test('should throw an error for an account number with 0 characters', () => {\n        expect(() => hideBankAccount('')).toThrow();\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Hides the sensitive part of a bank account number with 17 number only show the last 4 characters.\n * For example:\n *      input: 12345678901234567\n *      output: ****4567\n * @param {string} account - The bank account number to hide.\n * @returns {string} - The bank account number with the first part hidden.\n * @throws {Error} - Throws an error if the account number is not longer than 17 characters.\n */\nfunction hideBankAccount(account: string): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 577,
    "code_type": "method",
    "code_signature": "/**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count: number): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('formatPostCount', () => {\n    test('should return \"01 Post\" for count of 1', () => {\n        expect(formatPostCount(1)).toBe('01 Post');\n    });\n\n    test('should return \"02 Posts\" for count of 2', () => {\n        expect(formatPostCount(2)).toBe('02 Posts');\n    });\n\n    test('should return \"10 Posts\" for count of 10', () => {\n        expect(formatPostCount(10)).toBe('10 Posts');\n    });\n\n    test('should return \"99 Posts\" for count of 99', () => {\n        expect(formatPostCount(99)).toBe('99 Posts');\n    });\n\n    test('should return \"05 Posts\" for count of 5', () => {\n        expect(formatPostCount(5)).toBe('05 Posts');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Formats the post count into a human-readable string.\n * For example:\n *      input: 3 output: 02 Posts\n *      input: 1 output: 01 Post\n *\n * @param {number} count - The number of posts.\n * @returns {string} - A formatted string indicating the number of posts.\n */\nfunction formatPostCount(count: number): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 578,
    "code_type": "method",
    "code_signature": "/**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input: string): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('isKebabCase', () => {\n    test('should return true for a valid kebab-case string', () => {\n        expect(isKebabCase('kebab-case')).toBe(true);\n    });\n\n    test('should return true for a valid kebab-case string with multiple words', () => {\n        expect(isKebabCase('this-is-a-valid-kebab-case')).toBe(true);\n    });\n\n    test('should return false for a string with uppercase letters', () => {\n        expect(isKebabCase('Kebab-Case')).toBe(false);\n    });\n\n    test('should return false for a string with consecutive hyphens', () => {\n        expect(isKebabCase('kebab--case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isKebabCase('')).toBe(false);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in KEBAB_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in KEBAB_CASE, otherwise false.\n */\nfunction isKebabCase(input: string): boolean {\n}",
    "addition_info": ""
  },
  {
    "task_id": 581,
    "code_type": "method",
    "code_signature": "/**\n * Abbreviates a number to a string with a suffix based on its magnitude.suffix [\"\", \"k\", \"M\", \"B\", \"T\"] 1000 is k,1000000 is M,1000000000 is B\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number: number): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('abbreviateNumber', () => {\n    test('should return the same number for values less than 1000', () => {\n        expect(abbreviateNumber(999)).toBe('999');\n    });\n\n    test('should return \"1k\" for 1000', () => {\n        const result= abbreviateNumber(1000)\n        expect(['1k', '1.0k']).toContain(result);\n    });\n\n    test('should return \"1.5k\" for 1500', () => {\n        expect(abbreviateNumber(1500)).toBe('1.5k');\n    });\n\n    test('should return \"1M\" for 1 million', () => {\n        const result = abbreviateNumber(1000000);\n        expect(['1M', '1.0M']).toContain(result);\n    });\n\n    test('should return \"25M\" for 25 million', () => {\n        expect(abbreviateNumber(25000000)).toBe('25M');\n    });\n\n    test('should return \"1B\" for 1 billion', () => {\n        const result = abbreviateNumber(1000000000)\n        expect(['1B', '1.0B']).toContain(result);\n    });\n\n    test('should return \"1.2T\" for 1.2 trillion', () => {\n        expect(abbreviateNumber(1234567890123)).toBe('1.2T');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Abbreviates a number to a string with a suffix based on its magnitude.suffix [\"\", \"k\", \"M\", \"B\", \"T\"] 1000 is k,1000000 is M,1000000000 is B\n * For example:\n *      input: 999 output: 999\n *      input: 1549 output: 1.5k\n *      input: 1000 output: 1k\n *      input: 1234567890123 output: 1.2T\n * @param {number} number - The number to abbreviate.\n * @returns {string} - The abbreviated string representation of the number.\n */\nfunction abbreviateNumber(number: number): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 582,
    "code_type": "method",
    "code_signature": "/**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Record<string, any>} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params: Record<string, any>): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('toQueryString', () => {\n\n    test('should convert a simple object to a query string', () => {\n        const params = {search: 'test', page: 1, size: 10};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=test&page=1&size=10');\n    });\n\n\n    test('should encode special characters in the query string', () => {\n        const params = {search: 'hello world', filter: 'price < \\$50'};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=hello%20world&filter=price%20%3C%20%2450');\n    });\n\n    test('should handle empty string values', () => {\n        const params = {search: '', page: 1};\n        const result = toQueryString(params);\n        expect(result).toBe('?search=&page=1');\n    });\n\n    test('should handle boolean values', () => {\n        const params = {isActive: true, isVerified: false};\n        const result = toQueryString(params);\n        expect(result).toBe('?isActive=true&isVerified=false');\n    });\n});\n",
    "prompt": "please write a typescript function , the function signature as below /**\n * Converts an object to a query string.\n * For example:\n *      input: { search: 'test', page: 1, size: 10 };\n *      output: ?search=test&page=1&size=10\n *\n * @param {Record<string, any>} params - The parameters to convert.\n * @returns {string} - The query string.\n */\nfunction toQueryString(params: Record<string, any>): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 583,
    "code_type": "method",
    "code_signature": "/**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url: string, key: string): string {\n}",
    "code_language": "typescript",
    "test_code": "describe('removeQueryParam', () => {\n    test('should remove an existing parameter from the URL', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should not modify the URL if the parameter does not exist', () => {\n        const url = 'https://example.com?page=1&filter=red';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/?page=1&filter=red');\n    });\n\n    test('should return the original URL if there are no query parameters', () => {\n        const url = 'https://example.com';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n\n    test('should remove multiple occurrences of a parameter', () => {\n        const url = 'https://example.com?page=1&filter=red&filter=blue';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1');\n    });\n\n    test('should handle encoded characters in the parameter', () => {\n        const url = 'https://example.com?page=1&sort=asc&filter=hello%20world';\n        const result = removeQueryParam(url, 'filter');\n        expect(result).toBe('https://example.com/?page=1&sort=asc');\n    });\n\n    test('should handle the case when the parameter is the only one in the URL', () => {\n        const url = 'https://example.com?sort=asc';\n        const result = removeQueryParam(url, 'sort');\n        expect(result).toBe('https://example.com/');\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Removes the specified parameter from the URL query string.\n *\n * @param {string} url - The URL from which to remove the parameter.\n * @param {string} key - The key of the parameter to remove.\n * @returns {string} - The modified URL with the specified parameter removed.\n */\nfunction removeQueryParam(url: string, key: string): string {\n}",
    "addition_info": ""
  },
  {
    "task_id": 584,
    "code_type": "method",
    "code_signature": "/**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input: string): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('isPascalCase', () => {\n    test('should return true for a valid PascalCase string', () => {\n        expect(isPascalCase('PascalCase')).toBe(true);\n    });\n\n    test('should return true for a valid PascalCase string with multiple words', () => {\n        expect(isPascalCase('PascalCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with a lowercase letter', () => {\n        expect(isPascalCase('pascalCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isPascalCase('Pascal_case')).toBe(false);\n    });\n\n    test('should return false for a string that is empty', () => {\n        expect(isPascalCase('')).toBe(false);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in PASCAL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in PASCAL_CASE, otherwise false.\n */\nfunction isPascalCase(input: string): boolean {\n}",
    "addition_info": ""
  },
  {
    "task_id": 585,
    "code_type": "method",
    "code_signature": "/**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input: string): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('isCamelCase', () => {\n    test('should return true for a valid camelCase string', () => {\n        expect(isCamelCase('camelCase')).toBe(true);\n    });\n\n    test('should return true for a valid camelCase string with multiple words', () => {\n        expect(isCamelCase('camelCaseExample')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isCamelCase('CamelCase')).toBe(false);\n    });\n\n    test('should return false for a string with underscores', () => {\n        expect(isCamelCase('camel_case')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isCamelCase('')).toBe(false);\n    });\n\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in CAMEL_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in CAMEL_CASE, otherwise false.\n */\nfunction isCamelCase(input: string): boolean {\n}",
    "addition_info": ""
  },
  {
    "task_id": 586,
    "code_type": "method",
    "code_signature": "/**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input: string): boolean {\n}",
    "code_language": "typescript",
    "test_code": "describe('isSnakeCase', () => {\n    test('should return true for a valid snake_case string', () => {\n        expect(isSnakeCase('snake_case')).toBe(true);\n    });\n\n    test('should return true for a valid snake_case string with multiple words', () => {\n        expect(isSnakeCase('snake_case_example')).toBe(true);\n    });\n\n    test('should return false for a string that starts with an uppercase letter', () => {\n        expect(isSnakeCase('Snake_Case')).toBe(false);\n    });\n\n    test('should return false for a string with mixed case letters', () => {\n        expect(isSnakeCase('snakeCASE')).toBe(false);\n    });\n\n    test('should return false for a string with numbers', () => {\n        expect(isSnakeCase('snake_case_123')).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isSnakeCase('')).toBe(false);\n    });\n});",
    "prompt": "please write a typescript function , the function signature as below /**\n * Detects whether the string is in SNAKE_CASE.\n *\n * @param {string} input - The string to check.\n * @returns {boolean} - True if the string is in SNAKE_CASE, otherwise false.\n */\nfunction isSnakeCase(input: string): boolean {\n}",
    "addition_info": ""
  }
]