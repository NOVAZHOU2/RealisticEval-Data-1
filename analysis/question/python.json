[{"task_id": 1, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSmartConvert(unittest.TestCase):\n    def test_convert_integer(self):\n        self.assertEqual(numerical_str_convert(\"123\"), 123, \"Should convert to integer\")\n\n    def test_convert_float(self):\n        self.assertEqual(numerical_str_convert(\"123.45\"), 123.45, \"Should convert to float\")\n\n    def test_convert_non_numeric_string(self):\n        self.assertEqual(numerical_str_convert(\"abc\"), \"abc\", \"Should remain a string\")\n\n    def test_convert_negative_integer(self):\n        self.assertEqual(numerical_str_convert(\"-456\"), -456, \"Should convert to negative integer\")\n\n    def test_convert_negative_float(self):\n        self.assertEqual(numerical_str_convert(\"-456.78\"), -456.78, \"Should convert to negative float\")\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n\n    Args:\n        value (str): input value str\n    Returns:\n       Union[int, float, str]: convert model_answer_result\n    \"\"\"\n"}, {"task_id": 5, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestMatrixMultiplication(unittest.TestCase):\n    def test_standard_matrices(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should correctly multiply standard matrices\")\n\n    def test_empty_matrices(self):\n        mat1 = []\n        mat2 = []\n        expected = []\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should handle empty matrices without error\")\n\n    def test_identity_matrix(self):\n        mat1 = [[1, 0], [0, 1]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[5, 6], [7, 8]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the identity matrix should yield the answer.py matrix\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n\n    Args:\n        matrixA (List[List[int]]): matrix A\n        matrixB (List[List[int]]): matrix B\n\n    Returns:\n        List[List[int]]: matrixA matrixB multiplication model_answer_result\n    \"\"\"\n"}, {"task_id": 6, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSimplifyWindowsPath(unittest.TestCase):\n    def test_simple_path(self):\n        self.assertEqual(simplify_windows_path(r\"C:\\Users\\User\\file.txt\"), \"C_Users_User_file.txt\")\n\n    def test_simple_path2(self):\n        self.assertEqual(simplify_windows_path(r\"D:\\User\\file.txt\"), \"D_User_file.txt\")\n\n    def test_path_with_spaces(self):\n        self.assertEqual(simplify_windows_path(r\"E:\\New Folder\\my file.docx\"), \"E_New Folder_my file.docx\")\n\n    def test_nested_directories(self):\n        self.assertEqual(simplify_windows_path(r\"G:\\folder1\\folder2\\folder3\\file.jpeg\"),\n                         \"G_folder1_folder2_folder3_file.jpeg\")\n", "prompt": "please write a python function , the function signature as below def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings.\n    For example:\n        input: C:\\\\Users\\\\User\\\\file.txt\n        output: C_Users_User_file.txt\n    Args:\n        path (str): windows file path str\n\n    Returns:\n        str: simplify path str\n    \"\"\"\n"}, {"task_id": 7, "code_type": "class", "code_language": "python", "test_code": "import logging\nimport unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\n\nclass TestLogger(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a Logger instance for testing.\"\"\"\n        self.logger_name = \"TestLogger\"\n        self.logger = Logger(self.logger_name)\n\n    def test_initialization(self):\n        \"\"\"Test that the logger is initialized with the correct name and level.\"\"\"\n        self.assertEqual(self.logger.logger.name, self.logger_name)\n        self.assertEqual(self.logger.logger.level, logging.DEBUG)\n\n    def test_default_logging_level(self):\n        \"\"\"Test that the logger defaults to DEBUG level if not specified.\"\"\"\n        logger_default = Logger(\"DefaultLogger\")\n        self.assertEqual(logger_default.logger.level, logging.DEBUG)\n\n    def test_console_handler_added(self):\n        \"\"\"Test that the console handler is added to the logger.\"\"\"\n        handlers = self.logger.logger.handlers\n        self.assertGreater(len(handlers), 0)\n        self.assertIsInstance(handlers[0], logging.StreamHandler)\n\n", "prompt": "please write a python class , the class signature as below import logging\n\n\nclass Logger:\n    def __init__(self, name, level=logging.DEBUG):\n        \"\"\"\n        Initializes a new logger instance.\n\n        :param name: Name of the logger, typically __name__ to reference the module name.\n        :param level: Logging level, default is DEBUG.\n        \"\"\"\n\n    def log(self, level, message):\n        \"\"\"\n        Logs a message with the given level.\n\n        :param level: Logging level for the message (e.g., logging.INFO).\n        :param message: Log message.\n        \"\"\"\n"}, {"task_id": 8, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestDecryptFunction(unittest.TestCase):\n    def test_basic_functionality(self):\n        self.assertEqual(perform_polynomial_decryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]), [4, 4, 4, 4])\n\n    def test_zero_secret_key(self):\n        self.assertEqual(perform_polynomial_decryption(3, 7, [0, 0, 0], [6, 13, 20]), [6, 6, 6])\n\n    def test_zero_ciphertext(self):\n        self.assertEqual(perform_polynomial_decryption(3, 9, [1, 2, 3], [0, 0, 0]), [8, 7, 6])\n\n    def test_large_values(self):\n        self.assertEqual(perform_polynomial_decryption(2, 1000, [500, 500], [1000, 1000]), [500, 500])\n\n\ndef perform_polynomial_decryption(degree, modulus, key, encrypted_data):\n    # Decrypts the polynomial based encryption by reversing the encryption steps\n    decrypted_data = [0] * degree\n\n    for index in range(degree):\n        # Reversing encryption: subtract key and take modulo\n        decrypted_data[index] = (encrypted_data[index] - key[index]) % modulus\n\n    return decrypted_data\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting question\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted question\n\n    Returns: decrypted question\n\n    \"\"\""}, {"task_id": 9, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\ndef is_point_on_line(A, B, C):\n    (x_a, y_a), (x_b, y_b), (x_c, y_c) = A, B, C\n    if x_a == x_b:  # Check for vertical line\n        return x_c == x_a\n    return (y_c - y_a) * (x_b - x_a) == (y_b - y_a) * (x_c - x_a)\n\n\nclass TestPointOnLine(unittest.TestCase):\n    def test_point_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 6)\n        self.assertFalse(is_point_on_line(A, B, C))\n\n    def test_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_horizontal_line(self):\n        A = (0, 5)\n        B = (10, 5)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (6, 5)\n        self.assertFalse(is_point_on_line(A, B, C))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\""}, {"task_id": 11, "code_type": "class", "code_language": "python", "test_code": "import unittest\n\n\nclass TestTrie(unittest.TestCase):\n    def setUp(self):\n        self.trie = Trie()\n        self.trie.insert(\"apple\")\n        self.trie.insert(\"app\")\n        self.trie.insert(\"apricot\")\n        self.trie.insert(\"banana\")\n        self.trie.insert(\"carrot\")\n        self.trie.insert(\"car\")\n        self.trie.insert(\"care\")\n        self.trie.insert(\"\")\n        self.trie.insert(\"Hello\")\n        self.trie.insert(\"hello\")\n\n    def test_basic_search(self):\n        self.assertTrue(self.trie.search(\"apple\"))\n        self.assertTrue(self.trie.search(\"app\"))\n        self.assertTrue(self.trie.search(\"apricot\"))\n\n    def test_unsuccessful_search(self):\n        self.assertFalse(self.trie.search(\"bandana\"))\n\n    def test_prefix_search(self):\n        self.assertTrue(self.trie.starts_with(\"car\"))\n        self.assertTrue(self.trie.starts_with(\"care\"))\n        self.assertFalse(self.trie.starts_with(\"cat\"))\n\n    def test_empty_string(self):\n        self.assertTrue(self.trie.search(\"\"))\n        self.assertTrue(self.trie.starts_with(\"\"))\n\n    def test_case_sensitivity(self):\n        self.assertTrue(self.trie.search(\"Hello\"))\n        self.assertTrue(self.trie.search(\"hello\"))\n        self.assertFalse(self.trie.search(\"HELLO\"))\n", "prompt": "please write a python class , the class signature as below class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n"}, {"task_id": 12, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCalculateDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Both agents are at the same point\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 0.0)\n\n    def test_horizontal_distance(self):\n        # Agents are horizontally apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 3, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 3.0)\n\n    def test_vertical_distance(self):\n        # Agents are vertically apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 4}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 4.0)\n\n    def test_diagonal_distance(self):\n        # Agents are diagonally apart\n        observations = {\n            \"agent1\": {\"x\": 1, \"y\": 2},\n            \"agent2\": {\"x\": 4, \"y\": 6}\n        }\n        expected_distance = np.sqrt((4 - 1) ** 2 + (6 - 2) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)\n\n    def test_negative_coordinates(self):\n        # Agents have negative coordinates\n        observations = {\n            \"agent1\": {\"x\": -1, \"y\": -1},\n            \"agent2\": {\"x\": -4, \"y\": -5}\n        }\n        expected_distance = np.sqrt((-4 + 1) ** 2 + (-5 + 1) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)", "prompt": "please write a python function , the function signature as below def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation question with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n"}, {"task_id": 13, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestParseMarkdownTable(unittest.TestCase):\n    def test_standard_table(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_inconsistent_columns(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2'),\n            ('Row1', 'Row1Col2', 'ExtraCol'),\n            ('Row2',)\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_empty_cells(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', 'Row1Col2', ''),\n            ('Row2Col1', '', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_all_empty_rows(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', '', ''),\n            ('', '', '')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_excessive_whitespace(self):\n        md_table = \"\"\"\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n\ndef parse_markdown_table(md_table):\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"\n    # Split the input string into lines and strip whitespace\n    lines = md_table.strip().split('\\n')\n\n    # Filter out the separator line for the header (which usually contains \"---\")\n    lines = [line for line in lines if not line.strip().startswith('|---')]\n\n    # Initialize the list to store each row as a tuple\n    table_data = []\n\n    # Process each line\n    for line in lines:\n        # Strip leading and trailing spaces and pipes, then split by \"|\"\n        row = line.strip('| \\n').split('|')\n        # Strip spaces from each cell, handle empty cells, and create a tuple\n        table_data.append(tuple(cell.strip() for cell in row if cell.strip() or cell == ''))\n\n    return table_data\n", "prompt": "please write a python function , the function signature as below "}, {"task_id": 14, "code_type": "method", "code_language": "python", "test_code": "import os\nimport shutil\nimport unittest\nfrom tempfile import mkdtemp\nfrom unittest.mock import patch, mock_open\n\n\nclass TestFindJsonFilesWithKeyword(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory\n        self.test_dir = mkdtemp()\n        self.test_file_path = os.path.join(self.test_dir, 'test.js.json')\n        with open(self.test_file_path, 'w') as f:\n            f.write('{\"key\": \"value with keyword\"}')\n\n    def tearDown(self):\n        # Remove the directory after test\n        shutil.rmtree(self.test_dir)\n\n    @patch('os.walk')\n    @patch('builtins.open', new_callable=mock_open, read_data='{\"key\": \"value with keyword\"}')\n    @patch('json.load', return_value={\"key\": \"value with keyword\"})\n    def test_keyword_in_single_file(self, mock_json_load, mock_file, mock_os_walk):\n        mock_os_walk.return_value = [\n            (self.test_dir, (), ('test.js.json',)),\n        ]\n        expected = ['test.js.json']\n        result = find_json_files_with_keyword(self.test_dir, 'keyword')\n        self.assertEqual(result, expected)\n\n    @patch('os.walk')\n    @patch('builtins.open', new_callable=mock_open, read_data='{\"key\": \"no keyword here\"}')\n    @patch('json.load', return_value={\"key\": \"no keyword here\"})\n    def test_keyword_not_in_file(self, mock_json_load, mock_file, mock_os_walk):\n        mock_os_walk.return_value = [\n            (self.test_dir, (), ('test.js.json',)),\n        ]\n        expected = []\n        result = find_json_files_with_keyword(self.test_dir, 'wc')\n        self.assertEqual(result, expected)\n\n    @patch('os.walk')\n    def test_no_json_files_in_directory(self, mock_os_walk):\n        # Use an empty temporary directory set up in setUp\n        mock_os_walk.return_value = [\n            (self.test_dir, (), ()),\n        ]\n        expected = []\n        result = find_json_files_with_keyword(self.test_dir, 'keyword')\n        self.assertEqual(result, expected)\n\n    @patch('os.walk')\n    @patch('builtins.open', new_callable=mock_open, read_data='{\"key\": \"keyword present here\"}')\n    @patch('json.load', return_value={\"key\": \"keyword present here\"})\n    def test_multiple_json_files(self, mock_json_load, mock_file, mock_os_walk):\n        # Create multiple files in setUp\n        file1_path = os.path.join(self.test_dir, 'file1.json')\n        file2_path = os.path.join(self.test_dir, 'file2.json')\n        with open(file1_path, 'w') as f:\n            f.write('{\"key\": \"keyword present here\"}')\n        with open(file2_path, 'w') as f:\n            f.write('{\"key\": \"keyword present here\"}')\n        mock_os_walk.return_value = [\n            (self.test_dir, (), ('file1.json', 'file2.json')),\n        ]\n        expected = ['file1.json', 'file2.json']\n        result = find_json_files_with_keyword(self.test_dir, 'keyword')\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_json_files_with_keyword(directory:str, keyword:str) ->List[str]:\n    \"\"\"\n    Select all json files containing the keyword from the specified directory, and return all matching json file names in the form of a list\n\n    Args:\n        directory (str): Path to the directory where JSON files are stored.\n        keyword (str): Keyword to search for within the JSON files.\n\n    Returns:\n        list: A list of filenames (str) of JSON files containing the keyword.\n    \"\"\""}, {"task_id": 17, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestHaversineDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Same point should return a distance of 0\n        lat, lon = 52.2296756, 21.0122287\n        result = haversine_distance(lat, lon, lat, lon)\n        self.assertAlmostEqual(result, 0.0, places=6)\n\n    def test_small_distance(self):\n        # Points that are very close together (few meters apart)\n        lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n        lat2, lon2 = 52.2296756, 21.0122297  # Very close to the previous point\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 0.0001, places=4)  # Expected small distance\n\n    def test_large_distance(self):\n        # Points that are far apart\n        lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n        lat2, lon2 = 41.8919300, 12.5113300  # Rome, Italy\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 1315.514, places=2)  # Approx distance in km\n\n    def test_equator_distance(self):\n        # Points on the equator\n        lat1, lon1 = 0.0, 0.0  # Gulf of Guinea (Equator and Prime Meridian intersection)\n        lat2, lon2 = 0.0, 90.0  # On the Equator, 90 degrees east\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 10007.54, places=2)  # Approx quarter of Earth's circumference\n\n    def test_pole_to_pole(self):\n        # Distance from North Pole to South Pole\n        lat1, lon1 = 90.0, 0.0  # North Pole\n        lat2, lon2 = -90.0, 0.0  # South Pole\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 20015.09, places=2)  # Approx half of Earth's circumference\n", "prompt": "please write a python function , the function signature as below def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\""}, {"task_id": 18, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFloatToRGB(unittest.TestCase):\n\n    def test_pure_red(self):\n        # Value at the lower boundary (0.0) should return pure red\n        result = float_to_rgb(0.0)\n        self.assertEqual(result, (255, 0, 0))\n\n    def test_pure_green(self):\n        # Value at the upper boundary (1.0) should return pure green\n        result = float_to_rgb(1.0)\n        self.assertEqual(result, (0, 255, 0))\n\n    def test_midpoint(self):\n        # Value at 0.5 should return an equal mix of red and green, resulting in yellow\n        result = float_to_rgb(0.5)\n        self.assertEqual(result, (127, 127, 0))\n\n    def test_quarter_point(self):\n        # Value at 0.25 should return more red than green\n        result = float_to_rgb(0.25)\n        self.assertEqual(result, (191, 63, 0))\n\n    def test_invalid_value(self):\n        # Value outside the range [0, 1] should raise a ValueError\n        with self.assertRaises(ValueError):\n            float_to_rgb(1.5)", "prompt": "please write a python function , the function signature as below def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n"}, {"task_id": 19, "code_type": "method", "code_language": "python", "test_code": "import re\nimport unittest\n\n\nclass TestPhoneNumberDetection(unittest.TestCase):\n    def test_with_international_prefix(self):\n        self.assertTrue(contains_phone_number(\"+1-800-555-1234\"), \"Should detect international prefix\")\n\n    def test_with_standard_dashes(self):\n        self.assertTrue(contains_phone_number(\"800-555-1234\"), \"Should detect standard format with dashes\")\n\n    def test_with_spaces(self):\n        self.assertTrue(contains_phone_number(\"800 555 1234\"), \"Should detect standard format with spaces\")\n\n    def test_without_phone_number(self):\n        self.assertFalse(contains_phone_number(\"Hello, world!\"), \"Should not detect any phone number\")\n\n    def test_with_text_containing_numbers(self):\n        self.assertTrue(contains_phone_number(\"Call me at 800-555-1234 today!\"), \"Should detect phone number in text\")", "prompt": "please write a python function , the function signature as below def contains_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n"}, {"task_id": 20, "code_type": "method", "code_language": "python", "test_code": "import os\nimport unittest\n\n\nclass TestMarkdownProcessor(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Setup test case data.\"\"\"\n        # Sample Markdown content for testing\n        self.test_cases = {\n            \"test_case_2.md\": \"This is _italic_ text.\",\n            \"test_case_3.md\": \"This is **bold** and _italic_ text.\",\n            \"test_case_5.md\": \"This text has no special formatting.\",\n            \"test_case_6.md\": \"*Asterisks at the start* and end*.\",\n            \"test_case_7.md\": \"Mixed *text with **multiple** asterisks*.\"\n        }\n\n        # Expected outputs after processing\n        self.expected_outputs = {\n            \"test_case_1.md\": \"This is **bold** text.\",\n            \"test_case_2.md\": \"This is _italic_ text.\",\n            \"test_case_3.md\": \"This is **bold** and _italic_ text.\",\n            \"test_case_4.md\": \"This is **bold and _italic_** text.\",\n            \"test_case_5.md\": \"This text has no special formatting.\",\n            \"test_case_6.md\": \"*Asterisks at the start* and end*.\",\n            \"test_case_7.md\": \"Mixed *text with **multiple** asterisks*.\"\n        }\n\n    def write_temp_file(self, filename, content):\n        \"\"\"Helper method to write content to a temporary test file.\"\"\"\n        with open(filename, 'w', encoding='utf-8') as f:\n            f.write(content)\n\n    def test_markdown_processing(self):\n        \"\"\"Run all test cases.\"\"\"\n        for filename, content in self.test_cases.items():\n            self.write_temp_file(filename, content)\n            processed_content = process_markdown_file(filename)\n            expected_content = self.expected_outputs[filename]\n            self.assertEqual(processed_content, expected_content)\n\n    def tearDown(self):\n        \"\"\"Cleanup temporary test files after tests.\"\"\"\n        for filename in self.test_cases.keys():\n            try:\n                os.remove(filename)\n            except FileNotFoundError:\n                pass\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef process_markdown_file(file_path):\n    \"\"\"Process the contents of a Markdown file to remove unnecessary asterisks.\n\n    Args:\n        file_path (str): The path to the Markdown file.\n\n    Returns:\n        str: The processed Markdown content with only outermost asterisks retained.\n    \"\"\""}, {"task_id": 21, "code_type": "method", "code_language": "python", "test_code": "import os\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestCompareFiles(unittest.TestCase):\n\n    def setUp(self):\n        # \u521b\u5efa\u6587\u4ef6\u7528\u4e8e\u6d4b\u8bd5\n        self.file1_path = 'file1.txt'\n        self.file2_path = 'file2.txt'\n\n    def tearDown(self):\n        # \u5220\u9664\u521b\u5efa\u7684\u6587\u4ef6\n        if os.path.exists(self.file1_path):\n            os.remove(self.file1_path)\n        if os.path.exists(self.file2_path):\n            os.remove(self.file2_path)\n\n    def test_identical_files(self):\n        # Mock question for two identical files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLine2\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = compare_files(self.file1_path, self.file2_path)\n        self.assertEqual(len(result), 0, \"There should be no differences detected\")\n\n    def test_files_with_differences(self):\n        # Mock question for two different files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLineChanged\\nLine3\\n\"\n\n        with open(self.file1_path, 'w') as f1, open(self.file2_path, 'w') as f2:\n            f1.write(file1_content)\n            f2.write(file2_content)\n\n        result = compare_files(self.file1_path, self.file2_path)\n        self.assertNotEqual(len(result), 0, \"There should be differences detected\")\n\n    def test_nonexistent_file(self):\n        # Test when one of the files does not exist\n        with patch('builtins.open', side_effect=FileNotFoundError(\"File not found\")):\n            with self.assertRaises(FileNotFoundError):\n                compare_files('nonexistent.txt', 'file2.txt')\n\n    def test_file_reading_error(self):\n        # Test when there's an error reading the file\n        with patch('builtins.open', side_effect=IOError(\"Error reading file\")):\n            with self.assertRaises(IOError):\n                compare_files('file1.txt', 'file2.txt')\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef compare_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n"}, {"task_id": 22, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom typing import Tuple\n\nclass TestCalculateEuclideanDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        # Basic logic functionality test.js\n        point1 = (0, 0)\n        point2 = (3, 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should calculate the distance correctly\")\n\n    def test_negative_coordinates(self):\n        # Test with negative coordinates\n        point1 = (-1, -1)\n        point2 = (-4, -5)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle negative coordinates correctly\")\n\n    def test_zero_distance(self):\n        # Boundary test.js: points are the same\n        point1 = (2, 3)\n        point2 = (2, 3)\n        expected_distance = 0.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should return 0 when both points are the same\")\n\n    def test_large_coordinates(self):\n        # Boundary test.js: large coordinates\n        point1 = (1e6, 1e6)\n        point2 = (1e6 + 3, 1e6 + 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle large coordinates correctly\")\n\n    def test_invalid_input(self):\n        # Exception handling test.js: invalid input (non-tuple)\n        with self.assertRaises(TypeError):\n            calculate_euclidean_distance(\"invalid\", (0, 0))\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    calculate the Euclidean distance between two points in a 2D space.\n\n    Args:\n        point1 (Tuple[float, float]): The first point as a tuple of coordinates (x1, y1).\n        point2 (Tuple[float, float]): The second point as a tuple of coordinates (x2, y2).\n\n    Returns:\n        float: The Euclidean distance between the two points.\n\n    \"\"\"\n"}, {"task_id": 23, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestLineSegmentIntersection(unittest.TestCase):\n    def test_intersecting_lines(self):\n        self.assertEqual(\n            get_line_segment_intersection(((1, 1), (4, 4)), ((1, 4), (4, 1))),\n            (2.5, 2.5),\n            \"Should find intersection at (2.5, 2.5)\"\n        )\n\n    def test_parallel_lines(self):\n        self.assertIsNone(\n            get_line_segment_intersection(((1, 1), (4, 4)), ((2, 2), (5, 5))),\n            \"Should return None for parallel lines\"\n        )\n\n    def test_no_intersection(self):\n        self.assertIsNone(\n            get_line_segment_intersection(((1, 1), (2, 2)), ((3, 3), (4, 4))),\n            \"Should return None when there is no intersection\"\n        )\n\n    def test_intersection_in_middle(self):\n        result = get_line_segment_intersection(((0, 0), (4, 4)), ((0, 4), (4, 0)))\n        self.assertIsNotNone(result, \"Should find an intersection at the middle (2, 2)\")\n        self.assertAlmostEqual(result[0], 2, places=7, msg=\"X coordinate should be close to 2\")\n        self.assertAlmostEqual(result[1], 2, places=7, msg=\"Y coordinate should be close to 2\")\n\n    def test_identical_segments(self):\n        self.assertIsNone(\n            get_line_segment_intersection(((1, 1), (4, 4)), ((1, 1), (4, 4))),\n            \"Should return None for identical segments\"\n        )\n\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef get_line_segment_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n"}, {"task_id": 24, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport os\nimport json\nimport yaml\n\n\nclass TestConvertYamlToJson(unittest.TestCase):\n\n    def setUp(self):\n        # Create temporary YAML files for testing\n        self.simple_yaml = 'simple.yaml'\n        self.nested_yaml = 'nested.yaml'\n        self.empty_yaml = 'empty.yaml'\n        self.list_yaml = 'list.yaml'\n        self.invalid_yaml = 'invalid.yaml'\n\n        with open(self.simple_yaml, 'w') as file:\n            file.write(\"name: John Doe\\nage: 30\\n\")\n\n        with open(self.nested_yaml, 'w') as file:\n            file.write(\"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\")\n\n        with open(self.empty_yaml, 'w') as file:\n            file.write(\"\")\n\n        with open(self.list_yaml, 'w') as file:\n            file.write(\"- item1\\n- item2\\n- item3\\n\")\n\n        with open(self.invalid_yaml, 'w') as file:\n            file.write(\"{ invalid: YAML: structure }\\n\")\n\n    def tearDown(self):\n        # Remove temporary files after testing\n        os.remove(self.simple_yaml)\n        os.remove(self.nested_yaml)\n        os.remove(self.empty_yaml)\n        os.remove(self.list_yaml)\n        os.remove(self.invalid_yaml)\n\n        if os.path.exists('output.json'):\n            os.remove('output.json')\n\n    def test_simple_yaml_conversion(self):\n        convert_yaml_to_json(self.simple_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, {\"name\": \"John Doe\", \"age\": 30})\n\n    def test_nested_yaml_conversion(self):\n        convert_yaml_to_json(self.nested_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        expected_data = {\n            \"person\": {\n                \"name\": \"Jane Doe\",\n                \"age\": 25,\n                \"address\": {\n                    \"city\": \"New York\",\n                    \"zip\": 10001\n                }\n            }\n        }\n        self.assertEqual(data, expected_data)\n\n    def test_empty_yaml_conversion(self):\n        convert_yaml_to_json(self.empty_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, None)  # YAML.safe_load() returns None for empty files\n\n    def test_list_yaml_conversion(self):\n        convert_yaml_to_json(self.list_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, [\"item1\", \"item2\", \"item3\"])\n\n    def test_invalid_yaml_conversion(self):\n        with self.assertRaises(yaml.YAMLError):\n            convert_yaml_to_json(self.invalid_yaml, 'output.json')\n", "prompt": "please write a python function , the function signature as below def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 25, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport json\nimport tempfile\nimport os\n\nclass TestClassifyJsonObjectsByPid(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.mkdtemp()\n\n        # Create temporary files for testing\n        self.source_file = os.path.join(self.temp_dir, 'source.json')\n        self.match_file = os.path.join(self.temp_dir, 'match.json')\n        self.mismatch_file = os.path.join(self.temp_dir, 'mismatch.json')\n\n        # Example question\n        self.data = [\n            {\"name\": \"Alice\", \"pid\": 1},\n            {\"name\": \"Bob\", \"pid\": 2},\n            {\"name\": \"Charlie\", \"pid\": 3}\n        ]\n        self.pid_list = [1, 3]\n\n        # Write example question to source file\n        with open(self.source_file, 'w') as f:\n            json.dump(self.data, f)\n\n    def test_all_match(self):\n        # Test where all items match\n        classify_json_objects_by_pid(self.source_file, [1, 2, 3], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 3)\n        self.assertEqual(len(mismatches), 0)\n\n    def test_no_match(self):\n        # Test where no items match\n        classify_json_objects_by_pid(self.source_file, [4, 5], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n\n    def test_partial_match(self):\n        # Test where some items match\n        classify_json_objects_by_pid(self.source_file, self.pid_list, self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 2)\n        self.assertEqual(len(mismatches), 1)\n\n    def test_empty_pid_list(self):\n        # Test with an empty PID list\n        classify_json_objects_by_pid(self.source_file, [], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file question based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 26, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestConvertToCommaSeparated(unittest.TestCase):\n    def test_basic_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"apple;banana*orange/mango\"), \"apple,banana,orange,mango\",\n                         \"Failed to convert basic separators.\")\n\n    def test_mixed_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes;lemon/melon*kiwi;litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n    def test_mixed_separators2(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes/lemon/melon*kiwi*litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n\n    def test_no_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"watermelon\"), \"watermelon\",\n                         \"Failed when no separators are present.\")", "prompt": "please write a python function , the function signature as below def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n"}, {"task_id": 27, "code_type": "method", "code_language": "python", "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestConcatenateJsonArrays(unittest.TestCase):\n\n    def setUp(self):\n        # Set up a test.js directory and test.js files\n        self.test_dir = 'test_json'\n        os.makedirs(self.test_dir, exist_ok=True)\n        # Create test.js JSON files\n        self.create_test_file('array1.json', [1, 2, 3])\n        self.create_test_file('array2.json', ['a', 'b', 'c'])\n        self.create_test_file('not_array.json', {'key': 'value'})\n        self.create_test_file('empty.json', [])\n        self.create_test_file('non_json.txt', \"This is not a JSON file.\")\n\n    def tearDown(self):\n        # Clean up: Remove created files and directory\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def create_test_file(self, filename, content):\n        # Helper method to create JSON files\n        with open(os.path.join(self.test_dir, filename), 'w') as f:\n            json.dump(content, f)\n\n    def test_concatenate_valid_json_arrays(self):\n        # Test with valid JSON arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertCountEqual(result, [1, 2, 3, 'a', 'b', 'c'])\n\n    def test_ignore_non_array_json(self):\n        # Test that non-array JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn('key', result)\n\n    def test_ignore_non_json_files(self):\n        # Test that non-JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn(\"This is not a JSON file.\", result)\n\n    def test_handle_empty_arrays(self):\n        # Test concatenation includes empty arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn([], result)\n\n    def test_empty_directory(self):\n        # Test with no JSON files in the directory\n        empty_dir = 'empty_test_json'\n        os.makedirs(empty_dir, exist_ok=True)\n        result = concatenate_json_arrays(empty_dir)\n        self.assertEqual(result, [])\n        os.rmdir(empty_dir)\n", "prompt": "please write a python function , the function signature as below import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged question\n\n    \"\"\"\n"}, {"task_id": 28, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom io import StringIO\nimport sys\n\n\nclass TestPrintMemoryBits(unittest.TestCase):\n\n    def setUp(self):\n        # Capture the output during each test\n        self.held_stdout = StringIO()\n        sys.stdout = self.held_stdout\n\n    def tearDown(self):\n        # Restore the normal stdout\n        sys.stdout = sys.__stdout__\n\n    def test_single_byte(self):\n        memory_section = bytes([0b10101010])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"1 0 1 0 1 0 1 0\"\n        self.assertEqual(output, expected_output)\n\n    def test_multiple_bytes(self):\n        memory_section = bytes([0b11001100, 0b11110000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"1 1 0 0 1 1 0 0\\n1 1 1 1 0 0 0 0\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_zeros(self):\n        memory_section = bytes([0b00000000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"0 0 0 0 0 0 0 0\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_ones(self):\n        memory_section = bytes([0b11111111])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"1 1 1 1 1 1 1 1\"\n        self.assertEqual(output, expected_output)", "prompt": "please write a python function , the function signature as below def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\""}, {"task_id": 31, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCalculateRedProportion(unittest.TestCase):\n\n    def test_all_red_pixels(self):\n        # All pixels are fully red\n        pixels = [(255, 0, 0), (255, 0, 0), (255, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 1.0)\n\n    def test_no_red_pixels(self):\n        # No red component in any pixel\n        pixels = [(0, 255, 0), (0, 0, 255), (0, 255, 255)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_empty_pixel_list(self):\n        # Empty list of pixels\n        pixels = []\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_all_black_pixels(self):\n        # All pixels are black\n        pixels = [(0, 0, 0), (0, 0, 0), (0, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\""}, {"task_id": 33, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\nimport xml.etree.ElementTree as ET\n\nclass TestXmlToDataFrame(unittest.TestCase):\n    def test_single_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>John</name>\n                            <age>30</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'John', 'age': '30'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_multiple_sequences(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Alice</name>\n                            <age>25</age>\n                        </sequence>\n                        <sequence>\n                            <name>Bob</name>\n                            <age>22</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Alice', 'age': '25'}, {'name': 'Bob', 'age': '22'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_empty_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence></sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_mixed_content(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Chris</name>\n                        </sequence>\n                        <sequence>\n                            <age>28</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Chris', 'age': None}, {'name': None, 'age': '28'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_no_sequences(self):\n        xml_data = \"\"\"<root></root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame()\n        pd.testing.assert_frame_equal(df, expected)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and question of the DataFrame\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the question from the XML file.\n    \"\"\"\n"}, {"task_id": 35, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestPointInPolygon(unittest.TestCase):\n    def setUp(self):\n        # Define some polygons to use in tests\n        self.square = [(0, 0), (0, 10), (10, 10), (10, 0)]\n        self.triangle = [(0, 0), (5, 10), (10, 0)]\n        self.concave = [(0, 0), (5, 5), (10, 0), (5, 10), (0, 10)]\n\n    def test_point_inside_square(self):\n        # Point inside the square\n        self.assertTrue(is_point_in_polygon((5, 5), self.square))\n\n    def test_point_outside_square(self):\n        # Point outside the square\n        self.assertFalse(is_point_in_polygon((15, 5), self.square))\n\n    def test_point_on_edge_of_triangle(self):\n        # Point on the edge of the triangle\n        self.assertFalse(is_point_in_polygon((5, 0), self.triangle))\n\n    def test_point_inside_concave_polygon(self):\n        # Point inside concave polygon\n        self.assertTrue(is_point_in_polygon((5, 9), self.concave))\n\n    def test_point_outside_concave_polygon(self):\n        # Point outside concave polygon\n        self.assertFalse(is_point_in_polygon((5, 1), self.concave))", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n"}, {"task_id": 36, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestFloydWarshallShortestPaths(unittest.TestCase):\n    def test_basic_functionality(self):\n        # Basic test.js case with a simple graph\n        matrix = [\n            [0, 3, float('inf'), 7],\n            [8, 0, 2, float('inf')],\n            [5, float('inf'), 0, 1],\n            [2, float('inf'), float('inf'), 0]\n        ]\n        expected = [\n            [0, 3, 5, 6],\n            [5, 0, 2, 3],\n            [3, 6, 0, 1],\n            [2, 5, 7, 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Basic functionality test.js failed\")\n\n    def test_single_vertex_graph(self):\n        # Test case with a single vertex graph (1x1 matrix)\n        matrix = [\n            [0]\n        ]\n        expected = [\n            [0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Single vertex graph test.js failed\")\n\n    def test_two_vertices_graph(self):\n        # Test case with two vertices\n        matrix = [\n            [0, 1],\n            [1, 0]\n        ]\n        expected = [\n            [0, 1],\n            [1, 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Two vertices graph test.js failed\")\n\n    def test_large_infinite_weights(self):\n        # Test case with infinite weights\n        matrix = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        expected = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Large infinite weights test.js failed\")\n\n    def test_negative_cycle(self):\n        # Test case with a negative cycle\n        matrix = [\n            [0, 1, float('inf')],\n            [float('inf'), 0, -1],\n            [-1, float('inf'), 0]\n        ]\n        expected = [\n            [-1, 0, -1],\n            [-2, -1, -2],\n            [-2, -1, -2]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Negative cycle test.js failed\")\n\n\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\ndef floyd_warshall_shortest_paths(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\""}, {"task_id": 37, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x, w):\n        self.x = np.array(x)\n        self.w = np.array(w)\n\n\nclass TestOrthogonalPolynomial(unittest.TestCase):\n    def test_lanczos_basic(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 2\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n\n    def test_lanczos_n_greater_than_length(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 4\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_n_zero(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 0\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_weights_nonuniform(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.1, 0.4, 0.5]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 3\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))\n\n    def test_lanczos_single_node(self):\n        x = [0.5]\n        w = [1.0]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 1\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n"}, {"task_id": 38, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestRainbowHexGenerator(unittest.TestCase):\n    def setUp(self):\n        self.rainbow_colors = [\n            \"#FF0000\",  # Red\n            \"#FF7F00\",  # Orange\n            \"#FFFF00\",  # Yellow\n            \"#00FF00\",  # Green\n            \"#0000FF\",  # Blue\n            \"#4B0082\",  # Indigo\n            \"#8A2BE2\"  # Violet\n        ]\n\n    def test_one_intermediate(self):\n        # Test with one intermediate color between each main color\n        result = rainbowHexGenerator(1)\n        # Check if the length is correct (7 main + 6 intermediates)\n        self.assertEqual(len(result), 13, \"Should have 13 colors with one intermediate\")\n\n    def test_include_endpoints(self):\n        # Test including the endpoint (wrap-around) interpolation\n        result = rainbowHexGenerator(1, include_endpoints=True)\n        # Check if the length is correct (7 main + 7 intermediates including wrap-around)\n        self.assertEqual(len(result), 14, \"Should have 14 colors with wrap-around interpolation\")\n\n    def test_high_number_of_intermediates(self):\n        # Test with a high number of intermediates to check gradient smoothness\n        result = rainbowHexGenerator(10)\n        # Check if the length is correct (7 main + 60 intermediates)\n        self.assertEqual(len(result), 67, \"Should have 67 colors with 10 intermediates each\")\n\n", "prompt": "please write a python function , the function signature as below def rainbowHexGenerator(num_intermediates: int, include_endpoints=False):\n    \"\"\"\n    generates a color spectrum list containing the main rainbow colors and the gradient colors between them. The function takes two parameters: num_intermediates specifies the number of intermediate colors to be generated between each two major colors;include_endpoints determines whether to add a gradient from the last color back to the first color at the end of the color spectrum\n    Args:\n        num_intermediates (int): The number of intermediate colors that need to be generated between each pair of main rainbow colors. If set to 0, no intermediate colors are generated, and only the original seven rainbow colors are returned. If set to a positive integer, the function generates a specified number of transition colors between adjacent colors, creating a smoother color gradient.\n\n        include_endpoints (bool): Do you add a transition from the last color (purple) back to the first color (red) at the end of the spectrum\n\n\n    Returns:\n        The list contains a series of hexadecimal color codes that represent the colors of rainbows and the gradient colors between them\n\n    \"\"\"\n"}, {"task_id": 40, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestAdjustToCMajor(unittest.TestCase):\n    def test_note_already_in_c_major(self):\n        self.assertEqual(adjust_to_c_major(\"C4\"), \"C4\")\n        self.assertEqual(adjust_to_c_major(\"G3\"), \"G3\")\n\n    def test_note_not_in_c_major(self):\n        self.assertEqual(adjust_to_c_major(\"C#4\"), \"D4\")\n        self.assertEqual(adjust_to_c_major(\"F#3\"), \"G3\")\n\n    def test_invalid_note_name(self):\n        self.assertEqual(adjust_to_c_major(\"H2\"), \"C4\")\n\n    def test_edge_case_near_c_major(self):\n        self.assertEqual(adjust_to_c_major(\"B#3\"), \"C4\")\n        self.assertEqual(adjust_to_c_major(\"E#4\"), \"F4\")", "prompt": "please write a python function , the function signature as below from music21 import pitch\n\n\ndef adjust_to_c_major(note_name: str) -> str:\n    \"\"\"\n    Adjusts a given musical note to the nearest note in the C major scale.\n    Args:\n        note_name (str): The name of the note to adjust.\n\n    Returns:\n        str: The adjusted note name with octave if applicable, or the input note if already in C major.\n    \"\"\"\n"}, {"task_id": 41, "code_type": "class", "code_language": "python", "test_code": "import unittest\n\n\nclass TestBloomFilter(unittest.TestCase):\n\n    def setUp(self):\n        # Initialize BloomFilter with reasonable size and hash count for testing\n        self.bf = BloomFilter(1000, 5)\n\n    def test_add_and_check_presence(self):\n        # Test that added elements are reported as present\n        test_item = \"hello world\"\n        self.bf.add(test_item)\n        self.assertIn(test_item, self.bf)\n\n    def test_check_absence(self):\n        # Test that an unadded element is not present\n        self.assertNotIn(\"random item\", self.bf)\n\n    def test_false_positives(self):\n        # Adding some elements and check for a false positive\n        items_to_add = [\"item1\", \"item2\", \"item3\"]\n        for item in items_to_add:\n            self.bf.add(item)\n        # Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        self.assertNotIn(\"item4\", self.bf)\n\n    def test_collision_handling(self):\n        # Test how the Bloom filter handles hash collisions by adding similar items\n        self.bf.add(\"item123\")\n        self.bf.add(\"item124\")\n        self.assertIn(\"item123\", self.bf)\n        self.assertIn(\"item124\", self.bf)\n\n    def test_empty_bloom_filter(self):\n        # Ensure that an empty Bloom Filter reports no items\n        self.assertNotIn(\"anything\", self.bf)", "prompt": "please write a python class , the class signature as below class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n"}, {"task_id": 42, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestReplacePhoneNumbers(unittest.TestCase):\n    def test_basic_number(self):\n        msg = \"Call me at 123-456-7890.\"\n        expected = \"Call me at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_international_number(self):\n        msg = \"Contact us at 44 123 456 789.\"\n        expected = \"Contact us at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_number_with_parentheses(self):\n        msg = \"Our office number is 123 456-7890.\"\n        expected = \"Our office number is [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_number_with_dots(self):\n        msg = \"Fax us at 123.456.7890.\"\n        expected = \"Fax us at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_no_phone_number(self):\n        msg = \"Hello, please reply to this email.\"\n        expected = \"Hello, please reply to this email.\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n", "prompt": "please write a python function , the function signature as below def replace_phone_numbers(text:str):\n    \"\"\"\n    replace all phones in the string with the string [PHONE_NUM]\n    For example:\n        input: Call me at 123-456-7890.\n        output: Call me at [PHONE_NUM].\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n"}, {"task_id": 43, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestRGBtoHSV(unittest.TestCase):\n\n    def test_rgb_to_hsv_red(self):\n        # Test conversion of pure red color\n        r, g, b = 255, 0, 0\n        expected_result = (0, 100, 100)  # Hue should be 0, Saturation 1, Value 1 for red\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_green(self):\n        # Test conversion of pure green color\n        r, g, b = 0, 255, 0\n        expected_result = (120, 100, 100)  # Hue should be 120, Saturation 1, Value 1 for green\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_blue(self):\n        # Test conversion of pure blue color\n        r, g, b = 0, 0, 255\n        expected_result = (240, 100, 100)  # Hue should be 240, Saturation 1, Value 1 for blue\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_white(self):\n        # Test conversion of white color\n        r, g, b = 255, 255, 255\n        expected_result = (0, 0, 100)  # Hue is undefined, typically 0; Saturation 0, Value 1 for white\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_black(self):\n        # Test conversion of black color\n        r, g, b = 0, 0, 0\n        expected_result = (0, 0, 0)  # Hue is undefined, typically 0; Saturation 0, Value 0 for black\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef rgb_to_hsv(r: int, g: int, b: int) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color.\n    For example:\n        input: 0, 0, 255\n        output: 240, 100, 100\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns:\n       Tuple[int, int, int]: HSV value\n    \"\"\"\n"}, {"task_id": 44, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestStringSideBySide(unittest.TestCase):\n\n    def test_equal_length_strings(self):\n        str1 = \"Hello\\nWorld\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2)\n        expected = \"Hello                | Python              \\nWorld                | Code                \"\n        self.assertEqual(result, expected)\n\n    def test_first_string_longer(self):\n        str1 = \"Hello\\nWorld\\nTest\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2)\n        expected = \"Hello                | Python              \\nWorld                | Code                \\nTest                 |                     \"\n        self.assertEqual(result, expected)\n\n    def test_second_string_longer(self):\n        str1 = \"Hello\\nWorld\"\n        str2 = \"Python\\nCode\\nTest\"\n        result = string_side_by_side(str1, str2)\n        expected = \"Hello                | Python              \\nWorld                | Code                \\n                     | Test                \"\n        self.assertEqual(result, expected)\n\n    def test_empty_first_string(self):\n        str1 = \"\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2)\n        expected = \"                     | Python              \\n                     | Code                \"\n        self.assertEqual(result, expected)\n\n    def test_custom_column_width(self):\n        str1 = \"Hello\\nWorld\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2, column_width=10)\n        expected = \"Hello      | Python    \\nWorld      | Code      \"\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def string_side_by_side(string1: str, string2: str, column_width=20) -> str:\n    \"\"\"\n    Display the two strings side by side so that their rows are left aligned, and make sure that each row fits into the specified column width\n    Args:\n        string1 (str): string1\n        string2 (str): string2\n        column_width (int): width of each line\n\n    Returns:\n        str: format lines\n    \"\"\"\n"}, {"task_id": 45, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport datetime\n\n\nclass TestGetCurrentDateInfo(unittest.TestCase):\n\n    def test_beginning_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 1))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 1,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_middle_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 15))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 3,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_end_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 31))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 6,\n            'day_of_the_week': 'Tuesday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_leap_year(self):\n        result = get_current_date_info(datetime.date(2024, 2, 29))\n        expected = {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_change_of_year(self):\n        result = get_current_date_info(datetime.date(2022, 12, 31))\n        expected = {\n            'year': 2022,\n            'month': 'December',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Saturday'\n        }\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def get_current_date_info(test_date=None) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n"}, {"task_id": 46, "code_type": "class", "code_language": "python", "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Setup basic tree structure for testing.\"\"\"\n        # Tree structure:\n        #      1\n        #     / \\\n        #    2   3\n        #   / \\\n        #  4   5\n        self.tree = BinaryTree(TreeNode(1))\n        self.tree.root.left = TreeNode(2, TreeNode(4), TreeNode(5))\n        self.tree.root.right = TreeNode(3)\n\n    def test_preorder_traversal(self):\n        \"\"\"Test preorder traversal.\"\"\"\n        result = self.tree.preorder_traversal(self.tree.root)\n        self.assertEqual(result, [1, 2, 4, 5, 3])\n\n    def test_inorder_traversal(self):\n        \"\"\"Test inorder traversal.\"\"\"\n        result = self.tree.inorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 2, 5, 1, 3])\n\n    def test_postorder_traversal(self):\n        \"\"\"Test postorder traversal.\"\"\"\n        result = self.tree.postorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 5, 2, 3, 1])\n\n    def test_empty_tree(self):\n        \"\"\"Test traversals on an empty tree.\"\"\"\n        empty_tree = BinaryTree()\n        self.assertEqual(empty_tree.preorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.inorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.postorder_traversal(empty_tree.root), [])\n\n    def test_single_node_tree(self):\n        \"\"\"Test all traversals on a tree with only one node.\"\"\"\n        single_node_tree = BinaryTree(TreeNode(10))\n        self.assertEqual(single_node_tree.preorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.inorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.postorder_traversal(single_node_tree.root), [10])\n", "prompt": "please write a python class , the class signature as below class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n"}, {"task_id": 47, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom datetime import datetime\n\n\nclass TestFindNthWeekdayOfSpecificYear(unittest.TestCase):\n\n    def test_regular_occurrence(self):\n        # Test for the 2nd Monday of May 2023\n        result = find_nth_weekday_of_specific_year(2023, 5, 2, 0)\n        expected = datetime(2023, 5, 8)\n        self.assertEqual(result, expected)\n\n    def test_last_occurrence(self):\n        # Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        result = find_nth_weekday_of_specific_year(2023, 5, 5, 0)\n        expected = datetime(2023, 5, 29)\n        self.assertEqual(result, expected)\n\n    def test_out_of_range(self):\n        # Test for the 10th Monday of May 2023, which definitely doesn't exist, should return the last Monday\n        result = find_nth_weekday_of_specific_year(2023, 5, 10, 0)\n        expected = datetime(2023, 5, 29)\n        self.assertEqual(result, expected)\n\n    def test_first_day_is_weekday(self):\n        # Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        result = find_nth_weekday_of_specific_year(2023, 8, 1, 1)\n        expected = datetime(2023, 8, 1)\n        self.assertEqual(result, expected)\n\n    def test_edge_year_transition(self):\n        # Test for the 1st Friday of December 2023, checking the transition to a new year boundary condition\n        result = find_nth_weekday_of_specific_year(2023, 12, 1, 4)\n        expected = datetime(2023, 12, 1)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below import datetime\n\n\ndef find_nth_weekday_of_specific_year(y: int, m: int, n: int, k: int) -> datetime:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n"}, {"task_id": 51, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport numpy as np\n\nclass TestChangeReferenceFrame(unittest.TestCase):\n    def setUp(self):\n        # Basic setup for tests, initialize some common point clouds and frames\n        self.point_cloud = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.ref_frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([0, 1, 0])]\n\n    def test_identity_transformation(self):\n        # Test with an identity transformation where the reference frame is the standard basis\n        result = change_reference_frame(self.point_cloud, self.ref_frame_points)\n        np.testing.assert_array_almost_equal(result, self.point_cloud - np.array([0, 0, 0]))\n\n    def test_translation(self):\n        # Only translation no rotation; move the origin\n        frame_points = [np.array([1, 1, 1]), np.array([2, 1, 1]), np.array([1, 2, 1])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[-1. , 0.,  1.], [ 2. , 3.,  4.], [ 5.,  6. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_rotation(self):\n        # Rotation about z-axis by 90 degrees\n        frame_points = [np.array([0, 0, 0]), np.array([0, 1, 0]), np.array([0, 1, 1])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[2. , 3.,  1.], [ 5. , 6.,  4.], [ 8.,  9. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_non_orthonormal_frame(self):\n        # Use non-orthonormal frame to see how function handles it (should normalize internally)\n        frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([1, 1, 0])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        # Manually compute expected model_answer_result\n        u = np.array([1, 0, 0])\n        v = np.array([0, 1, 0])\n        w = np.cross(u, v)\n        rotation_matrix = np.column_stack((u, v, w))\n        expected = np.dot(self.point_cloud, rotation_matrix.T)\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_inverted_frame(self):\n        # Inverting the frame to see if negatives are handled\n        frame_points = [np.array([0, 0, 0]), np.array([-1, 0, 0]), np.array([0, -1, 0])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.dot(self.point_cloud, np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]))\n        np.testing.assert_array_almost_equal(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\nimport numpy as np\n\n\ndef change_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (list): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n"}, {"task_id": 52, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestRenameFilePath(unittest.TestCase):\n    def test_rename_with_colon_in_filename(self):\n        # Test path with colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_without_colon_in_filename(self):\n        # Test path without colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_multiple_colons_in_filename(self):\n        # Test path with multiple colons in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_end_of_filename(self):\n        # Test path with a colon at the end of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\backup:'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\backup_'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_start_of_filename(self):\n        # Test path with a colon at the start of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt'\n        self.assertEqual(rename_file_path(path), expected)\n", "prompt": "please write a python function , the function signature as below def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n"}, {"task_id": 53, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport sys\n\nclass TestSizeInBytes(unittest.TestCase):\n\n    def test_size_of_integer(self):\n        # Test the size of an integer\n        integer_value = 42\n        expected_size = sys.getsizeof(integer_value)\n        result_size = size_in_bytes(integer_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_string(self):\n        # Test the size of a string\n        string_value = \"Hello, world!\"\n        expected_size = sys.getsizeof(string_value)\n        result_size = size_in_bytes(string_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_list(self):\n        # Test the size of a list\n        list_value = [1, 2, 3, 4, 5]\n        expected_size = sys.getsizeof(list_value)\n        result_size = size_in_bytes(list_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_dictionary(self):\n        # Test the size of a dictionary\n        dict_value = {'key1': 'value1', 'key2': 'value2'}\n        expected_size = sys.getsizeof(dict_value)\n        result_size = size_in_bytes(dict_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_custom_object(self):\n        # Test the size of a custom object\n        class CustomObject:\n            def __init__(self):\n                self.attr1 = 'a'\n                self.attr2 = 123\n        custom_obj = CustomObject()\n        expected_size = sys.getsizeof(custom_obj)  # Note: Does not include size of attributes unless explicitly calculated\n        result_size = size_in_bytes(custom_obj)\n        self.assertEqual(result_size, expected_size)", "prompt": "please write a python function , the function signature as below def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): question object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n"}, {"task_id": 54, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestRemoveTripleBackticks(unittest.TestCase):\n\n    def test_remove_triple_backticks_basic(self):\n        # Test basic functionality\n        input_strings = ['Here is ```code``` example', 'Another ```example``` here', 'No backticks here']\n        expected_output = ['Here is code example', 'Another example here', 'No backticks here']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_strings_with_multiple_instances(self):\n        # Test strings containing multiple instances of triple backticks\n        input_strings = ['Multiple ```backticks``` in ```one``` string']\n        expected_output = ['Multiple backticks in one string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_empty_strings(self):\n        # Test with empty strings\n        input_strings = ['']\n        expected_output = ['']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_no_triple_backticks(self):\n        # Test strings that do not contain triple backticks\n        input_strings = ['Just a normal string', 'Another normal string']\n        expected_output = ['Just a normal string', 'Another normal string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_edge_cases(self):\n        # Test edge cases like strings made entirely of triple backticks\n        input_strings = ['```', '```more```', 'text``````']\n        expected_output = ['', 'more', 'text']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n"}, {"task_id": 55, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestMinRemovalsToMakeUnique(unittest.TestCase):\n    def test_basic_array(self):\n        \"\"\"Test with a basic array where multiple removals are needed.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([3, 3, 1, 2, 2, 1]), 3)\n\n    def test_all_identical(self):\n        \"\"\"Test an array where all elements are identical.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([4, 4, 4, 4]), 3)\n\n    def test_all_unique(self):\n        \"\"\"Test an array where all elements are already unique.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 3, 4]), 0)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([]), 0)\n\n    def test_complex_case(self):\n        \"\"\"Test a more complex case with a larger array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]), 6)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    Given an integer array, calculate the minimum number of elements to delete so that the elements in the array are not duplicate.\n    For example:\n        input: [3, 3, 1, 2, 2, 1]\n        output: 3\n\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n"}, {"task_id": 56, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFindShiftJISNotGBK(unittest.TestCase):\n\n    def setUp(self):\n        # Pre-calculate the list once since it's computationally expensive\n        self.shiftjis_not_gbk = find_shiftjis_not_gbk()\n\n    def test_known_shiftjis_character_not_in_gbk(self):\n        # Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        known_shiftjis_only = '\u30f1'  # An example character, ensure this is correct as per your encodings\n        self.assertNotIn(known_shiftjis_only, self.shiftjis_not_gbk)\n\n    def test_character_in_both_encodings(self):\n        # Test characters known to be in both encodings\n        common_character = '\u6c34'  # Common in both, ensure accuracy\n        self.assertNotIn(common_character, self.shiftjis_not_gbk)\n\n    def test_character_in_neither_encoding(self):\n        # Character not typically found in either encoding\n        neither_encoding_char = '\\U0001F4A9'  # Emoji, not in basic Shift-JIS or GBK\n        self.assertNotIn(neither_encoding_char, self.shiftjis_not_gbk)\n\n    def test_bounds_of_bmp(self):\n        # Characters at the edge of the BMP should be checked\n        edge_of_bmp = '\\uffff'  # Last character in BMP\n        # Since this test.js is situational, we check based on the known state; may not be necessary\n        if edge_of_bmp in self.shiftjis_not_gbk:\n            self.assertIn(edge_of_bmp, self.shiftjis_not_gbk)\n        else:\n            self.assertNotIn(edge_of_bmp, self.shiftjis_not_gbk)\n\n    def test_empty_input_handling(self):\n        # Checking function's behavior with empty input scenario, modifying function required\n        self.assertTrue(len(self.shiftjis_not_gbk) > 0)  # Expect non-zero length list, confirming function runs", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n"}, {"task_id": 57, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestConvertPngToIco(unittest.TestCase):\n    @patch('PIL.Image.open')\n    def test_single_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_multiple_icon_sizes(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(16, 16), (32, 32), (64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(16, 16), (32, 32), (64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_default_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico')\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_file_handling(self, mock_open):\n        mock_image = MagicMock()\n        mock_open.return_value.__enter__.return_value = mock_image\n        convert_png_to_ico('source.png', 'output.ico')\n        # Check if save was called correctly\n        mock_image.save.assert_called_once_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_invalid_image_path(self, mock_open):\n        mock_open.side_effect = FileNotFoundError\n        with self.assertRaises(FileNotFoundError):\n            convert_png_to_ico('invalid.png', 'output.ico')\n", "prompt": "please write a python function , the function signature as below def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 58, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom math import isclose\n\n\nclass TestProbabilityOfRedBalls(unittest.TestCase):\n\n    def test_half_red_balls(self):\n        # Scenario where half of the drawn balls are expected to be red\n        result = probability_of_red_balls(7, 10, 10)\n        expected_result = probability_of_red_balls(7, 10, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with half red balls failed\")\n\n    def test_some_red_balls(self):\n        # Scenario with some red balls in the jar, expecting a few red draws\n        result = probability_of_red_balls(5, 5, 10)\n        expected_result = probability_of_red_balls(5, 5, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with some red balls failed\")\n\n    def test_extreme_case(self):\n        # Extreme scenario where the probability is low for the chosen n\n        result = probability_of_red_balls(15, 1, 99)\n        expected_result = probability_of_red_balls(15, 1, 99)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with extreme case failed\")", "prompt": "please write a python function , the function signature as below def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n"}, {"task_id": 59, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom math import comb\n\n\nclass TestProbabilityRedBalls(unittest.TestCase):\n    def test_all_red(self):\n        # Case where all balls are red\n        self.assertEqual(probability_red_balls(5, 5, 0), 1)\n\n    def test_no_red(self):\n        # Case where no red balls are available\n        self.assertEqual(probability_red_balls(1, 0, 5), 0)\n\n    def test_typical_case(self):\n        # Typical scenario\n        self.assertAlmostEqual(probability_red_balls(2, 10, 5), comb(10, 2) / comb(15, 2))\n\n    def test_impossible_case(self):\n        # More balls requested than available\n        self.assertEqual(probability_red_balls(6, 5, 4), 0)\n\n    def test_high_combinations(self):\n        # Test with higher number of combinations\n        self.assertAlmostEqual(probability_red_balls(3, 20, 30), comb(20, 3) / comb(50, 3))", "prompt": "please write a python function , the function signature as below def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n"}, {"task_id": 60, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestCommonColumns(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory\n        self.test_dir = \"test_dir\"\n        os.makedirs(self.test_dir, exist_ok=True)\n\n    def tearDown(self):\n        # Remove created files and directory after each test.js\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def test_all_same_columns(self):\n        # All CSV files have the same columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"A,B,C\\n4,5,6\"\n        data3 = \"A,B,C\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(find_common_columns(self.test_dir)), set(['C', 'B', 'A']))\n\n    def test_no_common_columns(self):\n        # No common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"D,E,F\\n4,5,6\"\n        data3 = \"G,H,I\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(find_common_columns(self.test_dir), [])\n\n    def test_some_common_columns(self):\n        # Some common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"C,D,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(find_common_columns(self.test_dir), ['C'])\n\n    def test_mixed_common_and_unique_columns(self):\n        # Mixed common and unique columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"B,C,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(find_common_columns(self.test_dir)), set(['B', 'C']))\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_common_columns(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n"}, {"task_id": 62, "code_type": "class", "code_language": "python", "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n\n    def test_empty_tree(self):\n        bt = BinaryTree()\n        self.assertEqual(bt.inorder_traversal(), [])\n        self.assertEqual(bt.preorder_traversal(), [])\n        self.assertEqual(bt.postorder_traversal(), [])\n\n    def test_single_node_tree(self):\n        bt = BinaryTree()\n        bt.insert(10)\n        self.assertEqual(bt.inorder_traversal(), [10])\n        self.assertEqual(bt.preorder_traversal(), [10])\n        self.assertEqual(bt.postorder_traversal(), [10])\n\n    def test_balanced_tree(self):\n        bt = BinaryTree()\n        elements = [8, 3, 10, 1, 6, 9, 14]\n        for elem in elements:\n            bt.insert(elem)\n        self.assertEqual(bt.inorder_traversal(), [1, 3, 6, 8, 9, 10, 14])\n        self.assertEqual(bt.preorder_traversal(), [8, 3, 1, 6, 10, 9, 14])\n        self.assertEqual(bt.postorder_traversal(), [1, 6, 3, 9, 14, 10, 8])\n\n    def test_left_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(10, 0, -1):  # Inserts 10, 9, ..., 1\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [10-i for i in range(10)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(1, 11)])\n\n    def test_right_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(1, 11):  # Inserts 1, 2, ..., 10\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(10, 0, -1)])", "prompt": "please write a python class , the class signature as below class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the question structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n"}, {"task_id": 63, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import patch, mock_open\nimport pandas as pd\n\n\nclass TestDataframeToMarkdown(unittest.TestCase):\n    def setUp(self):\n        # Create a sample DataFrame\n        self.data = {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        self.df = pd.DataFrame(self.data)\n\n    @patch('builtins.open', new_callable=mock_open)\n    def test_write_to_file(self, mock_file):\n        # Test that the function writes the correct markdown to a file\n        expected_markdown = \"| Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\"\n        result = dataframe_to_markdown(self.df, 'dummy_path.md')\n        mock_file().write.assert_called_once_with(expected_markdown)\n        self.assertEqual(result, expected_markdown)\n\n    def test_empty_dataframe(self):\n        # Test how the function handles an empty DataFrame\n        df_empty = pd.DataFrame()\n        expected_markdown = \"|  |\\n|  |\\n\"\n        result = dataframe_to_markdown(df_empty, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_single_row_dataframe(self):\n        # Test with a DataFrame that contains only one row\n        df_single_row = pd.DataFrame({'Name': ['Alice'], 'Age': [30]})\n        expected_markdown = \"| Name | Age |\\n| --- | --- |\\n| Alice | 30 |\\n\"\n        result = dataframe_to_markdown(df_single_row, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_non_string_columns(self):\n        # Test with non-string question types in the DataFrame\n        df_non_string = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30], 'Height': [5.5, 6.0]})\n        expected_markdown = \"| Name | Age | Height |\\n| --- | --- | --- |\\n| Alice | 25 | 5.5 |\\n| Bob | 30 | 6.0 |\\n\"\n        result = dataframe_to_markdown(df_non_string, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_special_characters(self):\n        # Test handling of special characters in DataFrame\n        df_special_chars = pd.DataFrame(\n            {'Name': ['Alice', 'Bob'], 'Comments': ['Good@Work!', 'Excellent & Commendable']})\n        expected_markdown = \"| Name | Comments |\\n| --- | --- |\\n| Alice | Good@Work! |\\n| Bob | Excellent & Commendable |\\n\"\n        result = dataframe_to_markdown(df_special_chars, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    Args:\n        df (DataFrame): DataFrame type question\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n"}, {"task_id": 64, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport os\n\n\nclass TestCsvToSqlInsert(unittest.TestCase):\n\n    def setUp(self):\n        # Create sample CSV files for testing\n        self.test_files = {\n            'test1.csv': 'id,name,age\\n1,Alice,30\\n2,Bob,25',\n            'test2.csv': 'product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49',\n            'test3.csv': 'user_id,email\\n3,test@example.com\\n4,user@domain.com',\n            'test4.csv': 'order_id,order_date,total\\n1001,2024-09-01,59.99',\n            'test5.csv': 'quote_id,quote\\n1,\"It\\'s a beautiful day.\"\\n2,\"She said, \"\"Hello!\"\"\"'\n        }\n        # Create the files on disk\n        for filename, content in self.test_files.items():\n            with open(filename, 'w') as f:\n                f.write(content)\n\n    def tearDown(self):\n        # Remove the test files after tests\n        for filename in self.test_files:\n            os.remove(filename)\n\n    def test_simple_csv(self):\n        expected_sql = (\n            \"INSERT INTO test1 (id, name, age) VALUES ('1', 'Alice', '30');\\n\"\n            \"INSERT INTO test1 (id, name, age) VALUES ('2', 'Bob', '25');\"\n        )\n        result = csv_to_sql_insert('test1.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_product_csv(self):\n        expected_sql = (\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('101', 'Widget', '9.99');\\n\"\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES ('102', 'Gadget', '12.49');\"\n        )\n        result = csv_to_sql_insert('test2.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_email_csv(self):\n        expected_sql = (\n            \"INSERT INTO test3 (user_id, email) VALUES ('3', 'test@example.com');\\n\"\n            \"INSERT INTO test3 (user_id, email) VALUES ('4', 'user@domain.com');\"\n        )\n        result = csv_to_sql_insert('test3.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_date_and_decimal_csv(self):\n        expected_sql = (\n            \"INSERT INTO test4 (order_id, order_date, total) VALUES ('1001', '2024-09-01', '59.99');\"\n        )\n        result = csv_to_sql_insert('test4.csv')\n        self.assertEqual(result, expected_sql)", "prompt": "please write a python function , the function signature as below import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed.\n\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n"}, {"task_id": 65, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestFindDuplicateIps(unittest.TestCase):\n    def setUp(self):\n        self.files = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\n        self.ignored_ips = {\"192.168.1.1\", \"10.0.0.2\"}\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n192.168.1.1\\n192.168.0.1\\n\")\n    def test_duplicates_with_ignored(self, mock_file, mock_isfile):\n        # Setup\n        mock_isfile.return_value = True\n        expected_result = {'192.168.0.1': ['file1.txt']}\n\n        # Execution\n        result = find_duplicate_ips(self.files[:1], self.ignored_ips)\n\n        # Assertion\n        self.assertEqual(result, expected_result)\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n192.168.0.1\\n\")\n    def test_single_file_duplicates(self, mock_file, mock_isfile):\n        mock_isfile.return_value = True\n        expected_result = {'192.168.0.1': ['file1.txt']}\n        result = find_duplicate_ips(self.files[:1], set())\n        self.assertEqual(result, expected_result)\n\n    @patch('os.path.isfile')\n    def test_non_existent_file(self, mock_isfile):\n        mock_isfile.return_value = False\n        result = find_duplicate_ips([\"nonexistent.txt\"], self.ignored_ips)\n        self.assertEqual(result, {})\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n10.0.0.1\\n192.168.0.1\\n\")\n    def test_multiple_files_one_ignored(self, mock_file, mock_isfile):\n        mock_isfile.side_effect = [True, True, True]\n        expected_result = {'192.168.0.1': ['file1.txt', 'file2.txt']}\n        result = find_duplicate_ips(self.files, self.ignored_ips)\n        self.assertEqual(result, expected_result)\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n192.168.0.1\\n192.168.0.1\\n\")\n    def test_multiple_occurrences_single_file(self, mock_file, mock_isfile):\n        mock_isfile.return_value = True\n        expected_result = {'192.168.0.1': ['file1.txt']}\n        result = find_duplicate_ips(self.files[:1], set())\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef find_duplicate_ips(files: List[str], ignored_ips: set) -> dict:\n    \"\"\"\n    find duplicate IP addresses across multiple files, excluding any IPs in the ignored list.\n    Args:\n        files (list): List of file paths to search.\n        ignored_ips (set): Set of IP addresses to ignore.\n\n    Returns:\n        dict: A dictionary where each key is a duplicated IP address and the value is a list of filenames where the IP appears.\n    \"\"\"\n"}, {"task_id": 66, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass Course:\n    def __init__(self, course_id, must_courses=None, recommend_courses=None):\n        self.id = course_id\n        self.must_courses = must_courses if must_courses is not None else []\n        self.recommend_courses = recommend_courses if recommend_courses is not None else []\n\n\nclass LeveledCourse:\n    def __init__(self, course: Course, level: int):\n        self.course = course\n        self.level = level\n\nclass TestTopologicalSort(unittest.TestCase):\n\n    def test_empty_list(self):\n        \"\"\" Test sorting with no courses \"\"\"\n        courses = []\n        self.assertEqual(topological_sort(courses), [])\n\n    def test_single_course(self):\n        \"\"\" Test sorting with one course that has no dependencies \"\"\"\n        courses = [Course(\"101\")]\n        sorted_courses = topological_sort(courses)\n        self.assertEqual(len(sorted_courses), 1)\n        self.assertEqual(sorted_courses[0].course.id, \"101\")\n\n    def test_basic_dependency(self):\n        \"\"\" Test sorting where one course directly depends on another \"\"\"\n        courses = [Course(\"101\"), Course(\"102\", [\"101\"])]\n        sorted_courses = topological_sort(courses)\n        self.assertEqual([course.course.id for course in sorted_courses], [\"101\", \"102\"])\n\n    def test_complex_dependency(self):\n        \"\"\" Test a complex scenario with multiple dependencies \"\"\"\n        courses = [\n            Course(\"Math\"),\n            Course(\"Advanced Math\", [\"Math\"]),\n            Course(\"Physics\", [\"Math\"], [\"Advanced Math\"]),\n            Course(\"Chemistry\")\n        ]\n        sorted_courses = topological_sort(courses)\n        ids = [course.course.id for course in sorted_courses]\n        self.assertTrue(ids.index(\"Math\") < ids.index(\"Advanced Math\"))\n        self.assertTrue(ids.index(\"Math\") < ids.index(\"Physics\"))\n\n    def test_cycle_detection(self):\n        \"\"\" Test detection of cycles in course prerequisites \"\"\"\n        courses = [Course(\"101\", [\"102\"]), Course(\"102\", [\"101\"])]\n        with self.assertRaises(ValueError):\n            topological_sort(courses)", "prompt": "please write a python function , the function signature as below from typing import Iterable, List\n\n\nclass Course:\n    def __init__(self, course_id, must_courses=None, recommend_courses=None):\n        self.id = course_id\n        self.must_courses = must_courses if must_courses is not None else []\n        self.recommend_courses = recommend_courses if recommend_courses is not None else []\n\n\nclass LeveledCourse:\n    def __init__(self, course: Course, level: int):\n        self.course = course\n        self.level = level\n\ndef topological_sort(courses: Iterable[Course]) -> List[LeveledCourse]:\n    \"\"\"\n    Performs a topological sort on a collection of courses using Kahn's algorithm.\n\n    Args:\n    courses (Iterable[Course]): A collection of courses, where each course is assumed to have an 'id',\n                                and optionally 'must_courses' and 'recommend_courses' lists of course ids.\n\n    Returns:\n    List[LeveledCourse]: A list of courses sorted in topological order, each wrapped in a LeveledCourse\n                         object that also contains the level (i.e., distance from start in topological sort).\n\n    Raises:\n    ValueError: If there is a cycle detected in the courses, which prevents a complete topological sort.\n    \"\"\"\n"}, {"task_id": 67, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport xml.etree.ElementTree as ET\nfrom io import StringIO\n\n\nclass TestParseXamlToDict(unittest.TestCase):\n    def test_valid_strings(self):\n        xaml_data = \"\"\"<root>\n                         <String Key=\"Username\">Alice</String>\n                         <String Key=\"Password\">secret</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Alice', 'Password': 'secret'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_missing_key_attribute(self):\n        xaml_data = \"\"\"<root>\n                         <String>Alice</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n\n    def test_no_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Data>Some question</Data>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_nested_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Container>\n                           <String Key=\"Username\">Bob</String>\n                         </Container>\n                         <String Key=\"Location\">Earth</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Bob', 'Location': 'Earth'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the model_answer_result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n"}, {"task_id": 68, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestDivideList(unittest.TestCase):\n    def test_even_division(self):\n        lst = [1, 2, 3, 4, 5, 6]\n        n = 3\n        expected = [[1, 2], [3, 4], [5, 6]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_uneven_division(self):\n        lst = [1, 2, 3, 4, 5, 6, 7]\n        n = 3\n        expected = [[1, 2, 3], [4, 5], [6, 7]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_more_parts_than_items(self):\n        lst = [1, 2, 3]\n        n = 5\n        expected = [[1], [2], [3], [], []]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_single_element(self):\n        lst = [1]\n        n = 1\n        expected = [[1]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_empty_list(self):\n        lst = []\n        n = 3\n        expected = [[], [], []]\n        self.assertEqual(divide_list(lst, n), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef divide_list(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n"}, {"task_id": 70, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCodeBlockRemover(unittest.TestCase):\n\n    def test_single_code_block(self):\n        markdown = \"\"\"\n        This is a markdown with a code block.\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['print(\"Hello, World!\")']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_multiple_code_blocks(self):\n        markdown = \"\"\"\n        First code block:\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        Second code block:\n\n        ```javascript\n        console.log(\"Hello, World!\");\n        ```\n        \"\"\"\n        expected = [\n            'print(\"Hello, World!\")',\n            'console.log(\"Hello, World!\");'\n        ]\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_no_code_block(self):\n        markdown = \"\"\"\n        This markdown has no code blocks.\n\n        Just some plain text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_empty_code_block(self):\n        markdown = \"\"\"\n        Here is an empty code block:\n\n        ```python\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_malformed_code_block(self):\n        markdown = \"\"\"\n        This code block is missing ending:\n\n        ```python\n        print(\"Hello, World!\")\n\n        And some more text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n"}, {"task_id": 71, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport numpy as np\nimport os\n\n\ndef read_columns(file_name):\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n    # Initialize a variable to track the last slash line index\n    last_slash_index = None\n\n    with open(file_name) as f:\n        lines = f.readlines()\n\n    # Find the index of the last line that contains the \"/\" character\n    for i, line in enumerate(lines):\n        if \"/\" in line:\n            last_slash_index = i\n\n    # If no \"/\" character was found, raise an error\n    if last_slash_index is None:\n        raise ValueError(\"File does not contain '/' character\")\n\n    # Read the remaining lines in the file, starting from the line after the last \"/\"\n    data_lines = lines[last_slash_index + 1:]\n\n    # Remove any empty lines or lines that start with a comment character\n    data_lines = [line.strip() for line in data_lines if line.strip() and not line.strip().startswith('!')]\n\n    # If no valid lines remain, return an empty array\n    if not data_lines:\n        return np.array([])\n\n    # Get the row and column count by counting the number of columns in the first line\n    col_count = len(data_lines[0].split())\n\n    # Create an empty numpy array of the required size\n    arr = np.zeros((len(data_lines), col_count))\n\n    # Loop through the lines in the file\n    for i, line in enumerate(data_lines):\n        # Split the line into numbers and convert them to floats\n        nums = [float(x) for x in line.split()]\n        # Store the numbers in the array\n        arr[i, :] = nums\n\n    # Return the array\n    return arr\n\n\nclass TestReadColumns(unittest.TestCase):\n\n    def setUp(self):\n        # Setup a temporary directory to use for each test\n        self.test_file = 'test_file.txt'\n\n    def tearDown(self):\n        # Clean up the temporary file after each test\n        if os.path.exists(self.test_file):\n            os.remove(self.test_file)\n\n    def test_basic_functionality(self):\n        # Test reading a file with a valid structure and numerical question\n        content = \"\"\"Line 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_columns(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_no_slash_character(self):\n        # Test that a ValueError is raised if no '/' character is found\n        content = \"\"\"Line 1\nLine 2\nLine 3\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n\n    def test_file_with_comments_and_empty_lines(self):\n        # Test handling of comments and empty lines\n        content = \"\"\"Line 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_columns(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_different_number_of_columns(self):\n        # Test that the function handles different number of columns correctly\n        content = \"\"\"Line 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n\n    def test_empty_file(self):\n        # Test handling of an empty file\n        content = \"\"\"\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef read_columns(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical question.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n"}, {"task_id": 72, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestGet3DCoordinates(unittest.TestCase):\n    def setUp(self):\n        # Define a common intrinsic matrix for testing\n        self.K = np.array([[1000, 0, 320],\n                           [0, 1000, 240],\n                           [0, 0, 1]])\n\n    def test_center_coordinates(self):\n        \"\"\" Test with center pixel coordinates where x and y should map to zero in NDC. \"\"\"\n        result = get_3d_coordinates(self.K, 100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 100]))\n\n    def test_boundary_coordinates(self):\n        \"\"\" Test with boundary values in the image frame. \"\"\"\n        result = get_3d_coordinates(self.K, 50, 640, 480)\n        expected_x = (640 - 320) / 1000 * 50\n        expected_y = (480 - 240) / 1000 * 50\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 50]))\n\n    def test_negative_depth(self):\n        \"\"\" Test with a negative depth to see if it handles incorrect input properly. \"\"\"\n        result = get_3d_coordinates(self.K, -100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, -100]))\n\n    def test_zero_depth(self):\n        \"\"\" Test with zero depth which should lead to a zero-length vector. \"\"\"\n        result = get_3d_coordinates(self.K, 0, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 0.0]))\n\n    def test_non_integer_values(self):\n        \"\"\" Test with non-integer pixel coordinates. \"\"\"\n        result = get_3d_coordinates(self.K, 100, 320.5, 240.5)\n        expected_x = (320.5 - 320) / 1000 * 100\n        expected_y = (240.5 - 240) / 1000 * 100\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 100]))", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n    Args:\n        K ((3,3) np.array): camera intrinsic matrix\n        d (float): depth (distance along z-axis)\n        x (float): pixel x coordinate\n        y (float): pixel y coordinate\n\n    Returns:\n        np.array: x, y, z 3D point coordinates in camera RDF coordinates\n    \"\"\"\n"}, {"task_id": 73, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestDictOfListsToListOfDicts(unittest.TestCase):\n    def test_standard_conversion(self):\n        \"\"\"Test standard conversion with equal length lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n            \"age\": [25, 30, 35],\n            \"city\": [\"New York\", \"Los Angeles\", \"Chicago\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'},\n            {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'},\n            {'name': 'Charlie', 'age': 35, 'city': 'Chicago'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_empty_lists(self):\n        \"\"\"Test the function with empty lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [],\n            \"age\": [],\n            \"city\": []\n        }\n        expected_result = []\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_lists(self):\n        \"\"\"Test the function with single-element lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\"],\n            \"age\": [25],\n            \"city\": [\"New York\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n"}, {"task_id": 74, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestConvertDecimalToBinary(unittest.TestCase):\n    def test_basic_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 32),\n                         '01000000010010001111010111000011',\n                         \"3.14 should be correctly converted to 32-bit binary\")\n\n    def test_basic_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 64),\n                         '0100000000001001000111101011100001010001111010111000010100011111',\n                         \"3.14 should be correctly converted to 64-bit binary\")\n\n    def test_advance_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 32), '00111111110000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n\n    def test_advance_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(1.5, 64),\n                         '0011111111111000000000000000000000000000000000000000000000000000',\n                         \"1.5 should be correctly converted to 32-bit binary\")\n", "prompt": "please write a python function , the function signature as below import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\""}, {"task_id": 75, "code_type": "method", "code_language": "python", "test_code": "import re\nimport unittest\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\n\n\n\nclass TestRenameFiles(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for each test\n        self.test_dir = tempfile.mkdtemp()\n\n    def tearDown(self):\n        # Remove the temporary directory after each test\n        shutil.rmtree(self.test_dir)\n\n    def create_png_files(self, filenames):\n        for filename in filenames:\n            file_path = Path(self.test_dir) / filename\n            file_path.touch()  # Create an empty file\n\n    def test_basic_renaming(self):\n        # Test renaming in a basic scenario with simple filenames\n        filenames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'image3001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_reset_counter_for_different_base_names(self):\n        # Test that the counter resets for different base names\n        filenames = [\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'picture1001.png', 'picture2001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_no_png_files(self):\n        # Test handling of directories with no PNG files\n        filenames = [\"file1.txt\", \"file2.jpg\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = filenames  # No changes expected\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_empty_directory(self):\n        # Test handling of an empty directory\n        rename_files(self.test_dir)\n        expected_files = []  # No files to rename\n        result_files = os.listdir(self.test_dir)\n        self.assertEqual(result_files, expected_files)\n\n    def test_files_with_existing_numbers(self):\n        # Test renaming files that already have numbers in their names\n        filenames = [\"file001.png\", \"file002.png\", \"file003.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['file001001.png', 'file002001.png', 'file003001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)", "prompt": "please write a python function , the function signature as below def rename_files(directory: str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n    For example:\n        director have three PNG files such as \"image1.png\", \"image2.png\", \"image3.png\"\n        after renaming PNG files are \"image1001.png\", \"image2001.png\", \"image3001.png\"\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"\n"}, {"task_id": 76, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestRemoveCommonIndentation(unittest.TestCase):\n\n    def test_empty_string(self):\n        # Testing edge case with an empty string\n        self.assertEqual(remove_common_indentation(\"\"), \"\", \"Should return an empty string\")\n\n    def test_single_line_string(self):\n        # Testing a single line with no indentation\n        self.assertEqual(remove_common_indentation(\"No indentation here\"), \"No indentation here\", \"Should return the same string as input\")\n\n    def test_multiple_lines_with_uniform_indentation(self):\n        # Testing basic logic with uniform indentation across multiple lines\n        input_text = \"    Line one\\n    Line two\\n    Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove common leading indentation\")\n\n    def test_multiple_lines_with_mixed_indentation(self):\n        # Testing lines with mixed indentation levels\n        input_text = \"  Line one\\n  Line two\\n  Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove the minimum common indentation\")\n\n", "prompt": "please write a python function , the function signature as below def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\""}, {"task_id": 77, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom typing import Optional\n\nclass TestFormatTimestampToString(unittest.TestCase):\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with a known timestamp.\"\"\"\n        timestamp = 1655364000.0  # Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        # Assuming the local timezone is UTC\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the timestamp\")\n\n    def test_default_format(self):\n        \"\"\"Test using the default format string.\"\"\"\n        timestamp = 1655364000.0\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Default format should match the expected date string\")\n\n    def test_custom_format(self):\n        \"\"\"Test with a custom format string.\"\"\"\n        timestamp = 1655364000.0\n        custom_format = '%Y-%m-%d %H:%M:%S'\n        expected_date_str = '2022-06-16 15:20:00'\n        self.assertEqual(format_timestamp_to_string(timestamp, custom_format), expected_date_str, \"Should correctly format the timestamp using the custom format\")\n\n\n    def test_edge_case_boundary_value(self):\n        \"\"\"Test with an edge case timestamp (e.g., Unix epoch start).\"\"\"\n        timestamp = 0.0  # Unix epoch start\n        expected_date_str = 'Thu Jan 01 08:00:00 AM +0800 1970'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the Unix epoch start time\")", "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"\n"}, {"task_id": 78, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport numpy as np\n\nclass TestEulerToRotationMatrix(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Test with zero rotation for all axes\n        R = euler_to_rotation_matrix(0, 0, 0)\n        np.testing.assert_array_almost_equal(R, np.identity(3))\n\n    def test_rotation_about_x(self):\n        # Test rotation about the x-axis\n        R = euler_to_rotation_matrix(90, 0, 0)\n        expected = np.array([\n            [1, 0, 0],\n            [0, 0, -1],\n            [0, 1, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_y(self):\n        # Test rotation about the y-axis\n        R = euler_to_rotation_matrix(0, 90, 0)\n        expected = np.array([\n            [0, 0, 1],\n            [0, 1, 0],\n            [-1, 0, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_z(self):\n        # Test rotation about the z-axis\n        R = euler_to_rotation_matrix(0, 0, 90)\n        expected = np.array([\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_combined_rotation(self):\n        # Test combined rotation\n        R = euler_to_rotation_matrix(30, 45, 60)\n        # Expected model_answer_result manually calculated or verified via a reliable source\n        expected = np.array([[ 0.35355339, -0.5732233,   0.73919892], [ 0.61237244 , 0.73919892,  0.28033009], [-0.70710678 , 0.35355339,  0.61237244]])\n        np.testing.assert_array_almost_equal(R, np.array(expected), decimal=5)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n"}, {"task_id": 79, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestDateRangeString(unittest.TestCase):\n    def test_same_month(self):\n        # Test dates within the same month\n        result = date_range_string(\"2023-08-01\", \"2023-08-15\")\n        self.assertEqual(result, \"August 1 to 15, 2023\")\n\n    def test_different_months_same_year(self):\n        # Test dates across different months within the same year\n        result = date_range_string(\"2023-08-30\", \"2023-09-05\")\n        self.assertEqual(result, \"August 30 to September 5, 2023\")\n\n    def test_different_years(self):\n        # Test dates across different years\n        result = date_range_string(\"2023-12-30\", \"2024-01-02\")\n        self.assertEqual(result, \"December 30, 2023 to January 2, 2024\")\n\n    def test_incorrect_date_format(self):\n        # Test incorrect date formats\n        with self.assertRaises(ValueError) as context:\n            date_range_string(\"2023/08/01\", \"2023/08/15\")\n        self.assertTrue(\"Date must be in 'YYYY-MM-DD' format.\" in str(context.exception))\n", "prompt": "please write a python function , the function signature as below def date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\".\n    For example:\n        input:\n            start_date: 2023-08-01\n            end_date: 2023-08-15\n        output:\n            August 1 to 15, 2023\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n"}, {"task_id": 80, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSanitizeFilename(unittest.TestCase):\n\n    def test_valid_filename(self):\n        self.assertEqual(sanitize_filename(\"valid_filename.txt\"), \"valid_filename.txt\")\n\n    def test_illegal_characters(self):\n        self.assertEqual(sanitize_filename(\"invalid<filename>.txt\"), \"invalid_filename_.txt\")\n        self.assertEqual(sanitize_filename(\"file/name:with*illegal|chars?.txt\"), \"file_name_with_illegal_chars_.txt\")\n\n    def test_control_characters(self):\n        self.assertEqual(sanitize_filename(\"control\\x00char.txt\"), \"control_char.txt\")\n        self.assertEqual(sanitize_filename(\"file_with_control\\x1Fchars.txt\"), \"file_with_control_chars.txt\")\n\n    def test_long_filename(self):\n        long_filename = \"a\" * 300 + \".txt\"\n        sanitized_filename = sanitize_filename(long_filename)\n        self.assertEqual(len(sanitized_filename), 255)\n        self.assertEqual(sanitized_filename, \"a\" * 255)\n\n    def test_empty_filename(self):\n        self.assertEqual(sanitize_filename(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from windows file path string\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n"}, {"task_id": 81, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFindClosestElement(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        self.assertEqual(find_closest_element(5, [1, 3, 7, 8, 9]), 3,\n                         \"Should return 3 as it is the first closest element to 5\")\n\n    def test_exact_match(self):\n        self.assertEqual(find_closest_element(7, [1, 3, 7, 8, 9]), 7,\n                         \"Should return 7 as it exactly matches the target\")\n\n    def test_multiple_closest_values(self):\n        self.assertEqual(find_closest_element(5, [4, 6, 8, 9]), 4,\n                         \"Should return 4 as it is the first closest element to 5\")\n\n    def test_float_values(self):\n        self.assertEqual(find_closest_element(5.5, [1.1, 3.3, 7.7, 8.8]), 3.3,\n                         \"Should return 3.3 as it is the first closest element to 5.5\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n"}, {"task_id": 82, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom collections import defaultdict\n\n\nclass TestGraphCycles(unittest.TestCase):\n    def test_empty_graph(self):\n        g = Graph([])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for an empty graph.\")\n\n    def test_graph_no_cycles(self):\n        g = Graph([(1, 2), (2, 3)])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for a graph with no cycles.\")\n\n    def test_simple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertIn(list(results[3][0].nodes()), [[1, 2, 3]], \"Failed: Expected cycle nodes to match.\")\n\n    def test_multiple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertEqual(len(results[4]), 1, \"Failed: Expected one cycle of length 4.\")\n", "prompt": "please write a python function , the function signature as below from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n"}, {"task_id": 83, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestRotateListElements(unittest.TestCase):\n\n    def test_basic_rotation(self):\n        self.assertEqual(rotate_list_elements([1, 2, 3, 4]), [2, 3, 4, 1], \"Should rotate the list elements correctly\")\n\n    def test_single_element_list(self):\n        self.assertEqual(rotate_list_elements([10]), [10], \"Single element list should remain unchanged\")\n\n    def test_empty_list(self):\n        self.assertEqual(rotate_list_elements([]), [], \"Empty list should remain unchanged\")\n\n    def test_two_element_list(self):\n        self.assertEqual(rotate_list_elements([5, 9]), [9, 5], \"Should correctly rotate a two-element list\")\n\n    def test_large_list(self):\n        large_list = list(range(1, 1001))\n        rotated_list = rotate_list_elements(large_list)\n        self.assertEqual(rotated_list, list(range(2, 1001)) + [1], \"Should correctly rotate a large list\")\n\n\n\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n"}, {"task_id": 84, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFindMinWindowSubstring(unittest.TestCase):\n\n    def test_empty_source_string(self):\n        # Test with an empty source string\n        self.assertEqual(find_min_window_substring(\"\", \"abc\"), \"\", \"Should return an empty string when source is empty\")\n\n    def test_empty_target_string(self):\n        # Test with an empty target string\n        self.assertEqual(find_min_window_substring(\"abc\", \"\"), \"\", \"Should return an empty string when target is empty\")\n\n    def test_no_valid_window(self):\n        # Test when there is no valid window\n        self.assertEqual(find_min_window_substring(\"abcdef\", \"xyz\"), \"\",\n                         \"Should return an empty string when no valid window exists\")\n\n    def test_exact_match_window(self):\n        # Test when the entire source string is the exact match\n        self.assertEqual(find_min_window_substring(\"abcd\", \"abcd\"), \"abcd\",\n                         \"Should return the entire string when it is an exact match\")\n\n    def test_minimal_valid_window(self):\n        # Test with a minimal valid window case\n        self.assertEqual(find_min_window_substring(\"ADOBECODEBANC\", \"ABC\"), \"BANC\",\n                         \"Should return 'BANC' as the smallest window containing all characters of 'ABC'\")\n\n\n", "prompt": "please write a python function , the function signature as below from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\""}, {"task_id": 85, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport pandas as pd\n\nclass TestNaiveFfill(unittest.TestCase):\n\n    def test_basic_forward_fill(self):\n        df = pd.DataFrame({'A': [1, None, 3, None, 5]})\n        naive_ffill(df, 'A')\n        expected = pd.DataFrame({'A': [1, 1, 3, 3, 5]})\n        pd.testing.assert_frame_equal(df, expected)\n\n\n    def test_non_existent_column(self):\n        df = pd.DataFrame({'A': [1, 2, 3]})\n        with self.assertRaises(KeyError):\n            naive_ffill(df, 'B')\n\n    def test_multiple_columns(self):\n        df = pd.DataFrame({'A': [1, None, 3], 'B': [None, 2, None]})\n        naive_ffill(df, 'A')\n        expected = pd.DataFrame({'A': [1, 1, 3], 'B': [None, 2, None]})\n        pd.testing.assert_frame_equal(df, expected)", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef naive_ffill(df: pd.DataFrame, column: str) -> None:\n    \"\"\"\n    Forward fills missing values in a specified column of a pandas DataFrame using a naive method.\n\n    Args:\n    df (pd.DataFrame): The DataFrame containing the question.\n    column (str): The name of the column in which to forward fill missing values.\n\n    Returns:\n    None: The function modifies the DataFrame in place.\n    \"\"\""}, {"task_id": 86, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        self.assertEqual(bresenham_line(1, 5, 5, 5), [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5)])\n\n    def test_vertical_line(self):\n        self.assertEqual(bresenham_line(3, 2, 3, 6), [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6)])\n\n    def test_diagonal_line(self):\n        self.assertEqual(bresenham_line(2, 2, 6, 6), [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])\n\n    def test_steep_slope(self):\n        self.assertEqual(bresenham_line(1, 1, 4, 6), [(1, 1), (2, 2), (2, 3), (3, 4), (3, 5), (4, 6)])\n\n    def test_negative_slope(self):\n        self.assertEqual(bresenham_line(5, 1, 1, 5), [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5)])\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n"}, {"task_id": 213, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestIm2Col(unittest.TestCase):\n\n    def test_single_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 3, 5, 6, 7, 9, 10, 11],\n            [2, 3, 4, 6, 7, 8, 10, 11, 12],\n            [5, 6, 7, 9, 10, 11, 13, 14, 15],\n            [6, 7, 8, 10, 11, 12, 14, 15, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_single_channel_no_padding_stride_2(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 2\n        padding = 0\n\n        expected_output = np.array([\n            [1, 3, 9, 11],\n            [2, 4, 10, 12],\n            [5, 7, 13, 15],\n            [6, 8, 14, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_multi_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3],\n             [4, 5, 6],\n             [7, 8, 9]],\n            [[9, 8, 7],\n             [6, 5, 4],\n             [3, 2, 1]]\n        ])  # Shape (2, 3, 3), 2 channels\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 4, 5],\n            [2, 3, 5, 6],\n            [4, 5, 7, 8],\n            [5, 6, 8, 9],\n            [9, 8, 6, 5],\n            [8, 7, 5, 4],\n            [6, 5, 3, 2],\n            [5, 4, 2, 1]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\""}, {"task_id": 214, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReadMappingFile(unittest.TestCase):\n    def test_invalid_format(self):\n        # Test handling of a file with incorrect format (missing comma)\n        file_content = \"'pattern' 'replacement'\"\n        m_open = mock_open(read_data=file_content)\n        with patch('builtins.open', m_open):\n            with self.assertRaises(ValueError):\n                read_mapping_file('fake_path.txt')\n\n    def test_empty_file(self):\n        # Test handling of an empty file\n        m_open = mock_open(read_data=\"\")\n        with patch('builtins.open', m_open):\n            result = read_mapping_file('fake_path.txt')\n            self.assertEqual(result, [])\n\n    def test_file_not_found(self):\n        # Test file not found error\n        with patch('builtins.open', side_effect=FileNotFoundError):\n            with self.assertRaises(FileNotFoundError):\n                read_mapping_file('nonexistent_path.txt')\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads question from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n"}, {"task_id": 215, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReplaceWordsInFile(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_single_word(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"hi world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_multiple_words(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\", \"world\": \"earth\"}\n        expected_output = \"hi earth\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_no_replacement(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"goodbye\": \"bye\"}\n        expected_output = \"hello world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"\")\n    def test_empty_file(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n", "prompt": "please write a python function , the function signature as below def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n"}, {"task_id": 216, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIp(unittest.TestCase):\n    def setUp(self):\n        # Sample IP command output for a wlan0 interface\n        self.sample_output = \"3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n\" \\\n                             \"    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic wlan0\\n\" \\\n                             \"       valid_lft 86394sec preferred_lft 86394sec\\n\"\n\n    @patch('subprocess.run')\n    def test_successful_ip_retrieval(self, mock_run):\n        # Configure the mock to return a successful output\n        mock_run.return_value = MagicMock(stdout=self.sample_output, check=True)\n        # Test function with wlan0 interface\n        ip = get_local_ip('wlan0')\n        self.assertEqual(ip, '192.168.1.100')\n\n    @patch('subprocess.run')\n    def test_no_ip_found(self, mock_run):\n        # Configure the mock to simulate no IP found on the interface\n        mock_run.return_value = MagicMock(stdout=\"3: wlan0: <NO-CARRIER,BROADCAST,MULTICAST,UP>\", check=True)\n        with self.assertRaises(RuntimeError) as context:\n            get_local_ip('wlan0')\n        self.assertIn(\"No local IP found\", str(context.exception))\n\n    @patch('subprocess.run')\n    def test_command_failure(self, mock_run):\n        # Simulate a subprocess failure\n        mock_run.side_effect = subprocess.CalledProcessError(1, ['ip', 'addr', 'show', 'wlan0'])\n        with self.assertRaises(RuntimeError) as context:\n            get_local_ip('wlan0')\n        self.assertIn(\"Failed to retrieve IP address\", str(context.exception))\n\n    @patch('subprocess.run')\n    def test_different_interface(self, mock_run):\n        # Configure the mock for a different interface\n        mock_run.return_value = MagicMock(\n            stdout=\"3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500\\n    inet 10.0.0.1/24\", check=True)\n        ip = get_local_ip('eth0')\n        self.assertEqual(ip, '10.0.0.1')\n", "prompt": "please write a python function , the function signature as below import re\nimport subprocess\n\n\ndef get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\""}, {"task_id": 219, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCheckDividendVariances(unittest.TestCase):\n\n    def test_no_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.22),\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_one_inconsistency(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = [('AAPL', '2023-09-01')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_multiple_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('MSFT', '2023-09-01', 0.60),  # Different amount\n            ('GOOG', '2023-09-02', 0.00),\n            ('TSLA', '2023-09-03', 0.10),\n            ('TSLA', '2023-09-03', 0.10),  # Same amount, no inconsistency\n            ('TSLA', '2023-09-03', 0.15)  # Different amount\n        ]\n        expected_output = [('AAPL', '2023-09-01'), ('MSFT', '2023-09-01'), ('TSLA', '2023-09-03')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_single_record(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_empty_list(self):\n        records = []\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n\n    Parameters:\n    - records (list of tuples): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n    - list of tuples: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"\n"}, {"task_id": 220, "code_type": "class", "code_language": "python", "test_code": "import unittest\nfrom collections import deque\n\nclass TestUniqueDeque(unittest.TestCase):\n\n    def test_add_unique_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertTrue(ud.add(2))\n        self.assertTrue(ud.add(3))\n        self.assertEqual(len(ud), 3)\n        self.assertEqual(list(ud), [1, 2, 3])\n\n    def test_add_duplicate_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertFalse(ud.add(1))  # Duplicate add should return False\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [1])\n\n    def test_delete_elements(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        ud.add(3)\n        self.assertTrue(ud.delete(2))\n        self.assertFalse(ud.delete(2))  # Deleting non-existing element should return False\n        self.assertEqual(len(ud), 2)\n        self.assertEqual(list(ud), [1, 3])\n\n    def test_contains(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        self.assertTrue(ud.contains(1))\n        self.assertFalse(ud.contains(2))\n        ud.delete(1)\n        self.assertFalse(ud.contains(1))\n\n    def test_iter_and_len(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        self.assertEqual(len(ud), 2)\n        items = list(iter(ud))\n        self.assertEqual(items, [1, 2])\n        ud.delete(1)\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [2])", "prompt": "please write a python class , the class signature as below from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n\n    def __len__(self):\n        \"\"\"\n        Get the number of elements in the deque.\n\n        Returns:\n        - int: The number of unique elements in the deque.\n        \"\"\"\n\n    def __iter__(self):\n        \"\"\"\n        Create an iterator for the deque.\n\n        Returns:\n        - iterator: An iterator over the elements in the deque.\n        \"\"\"\n"}, {"task_id": 221, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractParseDicts(unittest.TestCase):\n    def test_extract_single_valid_dictionary(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}])\n\n    def test_extract_multiple_dictionaries(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}\\n{\"city\": \"New York\", \"country\": \"USA\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}, {\"city\": \"New York\", \"country\": \"USA\"}])\n\n    def test_invalid_dictionary_format(self):\n        mock_content = '{\"name\": \"John\", \"age\": \"thirty\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{'name': 'John', 'age': 'thirty'}])\n\n    def test_empty_file(self):\n        with patch('builtins.open', mock_open(read_data='')):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [])\n\n    def test_file_with_no_dictionaries(self):\n        mock_content = 'This is just some text without any dictionaries.'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [])\n", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n"}, {"task_id": 224, "code_type": "method", "code_language": "python", "test_code": "import os\nimport shutil\nimport tempfile\nimport unittest\n\n\nclass TestEmptyDirectory(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory with some files and directories\n        self.test_dir = tempfile.mkdtemp()\n        # Create some files and directories\n        os.mkdir(os.path.join(self.test_dir, 'subdir'))\n        with open(os.path.join(self.test_dir, 'file1.txt'), 'w') as f:\n            f.write(\"Hello\")\n        with open(os.path.join(self.test_dir, 'subdir', 'file2.txt'), 'w') as f:\n            f.write(\"World\")\n\n    def tearDown(self):\n        # Remove the temporary directory after each test.js\n        shutil.rmtree(self.test_dir)\n\n    def test_empty_directory_success(self):\n        \"\"\" Test that the directory is emptied successfully \"\"\"\n        empty_directory(self.test_dir)\n        self.assertEqual(os.listdir(self.test_dir), [])  # Directory should be empty\n\n\n\n    def test_empty_directory_with_subdirectories(self):\n        \"\"\" Test emptying a directory that includes subdirectories \"\"\"\n        empty_directory(self.test_dir)\n        self.assertFalse(os.listdir(self.test_dir))  # Directory and subdirectory should be empty\n\n    def test_empty_already_empty_directory(self):\n        \"\"\" Test emptying a directory that is already empty \"\"\"\n        empty_directory(self.test_dir)  # First emptying\n        empty_directory(self.test_dir)  # Empty again\n        self.assertEqual(os.listdir(self.test_dir), [])  # Still should be empty\n", "prompt": "please write a python function , the function signature as below def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n"}, {"task_id": 226, "code_type": "method", "code_language": "python", "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestTSVtoJSONL(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for testing\n        self.test_dir = tempfile.TemporaryDirectory()\n\n    def tearDown(self):\n        # Clean up the temporary directory\n        self.test_dir.cleanup()\n\n    def test_standard_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\nBob\\t25\\tCanada\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_standard.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_standard.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Country\":\"Canada\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n\n    def test_single_row_tsv(self):\n        tsv_content = \"Name\\tAge\\tCountry\\nAlice\\t30\\tUSA\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_single_row.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_single_row.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Country\":\"USA\"}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n\n    def test_numeric_and_boolean_values(self):\n        tsv_content = \"Name\\tAge\\tIs_Student\\nAlice\\t30\\tTrue\\nBob\\t25\\tFalse\\n\"\n        tsv_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.tsv')\n        jsonl_file = os.path.join(self.test_dir.name, 'test_numeric_boolean.jsonl')\n\n        with open(tsv_file, 'w', encoding='utf-8') as f:\n            f.write(tsv_content)\n\n        tsv_to_jsonl(tsv_file, jsonl_file)\n\n        with open(jsonl_file, 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n\n        expected_lines = [\n            '{\"Name\":\"Alice\",\"Age\":30,\"Is_Student\":true}\\n',\n            '{\"Name\":\"Bob\",\"Age\":25,\"Is_Student\":false}\\n'\n        ]\n        self.assertEqual(lines, expected_lines)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef tsv_to_jsonl(tsv_file: str, jsonl_file: str):\n    \"\"\"\n    Convert tsv file to jsonl file\n\n    Args:\n        tsv_file: tsf file path\n        jsonl_file: jsonl file path\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 227, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCountUniqueColor(unittest.TestCase):\n\n    def test_case1(self):\n        picture_path = \"./picture1_2_color.png\"\n        expected_color_num = 2\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case2(self):\n        picture_path = \"./picture2_1_color.png\"\n        expected_color_num = 1\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case3(self):\n        picture_path = \"./picture3_2_color.png\"\n        expected_color_num = 31\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case4(self):\n        picture_path = \"./picture4_5_color.png\"\n        expected_color_num = 524\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n", "prompt": "please write a python function , the function signature as below def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Args:\n        image_path (str): Path to the image file.\n\n    Returns:\n        int: The number of unique colors in the image.\n    \"\"\"\n"}, {"task_id": 229, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestGetFileSize(unittest.TestCase):\n\n    def test_auto_unit_selection(self):\n        \"\"\" Test automatic unit selection based on file size \"\"\"\n        # Test that units are correctly auto-selected based on size\n        self.assertEqual(get_file_size(500), ('500 B', 500))  # Bytes\n        self.assertEqual(get_file_size(2000), ('1.95 KB', 1.953125))  # Kilobytes\n        self.assertEqual(get_file_size(3 * 1024 ** 2), ('3.00 MB', 3.0))  # Megabytes\n        self.assertEqual(get_file_size(5 * 1024 ** 3), ('5.00 GB', 5.0))  # Gigabytes\n\n    def test_specific_unit(self):\n        \"\"\" Test output when specific units are requested \"\"\"\n        # Test for each unit conversion\n        self.assertEqual(get_file_size(1024, 'KB'), ('1.00 KB', 1.0))\n\n    def test_invalid_unit(self):\n        \"\"\" Test behavior when an invalid unit is provided \"\"\"\n        with self.assertRaises(ValueError):\n            get_file_size(1024, 'xyz')  # Should raise ValueError for invalid unit\n\n    def test_large_file_size(self):\n        \"\"\" Test with very large file size \"\"\"\n        # Testing a large number, should format to gigabytes\n        self.assertEqual(get_file_size(10 * 1024 ** 4), ('10240.00 GB', 10240.0))\n\n    def test_zero_bytes(self):\n        \"\"\" Test with zero bytes \"\"\"\n        # Edge case for zero bytes\n        self.assertEqual(get_file_size(0), ('0 B', 0))\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef get_file_size(size_in_bytes, unit=None) -> Tuple[int, float]:\n    \"\"\"\n    Convert file size from bytes to a more readable format (e.g. KB, MB, GB)\n\n    Args:\n        size_in_bytes (int): File size in bytes.\n        unit (str, optional): The unit to convert the size to ('B', 'KB', 'MB', 'GB').\n\n    Returns:\n        tuple: A tuple containing the formatted size string and the size converted to the specified or chosen unit as float.\n    \"\"\"\n"}, {"task_id": 230, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestMoveEmojisToEnd(unittest.TestCase):\n\n    def test_single_emoji_at_start(self):\n        \"\"\" Test string with a single emoji at the start \"\"\"\n        input_text = \"\ud83d\ude0a Hello, world!\"\n        expected_output = \" Hello, world!\ud83d\ude0a\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_multiple_emojis_mixed(self):\n        \"\"\" Test string with multiple emojis mixed in text \"\"\"\n        input_text = \"Ready \ud83d\ude0a to start \ud83d\ude80 your day? \ud83c\udf1e\"\n        expected_output = \"Ready  to start  your day? \ud83d\ude0a\ud83d\ude80\ud83c\udf1e\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_all_emojis(self):\n        \"\"\" Test string that contains only emojis \"\"\"\n        input_text = \"\ud83d\ude0a\ud83d\ude80\ud83c\udf1e\ud83c\udf89\"\n        expected_output = \"\ud83d\ude0a\ud83d\ude80\ud83c\udf1e\ud83c\udf89\"  # Output should remain the same as input\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_no_emojis(self):\n        \"\"\" Test string with no emojis \"\"\"\n        input_text = \"Hello, world!\"\n        expected_output = \"Hello, world!\"  # Output should remain the same as input\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_and_whitespace(self):\n        \"\"\" Test string with emojis and whitespace characters \"\"\"\n        input_text = \"\ud83d\ude80 Are we \ud83d\ude0a ready? \ud83c\udf1e  \"\n        expected_output = \" Are we  ready?   \ud83d\ude80\ud83d\ude0a\ud83c\udf1e\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below import emoji\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n"}, {"task_id": 231, "code_type": "method", "code_language": "python", "test_code": "import json\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReadLog(unittest.TestCase):\n\n    def test_read_correct_data(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 89.0, \"train_loss\": 0.70}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75, 0.70])\n            self.assertEqual(test_acc1, [88.5, 89.0])\n\n    def test_file_not_found(self):\n        \"\"\" Test behavior when the file does not exist \"\"\"\n        with patch('builtins.open', side_effect=FileNotFoundError):\n            train_loss, test_acc1 = read_log(\"nonexistent_path.json\")\n            self.assertEqual(train_loss, [])\n            self.assertEqual(test_acc1, [])\n\n    def test_invalid_json(self):\n        \"\"\" Test behavior when file contains invalid JSON \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\nInvalid JSON Line'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            with patch('json.loads', side_effect=json.JSONDecodeError(\"Expecting value\", \"doc\", 0)):\n                train_loss, test_acc1 = read_log(\"dummy_path.json\")\n                self.assertEqual(train_loss, [])\n                self.assertEqual(test_acc1, [])\n\n    def test_empty_file(self):\n        \"\"\" Test reading an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data=\"\")):\n            train_loss, test_acc1 = read_log(\"empty_file.json\")\n            self.assertEqual(train_loss, [])\n            self.assertEqual(test_acc1, [])\n\n    def test_partial_data_entries(self):\n        \"\"\" Test file with missing fields in some entries \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 90.0}'  # Missing train_loss\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"partial_data_file.json\")\n            self.assertEqual(train_loss, [0.75])  # Only one complete entry\n            self.assertEqual(test_acc1, [88.5, 90.0])\n", "prompt": "please write a python function , the function signature as below def read_log(log_file_path):\n    \"\"\"\n    Reads a log file containing JSON entries and extracts training loss and test accuracy.\n    Json entries such as {\"test_acc1\": 88.5, \"train_loss\": 0.75}\n    Args:\n        log_file_path (str): The path to the log file to be read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n            - train_loss_list (list): A list of training loss values extracted from the log.\n            - test_acc1_list (list): A list of test accuracy values extracted from the log.\n    \"\"\"\n"}, {"task_id": 232, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestConvertHmsToMilliseconds(unittest.TestCase):\n\n    def test_basic_conversion(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"1h20min30s\"), 4830000, \"Should convert 1h20min30s to 4830000 milliseconds\")\n\n    def test_no_hours_or_minutes(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"30s\"), 30000, \"Should convert 30s to 30000 milliseconds\")\n\n    def test_invalid_format(self):\n        self.assertIsNone(convert_hms_to_milliseconds(\"1hour20minutes\"), \"Should return None for invalid time format\")\n\n    def test_edge_case_max_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"23h59min59s\"), 86399000, \"Should convert 23h59min59s to 86399000 milliseconds\")\n\n    def test_exceeding_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"24h1min\"), 86460000,\n                         \"Should correctly convert 24h1min to 86460000 milliseconds\")", "prompt": "please write a python function , the function signature as below from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n"}, {"task_id": 233, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestRemoveComments(unittest.TestCase):\n\n    def test_single_line_comment(self):\n        \"\"\" Test string with a comment on a single line \"\"\"\n        input_string = \"Hello, world! # This is a comment\"\n        expected_output = \"Hello, world! \"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_multi_line_comments(self):\n        \"\"\" Test string with multiple lines, each containing comments \"\"\"\n        input_string = \"Hello, world!\\n# This is a comment\\nPython is fun! # another comment\"\n        expected_output = \"Hello, world!\\n\\nPython is fun! \"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_no_comments(self):\n        \"\"\" Test string with no comments \"\"\"\n        input_string = \"Hello, world!\\nPython is fun!\"\n        expected_output = \"Hello, world!\\nPython is fun!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_empty_string(self):\n        \"\"\" Test an empty string \"\"\"\n        input_string = \"\"\n        expected_output = \"\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_comments_only(self):\n        \"\"\" Test string where all lines are comments \"\"\"\n        input_string = \"# comment only line\\n#another comment line\"\n        expected_output = \"\\n\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n", "prompt": "please write a python function , the function signature as below def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    For example:\n        input: Hello, world! # This is a comment\n        output:  Hello, world!\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n"}, {"task_id": 234, "code_type": "method", "code_language": "python", "test_code": "import csv\nimport io\nimport unittest\n\n\nclass TestAppendOrSkipRow(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a mock CSV file using StringIO.\"\"\"\n        self.mock_file = io.StringIO()\n        self.mock_file.write(\"Alice,30,USA\\nBob,25,UK\\nCharlie,35,Canada\\n\")\n        self.mock_file.seek(0)  # Reset pointer to the start of the mock file\n        self.reader = csv.reader(self.mock_file)\n\n    def test_append_new_row(self):\n        \"\"\"Test appending a new row when there are no matching values.\"\"\"\n        new_row = ['David', '28', 'Australia']\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_skip_different_values(self):\n        \"\"\"Test appending a new row with different values.\"\"\"\n        new_row = ['Alice', '31', 'USA']  # Same name, different age\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_append_row_with_different_columns(self):\n        \"\"\"Test appending a row with different values in the first three columns.\"\"\"\n        new_row = ['Eve', '40', 'Australia', 'Engineer']\n        append_or_skip_row(self.mock_file, self.reader, new_row)\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        self.assertIn(new_row, result)\n\n    def test_multiple_appends(self):\n        \"\"\"Test appending multiple new rows correctly.\"\"\"\n        new_rows = [\n            ['Frank', '29', 'Germany'],\n            ['Grace', '22', 'France']\n        ]\n\n        for row in new_rows:\n            append_or_skip_row(self.mock_file, self.reader, row)\n            self.mock_file.seek(0)  # Reset pointer for the next read\n            self.reader = csv.reader(self.mock_file)  # Recreate the reader after each append\n\n        self.mock_file.seek(0)  # Reset pointer to read from the start\n        result = list(csv.reader(self.mock_file))\n        for row in new_rows:\n            self.assertIn(row, result)", "prompt": "please write a python function , the function signature as below def append_or_skip_row(file_handler, reader, row_candidate):\n    \"\"\"\n    Appends a new row to a CSV file if there isn't a row with matching values in the first three columns.\n\n    Args:\n        file_handler: File handler of the CSV file opened in read-plus mode ('r+').\n        reader: CSV reader object for reading existing rows.\n        row_candidate: List containing the new row to be appended.\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 235, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestCalculateBearing(unittest.TestCase):\n    def test_north_bearing(self):\n        # From equator directly north\n        self.assertAlmostEqual(calculate_bearing(0, 0, 10, 0), 0)\n\n    def test_east_bearing(self):\n        # From prime meridian directly east\n        self.assertAlmostEqual(calculate_bearing(0, 0, 0, 10), 90)\n\n    def test_south_bearing(self):\n        # From a point directly south\n        self.assertAlmostEqual(calculate_bearing(10, 0, 0, 0), 180)\n\n    def test_west_bearing(self):\n        # From a point directly west\n        self.assertAlmostEqual(calculate_bearing(0, 10, 0, 0), 270)\n\n    def test_across_prime_meridian(self):\n        # From a point west of the prime meridian to a point east\n        self.assertAlmostEqual(calculate_bearing(0, -1, 0, 1), 90)", "prompt": "please write a python function , the function signature as below def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n"}, {"task_id": 240, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom datetime import timedelta\n\n\nclass TestGenTimeoutTimedelta(unittest.TestCase):\n\n    def test_complete_time_string(self):\n        \"\"\" Test a string containing all time units \"\"\"\n        result = gen_timeout_timedelta(\"1d 2h 3m 4s 500ms\")\n        self.assertEqual(result.days, 1)\n        self.assertEqual(result.seconds, (2 * 3600) + (3 * 60) + 4)\n        self.assertEqual(result.microseconds, 500)\n\n    def test_partial_time_string(self):\n        \"\"\" Test a string containing only some time units \"\"\"\n        result = gen_timeout_timedelta(\"2h 30m\")\n        self.assertEqual(result.days, 0)\n        self.assertEqual(result.seconds, (2 * 3600) + (30 * 60))\n        self.assertEqual(result.microseconds, 0)\n", "prompt": "please write a python function , the function signature as below from datetime import timedelta\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg.\"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n    Args:\n        time_string (str):A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"\n"}, {"task_id": 241, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        \"\"\" Test basic functionality with expected input \"\"\"\n        mock_content = \"hello world\\napple banana apple\\norange apple banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (2, 1))\n\n\n    def test_words_not_present(self):\n        \"\"\" Test case where one or both words are not present \"\"\"\n        mock_content = \"apple orange pear\\norange pear apple\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_empty_file(self):\n        \"\"\" Test an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data='')):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_multiple_lines_with_varying_distances(self):\n        \"\"\" Test multiple lines with varying distances between words \"\"\"\n        mock_content = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (1, 1))", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n"}, {"task_id": 242, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestClassifyFilesByExtension(unittest.TestCase):\n\n    def test_multiple_file_types(self):\n        \"\"\"Test with multiple file types.\"\"\"\n        files = [\n            \"document.docx\",\n            \"photo.jpeg\",\n            \"report.pdf\",\n            \"image.png\",\n            \"archive.zip\"\n        ]\n        expected_result = {\n            'docx': ['document.docx'],\n            'jpeg': ['photo.jpeg'],\n            'pdf': ['report.pdf'],\n            'png': ['image.png'],\n            'zip': ['archive.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_empty_list(self):\n        \"\"\"Test with an empty list of file names.\"\"\"\n        files = []\n        expected_result = {}\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_no_extension_files(self):\n        \"\"\"Test with files that have no extensions.\"\"\"\n        files = [\n            \"README\",\n            \"LICENSE\",\n            \"script\",\n            \"data\"\n        ]\n        expected_result = {}\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_same_extension(self):\n        \"\"\"Test with multiple files having the same extension.\"\"\"\n        files = [\n            \"file1.txt\",\n            \"file2.txt\",\n            \"file3.txt\",\n        ]\n        expected_result = {\n            'txt': [\n                \"file1.txt\",\n                \"file2.txt\",\n                \"file3.txt\",\n            ]\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)\n\n    def test_files_with_multiple_dots(self):\n        \"\"\"Test files that have multiple dots in their names.\"\"\"\n        files = [\n            \"my.document.docx\",\n            \"report.final.pdf\",\n            \"photo.album.jpeg\",\n            \"archive.backup.zip\"\n        ]\n        expected_result = {\n            'docx': ['my.document.docx'],\n            'pdf': ['report.final.pdf'],\n            'jpeg': ['photo.album.jpeg'],\n            'zip': ['archive.backup.zip']\n        }\n        self.assertEqual(classify_files_by_extension(files), expected_result)", "prompt": "please write a python function , the function signature as below from typing import List, Dict\n\n\ndef classify_files_by_extension(file_names: List[str]) -> Dict:\n    \"\"\"\n    Classify an array of file names according to their file extensions.\n\n    Args:\n        file_names: List of file names (strings).\n\n    Returns:\n        Dict: Dictionary with file extensions as keys and lists of file names as values.\n    \"\"\"\n"}, {"task_id": 244, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom typing import Callable\n\n\nclass MyClass:\n    def my_method(self, arg1: int, arg2: str, optional_arg: float = 3.14):\n        pass\n\n\nclass TestMethodArgTypeCheck(unittest.TestCase):\n    def test_correct_types(self):\n        \"\"\" Test with correct argument types. \"\"\"\n        try:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, \"hello\", optional_arg=3.14)\n        except ValueError:\n            self.fail(\"method_arg_type_check() raised ValueError unexpectedly!\")\n\n    def test_incorrect_type_for_arg1(self):\n        \"\"\" Test with incorrect type for arg1. \"\"\"\n        with self.assertRaises(ValueError) as context:\n            method_arg_type_check(MyClass.my_method, MyClass(), \"10\", \"hello\", optional_arg=3.14)\n        self.assertIn(\"arg1 should be of type int\", str(context.exception))\n\n    def test_incorrect_type_for_arg2(self):\n        \"\"\" Test with incorrect type for arg2. \"\"\"\n        with self.assertRaises(ValueError) as context:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, 10, optional_arg=3.14)\n        self.assertIn(\"arg2 should be of type str\", str(context.exception))\n\n    def test_incorrect_type_for_optional_arg(self):\n        \"\"\" Test with incorrect type for optional_arg. \"\"\"\n        with self.assertRaises(ValueError) as context:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, \"hello\", optional_arg=\"pi\")\n        self.assertIn(\"optional_arg should be of type float\", str(context.exception))\n\n    def test_missing_argument(self):\n        \"\"\" Test with missing required argument. \"\"\"\n        with self.assertRaises(TypeError):\n            method_arg_type_check(MyClass.my_method, MyClass(), 10)  # Missing arg2\n", "prompt": "please write a python function , the function signature as below from typing import Callable\n\n\ndef method_arg_type_check(method_obj: Callable, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected question types, based on the method's signature.js.py.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 248, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSanitizeData(unittest.TestCase):\n    def test_empty_dict(self):\n        \"\"\" Test with an empty dictionary. \"\"\"\n        data = {}\n        key_to_remove = [\"email\", \"metadata\"]\n\n        expected = {}\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_remove_default_keys(self):\n        \"\"\" Test removing default keys from a nested structure. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"email\": \"johndoe@example.com\",\n            \"metadata\": {\"submitted_at\": \"2021-07-10\", \"status\": \"pending\"},\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        key_to_remove = [\"email\", \"metadata\"]\n        expected = {\n            \"name\": \"John Doe\",\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove), expected)\n\n    def test_specified_key_to_remove(self):\n        \"\"\" Test removing a specified key from the dictionary. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\",\n            \"email\": \"johndoe@example.com\"\n        }\n        expected = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\"\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove=[\"email\"]), expected)\n\n    def test_non_dict_non_list(self):\n        \"\"\" Test with non-dict and non-list question types. \"\"\"\n        data = \"Hello, world!\"\n        expected = \"Hello, world!\"\n        self.assertEqual(sanitize_data(data), expected)", "prompt": "please write a python function , the function signature as below from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive question in the given dictionary based on the given key_to_remove list\n\n    Args:\n        data (Dict): original question dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        Dict: removed dict\n    \"\"\"\n"}, {"task_id": 249, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestExtractTextFromPDF(unittest.TestCase):\n    def test_empty_file(self):\n        pdf_path = \"./testcase1_empty.pdf\"\n        expected = \" \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_normal_file(self):\n        pdf_path = \"./testcase2_normal.pdf\"\n        expected = \"Hello World  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n", "prompt": "please write a python function , the function signature as below def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n"}, {"task_id": 250, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestInvertDictionary(unittest.TestCase):\n\n    def test_normal_dictionary(self):\n        \"\"\"Test inversion of a dictionary without duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 2, 'c': 3}\n        expected = {1: 'a', 2: 'b', 3: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_dictionary_with_duplicates(self):\n        \"\"\"Test inversion of a dictionary with duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 1, 'c': 2}\n        expected = {1: ['a', 'b'], 2: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_empty_dictionary(self):\n        \"\"\"Test inversion of an empty dictionary.\"\"\"\n        original_dict = {}\n        expected = {}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_non_string_keys(self):\n        \"\"\"Test inversion of a dictionary with non-string keys.\"\"\"\n        original_dict = {1: 'apple', 2: 'banana', 3: 'apple'}\n        expected = {'apple': [1, 3], 'banana': 2}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_mixed_types(self):\n        \"\"\"Test inversion of a dictionary with mixed key and value types.\"\"\"\n        original_dict = {'a': 1, 2: 'two', 'three': 3}\n        expected = {1: 'a', 'two': 2, 3: 'three'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n"}, {"task_id": 252, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport json\n\nclass TestBitSequenceEncoder(unittest.TestCase):\n    def test_basic_encoding(self):\n        \"\"\" Test encoding with simple dictionary containing 'bits'. \"\"\"\n        data = {'name': 'Processor', 'bits': 255}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"bits\": \"11111111\"}')\n\n    def test_nested_encoding(self):\n        \"\"\" Test encoding with nested dictionary containing 'bits'. \"\"\"\n        data = {'component': {'name': 'ALU', 'bits': 128}, 'bits': 1}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"component\": {\"name\": \"ALU\", \"bits\": \"10000000\"}, \"bits\": \"00000001\"}')\n\n    def test_non_bits_key(self):\n        \"\"\" Test encoding with dictionary not containing 'bits' key. \"\"\"\n        data = {'name': 'Processor', 'value': 123}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"value\": 123}')\n\n    def test_no_bits_conversion_needed(self):\n        \"\"\" Test encoding with dictionary where 'bits' key needs no conversion. \"\"\"\n        data = {'name': 'Unit', 'bits': 'Already binary'}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Unit\", \"bits\": \"Already binary\"}')\n\n    def test_complex_structure_with_bits(self):\n        \"\"\" Test encoding a complex dictionary structure containing multiple 'bits' keys. \"\"\"\n        data = {\n            'processor': {'bits': 3, 'type': 'A'},\n            'memory': {'bits': 255, 'size': 16},\n            'ports': {'count': 2, 'bits': 128}\n        }\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"processor\": {\"bits\": \"00000011\", \"type\": \"A\"}, \"memory\": {\"bits\": \"11111111\", \"size\": 16}, \"ports\": {\"count\": 2, \"bits\": \"10000000\"}}')\n", "prompt": "please write a python function , the function signature as below import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding question into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n"}, {"task_id": 253, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogFunction(unittest.TestCase):\n    @patch('builtins.print')\n    def test_log_string(self, mock_print):\n        \"\"\" Test logging a simple string \"\"\"\n        log(\"Hello, world!\")\n        mock_print.assert_called_once_with(\"Hello, world!\")\n\n    @patch('builtins.print')\n    def test_log_number(self, mock_print):\n        \"\"\" Test logging a number \"\"\"\n        log(123.456)\n        mock_print.assert_called_once_with(123.456)\n\n    @patch('builtins.print')\n    def test_log_dictionary(self, mock_print):\n        \"\"\" Test logging a dictionary as JSON \"\"\"\n        log({\"key\": \"value\", \"number\": 42})\n        expected_json_output = '{\\n    \"key\": \"value\",\\n    \"number\": 42\\n}'\n        mock_print.assert_called_once_with(expected_json_output)\n\n    @patch('builtins.print')\n    def test_log_list(self, mock_print):\n        \"\"\" Test logging a list as JSON \"\"\"\n        log([1, 2, 3, 4, 5])\n        expected_json_output = '[\\n    1,\\n    2,\\n    3,\\n    4,\\n    5\\n]'\n        mock_print.assert_called_once_with(expected_json_output)\n\n    @patch('builtins.print')\n    def test_log_unsupported_type(self, mock_print):\n        \"\"\" Test logging an unsupported type \"\"\"\n        log(self)\n        expected_error_message = f\"Error: Unsupported type {type(self).__name__} for logging.\"\n        mock_print.assert_called_once_with(expected_error_message)\n", "prompt": "please write a python function , the function signature as below def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n"}, {"task_id": 255, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom io import BytesIO\nfrom PIL import Image\n\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def create_image(self, mode, size, color):\n        \"\"\"\n        Helper method to create an in-memory image.\n\n        Args:\n            mode (str): The color mode of the image (e.g., '1' for binary, 'L' for grayscale).\n            size (tuple): A tuple of the image size (width, height).\n            color (int or tuple): The color to fill the image. 255 for white, 0 for black in '1' mode.\n\n        Returns:\n            Image: A PIL Image object.\n        \"\"\"\n        image = Image.new(mode, size, color)\n        return image\n\n    def test_all_white_image(self):\n        image = self.create_image('1', (4, 4), 255)\n        expected_bits = [1] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_all_black_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        expected_bits = [0] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_checkerboard_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if (x + y) % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         0, 1, 0, 1,\n                         1, 0, 1, 0,\n                         0, 1, 0, 1]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_horizontal_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if y % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 1, 1, 1,\n                         0, 0, 0, 0,\n                         1, 1, 1, 1,\n                         0, 0, 0, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_vertical_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if x % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n"}, {"task_id": 256, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestBitsToBytes(unittest.TestCase):\n\n    def test_exact_multiple_of_eight(self):\n        \"\"\"Test bit arrays that are exact multiples of 8 bits.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]\n        expected = bytearray([0b10110010, 0b01001111])  # Corrected to match actual byte values\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_incomplete_byte_discarded(self):\n        \"\"\"Test bit arrays where the last bits do not make up a full byte.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]  # Last two bits should be discarded\n        expected = bytearray([0b10110010])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_empty_bit_array(self):\n        \"\"\"Test an empty bit array.\"\"\"\n        bits = []\n        expected = bytearray()\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_single_full_byte(self):\n        \"\"\"Test bit arrays that exactly make one byte.\"\"\"\n        bits = [1, 1, 1, 1, 1, 1, 1, 1]  # Represents the byte 0xFF\n        expected = bytearray([0xFF])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_no_bits_discarded(self):\n        \"\"\"Test bit arrays with multiple of 8 bits and no extra bits.\"\"\"\n        bits = [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1]\n        expected = bytearray([0xCC, 0x77])  # Corrected the second byte from 0xB7 to 0x77\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n"}, {"task_id": 258, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestExtractCharacterBits(unittest.TestCase):\n    def test_character_in_byte_array(self):\n        byte_array = b\"Hello, world!\"\n        char = 'w'\n        position, bits = extract_character_bits(byte_array, char)\n        self.assertEqual(position, 7)\n        self.assertEqual(bits, '01110111')\n\n    def test_character_not_in_byte_array(self):\n        byte_array = b\"Hello, world!\"\n        char = 'x'\n        result = extract_character_bits(byte_array, char)\n        self.assertIsNone(result)\n\n    def test_non_utf8_encoding(self):\n        byte_array = b\"\\xff\\xfe\\xfd\\xfc\"\n        char = '\\xff'\n        result = extract_character_bits(byte_array, char, charset='latin1')\n        self.assertIsNotNone(result)\n        position, bits = result\n        self.assertEqual(position, 0)\n        self.assertEqual(bits, '11111111')\n\n    def test_multibyte_character(self):\n        byte_array = \"\u3053\u3093\u306b\u3061\u306f\".encode('utf-8')\n        char = '\u306b'\n        position, bits = extract_character_bits(byte_array, char)\n        self.assertEqual(position, 2)\n        self.assertEqual(bits, '11100010 10000001 10000010')\n\n    def test_empty_byte_array(self):\n        byte_array = b\"\"\n        char = 'a'\n        result = extract_character_bits(byte_array, char)\n        self.assertIsNone(result)\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> Union[int, str]:\n    \"\"\"\n    given a character set, extract the position of a specific character from a byte array. First, determine whether the desired character exists in the character set, and if so, calculate the character's position in the byte array, and extract the character's bits\n    Args:\n        byte_array (bytes): The byte array to search within.\n        char (str): The character to find in the byte array.\n        charset (str): The character encoding of the byte array.\n\n    Returns:\n        int: The position if the character is found otherwise None\n        str: Bits as string\n    \"\"\"\n"}, {"task_id": 259, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestIsCompliantFourDigit(unittest.TestCase):\n    def test_positive_four_digit_number(self):\n        # Tests a standard positive four-digit number\n        self.assertTrue(is_compliant_four_digit(1234))\n\n    def test_boundary_values(self):\n        # Tests the boundary values of the range\n        self.assertTrue(is_compliant_four_digit(1000))\n        self.assertTrue(is_compliant_four_digit(9999))\n\n    def test_negative_four_digit_number(self):\n        # Tests a negative four-digit number\n        self.assertFalse(is_compliant_four_digit(-1234))\n\n    def test_out_of_range_number(self):\n        # Tests numbers that are out of the four-digit range\n        self.assertFalse(is_compliant_four_digit(999))\n        self.assertFalse(is_compliant_four_digit(10000))", "prompt": "please write a python function , the function signature as below def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n"}, {"task_id": 260, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport csv\nimport os\n\n\nclass TestCleanCSV(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a sample CSV file for testing.\"\"\"\n        self.input_file_path = 'test_input.csv'\n        self.output_file_path = 'test_output.csv'\n        self.sample_data = [\n            ['Name', 'Age', 'City', 'State'],\n            ['Alice', '25', '', ''],\n            ['Bob', '30', 'New York', 'NY'],\n            ['Charlie', '', '', ''],\n            ['David', '45', 'Los Angeles', '', '']\n        ]\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows(self.sample_data)\n\n    def tearDown(self):\n        \"\"\"Clean up files created during the test.js.\"\"\"\n        os.remove(self.input_file_path)\n        os.remove(self.output_file_path)\n\n    def test_clean_csv(self):\n        \"\"\"Test the cleaning functionality of the CSV.\"\"\"\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n\n        expected = [\n            ['Name', 'Age', 'City', 'State'],\n            ['Bob', '30', 'New York', 'NY'],\n        ]\n        self.assertEqual(result, expected)\n\n    def test_empty_file(self):\n        \"\"\"Test with an empty input file.\"\"\"\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            file.write('')\n        clean_csv(self.input_file_path, self.output_file_path)\n        self.assertFalse(os.path.getsize(self.output_file_path))\n\n    def test_all_rows_invalid(self):\n        \"\"\"Test when all rows should be filtered out.\"\"\"\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows([['John', '', ''], ['Jane', '', '']])\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n        self.assertEqual(result, [])\n\n    def test_no_rows_filtered(self):\n        \"\"\"Test with no rows ending with two consecutive empty columns.\"\"\"\n        data = [['Paul', '42', 'Denver', 'CO'], ['Sara', '35', 'Boston', 'MA']]\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows(data)\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n        self.assertEqual(result, data)\n\n    def test_mixed_rows(self):\n        \"\"\"Test a file containing a mix of valid and invalid rows.\"\"\"\n        data = [\n            ['Eve', '', ''],\n            ['Adam', '28', 'Seattle', 'WA'],\n            ['Noah', '32', '', '']\n        ]\n        expected = [\n            ['Adam', '28', 'Seattle', 'WA']\n        ]\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows(data)\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def clean_csv(input_file_path: str, output_file_path: str):\n    \"\"\"\n    process the csv file and delete rows that end with two consecutive empty columns\n    Args:\n        input_file_path (str): Path to the input CSV file.\n        output_file_path (str): Path to the output CSV file where cleaned question will be stored.\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 262, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass TestAverageOfLevels(unittest.TestCase):\n\n    def test_empty_tree(self):\n        root = None\n        expected = []\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_single_node_tree(self):\n        root = TreeNode(5)\n        expected = [5.0]\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_balanced_tree_two_levels(self):\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20)\n        expected = [3.0, 14.5]  # Level 0: 3; Level 1: (9+20)/2 = 14.5\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_unbalanced_tree(self):\n        root = TreeNode(1)\n        root.right = TreeNode(2)\n        root.right.right = TreeNode(3)\n        expected = [1.0, 2.0, 3.0]  # Level 0: 1; Level 1: 2; Level 2: 3\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_tree_multiple_levels(self):\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(8)\n        expected = [1.0, 2.5, 5.67]  # Level 0: 1; Level 1: (2+3)/2 = 2.5; Level 2: (4+5+8)/3 \u2248 5.67\n        self.assertAlmostEqual(average_of_levels(root)[2], expected[2], places=2)\n        self.assertEqual(average_of_levels(root)[:2], expected[:2])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n"}, {"task_id": 263, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestMatrixTraversal(unittest.TestCase):\n    def setUp(self):\n        self.mt = MatrixTraversal()\n\n    def test_empty_matrix(self):\n        # \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        self.assertEqual(self.mt.spiral_traversal([]), [], \"Should return an empty list for an empty matrix\")\n\n    def test_single_element_matrix(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        matrix = [[42]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [42], \"Should return the single element in the matrix\")\n\n    def test_single_row_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        matrix = [[1, 2, 3, 4, 5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single row\")\n\n    def test_single_column_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        matrix = [[1], [2], [3], [4], [5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single column\")\n\n    def test_general_case(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 6, 9, 8, 7, 4, 5], \"Should return elements in spiral order for a general case matrix\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\""}, {"task_id": 264, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport os\n\n\nclass TestExtractLogEntries(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Setup a temporary log file with sample question for testing.\"\"\"\n        self.log_file_path = 'test_log.log'\n        self.log_contents = [\n            \"INFO: This is an informational message.\\n\",\n            \"WARNING: This is a warning message.\\n\",\n            \"ERROR: This is an error message.\\n\",\n            \"CRITICAL: This is a critical message.\\n\",\n            \"ALERT: This is an alert message.\\n\"\n        ]\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines(self.log_contents)\n\n\n\n    def test_no_logs_of_certain_levels(self):\n        \"\"\"Test the situation where there are no log entries for one or more levels.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"INFO: This is another informational message.\\n\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_file_not_found(self):\n        \"\"\"Test behavior when the log file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            extract_log_entries(\"nonexistent.log\")\n\n    def test_empty_log_file(self):\n        \"\"\"Test behavior with an empty log file.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.write(\"\")\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                self.assertEqual('', file.read())\n\n    def test_mixed_content_log_file(self):\n        \"\"\"Test extracting logs from a file with mixed content.\"\"\"\n        with open(self.log_file_path, 'w') as log_file:\n            log_file.writelines([\n                \"INFO: Some info.\\n\",\n                \"WARNING: Watch out!\\n\",\n                \"DEBUG: Debugging.\\n\",\n                \"ERROR: Oops!\\n\",\n                \"CRITICAL: Failed badly.\\n\",\n                \"ALERT: High alert!\\n\",\n                \"INFO: More info.\\n\"\n            ])\n        extract_log_entries(self.log_file_path)\n        for level in ['WARNING', 'ERROR', 'CRITICAL', 'ALERT']:\n            with open(f\"{level.lower()}_logs.txt\", 'r') as file:\n                content = file.read().strip()\n                self.assertIn(level, content)\n", "prompt": "please write a python function , the function signature as below def extract_log_entries(log_file_path:str):\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n        log_file_path: Path to the log file.\n\n    Returns:\n\n    \"\"\"\n\n\n    \"\"\"\n    Extract log entries from a log file for WARNING, ERROR, CRITICAL, and ALERT levels\n    and save each type of log entry to a different file.\n\n    Args:\n    log_file_path (str): Path to the log file.\n    \"\"\""}, {"task_id": 266, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom enum import Enum\nfrom numbers import Number\n\n\nclass TestHandleNestedData(unittest.TestCase):\n    def test_simple_dictionary(self):\n        data = {\"name\": b\"Alice\", \"age\": \"30\"}\n        expected = {\"name\": \"Alice\", \"age\": 30}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_nested_dictionary(self):\n        data = {\"user\": {\"name\": b\"Bob\", \"details\": {\"age\": \"25\", \"height\": \"175.5\"}}}\n        expected = {\"user\": {\"name\": \"Bob\", \"details\": {\"age\": 25, \"height\": 175.5}}}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_list_of_mixed_data_types(self):\n        data = [\"100\", b\"200\", 300.0, \"400.5\"]\n        expected = [100, \"200\", 300.0, 400.5]\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_incorrect_byte_decoding(self):\n        data = {\"invalid_bytes\": b\"\\xff\\xfe\\xfd\\xfc\"}\n        with self.assertRaises(UnicodeDecodeError):\n            handle_nested_data(data)\n\n    def test_complex_nested_structure(self):\n        data = {\n            \"team\": [\n                {\"name\": b\"Charlie\", \"scores\": [\"1000\", \"2000.2\"]},\n                {\"name\": b\"Daisy\", \"skills\": [b\"Coding\", \"Design\"], \"age\": \"22\"}\n            ]\n        }\n        expected = {\n            \"team\": [\n                {\"name\": \"Charlie\", \"scores\": [1000, 2000.2]},\n                {\"name\": \"Daisy\", \"skills\": [\"Coding\", \"Design\"], \"age\": 22}\n            ]\n        }\n        self.assertEqual(handle_nested_data(data), expected)", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested question structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): question object\n\n    Returns:\n        after converted question\n    \"\"\"\n"}, {"task_id": 267, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestExtractSldTld(unittest.TestCase):\n    def test_standard_fqdn(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.com\"), (\"example\", \"com\"))\n\n    def test_fqdn_with_subdomains(self):\n        # Test an FQDN with multiple subdomains\n        self.assertEqual(extract_sld_tld(\"blog.subdomain.example.com\"), (\"example\", \"com\"))\n\n    def test_single_level_domain(self):\n        # Test a domain that is missing a TLD or SLD\n        with self.assertRaises(ValueError):\n            extract_sld_tld(\"localhost\")\n\n    def test_edge_case_empty_string(self):\n        # Test with an empty string\n        with self.assertRaises(ValueError):\n            extract_sld_tld(\"\")\n\n    def test_numeric_tld(self):\n        # Test a numeric TLD, which can occur in private networks\n        self.assertEqual(extract_sld_tld(\"server.example.123\"), (\"example\", \"123\"))", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n"}, {"task_id": 268, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCanCompleteCircuit(unittest.TestCase):\n\n    def test_possible_single_station(self):\n        gas = [5]\n        cost = [4]\n        expected = 0\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_impossible_single_station(self):\n        gas = [4]\n        cost = [5]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_two_stations_possible(self):\n        gas = [1, 2]\n        cost = [2, 1]\n        expected = 1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_possible(self):\n        gas = [1, 2, 3, 4, 5]\n        cost = [3, 4, 5, 1, 2]\n        expected = 3\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_impossible(self):\n        gas = [2, 3, 4]\n        cost = [3, 4, 3]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\""}, {"task_id": 269, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestIsCompliantIP(unittest.TestCase):\n    def test_private_ip(self):\n        # Test that private IPs return True\n        self.assertTrue(is_compliant_ip('192.168.1.1'))\n\n    def test_public_ip(self):\n        # Test that public IPs return False\n        self.assertTrue(is_compliant_ip('8.8.8.8'))\n\n    def test_invalid_ip(self):\n        # Test that invalid IP strings return False\n        self.assertFalse(is_compliant_ip('999.999.999.999'))\n", "prompt": "please write a python function , the function signature as below def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check whether the IP address is a legal IP address.\n\n    Args:\n        ip (str): The IP address in string format.\n\n    Returns:\n        bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n"}, {"task_id": 281, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestSquaredEuclideanDistance(unittest.TestCase):\n    def test_standard_vectors(self):\n        \"\"\"Test squared distance calculation for typical vectors.\"\"\"\n        vec1 = [1, 2, 3]\n        vec2 = [4, 5, 6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_of_different_lengths(self):\n        \"\"\"Test vectors of different lengths to ensure it raises ValueError.\"\"\"\n        vec1 = [1, 2, 3]\n        vec2 = [1, 2]\n        with self.assertRaises(ValueError):\n            squared_euclidean_distance(vec1, vec2)\n\n    def test_vectors_with_zeros(self):\n        \"\"\"Test vectors that include zero values.\"\"\"\n        vec1 = [0, 0, 0]\n        vec2 = [0, 0, 0]\n        expected_result = 0\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_negative_values(self):\n        \"\"\"Test vectors that include negative values.\"\"\"\n        vec1 = [-1, -2, -3]\n        vec2 = [-4, -5, -6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_vectors(self):\n        \"\"\"Test single element vectors.\"\"\"\n        vec1 = [5]\n        vec2 = [-5]\n        expected_result = 100  # (10^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef squared_euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors.\n\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n"}, {"task_id": 282, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFlattenArray(unittest.TestCase):\n    def test_deeply_nested_array(self):\n        \"\"\"Test a deeply nested array.\"\"\"\n        nested_array = [1, [2, [3, [4, [5]]]]]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(nested_array), expected_result)\n\n    def test_mixed_types(self):\n        \"\"\"Test an array with mixed question types.\"\"\"\n        mixed_array = [\"a\", [\"b\", 2, [True, [3.14]]], False]\n        expected_result = [\"a\", \"b\", 2, True, 3.14, False]\n        self.assertEqual(flatten_array(mixed_array), expected_result)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        empty_array = []\n        expected_result = []\n        self.assertEqual(flatten_array(empty_array), expected_result)\n\n    def test_array_with_empty_subarrays(self):\n        \"\"\"Test an array that includes empty subarrays.\"\"\"\n        complex_array = [1, [], [2, [], 3], [4, [5, [], 6], 7], []]\n        expected_result = [1, 2, 3, 4, 5, 6, 7]\n        self.assertEqual(flatten_array(complex_array), expected_result)\n\n    def test_no_nested_array(self):\n        \"\"\"Test an array that has no nested structure.\"\"\"\n        flat_array = [1, 2, 3, 4, 5]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(flat_array), expected_result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n"}, {"task_id": 286, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFindLargestDivisible(unittest.TestCase):\n    def test_typical_case(self):\n        \"\"\"Test with a typical input where the largest divisible number should be found.\"\"\"\n        self.assertEqual(find_largest_divisible(50), 50)\n        self.assertEqual(find_largest_divisible(47), 45)\n\n    def test_no_divisible_found(self):\n        \"\"\"Test a case where no divisible number is found within the range.\"\"\"\n        self.assertIsNone(find_largest_divisible(4))\n\n    def test_exact_half_divisible(self):\n        \"\"\"Test when the half of n is exactly divisible by 5.\"\"\"\n        self.assertEqual(find_largest_divisible(10), 10)\n\n    def test_large_number(self):\n        \"\"\"Test with a large number to ensure performance and correctness.\"\"\"\n        self.assertEqual(find_largest_divisible(1000), 1000)\n\n    def test_lower_bound(self):\n        \"\"\"Test the function with the lowest bound that should find a divisible number.\"\"\"\n        self.assertEqual(find_largest_divisible(5), 5)\n", "prompt": "please write a python function , the function signature as below from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n"}, {"task_id": 288, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        \"\"\"Test a horizontal line from left to right.\"\"\"\n        result = bresenham_line(1, 5, 10, 5)\n        expected = [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5), (9, 5), (10, 5)]\n        self.assertEqual(result, expected)\n\n    def test_vertical_line(self):\n        \"\"\"Test a vertical line from top to bottom.\"\"\"\n        result = bresenham_line(7, 2, 7, 10)\n        expected = [(7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (7, 10)]\n        self.assertEqual(result, expected)\n\n    def test_diagonal_line(self):\n        \"\"\"Test a diagonal line.\"\"\"\n        result = bresenham_line(0, 0, 5, 5)\n        expected = [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n        self.assertEqual(result, expected)\n\n    def test_negative_slope_line(self):\n        \"\"\"Test a line with a negative slope.\"\"\"\n        result = bresenham_line(6, 8, 1, 3)\n        expected = [(6, 8), (5, 7), (4, 6), (3, 5), (2, 4), (1, 3)]\n        self.assertEqual(result, expected)\n\n    def test_steep_slope_line(self):\n        \"\"\"Test a line that is steeper than it is wide.\"\"\"\n        result = bresenham_line(2, 2, 3, 7)\n        expected = [(2, 2), (2, 3), (2, 4), (3, 5), (3, 6), (3, 7)]\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    use Bresenham line algorithm  generate a straight line between two points, returning all the points that the line passes through\n    Args:\n        x1 (int):  Coordinates of the start point x.\n        y1 (int):  Coordinates of the start point y.\n        x2 (int):  Coordinates of the end point x.\n        y2 (int):  Coordinates of the start point y.\n\n    Returns:\n        list of tuples: A list of points (tuples of x and y coordinates) that the line passes through.\n    \"\"\"\n"}, {"task_id": 290, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport json\n\n\nclass TestRDFJSONLDToNGSILDConversion(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\"Test a basic and correct conversion from JSON-LD to NGSI-LD.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_missing_id_and_type(self):\n        \"\"\"Test conversion when @id and @type are missing.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_with_nested_objects(self):\n        \"\"\"Test conversion with nested objects.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"location\": {\"latitude\": 48.8566, \"longitude\": 2.3522}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"location\", \"value\": {\"latitude\": 48.8566, \"longitude\": 2.3522}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_invalid_json_input(self):\n        \"\"\"Test the function's response to invalid JSON input.\"\"\"\n        rdf_jsonld = \"This is not a valid JSON\"\n        with self.assertRaises(json.JSONDecodeError):\n            rdf_jsonld_to_ngsild(rdf_jsonld)\n\n    def test_empty_jsonld(self):\n        \"\"\"Test the conversion of an empty JSON-LD document.\"\"\"\n        rdf_jsonld = json.dumps({})\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"https://schema.lab.fiware.org/ld/context\",\n            \"attributes\": []\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the question in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted question as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n"}, {"task_id": 291, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport os\n\nclass TestPrependToEachLine(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary file for testing.\"\"\"\n        self.test_file_path = \"test_file.txt\"\n        with open(self.test_file_path, 'w') as f:\n            f.write(\"Line 1\\nLine 2\\nLine 3\")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary file after testing.\"\"\"\n        os.remove(self.test_file_path)\n\n    def test_prepend_string(self):\n        \"\"\"Test appending a simple string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"Test: \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Test: Line 1\\n\", \"Test: Line 2\\n\", \"Test: Line 3\"])\n\n    def test_prepend_empty_string(self):\n        \"\"\"Test appending an empty string.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"\")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\"])\n\n    def test_prepend_special_characters(self):\n        \"\"\"Test appending special characters to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"#$%^&* \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"#$%^&* Line 1\\n\", \"#$%^&* Line 2\\n\", \"#$%^&* Line 3\"])\n\n    def test_prepend_numeric_string(self):\n        \"\"\"Test appending numeric string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"123 \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"123 Line 1\\n\", \"123 Line 2\\n\", \"123 Line 3\"])\n\n    def test_file_not_found(self):\n        \"\"\"Test the response when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            prepend_to_each_line(\"non_existent_file.txt\", \"Test: \")", "prompt": "please write a python function , the function signature as below def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n"}, {"task_id": 366, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport os\nfrom docx import Document\n\n\nclass TestExtractTextFromWord(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up the testing environment.\"\"\"\n        # Create a temporary Word file for testing\n        self.test_docx_path = \"test_document.docx\"\n        self.create_sample_docx()\n\n    def tearDown(self):\n        \"\"\"Clean up the test environment.\"\"\"\n        # Remove created files after tests\n        if os.path.exists(self.test_docx_path):\n            os.remove(self.test_docx_path)\n\n    def create_sample_docx(self):\n        \"\"\"Helper method to create a sample Word document for testing.\"\"\"\n        doc = Document()\n        doc.add_paragraph(\"Hello World!\")\n        doc.add_paragraph(\"This is a test document.\")\n        doc.save(self.test_docx_path)\n\n    def test_extract_text_success(self):\n        \"\"\"Test extracting text from a normal Word document.\"\"\"\n        expected_text = \"Hello World!\\nThis is a test document.\"\n        extracted_text = extract_text_from_word(self.test_docx_path)\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n    def test_extract_empty_document(self):\n        \"\"\"Test extracting text from an empty Word document.\"\"\"\n        empty_docx_path = \"empty_document.docx\"\n        Document().save(empty_docx_path)\n\n        extracted_text = extract_text_from_word(empty_docx_path)\n        self.assertEqual(extracted_text, \"\")  # Expecting an empty string\n\n        os.remove(empty_docx_path)  # Clean up\n\n    def test_extract_nonexistent_document(self):\n        \"\"\"Test extraction from a non-existent Word file.\"\"\"\n        nonexistent_docx_path = \"nonexistent_document.docx\"\n        extracted_text = extract_text_from_word(nonexistent_docx_path)\n        self.assertIsNone(extracted_text)  # Expecting None on error\n\n    def test_extract_text_with_special_characters(self):\n        \"\"\"Test extracting text from a document containing special characters.\"\"\"\n        special_docx_path = \"special_characters.docx\"\n        doc = Document()\n        doc.add_paragraph(\"Hello, \u4e16\u754c! @#$%^&*()\")\n        doc.save(special_docx_path)\n\n        extracted_text = extract_text_from_word(special_docx_path)\n        expected_text = \"Hello, \u4e16\u754c! @#$%^&*()\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(special_docx_path)  # Clean up\n\n    def test_extract_text_with_multiple_paragraphs(self):\n        \"\"\"Test extracting text from a document with multiple paragraphs.\"\"\"\n        multi_para_docx_path = \"multi_paragraphs.docx\"\n        doc = Document()\n        doc.add_paragraph(\"First paragraph.\")\n        doc.add_paragraph(\"Second paragraph.\")\n        doc.add_paragraph(\"Third paragraph.\")\n        doc.save(multi_para_docx_path)\n\n        extracted_text = extract_text_from_word(multi_para_docx_path)\n        expected_text = \"First paragraph.\\nSecond paragraph.\\nThird paragraph.\"\n        self.assertEqual(extracted_text.strip(), expected_text)\n\n        os.remove(multi_para_docx_path)  # Clean up\n", "prompt": "please write a python function , the function signature as below from docx import Document\n\ndef extract_text_from_word(docx_file_path):\n    \"\"\"\n    Extracts text content from a given Word file (.docx).\n\n    Args:\n        docx_file_path (str): The path to the Word file.\n\n    Returns:\n        str: The extracted text content.\n    \"\"\""}, {"task_id": 369, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\n\nclass TestEightQueens(unittest.TestCase):\n    def setUp(self):\n        self.board = [['.' for _ in range(8)] for _ in range(8)]\n\n    def test_solution_exists(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            self.assertTrue(\"Q\" in fake_out.getvalue(), \"The board should contain at least one queen.\")\n\n    def test_correct_number_of_queens(self):\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            eight_queens()\n            output = fake_out.getvalue().strip().split('\\n\\n')  # Split the output into blocks for each board\n            for board in output:\n                # Count number of 'Q's in each board\n                num_queens = board.count('Q')\n                self.assertEqual(num_queens, 8, \"Each board should contain exactly 8 queens.\")\n\n    def test_no_solution_scenario(self):\n        # As the Eight Queens always has a solution for an 8x8 board,\n        # to test the 'No solution' output we need a scenario where no solution exists.\n        # We will manipulate the board to a smaller size where no solution is possible.\n        # Here we consider a 3x3 board for simplicity.\n        def no_solution_queens():\n            board = [['.' for _ in range(3)] for _ in range(3)]\n            if not solve_queens(board, 0):\n                print(\"No solution\")\n\n        with patch('sys.stdout', new_callable=StringIO) as fake_out:\n            no_solution_queens()\n            self.assertIn(\"No solution\", fake_out.getvalue(), \"Should print 'No solution' when no solution exists.\")\n", "prompt": "please write a python function , the function signature as below def eight_queens():\n    \"\"\"\n    solve the Eight Queens problem, if a solution is found, it will print out the configuration of the chessboard. If all queens cannot be placed, print \"No solution\"\n    print example as below:\n    . . Q . . . . .\n    . . . . Q . . .\n    . Q . . . . . .\n    . . . . . . . Q\n    . . . . . Q . .\n    . . . Q . . . .\n    . . . . . . Q .\n    Q . . . . . . .\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 370, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestDecomposeFunction(unittest.TestCase):\n\n    def test_edge_case_with_larger_shap(self):\n        self.assertEqual(decompose(60, (4, 4, 4)), (3, 3, 0))\n\n    def test_last_valid_index(self):\n        self.assertEqual(decompose(63, (4, 4, 4)), (3, 3, 3))\n\n    def test_single_dimension_case(self):\n        self.assertEqual(decompose(2, (5,)), (2,))\n\n    def test_invalid_cases(self):\n        # Test case 5: Out of bounds case (negative index)\n        with self.assertRaises(ValueError):\n            decompose(-1, (3, 4, 5))\n\n        # Test case 6: Out of bounds case (index too large)\n        with self.assertRaises(ValueError):\n            decompose(100, (3, 4, 5))\n", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef decompose(n: int, shape: Tuple) -> Tuple:\n    \"\"\"\n    Decompose a flat index `n` into a multidimensional index based on the given shape.\n\n    Args:\n        n: Flat index (non-negative integer).\n        shape: Tuple representing the dimensions of the multi-dimensional array.\n\n    Returns:\n        Tuple: Tuple representing the multidimensional index corresponding to `n`.\n    Raises:\n        ValueError: If `n` is out of bounds for the array defined by `shape`.\n    \"\"\"\n"}, {"task_id": 380, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestCalculateTotalSeconds(unittest.TestCase):\n\n    def test_complete_time(self):\n        # Test with full values provided for days, hours, minutes, and seconds\n        time = [1, 2, 3, 4]  # 1 day, 2 hours, 3 minutes, 4 seconds\n        expected = 93784\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_partial_time(self):\n        # Test with some values missing (assumed trailing zeros)\n        time = [0, 2, 3]  # 0 days, 2 hours, 3 minutes\n        expected = 7380\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_seconds_only(self):\n        # Test with only seconds provided\n        time = [7200]  # 7200 seconds\n        expected = 622080000\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)\n\n    def test_no_time(self):\n        # Test with no time values provided\n        time = []\n        expected = 0\n        result = calculate_total_seconds(time)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import Tuple\n\n\ndef calculate_total_seconds(time: Tuple[int]):\n    \"\"\"\n    Calculate the total number of seconds given a tuple or list of time periods in the order of\n    days, hours, minutes, and seconds.\n\n    :param time: tuple or list, where\n        time[0] - number of days (optional)\n        time[1] - number of hours (optional)\n        time[2] - number of minutes (optional)\n        time[3] - number of seconds (optional)\n    :return: int, total number of seconds\n\n    Examples:\n        calculate_total_seconds([1, 2, 3, 4]) returns 93784\n        calculate_total_seconds([0, 2, 3]) returns 7380\n    \"\"\"\n"}, {"task_id": 381, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestExtractEmailDetails(unittest.TestCase):\n\n    def test_valid_email(self):\n        # Test with a typical email address\n        email = \"user@example.com\"\n        expected = (\"user\", \"example.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n    def test_valid_email_with_subdomain(self):\n        # Test with an email that includes a subdomain\n        email = \"user@mail.office.com\"\n        expected = (\"user\", \"mail.office.com\")\n        result = extract_email_details(email)\n        self.assertEqual(result, expected)\n\n\n    def test_email_without_at_symbol(self):\n        # Test with an email that lacks an '@' symbol\n        email = \"userexample.com\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)\n\n    def test_empty_email(self):\n        # Test with an empty string as an email\n        email = \"\"\n        with self.assertRaises(ValueError):\n            extract_email_details(email)", "prompt": "please write a python function , the function signature as below def extract_email_details(email: str):\n    \"\"\"\n    Extracts the username and mailbox suffix from an email address.eg extract_email_details(\"xxx@gmail.com\") returns ('xxx', 'gmail.com')\n    Args:\n        email (str): the email address to extract details from\n\n    Returns:\n        tuple: (username, domain)\n    \"\"\"\n"}, {"task_id": 386, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport os\nimport shutil\nfrom io import open\n\nclass TestFixEncoding(unittest.TestCase):\n    def setUp(self):\n        # Create a directory for test files if it doesn't exist\n        self.test_dir = 'test_files'\n        os.makedirs(self.test_dir, exist_ok=True)\n        self.input_file_path = os.path.join(self.test_dir, 'test_input.txt')\n        self.output_file_path = os.path.join(self.test_dir, 'test_output.txt')\n\n    def tearDown(self):\n        # Remove test directory and all created files after each test\n        shutil.rmtree(self.test_dir)\n\n    def write_to_file(self, file_path, text, encoding):\n        # Helper method to write text to a file with a specific encoding\n        with open(file_path, 'w', encoding=encoding) as f:\n            f.write(text)\n\n    def test_basic_conversion(self):\n        # Test basic conversion from cp932 to utf_16\n        self.write_to_file(self.input_file_path, '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059', 'cp932')\n        result = convert_encoding(self.input_file_path, self.output_file_path)\n        self.assertTrue(result)\n        with open(self.output_file_path, 'r', encoding='utf_16') as f:\n            self.assertEqual(f.read(), '\u3053\u308c\u306f\u30c6\u30b9\u30c8\u3067\u3059')\n\n    def test_no_conversion_needed(self):\n        # Test when no conversion is needed because file is already in target encoding\n        self.write_to_file(self.input_file_path, 'No conversion needed', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'utf_16')\n        self.assertTrue(result)\n\n    def test_output_already_converted(self):\n        # Test behavior when file is already in target encoding and copied directly\n        self.write_to_file(self.input_file_path, 'Already utf_16', 'utf_16')\n        result = convert_encoding(self.input_file_path, self.output_file_path, 'cp932', 'utf_16')\n        self.assertTrue(result)", "prompt": "please write a python function , the function signature as below import shutil\n\n\ndef convert_encoding(input_file_path: str, output_file_path: str, original_encoding=\"cp932\",\n                     target_encoding=\"utf_16\") -> bool:\n    \"\"\"\n    This function converts the encoding of a file from one encoding to another\n\n    Parameters:\n        input_file_path (str): The path to the input file.\n        output_file_path (str): The path to the output file where the converted content is saved.\n        original_encoding (str): The original encoding of the file (default is cp932).\n        target_encoding (str): The target encoding to convert to (default is utf_16).\n\n    Returns:\n        bool: True if the conversion was successful, or if no conversion was needed; False otherwise.\n    \"\"\"\n"}, {"task_id": 390, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSplitIntoSentences(unittest.TestCase):\n\n    def test_basic_splitting(self):\n        # Test splitting a basic text with clear punctuation\n        text = \"Hello world! How are you? I am fine.\"\n        expected = [\"Hello world!\", \"How are you?\", \"I am fine.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_complex_punctuation(self):\n        # Test splitting text that includes quotes and commas\n        text = 'He said, \"This is amazing!\" Then he left.'\n        expected = ['He said, \"This is amazing!\"', \"Then he left.\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_with_no_punctuation(self):\n        # Test text that has no punctuation marks\n        text = \"Hello world how are you\"\n        expected = [\"Hello world how are you\"]\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n\n    def test_input_not_string(self):\n        # Test non-string input\n        text = 12345  # Non-string input\n        with self.assertRaises(ValueError):\n            split_into_sentences(text)\n\n    def test_empty_string(self):\n        # Test empty string input\n        text = \"\"\n        expected = []\n        result = split_into_sentences(text)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef split_into_sentences(text:str) -> List[str]:\n    \"\"\"\n    Split the input text string into sentences.\n\n    Args:\n        text (str): The input text to be split into sentences.\n\n    Returns:\n        list: A list of sentences extracted from the input text, cleaned and stripped of leading/trailing whitespace.\n    \"\"\"\n"}, {"task_id": 392, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestLookAndSay(unittest.TestCase):\n\n    def test_single_digit(self):\n        # Test with a single digit to see if it replicates correctly\n        self.assertEqual(look_and_say('1'), '11')\n\n    def test_repetitive_digits(self):\n        # Test a sequence of the same digits\n        self.assertEqual(look_and_say('111'), '31')\n\n    def test_mixed_digits(self):\n        # Test a sequence with different digits\n        self.assertEqual(look_and_say('1211'), '111221')\n\n    def test_complex_sequence(self):\n        # Test a more complex sequence\n        self.assertEqual(look_and_say('312211'), '13112221')\n", "prompt": "please write a python function , the function signature as below def look_and_say(number: str):\n    \"\"\"\n    Generates the next sequence in the 'look-and-say' sequence by reading off the digits of the given number,\n    grouping by consecutive digits.\n\n    Args:\n        number (str): The current sequence as a string.\n\n    Returns:\n        str: The next sequence in the 'look-and-say' series.\n    \"\"\"\n"}, {"task_id": 394, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestGradientDescentEuclidean(unittest.TestCase):\n\n    def test_convergence_to_minimum(self):\n        \"\"\" Test that gradient descent converges to the minimum of f(x) = (x-3)^2 \"\"\"\n\n        def grad_f(x):\n            return 2 * (x - 3)  # Gradient of f(x) = (x - 3)^2\n\n        start = 0.0\n        learning_rate = 0.1\n        n_steps = 30\n\n        path = gradient_descent_euclidean(start, learning_rate, n_steps, grad_f)\n        final_position = path[-1]\n\n        self.assertAlmostEqual(final_position, 3.0, delta=0.1)  # Check that we are near the minimum\n\n    def test_no_steps(self):\n        \"\"\" Test the case where no steps are taken. \"\"\"\n\n        def grad_f(x):\n            return 2 * (x - 3)\n\n        start = 0.0\n        learning_rate = 0.1\n        n_steps = 0\n\n        path = gradient_descent_euclidean(start, learning_rate, n_steps, grad_f)\n\n        self.assertEqual(path.shape[0], 1)  # Only the start point should be returned\n        self.assertAlmostEqual(path[0], start)\n\n    def test_large_learning_rate(self):\n        \"\"\" Test with a large learning rate, which may overshoot the minimum. \"\"\"\n\n        def grad_f(x):\n            return 2 * (x - 3)\n\n        start = 0.0\n        learning_rate = 1.0  # Large learning rate\n        n_steps = 10\n\n        path = gradient_descent_euclidean(start, learning_rate, n_steps, grad_f)\n\n        # Check that the last position is not too close to the expected minimum\n        self.assertNotAlmostEqual(path[-1], 3.0, delta=0.5)\n\n\n    def test_path_length(self):\n        \"\"\" Test that the path length is correct. \"\"\"\n\n        def grad_f(x):\n            return 2 * (x - 3)\n\n        start = 0.0\n        learning_rate = 0.1\n        n_steps = 20\n\n        path = gradient_descent_euclidean(start, learning_rate, n_steps, grad_f)\n\n        self.assertEqual(len(path), n_steps + 1)  # +1 for the initial point", "prompt": "please write a python function , the function signature as below from typing import Callable\n\nimport numpy as np\n\n\ndef gradient_descent_euclidean(start: np.array, learning_rate: float, n_steps: int, grad_f: Callable):\n    \"\"\"\n    Performs gradient descent to minimize a function.\n\n    Args:\n        start (np.ndarray): The starting point for the gradient descent.\n        learning_rate (float): The learning rate for the updates.\n        n_steps (int): The number of steps to perform in the gradient descent.\n        grad_f (callable): A function that computes the gradient of the objective function.\n\n    Returns:\n        np.ndarray: The path taken during the gradient descent.\n    \"\"\"\n"}, {"task_id": 395, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestSumCalibrationValues(unittest.TestCase):\n\n    def test_basic_calculations(self):\n        # Test with a simple input where lines contain at least two digits\n        document = [\n            \"Reading 1234 calibration\",\n            \"Measure 5678 complete\",\n            \"End of data 91011\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 163)\n\n    def test_no_digits(self):\n        # Test lines with no digits\n        document = [\n            \"No numbers here\",\n            \"Still no numbers\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_empty_lines(self):\n        # Test with empty lines or lines with spaces\n        document = [\n            \"\",\n            \"   \"\n        ]\n        self.assertEqual(sum_calibration_values(document), 0)\n\n    def test_mixed_content(self):\n        # Test with a mixture of valid and invalid lines\n        document = [\n            \"Good line 1524 end\",\n            \"Bad line\",\n            \"Another good line 7681\"\n        ]\n        self.assertEqual(sum_calibration_values(document), 85)", "prompt": "please write a python function , the function signature as below def sum_calibration_values(calibration_document) -> int:\n    \"\"\"\n    Sums up calibration values extracted from the document.\n    Each calibration value is formed by combining the first and last digits of numbers found in each line\n    into a two-digit number.\n\n    Args:\n        calibration_document (iterable): An iterable of strings, each representing a line of text.\n\n    Returns:\n        int: The total sum of all calibration values.\n    \"\"\"\n"}, {"task_id": 396, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom typing import List\n\nclass TestLengthOfLIS(unittest.TestCase):\n\n    def test_empty_list(self):\n        # Test the function with an empty list\n        self.assertEqual(length_of_LIS([]), 0)\n\n    def test_single_element(self):\n        # Test with a list containing only one element\n        self.assertEqual(length_of_LIS([7]), 1)\n\n    def test_increasing_sequence(self):\n        # Test with a list where the elements are strictly increasing\n        self.assertEqual(length_of_LIS([1, 2, 3, 4, 5]), 5)\n\n    def test_decreasing_sequence(self):\n        # Test with a list where the elements are strictly decreasing\n        self.assertEqual(length_of_LIS([5, 4, 3, 2, 1]), 1)\n\n    def test_complex_sequence(self):\n        # Test with a complex sequence with mix of increasing and decreasing elements\n        self.assertEqual(length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]), 4)\n\n    def test_all_equal_elements(self):\n        # Test with all elements in the list being equal\n        self.assertEqual(length_of_LIS([2, 2, 2, 2]), 1)\n\n    def test_with_negative_numbers(self):\n        # Test with a mix of negative and positive numbers\n        self.assertEqual(length_of_LIS([-1, -2, -3, 0, 1, 2]), 4)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Given an array of integers nums, find the length of the longest strictly increasing subsequence in it\n\n    Args:\n        nums (List[int]): int array\n\n    Returns:\n        int: longest strictly increasing subsequence\n    \"\"\""}, {"task_id": 398, "code_type": "method", "code_language": "python", "test_code": "import os\nimport shutil\nimport unittest\n\n\nclass TestExtractFiles(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up test directories and files before each test case.\"\"\"\n        self.folderA = \"test_folderA\"\n        self.folderB = \"test_folderB\"\n        os.makedirs(self.folderA, exist_ok=True)\n        os.makedirs(self.folderB, exist_ok=True)\n\n    def tearDown(self):\n        \"\"\"Clean up the test directories after each test case.\"\"\"\n        shutil.rmtree(self.folderA)\n        shutil.rmtree(self.folderB)\n\n    def create_csv(self, filename_list):\n        \"\"\"Helper method to create a CSV file for testing.\"\"\"\n        csv_file = \"test_exclude.csv\"\n        with open(csv_file, \"w\", newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"filename\"])  # Write header\n            for name in filename_list:\n                writer.writerow([name])\n        return csv_file\n\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with some files excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n        with open(os.path.join(self.folderA, \"file3.txt\"), \"w\") as f:\n            f.write(\"Content of file 3\")\n\n        csv_file = self.create_csv([\"file2.txt\"])  # Exclude file2.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n        self.assertFalse(os.path.exists(os.path.join(self.folderB, \"file2.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file3.txt\")))\n\n    def test_empty_folderA(self):\n        \"\"\"Test when folderA is empty.\"\"\"\n        csv_file = self.create_csv([\"file1.txt\"])  # Exclude file1.txt\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_all_files_excluded(self):\n        \"\"\"Test when all files are excluded.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n        with open(os.path.join(self.folderA, \"file2.txt\"), \"w\") as f:\n            f.write(\"Content of file 2\")\n\n        csv_file = self.create_csv([\"file1.txt\", \"file2.txt\"])  # Exclude all files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertEqual(len(os.listdir(self.folderB)), 0)\n\n    def test_destination_folder_already_has_files(self):\n        \"\"\"Test when folderB already contains files.\"\"\"\n        with open(os.path.join(self.folderB, \"existing_file.txt\"), \"w\") as f:\n            f.write(\"This is an existing file.\")\n\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        # Check if both existing and new files are present\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"existing_file.txt\")))\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))\n\n    def test_empty_csv_file(self):\n        \"\"\"Test with an empty CSV file.\"\"\"\n        with open(os.path.join(self.folderA, \"file1.txt\"), \"w\") as f:\n            f.write(\"Content of file 1\")\n\n        csv_file = self.create_csv([])  # Empty CSV, do not exclude any files\n        extract_files_excluding_csv(self.folderA, csv_file, self.folderB)\n\n        self.assertTrue(os.path.exists(os.path.join(self.folderB, \"file1.txt\")))", "prompt": "please write a python function , the function signature as below import os\nimport csv\nimport shutil\n\n\ndef extract_files_excluding_csv(folderA: str, csv_file: str, folderB: str):\n    \"\"\"\n    Copy files from folderA to folderB excluding those listed in the specified CSV file.\n\n    Args:\n        folderA: Path to the source folder containing all files (str).\n        csv_file: Path to the CSV file containing filenames to exclude (str).\n        folderB: Path to the destination folder (str).\n\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 401, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFindPlaceholders(unittest.TestCase):\n\n    def test_multiple_placeholders(self):\n        \"\"\"Test string with multiple placeholders.\"\"\"\n        input_text = \"Here are some placeholders: {{ placeholder1 }}, {{ placeholder2 }}, and {{ placeholder3 }}.\"\n        expected_output = ['placeholder1', 'placeholder2', 'placeholder3']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_no_placeholders(self):\n        \"\"\"Test string with no placeholders.\"\"\"\n        input_text = \"This string has no placeholders.\"\n        expected_output = []\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_single_placeholder(self):\n        \"\"\"Test string with a single placeholder.\"\"\"\n        input_text = \"The only placeholder is {{ singlePlaceholder }}.\"\n        expected_output = ['singlePlaceholder']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n\n    def test_placeholder_with_spaces(self):\n        \"\"\"Test string with placeholders that have extra spaces.\"\"\"\n        input_text = \"Placeholders with spaces: {{  placeholder_with_spaces  }} and {{ placeholder2 }}.\"\n        expected_output = ['placeholder_with_spaces', 'placeholder2']\n        self.assertEqual(find_placeholders(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\n\ndef find_placeholders(text):\n    \"\"\"\n    Find and return a list of all placeholders in the format {{ placeholder }} from the input text.\n\n    Args:\n        text (str): The input string containing potential placeholders.\n\n    Returns:\n        list: A list of matching placeholders.\n    \"\"\""}, {"task_id": 404, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestMatrixPower(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        # Testing the power function with an identity matrix\n        matrix = [[1, 0], [0, 1]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 1)\n        self.assertEqual(result, expected)\n\n    def test_zero_power(self):\n        # Testing matrix to the power of zero (should return identity)\n        matrix = [[2, 3], [1, 4]]\n        expected = [[1, 0], [0, 1]]\n        result = power(matrix, 0)\n        self.assertEqual(result, expected)\n\n    def test_positive_power(self):\n        # Testing matrix to a positive power\n        matrix = [[2, 1], [1, 3]]\n        expected = [[5, 5], [5, 10]]  # This is the result of matrix^2\n        result = power(matrix, 2)\n        self.assertEqual(result, expected)\n\n    def test_negative_power(self):\n        # Testing matrix to a negative power (should raise ValueError)\n        matrix = [[2, 1], [1, 3]]\n        with self.assertRaises(ValueError):\n            power(matrix, -1)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef power(matrix: List[List[int]], n: int) -> List[List[int]]:\n    \"\"\"\n    Computes the n-th power of a matrix using the fast exponentiation method.\n\n    Args:\n        matrix (List[List[int]]): A square matrix to be exponentiated.\n        n (int): The exponent to raise the matrix to. Must be a non-negative integer.\n\n    Returns:\n        List[List[int]]: The matrix raised to the power of n.\n\n    Raises:\n        ValueError: If n is negative.\n        TypeError: If matrix is not a list of lists or n is not an integer.\n    \"\"\""}, {"task_id": 405, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestRemovePartsOfString(unittest.TestCase):\n\n    def test_case_3(self):\n        # Test with a string that has no uppercase letters\n        result = remove_parts_of_string(\"abcdefg\")\n        self.assertEqual(result, [\"abcdefg\"])\n\n    def test_case_4(self):\n        # Test with a string that has no lowercase letters\n        result = remove_parts_of_string(\"ABCDEFG\")\n        self.assertEqual(result, [\"ABCDEFG\"])\n\n    def test_case_5(self):\n        # Test with a string that has mixed cases\n        result = remove_parts_of_string(\"1234AbCde5678\")\n        self.assertEqual(result, [\"AbCde5678\"])\n\n    def test_case_6(self):\n        # Test with an empty string\n        result = remove_parts_of_string(\"\")\n        self.assertEqual(result, [\"\"])\n\n    def test_case_7(self):\n        # Test with a string that has only one uppercase letter\n        result = remove_parts_of_string(\"X\")\n        self.assertEqual(result, [\"X\"])\n\n    def test_case_8(self):\n        # Test with a string that has only one lowercase letter\n        result = remove_parts_of_string(\"y\")\n        self.assertEqual(result, [\"y\"])\n", "prompt": "please write a python function , the function signature as below def remove_parts_of_string(*strings):\n    \"\"\"\n    Remove the part before the first upper case letter and the first lower case letter from the string\n\n    For example:\n        input: 1234AbCde5678\n        output: AbCde5678\n    Args:\n        *strings: Accepts one or more strings as variable arguments\n    Returns:\n\n    \"\"\"\n"}, {"task_id": 406, "code_type": "class", "code_language": "python", "test_code": "import unittest\n\nclass TestColors(unittest.TestCase):\n\n    def test_red(self):\n        # Test that the red method returns a string formatted with red color\n        self.assertEqual(Colors.red(\"hello\"), '\\033[31mhello\\033[0m')\n\n    def test_green(self):\n        # Test that the green method returns a string formatted with green color\n        self.assertEqual(Colors.green(\"hello\"), '\\033[32mhello\\033[0m')\n\n    def test_blue(self):\n        # Test that the blue method returns a string formatted with blue color\n        self.assertEqual(Colors.blue(\"hello\"), '\\033[34mhello\\033[0m')\n\n    def test_yellow(self):\n        # Test that the yellow method returns a string formatted with yellow color\n        self.assertEqual(Colors.yellow(\"hello\"), '\\033[33mhello\\033[0m')\n\n    def test_magenta(self):\n        # Test that the magenta method returns a string formatted with magenta color\n        self.assertEqual(Colors.magenta(\"hello\"), '\\033[35mhello\\033[0m')\n\n    def test_cyan(self):\n        # Test that the cyan method returns a string formatted with cyan color\n        self.assertEqual(Colors.cyan(\"hello\"), '\\033[36mhello\\033[0m')\n", "prompt": "please write a python class , the class signature as below class Colors:\n\n    @staticmethod\n    def red(text: str) -> str:\n        \"\"\"text in red color\"\"\"\n        pass\n\n    @staticmethod\n    def green(text: str) -> str:\n        \"\"\"text in green color\"\"\"\n\n    @staticmethod\n    def blue(text: str) -> str:\n        \"\"\"text in blue color\"\"\"\n\n    @staticmethod\n    def yellow(text: str) -> str:\n        \"\"\"text in yellow color\"\"\"\n\n    @staticmethod\n    def magenta(text: str) -> str:\n        \"\"\"text in magenta color\"\"\"\n\n    @staticmethod\n    def cyan(text: str) -> str:\n        \"\"\"text in cyan color\"\"\"\n"}, {"task_id": 410, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCheckXorSum(unittest.TestCase):\n\n    def test_correct_xor_sums(self):\n        \"\"\" Test with combination values that produce the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_incorrect_xor_sums(self):\n        \"\"\" Test with combination values that do not meet the expected XOR sums. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_edge_case_with_zero(self):\n        \"\"\" Test with a combination where all values are zero. \"\"\"\n        combination = np.zeros((1, 8), dtype=int)  # 1 row of zeros\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_large_numbers(self):\n        \"\"\" Test with large numbers in the combination. \"\"\"\n        combination = np.array([\n            [0x6b000000, 0x00000000, 0x00000012, 0x00000000, 0x76000000, 0x00000000, 0x00000000, 0x00000000],\n            [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]\n        ])\n        self.assertFalse(check_xor_sum(combination))\n\n    def test_multiple_rows(self):\n        \"\"\" Test with a combination that contains multiple rows. \"\"\"\n        combination = np.array([\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00],\n            [0x6b, 0x00, 0x12, 0x00, 0x76, 0x00, 0x00, 0x00]\n        ])\n        self.assertTrue(check_xor_sum(combination))", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef check_xor_sum(combination: np.ndarray):\n    \"\"\"\n    Checks the XOR sums of specific columns in a given combination array.\n\n    Args:\n        combination (np.ndarray): A 2D numpy array where each column corresponds\n                                  to a specific value.\n\n    Returns:\n        bool: True if the XOR sums of the specified columns match the required\n              values; otherwise, False.\n    \"\"\"\n"}, {"task_id": 412, "code_type": "method", "code_language": "python", "test_code": "import os\nimport tempfile\nimport unittest\n\n\nclass TestFormatText(unittest.TestCase):\n\n    def test_basic_text(self):\n        # Test with basic text\n        input_text = \"This is line one.\\nThis is line two.\\nThis is line three.\"\n        expected_output = \"This is line one. This is line two. This is line three.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)  # Go back to the start of the file\n            output_file_path = tempfile.mktemp(suffix='.txt')  # Create a temporary output file\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_single_line(self):\n        # Test with a single line\n        input_text = \"This is a single line.\"\n        expected_output = \"This is a single line.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_empty_file(self):\n        # Test with an empty file\n        input_text = \"\"\n        expected_output = \"\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n\n    def test_file_with_no_newlines(self):\n        # Test with text that has no newlines\n        input_text = \"This is a continuous line without breaks.\"\n        expected_output = \"This is a continuous line without breaks.\"\n\n        with tempfile.NamedTemporaryFile(delete=False, mode='w+t') as input_file:\n            input_file.write(input_text)\n            input_file.seek(0)\n            output_file_path = tempfile.mktemp(suffix='.txt')\n\n            format_text(input_file.name, output_file_path)\n\n            with open(output_file_path, 'r') as output_file:\n                output_text = output_file.read().strip()\n\n            self.assertEqual(expected_output, output_text)\n\n        os.remove(input_file.name)\n        os.remove(output_file_path)\n", "prompt": "please write a python function , the function signature as below "}, {"task_id": 413, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestNthPalindrome(unittest.TestCase):\n    def test_single_digit(self):\n        \"\"\"Test case for the first palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1), [0], \"The first palindrome should be 0\")\n\n    def test_edge_of_single_and_double_digits(self):\n        \"\"\"Test case for the tenth palindrome, transitioning to double digits\"\"\"\n        self.assertEqual(get_palindrome_list(10), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n                         \"The tenth palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\")\n\n    def test_edge_of_double_and_triple_digits(self):\n        \"\"\"Test case for the 100th palindrome, transitioning to triple digits\"\"\"\n        self.assertEqual(get_palindrome_list(100), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99],\n                         \"The 100th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99]\")\n\n    def test_large_number(self):\n        \"\"\"Test case for a larger number, e.g., the 1000th palindrome\"\"\"\n        self.assertEqual(get_palindrome_list(1000),\n                         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141,\n                          151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333,\n                          343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525,\n                          535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717,\n                          727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909,\n                          919, 929, 939, 949, 959, 969, 979, 989, 999]\n                         ,\n                         \"The 1000th palindrome should be [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]\")\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_palindrome_list(n: int) ->  List[int]:\n    \"\"\"\n    Filter out the number of palindrome within any number n. Palindrome numbers are numbers with the same correction and reverse readings, such as 121, 1331\n\n    Args:\n        n (int): range number\n\n    Returns:\n        List[int]: Palindrome numbers\n    \"\"\"\n"}, {"task_id": 414, "code_type": "method", "code_language": "python", "test_code": "import re\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractBibInfo(unittest.TestCase):\n\n    def test_valid_entry(self):\n        \"\"\"Test extraction from a valid BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'A Comprehensive Study on AI', 'author': 'John Doe and Jane Smith', 'year': '2024'}]\n            self.assertEqual(result, expected)\n\n    def test_multiple_entries(self):\n        \"\"\"Test extraction from multiple BibTeX entries.\"\"\"\n        mock_bib = (\n            \"@article{sample2024,\\n\"\n            \"  author = {John Doe},\\n\"\n            \"  title = {A Comprehensive Study on AI},\\n\"\n            \"  year = {2024}\\n}\\n\"\n            \"@article{sample2023,\\n\"\n            \"  author = {Jane Smith},\\n\"\n            \"  title = {Deep Learning Techniques},\\n\"\n            \"  year = {2023}\\n}\"\n        )\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [\n                {'title': 'A Comprehensive Study on AI', 'author': 'John Doe', 'year': '2024'},\n                {'title': 'Deep Learning Techniques', 'author': 'Jane Smith', 'year': '2023'}\n            ]\n            self.assertEqual(result, expected)\n\n    def test_missing_fields(self):\n        \"\"\"Test extraction when some fields are missing.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = {John Doe},\\n  title = {Title Missing Year}\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Missing Year', 'author': 'John Doe', 'year': None}]\n            self.assertEqual(result, expected)\n\n    def test_empty_file(self):\n        \"\"\"Test extraction from an empty BibTeX file.\"\"\"\n        mock_bib = \"\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = []\n            self.assertEqual(result, expected)\n\n    def test_incorrect_format(self):\n        \"\"\"Test extraction from a badly formatted BibTeX entry.\"\"\"\n        mock_bib = \"@article{sample2024,\\n  author = John Doe,\\n  title = {Title Without Braces},\\n  year = 2024\\n}\"\n        with patch(\"builtins.open\", mock_open(read_data=mock_bib)):\n            result = extract_bib_info(\"dummy.bib\")\n            expected = [{'title': 'Title Without Braces', 'author': None, 'year': None}]\n            self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def extract_bib_info(bib_file: str):\n    \"\"\"\n    Extracts the title, author, and year from a BibTeX file.bib file content such as @article{sample2024,\\n  author = {John Doe and Jane Smith},\\n  title = {A Comprehensive Study on AI},\\n  year = {2024}\\n}\n\n    Args:\n        bib_file (str): The path to the BibTeX file.\n\n    Returns:\n        list of dict: A list containing dictionaries with title, author, and year for each article.\n    \"\"\"\n"}, {"task_id": 418, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestLengthOFLIS(unittest.TestCase):\n    def test_case_1(self):\n        nums = [10, 9, 2, 5, 3, 7, 101, 18]\n        expected = 4\n        self.assertEqual(length_of_LIS(nums), expected)\n\n    def test_case_2(self):\n        nums = [0, 1, 0, 3, 2, 3]\n        expected = 4\n        self.assertEqual(length_of_LIS(nums), expected)\n\n    def test_case_3(self):\n        nums = [7, 7, 7, 7, 7, 7, 7]\n        expected = 1\n        self.assertEqual(length_of_LIS(nums), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef length_of_LIS(nums: List[int]) -> int:\n    \"\"\"\n    Give you an integer array nums and find the length of the longest strictly increasing subsequence in it.\n    For example:\n        input: [10, 9, 2, 5, 3, 7, 101, 18]\n        output: 4\n\n    Args:\n        nums(List[int]): integer array\n\n    Returns:\n        int: the length of the longest strictly increasing subsequence\n    \"\"\"\n"}, {"task_id": 420, "code_type": "class", "code_language": "python", "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n    @patch('builtins.open')\n    def test_simple_case(self, mock_open):\n        # Mock the file read operation\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n\n\n    @patch('builtins.open')\n    def test_multiple_lines(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello planet\",\n            \"world hello planet\",\n            \"hello world planet\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (1, 1))\n\n    @patch('builtins.open')\n    def test_large_distance(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello a b c d e f g h i j k l m n o p q r s t u v w x y z world\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 27))\n\n    @patch('builtins.open')\n    def test_adjacent_words(self, mock_open):\n        mock_open.return_value.__enter__.return_value = iter([\n            \"hello world\",\n            \"hello hello world world\",\n            \"world hello\"\n        ])\n        self.assertEqual(get_min_distance(\"dummy_file.txt\", \"hello\", \"world\"), (0, 1))\n", "prompt": "please write a python class , the class signature as below def get_min_distance(file_path, word1, word2):\n    \"\"\"\n    Find the minimum distance between two specified words (word1 and word2) from the file and return in which line the distance occurred\n\n    Args:\n        file_path (str):\n        word1 (str):\n        word2 (str):\n\n    Returns:\n\n    \"\"\""}, {"task_id": 423, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport os\n\n\nclass TestWriteUniqueLineToFile(unittest.TestCase):\n    def setUp(self):\n        # Setup: create a temporary file for testing.\n        self.filename = 'test_file.txt'\n        with open(self.filename, 'w') as file:\n            file.write('')\n\n    def test_write_new_line(self):\n        # Test case 1: Writing a new line to an empty file.\n        line_content = \"First unique line.\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertIn(line_content, file.read())\n\n    def test_write_duplicate_line(self):\n        # Test case 2: Attempting to write a duplicate line.\n        line_content = \"First unique line.\"\n        # Write the line once.\n        write_unique_line_to_file(self.filename, line_content)\n        # Attempt to write it again.\n        write_unique_line_to_file(self.filename, line_content)\n        # Check if the line was written only once.\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read().strip().count(line_content), 1)\n\n    def test_write_multiple_unique_lines(self):\n        # Test case 3: Writing multiple unique lines.\n        lines = [\"First unique line.\", \"Second unique line.\", \"Third unique line.\"]\n        for line in lines:\n            write_unique_line_to_file(self.filename, line)\n        with open(self.filename, 'r') as file:\n            file_content = file.read()\n            for line in lines:\n                self.assertIn(line, file_content)\n\n    def test_write_empty_line(self):\n        # Test case 5: Writing an empty line, should not write.\n        line_content = \"\"\n        write_unique_line_to_file(self.filename, line_content)\n        with open(self.filename, 'r') as file:\n            self.assertEqual(file.read(), \"\")\n", "prompt": "please write a python function , the function signature as below def write_unique_line_to_file(filename: str, line_content: str):\n    \"\"\"\n    Writes a line to a text file only if the line with the same content does not already exist.\n\n    Args:\n        filename (str): The name of the file to write to.\n        line_content (str): The content of the line to write.\n\n    Returns:\n        None\n    \"\"\""}, {"task_id": 424, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestDijkstraAlgorithm(unittest.TestCase):\n\n    def setUp(self):\n        # Sample graphs for testing\n        self.graph1 = {\n            'A': [('B', 1), ('C', 4)],\n            'B': [('A', 1), ('C', 2), ('D', 5)],\n            'C': [('A', 4), ('B', 2), ('D', 1)],\n            'D': [('B', 5), ('C', 1)],\n        }\n\n        self.graph2 = {\n            'A': [('B', 2)],\n            'B': [('A', 2), ('C', 3)],\n            'C': [('B', 3), ('D', 1)],\n            'D': [('C', 1)],\n        }\n\n        self.graph_with_isolated_node = {\n            'A': [('B', 1)],\n            'B': [('A', 1)],\n            'C': [],  # Isolated node\n        }\n\n        self.graph_with_negative_weight = {\n            'A': [('B', 2), ('C', 1)],\n            'B': [('D', 3)],\n            'C': [('B', -1), ('D', 4)],\n            'D': [],\n        }\n\n    def test_shortest_paths_graph1(self):\n        \"\"\"Test shortest paths in a normal graph.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': 3, 'D': 4}\n        result = dijkstra(self.graph1, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_graph2(self):\n        \"\"\"Test shortest paths in a different normal graph.\"\"\"\n        expected = {'A': 0, 'B': 2, 'C': 5, 'D': 6}\n        result = dijkstra(self.graph2, 'A')\n        self.assertEqual(result, expected)\n\n    def test_shortest_paths_with_isolated_node(self):\n        \"\"\"Test shortest paths with an isolated node.\"\"\"\n        expected = {'A': 0, 'B': 1, 'C': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'A')\n        self.assertEqual(result, expected)\n\n\n    def test_starting_at_isolated_node(self):\n        \"\"\"Test when starting at an isolated node.\"\"\"\n        expected = {'C': 0, 'A': float('inf'), 'B': float('inf')}\n        result = dijkstra(self.graph_with_isolated_node, 'C')\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below import heapq\nfrom typing import Dict\n\n\ndef dijkstra(graph: Dict, start: str) -> Dict:\n    \"\"\"\n    Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph.\n    Args:\n        graph(Dict): A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight).\n        start(str): The starting node for the shortest path search.\n\n    Returns:\n        Dict: A dictionary with the shortest distance from the start node to each node.\n    \"\"\"\n"}, {"task_id": 427, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCheckSequences(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test cases with sequences.\"\"\"\n        # Create a temporary file with test cases\n        self.test_file = 'test_sequences.dat'\n        with open(self.test_file, 'w') as f:\n            f.write(\"2,4,6,8\\n\")    # Munodi sequence (d = 2)\n            f.write(\"1,3,5,7\\n\")    # Munodi sequence (d = 2)\n            f.write(\"10,20,30\\n\")   # Munodi sequence (d = 10)\n            f.write(\"1,2,4,8\\n\")    # Not a Munodi sequence (d changes)\n            f.write(\"5,10,15,20\\n\") # Munodi sequence (d = 5)\n\n    def test_sequences(self):\n        \"\"\"Test the sequences for Munodi property.\"\"\"\n        expected_results = {\n            (2, 4, 6, 8): True,\n            (1, 3, 5, 7): True,\n            (10, 20, 30): True,\n            (1, 2, 4, 8): False,\n            (5, 10, 15, 20): True,\n        }\n        results = check_sequences(self.test_file)\n        for seq in expected_results:\n            self.assertEqual(results[seq], expected_results[seq])\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after tests.\"\"\"\n        import os\n        os.remove(self.test_file)", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef check_sequences(filename:str) -> Dict:\n    \"\"\"\n    Read multiple sequences from the file and determine if each sequence is a \"Munodi sequence\". The definition of the Munodi sequence is based on a specific recursive relationship, that is, for even numbers, the next term is half of it, for odd numbers, the next term is 3*n + 1, and the sequence terminates when it encounters 1.\n    For example: (2, 4, 6, 8) is Mundi sequence\n\n    Args:\n        filename(str): file path\n\n    Returns:\n        Dict: sequences weather is Munodi sequence\n    \"\"\""}, {"task_id": 428, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\n# Assuming the parse_type_hint function is defined above or imported here\n\nclass TestParseTypeHint(unittest.TestCase):\n\n    def test_basic_types(self):\n        type_hint = 'int'\n        expected = ['int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_list_type(self):\n        type_hint = 'List[int]'\n        expected = ['List', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_union_type(self):\n        type_hint = 'Union[str, float]'\n        expected = ['Union', 'str', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_tuple_type(self):\n        type_hint = 'Tuple[str, int, float]'\n        expected = ['Tuple', 'str', 'int', 'float']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n\n    def test_complex_type(self):\n        type_hint = 'List[Union[int, float], Tuple[str, int]]'\n        expected = ['List', 'Union', 'int', 'float', 'Tuple', 'str', 'int']\n        self.assertEqual(parse_type_hint(type_hint), expected)\n", "prompt": "please write a python function , the function signature as below import ast\nfrom typing import List\n\n\ndef parse_type_hint(type_hint_string:str) -> List:\n    \"\"\"\n    Parses a Python type hint string and returns the individual types as a list of strings.\n\n    Args:\n        type_hint_string (str): The type hint string to parse.\n\n    Returns:\n        list: The individual types parsed from the type hint string.\n\n    Example:\n        type_hint = \"Union[typing.List[str], typing.Dict[str, int], Tuple[int, str], Optional[int]]\"\n        parsed_types = parse_type_hint(type_hint)\n        print(parsed_types)\n        # Output: ['Union', 'typing.List', 'str', 'typing.Dict', 'str', 'int', 'Tuple', 'int',\n                   'str', 'Optional', 'int']\n    \"\"\"\n"}, {"task_id": 430, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestIntersectVertically(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with rectangles touching at a point (not overlapping).\"\"\"\n        rect1 = (0, 0, 1, 1)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case3(self):\n        \"\"\"Test with adjacent rectangles (no overlap).\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (0, 2, 3, 3)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case4(self):\n        \"\"\"Test with one rectangle fully inside another.\"\"\"\n        rect1 = (1, 1, 4, 4)\n        rect2 = (2, 2, 3, 3)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n\n    def test_case5(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_vertically(rect1, rect2))\n", "prompt": "please write a python function , the function signature as below def intersect_vertically(rect1, rect2):\n    \"\"\"\n    Check whether two rectangles intersect in the vertical direction\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect vertically, False otherwise.\n    \"\"\""}, {"task_id": 431, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestIntersectHorizontally(unittest.TestCase):\n\n    def test_case1(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (1, 1, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case2(self):\n        \"\"\"Test with rectangles touching at a point (not overlapping).\"\"\"\n        rect1 = (0, 0, 1, 1)\n        rect2 = (1, 1, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case3(self):\n        \"\"\"Test with adjacent rectangles (no overlap).\"\"\"\n        rect1 = (0, 0, 2, 2)\n        rect2 = (2, 0, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case4(self):\n        \"\"\"Test with one rectangle fully inside another.\"\"\"\n        rect1 = (1, 1, 4, 4)\n        rect2 = (2, 2, 3, 3)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n\n    def test_case5(self):\n        \"\"\"Test with overlapping rectangles.\"\"\"\n        rect1 = (-1, -1, 1, 1)\n        rect2 = (0, 0, 2, 2)\n        self.assertTrue(intersect_horizontally(rect1, rect2))\n", "prompt": "please write a python function , the function signature as below def intersect_horizontally(rect1, rect2):\n    \"\"\"\n    Determine if two rectangles intersect horizontally.\n\n    Each rectangle is defined by a tuple (x1, y1, x2, y2), where:\n    - (x1, y1) are the coordinates of the bottom-left corner.\n    - (x2, y2) are the coordinates of the top-right corner.\n\n    Args:\n        rect1 (tuple): The first rectangle defined by (x1, y1, x2, y2).\n        rect2 (tuple): The second rectangle defined by (x1, y1, x2, y2).\n\n    Returns:\n        bool: True if the rectangles intersect horizontally, False otherwise.\n    \"\"\"\n"}, {"task_id": 433, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestExtractParagraphsAndLines(unittest.TestCase):\n\n    def test_single_paragraph(self):\n        input_text = \"This is a single paragraph.\"\n        expected_output = {\n            'paragraphs': [\"This is a single paragraph.\"],\n            'lines': [\"This is a single paragraph.\"]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_paragraphs(self):\n        input_text = \"First paragraph.\\nThis is the second line.\\n\\nSecond paragraph.\\nAnother line.\"\n        expected_output = {\n            'paragraphs': [\n                \"First paragraph.\\nThis is the second line.\",\n                \"Second paragraph.\\nAnother line.\"\n            ],\n            'lines': [\n                \"First paragraph.\",\n                \"This is the second line.\",\n                \"Second paragraph.\",\n                \"Another line.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_leading_and_trailing_whitespace(self):\n        input_text = \"   This paragraph has leading whitespace.\\nAnd a line after.\\n\\n   This one has trailing whitespace.   \"\n        expected_output = {\n            'paragraphs': [\n                \"This paragraph has leading whitespace.\\nAnd a line after.\",\n                \"This one has trailing whitespace.\"\n            ],\n            'lines': [\n                \"This paragraph has leading whitespace.\",\n                \"And a line after.\",\n                \"This one has trailing whitespace.\"\n            ]\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_empty_string(self):\n        input_text = \"\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n\n    def test_multiple_empty_paragraphs(self):\n        input_text = \"\\n\\n\\n\"\n        expected_output = {\n            'paragraphs': [],\n            'lines': []\n        }\n        self.assertEqual(extract_paragraphs_and_lines(input_text), expected_output)\n", "prompt": "please write a python function , the function signature as below def extract_paragraphs_and_lines(text: str):\n    \"\"\"\n    Extracts paragraphs and lines from the given text.\n\n    Args:\n        text (str): The input text from which paragraphs and lines will be extracted.\n\n    Returns:\n        dict: A dictionary containing:\n            - 'paragraphs': A list of paragraphs extracted from the text.\n            - 'lines': A list of lines extracted from the text.\n    \"\"\""}, {"task_id": 434, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestGetMaxPeople(unittest.TestCase):\n    def test_case_1(self):\n        people = [1, 2, 1]\n        status = ['+', '+', '-']\n        expected = 1\n        self.assertEqual(get_max_people(people, status), expected)\n\n    def test_case_2(self):\n        people = [1, 2, 3]\n        status = ['+', '+', '-']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)\n\n    def test_case_3(self):\n        people = [1, 2, 1]\n        status = ['+', '-', '+']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)\n\n    def test_case_4(self):\n        people = [1, 2, 1]\n        status = ['+', '+', '+']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)\n\n    def test_case_5(self):\n        people = [1, 2, 1]\n        status = ['+', '+', '+']\n        expected = -1\n        self.assertEqual(get_max_people(people, status), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef get_max_people(people: List[int], status: List[str]) -> int:\n    \"\"\"\n    Amazon is organizing a farewell party for its interns at a large party hall! There are q events in the form \"+x\" and \"-x\" that denote person x has entered or left the party, respectively.   Find the maximum number of people at any time at the party.Return -1 if the series of events is not possible.\n\n    Args:\n        people(List[int]): people array\n        status(List[str]): people action array\n\n    Returns:\n        int: the maximum number of people at any time at the party or -1 is series of events is not possible\n    \"\"\"\n"}, {"task_id": 438, "code_type": "method", "code_language": "python", "test_code": "import os\nimport unittest\n\nimport pandas as pd\n\n\nclass TestReadCsvToDataFrame(unittest.TestCase):\n\n    def setUp(self):\n        # Create temporary CSV files for testing\n        self.test_files = {\n            'valid_csv': 'test_valid.csv',\n            'empty_csv': 'test_empty.csv',\n            'non_existent_csv': 'non_existent.csv',\n            'invalid_csv': 'test_invalid.csv',\n            'another_valid_csv': 'test_another_valid.csv',\n        }\n\n        # Valid CSV content\n        with open(self.test_files['valid_csv'], 'w') as f:\n            f.write(\"name,age\\nAlice,30\\nBob,25\\n\")\n\n        # Empty CSV\n        with open(self.test_files['empty_csv'], 'w') as f:\n            f.write(\"\")\n\n        # Invalid CSV (unparsable)\n        with open(self.test_files['invalid_csv'], 'w') as f:\n            f.write(\"name;age\\nAlice;30\\nBob;25\\n\")  # wrong delimiter\n\n        # Another valid CSV\n        with open(self.test_files['another_valid_csv'], 'w') as f:\n            f.write(\"item,price\\napple,1.2\\nbanana,0.8\\n\")\n\n    def tearDown(self):\n        # Remove the test CSV files after tests\n        for file in self.test_files.values():\n            if os.path.exists(file):\n                os.remove(file)\n\n    def test_read_valid_csv(self):\n        df = read_csv_to_dataframe(self.test_files['valid_csv'])\n        self.assertIsInstance(df, pd.DataFrame)\n        self.assertEqual(len(df), 2)  # should have 2 rows of data\n        self.assertIn('name', df.columns)\n        self.assertIn('age', df.columns)\n\n    def test_read_empty_csv(self):\n        df = read_csv_to_dataframe(self.test_files['empty_csv'])\n        self.assertIsNone(df)  # expect None for empty file\n\n    def test_read_non_existent_csv(self):\n        df = read_csv_to_dataframe(self.test_files['non_existent_csv'])\n        self.assertIsNone(df)  # expect None for non-existent file\n\n    def test_read_another_valid_csv(self):\n        df = read_csv_to_dataframe(self.test_files['another_valid_csv'])\n        self.assertIsInstance(df, pd.DataFrame)\n        self.assertEqual(len(df), 2)  # should have 2 rows of data\n        self.assertIn('item', df.columns)\n        self.assertIn('price', df.columns)\n", "prompt": "please write a python function , the function signature as below import pandas as pd\n\n\ndef read_csv_to_dataframe(file_path: str) -> pd.DataFrame:\n    \"\"\"\n    Reads a CSV file and converts it to a pandas DataFrame.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the CSV file.\n    \"\"\"\n"}, {"task_id": 442, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestConvertStringsToNumbers(unittest.TestCase):\n\n    def test_flat_dict(self):\n        data = {'a': '1', 'b': '2.5', 'c': 'not a number'}\n        expected = {'a': 1, 'b': 2.5, 'c': 'not a number'}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_nested_dict(self):\n        data = {'x': {'y': '10', 'z': '3.14'}, 'w': '20.0'}\n        expected = {'x': {'y': 10, 'z': 3.14}, 'w': 20.0}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_list_of_strings(self):\n        data = ['1', '2.5', '3', 'invalid']\n        expected = [1, 2.5, 3, 'invalid']\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_mixed_structure(self):\n        data = {'numbers': ['1', '2.0', 3], 'more_numbers': [{'num': '4'}, '5']}\n        expected = {'numbers': [1, 2.0, 3], 'more_numbers': [{'num': 4}, 5]}\n        self.assertEqual(convert_strings_to_numbers(data), expected)\n\n    def test_empty_structure(self):\n        data = {}\n        expected = {}\n        self.assertEqual(convert_strings_to_numbers(data), expected)", "prompt": "please write a python function , the function signature as below from typing import List, Dict, Union\n\n\ndef convert_strings_to_numbers(data: Union[Dict, List]) -> Union[Dict, List]:\n    \"\"\"\n    Convert strings in nested structures (e.g. dictionaries, arrays) to numbers (integers or floating point numbers) as much as possible\n\n    Args:\n        data (Union[Dict,List]): before convert data\n\n    Returns:\n        Union[Dict,List]: after convert data\n    \"\"\"\n"}, {"task_id": 443, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCompressWhitespace(unittest.TestCase):\n\n    def test_single_spaces(self):\n        \"\"\"Test with a string containing single spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This is a test string.\"), \"This is a test string.\")\n\n    def test_multiple_spaces(self):\n        \"\"\"Test with a string containing multiple spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"This    is  a   test   string.\"), \"This is a test string.\")\n\n    def test_leading_trailing_spaces(self):\n        \"\"\"Test with leading and trailing spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"   Leading and trailing spaces   \"), \"Leading and trailing spaces\")\n\n    def test_only_spaces(self):\n        \"\"\"Test with a string containing only spaces\"\"\"\n        self.assertEqual(compress_whitespace(\"       \"), \"\")\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        self.assertEqual(compress_whitespace(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def compress_whitespace(input_string: str):\n    \"\"\"\n    Compress multiple consecutive whitespace characters in a string into a single space.\n\n    Args:\n        input_string(str): The string to be processed.\n\n    Returns:\n        str: The processed string with compressed whitespace.\n    \"\"\""}, {"task_id": 444, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFormatComment(unittest.TestCase):\n\n    def test_short_string(self):\n        \"\"\"Test with a short string that fits within max_length\"\"\"\n        input_string = \"This is a test.\"\n        expected_output = \"# This is a test.\"\n        self.assertEqual(format_comment(input_string), expected_output)\n\n    def test_long_string(self):\n        \"\"\"Test with a longer string that exceeds max_length\"\"\"\n        input_string = \"This is a test of the format_comment function which should wrap long lines correctly.\"\n        expected_output = (\n            \"# This is a test of the format_comment function which should\\n\"\n            \"# wrap long lines correctly.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_multiple_lines(self):\n        \"\"\"Test with multiple lines of input\"\"\"\n        input_string = \"First line.\\nSecond line that is quite long and needs to be wrapped.\"\n        expected_output = (\n            \"# First line.\\n\"\n            \"# Second line that is quite long and needs to be wrapped.\"\n        )\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_exact_max_length(self):\n        \"\"\"Test with a line that is exactly max_length characters long\"\"\"\n        input_string = \"A\" * 60  # 60 characters long\n        expected_output = \"# \" + \"A\" * 60\n        self.assertEqual(format_comment(input_string, max_length=60), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty string\"\"\"\n        input_string = \"\"\n        expected_output = \"# \"\n        self.assertEqual(format_comment(input_string), expected_output)\n", "prompt": "please write a python function , the function signature as below def format_comment(string, max_length=60):\n    \"\"\"\n    Formats a string into a commented block with specified maximum line length.\n\n    Args:\n        string (str): The input string to format.\n        max_length (int): Maximum length of each line in the output.\n\n    Returns:\n        str: A formatted string with each line prefixed by '# ' and not exceeding the specified max_length.\n    \"\"\""}, {"task_id": 445, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport numpy as np\nfrom numpy.testing import assert_array_almost_equal\n\n\n\nclass TestCreateRotMatrix(unittest.TestCase):\n    def test_rotation_x_90_degrees(self):\n        \"\"\" Test rotation around X-axis for 90 degrees \"\"\"\n        expected_matrix = np.array([\n            [1, 0, 0, 0],\n            [0, 0, -1, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(90, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_y_180_degrees(self):\n        \"\"\" Test rotation around Y-axis for 180 degrees \"\"\"\n        expected_matrix = np.array([\n            [-1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, -1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(180, 'y')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_rotation_z_270_degrees(self):\n        \"\"\" Test rotation around Z-axis for 270 degrees (or -90 degrees) \"\"\"\n        expected_matrix = np.array([\n            [0, 1, 0, 0],\n            [-1, 0, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1]\n        ])\n        result_matrix = create_rot_matrix(270, 'z')\n        assert_array_almost_equal(result_matrix, expected_matrix)\n\n    def test_invalid_axis(self):\n        \"\"\" Test behavior with invalid axis input \"\"\"\n        with self.assertRaises(ValueError):\n            create_rot_matrix(90, 'a')\n\n    def test_zero_rotation(self):\n        \"\"\" Test zero degree rotation which should lead to identity matrix \"\"\"\n        expected_matrix = np.eye(4)\n        result_matrix = create_rot_matrix(0, 'x')\n        assert_array_almost_equal(result_matrix, expected_matrix)", "prompt": "please write a python function , the function signature as below import numpy\nimport numpy as np\n\n\ndef create_rot_matrix(angle_deg: float, axis: str) -> numpy.ndarray:\n    \"\"\"\n    Create a pose matrix representing a rotation about a given axis.\n\n    Args:\n        angle_deg (float): Rotation angle in degrees.\n        axis (str): Axis to rotate about, must be one of 'X', 'Y', or 'Z'.\n\n    Returns:\n        numpy.ndarray: 4x4 pose matrix representing the rotation.\n    \"\"\"\n"}, {"task_id": 451, "code_type": "method", "code_language": "python", "test_code": "import os\nimport unittest\n\nfrom PIL import Image\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create test images before each test.\"\"\"\n        # Create a white image (all pixels white)\n        self.white_image_path = 'white_image.bmp'\n        white_image = Image.new('1', (2, 2), color=1)  # 1 is for white\n        white_image.save(self.white_image_path)\n\n        # Create a black image (all pixels black)\n        self.black_image_path = 'black_image.bmp'\n        black_image = Image.new('1', (2, 2), color=0)  # 0 is for black\n        black_image.save(self.black_image_path)\n\n        # Create a mixed image (half white, half black)\n        self.mixed_image_path = 'mixed_image.bmp'\n        mixed_image = Image.new('1', (2, 2))\n        mixed_image.putpixel((0, 0), 1)  # White\n        mixed_image.putpixel((0, 1), 0)  # Black\n        mixed_image.putpixel((1, 0), 0)  # Black\n        mixed_image.putpixel((1, 1), 1)  # White\n        mixed_image.save(self.mixed_image_path)\n\n    def tearDown(self):\n        \"\"\"Remove the test images after each test.\"\"\"\n        os.remove(self.white_image_path)\n        os.remove(self.black_image_path)\n        os.remove(self.mixed_image_path)\n\n    def test_white_image(self):\n        \"\"\"Test converting a white image.\"\"\"\n        expected_output = [1, 1, 1, 1]  # All pixels should be 1 (white)\n        result = convert_image_to_bits(self.white_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_black_image(self):\n        \"\"\"Test converting a black image.\"\"\"\n        expected_output = [0, 0, 0, 0]  # All pixels should be 0 (black)\n        result = convert_image_to_bits(self.black_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_mixed_image(self):\n        \"\"\"Test converting a mixed image.\"\"\"\n        expected_output = [1, 0, 0, 1]  # 1 white, 3 black\n        result = convert_image_to_bits(self.mixed_image_path)\n        self.assertEqual(result, expected_output)\n\n    def test_invalid_image_path(self):\n        \"\"\"Test converting an invalid image path.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            convert_image_to_bits('invalid_image_path.bmp')\n\n    def test_large_image(self):\n        \"\"\"Test converting a larger image.\"\"\"\n        # Create a larger image (3x3)\n        large_image_path = 'large_image.bmp'\n        large_image = Image.new('1', (3, 3))\n        large_image.putpixel((0, 0), 1)\n        large_image.putpixel((1, 1), 1)\n        large_image.putpixel((2, 2), 1)\n        large_image.save(large_image_path)\n\n        expected_output = [\n            1, 0, 0,\n            0, 1, 0,\n            0, 0, 1\n        ]\n        result = convert_image_to_bits(large_image_path)\n        self.assertEqual(result, expected_output)\n\n        # Clean up\n        os.remove(large_image_path)\n", "prompt": "please write a python function , the function signature as below def convert_image_to_bits(image_path: str):\n    \"\"\"\n    Converts an image to a binary representation.Convert the image to black and white mode, that is, each pixel is represented by only 1 bit, with a white pixel value of 255 and a black pixel value of 0\n\n    Args:\n        image_path (str): The file path of the image to convert.\n\n    Returns:\n        list: A list of bits representing the image, where 1 is for white pixels\n              and 0 is for black pixels.\n    \"\"\"\n"}, {"task_id": 460, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_non_square_matrix(self):\n        \"\"\"Test case for a non-square matrix and a compatible vector.\"\"\"\n        matrix = [[1, 2], [3, 4], [5, 6]]\n        vector = [2, 3]\n        expected_result = [8.0, 18.0, 28.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_invalid_dimensions(self):\n        \"\"\"Test case for incompatible dimensions.\"\"\"\n        matrix = [[1, 2], [3, 4]]\n        vector = [1, 2, 3]\n        with self.assertRaises(ValueError) as context:\n            matrix_vector_multiplication(matrix, vector)\n        self.assertEqual(str(context.exception), \"Matrix and vector dimensions are not compatible for multiplication\")\n\n    def test_zero_vector(self):\n        \"\"\"Test case for a matrix and a zero vector.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        vector = [0, 0, 0]\n        expected_result = [0.0, 0.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_single_element(self):\n        \"\"\"Test case for a single element matrix and vector.\"\"\"\n        matrix = [[5]]\n        vector = [3]\n        expected_result = [15.0]\n        self.assertEqual(matrix_vector_multiplication(matrix, vector), expected_result)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef matrix_vector_multiplication(matrix: List[List[float]], vector: List[float]) -> List[float]:\n    \"\"\"\n    Multiplies a matrix by a vector and returns the resulting vector.\n\n    Args:\n        matrix (List[List[float]]): A 2D list representing the matrix.\n        vector (List[float]): A 1D list representing the vector.\n\n    Returns:\n        List[float]: The resulting vector after multiplication.\n\n    Raises:\n        ValueError: If the dimensions of the matrix and vector are not compatible for multiplication.\n    \"\"\"\n"}, {"task_id": 461, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass TestAverageOfLevels(unittest.TestCase):\n    def test_empty_tree(self):\n        \"\"\"Test case for an empty tree.\"\"\"\n        self.assertEqual(average_of_levels(None), [])\n\n    def test_single_node(self):\n        \"\"\"Test case for a tree with a single node.\"\"\"\n        root = TreeNode(5)\n        self.assertEqual(average_of_levels(root), [5.0])\n\n    def test_three_levels(self):\n        \"\"\"Test case for a tree with three levels.\"\"\"\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(6)\n        self.assertEqual(average_of_levels(root), [1.0, 2.5, 5.0])  # (1), (2, 3) -> [1.0, (2+3)/2], (4, 5, 6) -> [5.0]\n", "prompt": "please write a python function , the function signature as below from typing import List, Optional\nfrom collections import deque\n\n\nclass TreeNode:\n    \"\"\"Definition for a binary tree node.\"\"\"\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: Optional[TreeNode]) -> List[float]:\n    \"\"\"\n    Calculate the average value of nodes at each level of a binary tree.\n\n    Args:\n        root (Optional[TreeNode]): The root of the binary tree.\n\n    Returns:\n        List[float]: A list of averages for each level of the binary tree.\n    \"\"\"\n"}, {"task_id": 462, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSpiralOrder(unittest.TestCase):\n    def test_empty_matrix(self):\n        self.assertEqual(spiral_order([]), [])\n\n    def test_single_row_matrix(self):\n        self.assertEqual(spiral_order([[1, 2, 3]]), [1, 2, 3])\n\n    def test_single_column_matrix(self):\n        self.assertEqual(spiral_order([[1], [2], [3]]), [1, 2, 3])\n\n    def test_square_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3],\n            [4, 5, 6],\n            [7, 8, 9]\n        ]), [1, 2, 3, 6, 9, 8, 7, 4, 5])\n\n    def test_rectangle_matrix(self):\n        self.assertEqual(spiral_order([\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]), [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7])", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef spiral_order(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Given a 2D matrix, return all elements of the matrix in spiral order.\n\n    Args:\n        matrix (List[List[int]]): A 2D list of integers.\n\n    Returns:\n        List[int]: A list of integers representing the matrix elements in spiral order.\n    \"\"\""}, {"task_id": 463, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport tempfile\nimport os\n\n\n# Assuming the extract_log_levels function is defined here or imported\n\nclass TestLogExtraction(unittest.TestCase):\n    def create_temp_log_file(self, content):\n        # Create a temporary log file\n        temp_file = tempfile.NamedTemporaryFile(delete=False, mode='w+')\n        temp_file.write(content)\n        temp_file.close()\n        return temp_file.name\n\n    def read_output_file(self, file_path):\n        # Read content from a file\n        with open(file_path, 'r') as file:\n            return file.read()\n\n    def test_warning_level(self):\n        logs = \"\"\"[INFO] Information message\n[WARNING] Warning message\n[DEBUG] Debug message\"\"\"\n        expected_output = \"[WARNING] Warning message\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_error_level(self):\n        logs = \"\"\"[ERROR] Error occurred\n[INFO] Just an info\"\"\"\n        expected_output = \"[ERROR] Error occurred\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_critical_and_alert_levels(self):\n        logs = \"\"\"[ALERT] Security breach\n[CRITICAL] System failure\n[NOTICE] Something to notice\"\"\"\n        expected_output = \"[ALERT] Security breach\\n[CRITICAL] System failure\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_no_relevant_logs(self):\n        logs = \"[INFO] No issues here\\n[DEBUG] All systems go\"\n        expected_output = \"\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n\n    def test_mixed_logs(self):\n        logs = \"\"\"[WARNING] Low disk space\n[INFO] Update completed\n[ERROR] Failed to load module\n[CRITICAL] Memory leak detected\n[DEBUG] This is a debug message\"\"\"\n        expected_output = \"[WARNING] Low disk space\\n[ERROR] Failed to load module\\n[CRITICAL] Memory leak detected\\n\"\n\n        log_file_path = self.create_temp_log_file(logs)\n        output_file_path = tempfile.NamedTemporaryFile(delete=False).name\n\n        extract_log_levels(log_file_path, output_file_path)\n\n        result = self.read_output_file(output_file_path)\n        self.assertEqual(result, expected_output)\n\n        os.unlink(log_file_path)\n        os.unlink(output_file_path)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_log_levels(log_file_path:str, output_file_path:str):\n    \"\"\"\n    Obtain logs of [WARNING], [ERROR], [CRITICAL], and [ALERT] levels from the log file\n    log content such as:\n        [INFO] Information message\n        [WARNING] Warning message\n        [DEBUG] Debug message\n\n    Args:\n        log_file_path: log file path\n        output_file_path: output log file path\n\n    Returns:\n\n    \"\"\""}, {"task_id": 465, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestMatrixVectorMultiplication(unittest.TestCase):\n\n    def test_case_1(self):\n        # Test with a simple 2x2 matrix and a 2-element vector\n        matrix = np.array([[1, 2], [3, 4]])\n        vector = np.array([5, 6])\n        expected_result = np.array([17, 39])  # [1*5 + 2*6, 3*5 + 4*6]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_2(self):\n        # Test with a 3x3 matrix and a 3-element vector\n        matrix = np.array([[1, 0, 2], [0, 1, 2], [1, 1, 0]])\n        vector = np.array([3, 4, 5])\n        expected_result = np.array([13, 14, 7])  # [1*3 + 0*4 + 2*5, 0*3 + 1*4 + 2*5, 1*3 + 1*4 + 0*5]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_3(self):\n        # Test with a zero matrix and a vector\n        matrix = np.array([[0, 0], [0, 0]])\n        vector = np.array([1, 1])\n        expected_result = np.array([0, 0])  # Zero matrix multiplied by any vector yields zero\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_4(self):\n        # Test with a matrix having negative values\n        matrix = np.array([[-1, -2], [-3, -4]])\n        vector = np.array([1, 1])\n        expected_result = np.array([-3, -7])  # [-1*1 + -2*1, -3*1 + -4*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)\n\n    def test_case_5(self):\n        # Test with non-square matrix (2x3) and a compatible vector (3-element)\n        matrix = np.array([[1, 2, 3], [4, 5, 6]])\n        vector = np.array([1, 0, 1])\n        expected_result = np.array([4, 10])  # [1*1 + 2*0 + 3*1, 4*1 + 5*0 + 6*1]\n        np.testing.assert_array_equal(matrix_vector_multiplication(matrix, vector), expected_result)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef matrix_vector_multiplication(matrix: np.array, vector: np.array):\n    \"\"\"\n    Multiplies a given matrix by a vector using NumPy's dot product.\n\n    Parameters:\n    matrix (numpy.ndarray): A 2D array (matrix) of shape (m, n) where m is the number of rows\n                            and n is the number of columns.\n    vector (numpy.ndarray): A 1D array (vector) of shape (n,) that represents a vector\n                            compatible for multiplication with the given matrix.\n\n    Returns:\n    numpy.ndarray: A 1D array (resulting vector) of shape (m,) representing the product of\n                   the matrix and the vector.\n    \"\"\"\n\n    # Perform matrix-vector multiplication using the dot product function.\n    result = np.dot(matrix, vector)\n\n    # Return the resulting vector from the multiplication.\n    return result\n"}, {"task_id": 468, "code_type": "method", "code_language": "python", "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_translation function is defined as provided\n\nclass TestGetTranslationFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no translation) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_translation = np.array([0.0, 0.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_translation_matrix(self):\n        \"\"\" Test for a translation matrix (5 in x, 10 in y) \"\"\"\n        matrix = np.array([[1, 0, 5],\n                           [0, 1, 10],\n                           [0, 0, 1]])\n        expected_translation = np.array([5.0, 10.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_negative_translation(self):\n        \"\"\" Test for a translation matrix with negative values \"\"\"\n        matrix = np.array([[1, 0, -3],\n                           [0, 1, -6],\n                           [0, 0, 1]])\n        expected_translation = np.array([-3.0, -6.0])\n        np.testing.assert_array_equal(get_translation(matrix), expected_translation)\n\n    def test_invalid_matrix_shape(self):\n        \"\"\" Test for an invalid matrix input (not 3x3) \"\"\"\n        invalid_matrix = np.array([[1, 2],\n                                   [3, 4]])  # 2x2 matrix\n        with self.assertRaises(ValueError):\n            get_translation(invalid_matrix)\n\n    def test_invalid_matrix_type(self):\n        \"\"\" Test for an invalid input type (not a numpy array) \"\"\"\n        invalid_matrix = [[1, 0, 0],\n                          [0, 1, 0],\n                          [0, 0, 1]]  # A list, not a numpy array\n        with self.assertRaises(ValueError):\n            get_translation(invalid_matrix)\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_translation(matrix: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 matrix, return the corresponding translation vector.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        np.ndarray: A 2-element array containing the translation components (translation_x, translation_y).\n    \"\"\""}, {"task_id": 469, "code_type": "method", "code_language": "python", "test_code": "import numpy as np\nimport unittest\n\n\n# Assume the get_scale function is defined as provided\n\nclass TestGetScaleFunction(unittest.TestCase):\n\n    def test_identity_matrix(self):\n        \"\"\" Test for the identity matrix (no scaling) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_scale = (1.0, 1.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n    def test_scaling_matrix(self):\n        \"\"\" Test for a scaling matrix (2x in x and 3x in y) \"\"\"\n        matrix = np.array([[2, 0, 0],\n                           [0, 3, 0],\n                           [0, 0, 1]])\n        expected_scale = (2.0, 3.0)\n        self.assertEqual(get_scale(matrix), expected_scale)\n\n\n    def test_invalid_matrix_shape(self):\n        \"\"\" Test for an invalid matrix input (not 3x3) \"\"\"\n        invalid_matrix = np.array([[1, 2],\n                                   [3, 4]])  # 2x2 matrix\n        with self.assertRaises(ValueError):\n            get_scale(invalid_matrix)\n\n    def test_invalid_matrix_type(self):\n        \"\"\" Test for an invalid input type (not a numpy array) \"\"\"\n        invalid_matrix = [[1, 0, 0],\n                          [0, 1, 0],\n                          [0, 0, 1]]  # A list, not a numpy array\n        with self.assertRaises(ValueError):\n            get_scale(invalid_matrix)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_scale(matrix: np.ndarray) -> tuple[np.float64, np.float64]:\n    \"\"\"\n    Given a 3x3 affine transformation matrix, return the corresponding scaling factors\n    along the x and y axes.\n\n    Args:\n        matrix (np.ndarray): A 3x3 affine transformation matrix.\n\n    Returns:\n        tuple[np.float64, np.float64]: A tuple containing the scale factors (scale_x, scale_y).\n    \"\"\""}, {"task_id": 470, "code_type": "method", "code_language": "python", "test_code": "import numpy as np\nimport unittest\n\nclass TestShearTransformation(unittest.TestCase):\n    def test_identity_shear(self):\n        \"\"\" Test with zero shear factor which should return the original matrix unchanged. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 0\n        expected_output = np.array([[1, 2], [3, 4]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should remain unchanged with zero shear factor.\")\n\n    def test_positive_shear(self):\n        \"\"\" Test with a positive shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = 1\n        expected_output = np.array([[1, 3], [3, 7]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared.\")\n\n    def test_negative_shear(self):\n        \"\"\" Test with a negative shear factor. \"\"\"\n        matrix = np.array([[1, 2], [3, 4]])\n        shear_factor = -1\n        expected_output = np.array([[1, 1], [3, 1]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared negatively.\")\n\n\n    def test_high_shear_factor(self):\n        \"\"\" Test with a high shear factor to see how the matrix adapts to extreme transformations. \"\"\"\n        matrix = np.array([[1, 1], [1, 1]])\n        shear_factor = 10\n        expected_output = np.array([[1, 11], [1, 11]])\n        result = apply_shear_x(matrix, shear_factor)\n        np.testing.assert_array_equal(result, expected_output, \"The matrix should be correctly sheared with a high shear factor.\")", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef apply_shear_x(matrix: np.array, shear_factor: float):\n    \"\"\"\n    Applies a shear transformation to a 2D matrix along the x-axis.\n\n    Args:\n    matrix (np.ndarray): A 2D numpy array representing the original matrix.\n    shear_factor (float): The factor by which the matrix is sheared along the x-axis.\n\n    Returns:\n    np.ndarray: The sheared matrix.\n    \"\"\"\n"}, {"task_id": 471, "code_type": "method", "code_language": "python", "test_code": "import numpy as np\nimport unittest\n\n\nclass TestGetRotationFunction(unittest.TestCase):\n\n    def test_rotation_0_degrees(self):\n        \"\"\" Test for a rotation of 0 degrees (identity matrix) \"\"\"\n        matrix = np.array([[1, 0, 0],\n                           [0, 1, 0],\n                           [0, 0, 1]])\n        expected_rotation = 0.0\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_90_degrees(self):\n        \"\"\" Test for a rotation of 90 degrees \"\"\"\n        matrix = np.array([[0, -1, 0],\n                           [1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi / 2  # 90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_180_degrees(self):\n        \"\"\" Test for a rotation of 180 degrees \"\"\"\n        matrix = np.array([[-1, 0, 0],\n                           [0, -1, 0],\n                           [0, 0, 1]])\n        expected_rotation = np.pi  # 180 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_negative_90_degrees(self):\n        \"\"\" Test for a rotation of -90 degrees \"\"\"\n        matrix = np.array([[0, 1, 0],\n                           [-1, 0, 0],\n                           [0, 0, 1]])\n        expected_rotation = -np.pi / 2  # -90 degrees in radians\n        self.assertAlmostEqual(get_rotation(matrix), expected_rotation, places=6)\n\n    def test_rotation_invalid_matrix(self):\n        \"\"\" Test for an invalid matrix input \"\"\"\n        invalid_matrix = np.array([[1, 0], [0, 1]])  # Not a 3x3 matrix\n        with self.assertRaises(ValueError):\n            get_rotation(invalid_matrix)", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef get_rotation(matrix:np.array) -> float:\n    \"\"\"\n    Given an affine transformation matrix, return the corresponding rotation angle in radians.\n\n    Args:\n        matrix (np.array): A 2D affine transformation matrix.\n\n    Returns:\n        float: The rotation angle in radians, extracted from the affine matrix.\n    \"\"\""}, {"task_id": 473, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFlattenFunction(unittest.TestCase):\n\n    def test_flatten_simple(self):\n        self.assertEqual(flatten([1, 2, 3]), [1, 2, 3], \"Should flatten a simple flat list\")\n\n    def test_flatten_one_level_nesting(self):\n        self.assertEqual(flatten([1, [2, 3], 4]), [1, 2, 3, 4], \"Should flatten a list with one level of nesting\")\n\n    def test_flatten_multiple_nested_lists(self):\n        self.assertEqual(flatten([[1, 2], [3, 4], 5]), [1, 2, 3, 4, 5],\n                         \"Should flatten multiple nested lists at one level\")\n\n    def test_flatten_multiple_levels_nesting(self):\n        self.assertEqual(flatten([1, [2, [3, 4], 5], 6]), [1, 2, 3, 4, 5, 6],\n                         \"Should flatten a list with multiple levels of nesting\")\n\n    def test_flatten_with_empty_lists(self):\n        self.assertEqual(flatten([1, [], [2, [3, []], 4]]), [1, 2, 3, 4], \"Should flatten a list with empty lists\")", "prompt": "please write a python function , the function signature as below def flatten(nested_list):\n    \"\"\"\n    Flattens a nested list into a single list.\n\n    Args:\n        nested_list (list): A list that may contain nested lists.\n\n    Returns:\n        list: A flattened version of the input list.\n    \"\"\""}, {"task_id": 474, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nclass TestAreSiblings(unittest.TestCase):\n    def setUp(self):\n        # Setting up a binary tree used for all the test cases\n        self.tree = [1, 2, 3, 4, 5, 6, 7]\n\n    def test_basic_case(self):\n        # Test with nodes 4 and 5, which are siblings\n        result = are_siblings(self.tree, 4, 5)\n        self.assertTrue(result)\n\n    def test_non_sibling_case(self):\n        # Test with nodes 4 and 6, which are not siblings\n        result = are_siblings(self.tree, 4, 6)\n        self.assertFalse(result)\n\n    def test_root_node_case(self):\n        # Test with node 1 (root) and any other node, should return False\n        result = are_siblings(self.tree, 1, 2)\n        self.assertFalse(result)\n\n    def test_non_existent_values(self):\n        # Test with non-existent values\n        result = are_siblings(self.tree, 8, 9)\n        self.assertFalse(result)\n\n    def test_same_node_case(self):\n        # Test with the same node for both values\n        result = are_siblings(self.tree, 4, 4)\n        self.assertFalse(result)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef are_siblings(tree:List[int], val1:int, val2:int):\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    Args:\n        tree(List[int]): the binary tree level-order representation\n        val1(int):\n        val2(int):\n\n    Returns:\n\n    \"\"\"\n\n    \"\"\"\n    Determines if two values are siblings in a binary tree represented as an array.\n\n    :param tree: List[int], the binary tree level-order representation\n    :param val1: int, first value to check for sibling relationship\n    :param val2: int, second value to check for sibling relationship\n    :return: bool, True if val1 and val2 are siblings, False otherwise\n    \"\"\""}, {"task_id": 475, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSafeFormat(unittest.TestCase):\n\n    def test_full_replacement(self):\n        \"\"\"Test with all placeholders having corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\", place=\"Wonderland\")\n        expected = \"Hello, Alice! Welcome to Wonderland.\"\n        self.assertEqual(result, expected)\n\n    def test_partial_replacement(self):\n        \"\"\"Test with some placeholders missing corresponding values.\"\"\"\n        template = \"Hello, {name}! Welcome to {place}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"Hello, Alice! Welcome to {place}.\"\n        self.assertEqual(result, expected)\n\n    def test_no_replacement(self):\n        \"\"\"Test when no placeholders are provided.\"\"\"\n        template = \"Hello, world!\"\n        result = safe_format(template)\n        expected = \"Hello, world!\"\n        self.assertEqual(result, expected)\n\n    def test_missing_placeholder(self):\n        \"\"\"Test with a placeholder that has no corresponding value.\"\"\"\n        template = \"My name is {name}, and I live in {city}.\"\n        result = safe_format(template, name=\"Alice\")\n        expected = \"My name is Alice, and I live in {city}.\"\n        self.assertEqual(result, expected)\n\n    def test_numeric_values(self):\n        \"\"\"Test with numeric values as replacements.\"\"\"\n        template = \"Your score is {score} out of {total}.\"\n        result = safe_format(template, score=85, total=100)\n        expected = \"Your score is 85 out of 100.\"\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def safe_format(template, **kwargs):\n    \"\"\"\n    Safely formats a template string by replacing placeholders with corresponding values\n    from the provided keyword arguments. If a placeholder does not have a corresponding\n    value in kwargs, it remains unchanged.\n\n    Args:\n        template (str): The string template containing placeholders in the form {key}.\n        **kwargs: Keyword arguments that map keys to their replacement values.\n\n    Returns:\n        str: The formatted string with placeholders replaced by values.\n    \"\"\""}, {"task_id": 476, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestTopologicalSortDFS(unittest.TestCase):\n    def test_simple_chain(self):\n        vertices = [1, 2, 3]\n        edges = [(1, 2), (2, 3)]\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1, 2, 3])\n\n\n    def test_disconnected_graph(self):\n        vertices = [1, 2, 3, 4]\n        edges = [(1, 2)]\n        # There are multiple correct answers possible\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(3 in result and 4 in result)\n\n    def test_complex_graph(self):\n        vertices = [1, 2, 3, 4, 5, 6]\n        edges = [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (6, 1)]\n        result = topological_sort_dfs(vertices, edges)\n        self.assertTrue(result.index(1) < result.index(2))\n        self.assertTrue(result.index(1) < result.index(3))\n        self.assertTrue(result.index(2) < result.index(4))\n        self.assertTrue(result.index(3) < result.index(4))\n        self.assertTrue(result.index(4) < result.index(5))\n        self.assertTrue(result.index(6) < result.index(1))\n\n    def test_single_vertex(self):\n        vertices = [1]\n        edges = []\n        self.assertEqual(topological_sort_dfs(vertices, edges), [1])", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\n\ndef topological_sort_dfs(vertices: List[int], edges: List[Tuple]) -> List:\n    \"\"\"\n    achieve topological sorting, based on depth priority search\n\n    Args:\n        vertices (List[int]): A list of vertices in the graph. Each vertex should be a unique integer.\n        edges (List[Tuple[int, int]]): A list of tuples where each tuple represents a directed edge\n                                       in the graph and is formed as (start_vertex, end_vertex).\n\n    Returns:\n        List[int]: A list of vertices in topological order. If the graph contains a cycle,\n                   and thus cannot have a valid topological ordering, an empty list is returned.\n    \"\"\""}, {"task_id": 477, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\nclass EmptyClass:\n    pass\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\nclass TestCanClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertTrue(can_class_to_dict(person))\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertTrue(can_class_to_dict(car))\n\n    def test_regular_class_with_private_attribute(self):\n        dog = Dog(name=\"Buddy\", breed=\"Golden Retriever\")\n        self.assertTrue(can_class_to_dict(dog))\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertTrue(can_class_to_dict(empty))\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertTrue(can_class_to_dict(student))\n\n    def test_non_class_object(self):\n        number = 42\n        self.assertFalse(can_class_to_dict(number))\n", "prompt": "please write a python function , the function signature as below from typing import Any\n\ndef can_class_to_dict(obj: Any) -> bool:\n    \"\"\"\n    Check if the given object can be treated as a dictionary.\n\n    Args:\n        obj (Any): any type\n\n    Returns:\n        bool: can obj to dict\n    \"\"\""}, {"task_id": 478, "code_type": "method", "code_language": "python", "test_code": "import unittest\nfrom dataclasses import dataclass\n\n\n# The class_to_dict function should already be defined above.\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n\nclass Car:\n    def __init__(self, make: str, model: str):\n        self.make = make\n        self.model = model\n        self.year = 2020\n\n\nclass Dog:\n    def __init__(self, name: str, breed: str):\n        self.name = name\n        self.breed = breed\n        self._age = 5  # Private attribute\n\n\nclass EmptyClass:\n    pass\n\n\nclass Student:\n    school_name = \"Example School\"\n\n    def __init__(self, name: str):\n        self.name = name\n        self.grade = \"A\"\n\n\nclass TestClassToDict(unittest.TestCase):\n\n    def test_dataclass(self):\n        person = Person(name=\"Alice\", age=30)\n        self.assertEqual(class_to_dict(person), {'name': 'Alice', 'age': 30})\n\n    def test_regular_class(self):\n        car = Car(make=\"Toyota\", model=\"Corolla\")\n        self.assertEqual(class_to_dict(car), {'make': 'Toyota', 'model': 'Corolla', 'year': 2020})\n\n    def test_regular_class_with_private_attribute(self):\n        dog = Dog(name=\"Buddy\", breed=\"Golden Retriever\")\n        self.assertEqual(class_to_dict(dog), {'name': 'Buddy', 'breed': 'Golden Retriever', '_age': 5})\n\n    def test_empty_class(self):\n        empty = EmptyClass()\n        self.assertEqual(class_to_dict(empty), {})\n\n    def test_class_with_class_variable(self):\n        student = Student(name=\"John\")\n        self.assertEqual(class_to_dict(student), {'name': 'John', 'grade': 'A'})\n", "prompt": "please write a python function , the function signature as below from dataclasses import is_dataclass\nfrom typing import Any, Dict\n\n\ndef class_to_dict(obj: Any) -> Dict[str, Any]:\n    \"\"\"\n    Converts a dataclass or class instance to a dictionary.\n\n    Args:\n        obj: An instance of a dataclass or a class.\n\n    Returns:\n        A dictionary representation of the class or dataclass.\n    \"\"\"\n"}, {"task_id": 482, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestExtractOutermostBrackets(unittest.TestCase):\n    \n    def test_single_parentheses(self):\n        self.assertEqual(extract_outermost_brackets(\"Text (example) more text\"), \"example\")\n\n    def test_nested_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text {with some {nested} brackets}\"), \"with some {nested} brackets\")\n\n    def test_square_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"Text [with [nested] brackets] and more text\"), \"with [nested] brackets\")\n\n    def test_mixed_bracket_types(self):\n        self.assertEqual(extract_outermost_brackets(\"Mixed (types {of brackets [in use]})\"), \"types {of brackets [in use]}\")\n\n    def test_no_brackets(self):\n        self.assertEqual(extract_outermost_brackets(\"No brackets here\"), \"\")", "prompt": "please write a python function , the function signature as below def extract_outermost_brackets(s: str) -> str:\n    \"\"\"\n    Extracts the contents of the outermost brackets from the input string.\n    For example:\n        input: Text [with [nested] brackets] and more text\n        output: with [nested] brackets\n    Args:\n        s (str): The input string containing brackets.\n\n    Returns:\n        str: The contents within the outermost brackets, or an empty string if no brackets are found.\n    \"\"\"\n"}, {"task_id": 483, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestEmailValidation(unittest.TestCase):\n\n    def test_valid_email(self):\n        self.assertTrue(is_valid_email(\"test@example.com\"))\n\n    def test_valid_email_with_subdomain(self):\n        self.assertTrue(is_valid_email(\"user@subdomain.example.com\"))\n\n    def test_valid_email_with_plus_tag(self):\n        self.assertTrue(is_valid_email(\"user.name+tag+sorting@example.com\"))\n\n    def test_invalid_email_missing_username(self):\n        self.assertFalse(is_valid_email(\"@missingusername.com\"))\n\n    def test_invalid_email_missing_at_symbol(self):\n        self.assertFalse(is_valid_email(\"missingatsign.com\"))\n\n\n    def test_invalid_email_tld_too_short(self):\n        self.assertFalse(is_valid_email(\"user@domain.c\"))\n\n    def test_invalid_email_with_special_characters(self):\n        self.assertFalse(is_valid_email(\"user@domain.com!\"))\n\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"\n    Verifies if the provided string is a valid email address.\n\n    Args:\n        email (str):The email address to validate.\n\n    Returns:\n        bool: True if the email address is valid, False otherwise.\n    \"\"\"\n"}, {"task_id": 485, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\n# Assuming the prepare_query function is defined above or imported\n\nclass TestPrepareQuery(unittest.TestCase):\n\n    def test_valid_named_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n        parameters = {\n            'user_id': 42,\n            'status': 'active'\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\"\n        expected_values = [42, 'active']\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_missing_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $status\"\n        parameters = {\n            'user_id': 42  # 'status' is missing\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $2\"\n        expected_values = [42]  # 'status' is not included\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_no_parameters(self):\n        sql_query = \"SELECT * FROM users\"\n        parameters = {}  # No parameters provided\n        expected_sql = \"SELECT * FROM users\"\n        expected_values = []\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_multiple_same_parameters(self):\n        sql_query = \"SELECT * FROM users WHERE id = $user_id AND status = $user_id\"\n        parameters = {\n            'user_id': 42\n        }\n        expected_sql = \"SELECT * FROM users WHERE id = $1 AND status = $1\"\n        expected_values = [42]  # Only one value for 'user_id'\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)\n\n    def test_special_characters_in_parameters(self):\n        sql_query = \"INSERT INTO users (name, email) VALUES ($name, $email)\"\n        parameters = {\n            'name': \"John Doe\",\n            'email': \"john.doe@example.com\"\n        }\n        expected_sql = \"INSERT INTO users (name, email) VALUES ($1, $2)\"\n        expected_values = [\"John Doe\", \"john.doe@example.com\"]\n\n        new_sql, value_list = prepare_query(sql_query, parameters)\n        self.assertEqual(new_sql, expected_sql)\n        self.assertEqual(value_list, expected_values)", "prompt": "please write a python function , the function signature as below import re\n\n\ndef prepare_query(sql: str, params: dict) -> tuple:\n    \"\"\"\n    This function modifies a SQL query string containing named parameters\n    (like $name, $age) into a format compatible with libraries that require\n    positional parameters (like $1, $2, etc.), such as asyncpg. It returns\n    a tuple containing the modified SQL string and a list of parameter values\n    ordered according to their new positions in the query.\n    For example:\n        input:\n            sql: SELECT * FROM users WHERE id = $user_id AND status = $status\n            params: {'user_id': 42,'status': 'active'}\n        output:\n            SELECT * FROM users WHERE id = $1 AND status = $2,[42, 'active']\n\n    Args:\n        sql (str): The original SQL query string with named parameters.\n        params (dict): A dictionary mapping parameter names to their values.\n\n    Returns:\n        tuple: A tuple where the first element is the modified SQL query string with positional parameters, and the second element is a list of parameter values sorted according to the order of the positional parameters.\n    \"\"\""}, {"task_id": 486, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCalculator(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create an instance of Calculator before each test.\"\"\"\n        self.calculator = Calculator()\n\n    def test_add(self):\n        \"\"\"Test the addition method.\"\"\"\n        result = self.calculator.add(10, 5)\n        self.assertEqual(result, 15)\n\n    def test_subtract(self):\n        \"\"\"Test the subtraction method.\"\"\"\n        result = self.calculator.subtract(10, 5)\n        self.assertEqual(result, 5)\n\n    def test_multiply(self):\n        \"\"\"Test the multiplication method.\"\"\"\n        result = self.calculator.multiply(10, 5)\n        self.assertEqual(result, 50)\n\n    def test_divide(self):\n        \"\"\"Test the division method.\"\"\"\n        result = self.calculator.divide(10, 5)\n        self.assertEqual(result, 2.0)\n\n    def test_divide_by_zero(self):\n        \"\"\"Test division by zero raises ValueError.\"\"\"\n        with self.assertRaises(ValueError) as context:\n            self.calculator.divide(10, 0)\n        self.assertEqual(str(context.exception), \"Cannot divide by zero.\")", "prompt": "please write a python function , the function signature as below class Calculator:\n    def add(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the sum of a and b.\n        \"\"\"\n        pass\n\n    def subtract(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the difference of a and b.\n        \"\"\"\n        pass\n\n    def multiply(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the product of a and b.\n        \"\"\"\n        pass\n\n    def divide(self, a: float, b: float) -> float:\n        \"\"\"\n        Returns the quotient of a and b.\n        Raises ValueError if b is zero.\n        \"\"\"\n        pass\n"}, {"task_id": 487, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestContainsEmail(unittest.TestCase):\n\n    def test_contains_valid_email(self):\n        \"\"\"Test if a valid email is detected in the string.\"\"\"\n        test_string = \"You can reach me at example@example.com for more info.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_email_with_special_characters(self):\n        \"\"\"Test if an email with special characters is detected.\"\"\"\n        test_string = \"My email address is john.doe123+test@gmail.com!\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_does_not_contain_email(self):\n        \"\"\"Test a string that does not contain any email address.\"\"\"\n        test_string = \"This string does not have an email.\"\n        self.assertFalse(contains_email(test_string))\n\n    def test_contains_multiple_emails(self):\n        \"\"\"Test a string containing multiple email addresses.\"\"\"\n        test_string = \"You can contact me at example1@example.com or example2@example.com.\"\n        self.assertTrue(contains_email(test_string))\n\n    def test_contains_invalid_email_format(self):\n        \"\"\"Test a string with an invalid email format.\"\"\"\n        test_string = \"Please contact me at example@.com or test@domain.\"\n        self.assertFalse(contains_email(test_string))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef contains_email(text: str) -> bool:\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n        text (str): The string to search for an email address.\n\n    Returns:\n        bool: True if an email address is found, False otherwise.\n    \"\"\"\n\n\n    \"\"\"\n    Check if the given text contains an email address.\n\n    Args:\n    text (str): The string to search for an email address.\n\n    Returns:\n    bool: True if an email address is found, False otherwise.\n    \"\"\""}, {"task_id": 488, "code_type": "method", "code_language": "python", "test_code": "import subprocess\nimport unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIP(unittest.TestCase):\n\n    @patch('subprocess.run')\n    def test_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where a local IP is found\n        mock_run.return_value = MagicMock(stdout='192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_no_local_ip_found(self, mock_run):\n        # Mock the output of ipconfig for a case where no local IP is found\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_multiple_ips_found(self, mock_run):\n        # Mock the output with multiple local IPs\n        mock_run.return_value = MagicMock(stdout='10.0.0.5\\n'\n                                                  '192.168.1.10\\n')\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.10')\n\n    @patch('subprocess.run')\n    def test_invalid_command(self, mock_run):\n        # Simulate a case where subprocess.run raises a CalledProcessError\n        mock_run.side_effect = subprocess.CalledProcessError(1, 'ipconfig')\n        result = get_local_ip()\n        self.assertIsNone(result)\n\n    @patch('subprocess.run')\n    def test_unexpected_error(self, mock_run):\n        # Simulate an unexpected error\n        mock_run.side_effect = Exception(\"Unexpected error\")\n        result = get_local_ip()\n        self.assertIsNone(result)", "prompt": "please write a python function , the function signature as below import subprocess\nimport re\nfrom typing import Optional\n\n\ndef get_local_ip(interface: str = 'Wi-Fi') -> Optional[str]:\n    \"\"\"\n    Retrieve the local IP address of the specified network interface on Windows.\n\n    Args:\n        interface (str): The name of the network interface to check (default is 'Wi-Fi').\n\n    Returns:\n        Optional[str]: The local IP address if found, otherwise None.\n    \"\"\"\n"}, {"task_id": 490, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFormatStr(unittest.TestCase):\n\n    def test_simple_string(self):\n        \"\"\"Test a simple string input.\"\"\"\n        input_str = \"Hello, World!\"\n        expected_output = \"> Hello, World!\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_multiline_string(self):\n        \"\"\"Test a multiline string input.\"\"\"\n        input_str = \"Line 1\\nLine 2\\nLine 3\"\n        expected_output = \"> Line 1\\n> Line 2\\n> Line 3\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_code_block_delimiters_even(self):\n        \"\"\"Test a string with an even number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\\n```\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_code_block_delimiters_odd(self):\n        \"\"\"Test a string with an odd number of code block delimiters.\"\"\"\n        input_str = \"Some code:\\n```\\nprint('Hello')\"\n        expected_output = \"> Some code:\\n> ```\\n> print('Hello')\\n> ```\"\n        self.assertEqual(format_str(input_str), expected_output)\n\n    def test_non_string_input(self):\n        \"\"\"Test non-string input (e.g., integer) to ensure it's converted.\"\"\"\n        input_value = 123\n        expected_output = \"> 123\"\n        self.assertEqual(format_str(input_value), expected_output)", "prompt": "please write a python function , the function signature as below def format_str(x: str) -> str:\n    \"\"\"\n    Formats a string by prepending '> ' to each line and ensuring proper\n    formatting of code blocks.\n\n    Args:\n        x (str): The input string to be formatted. If the input is not a\n        string, it will be converted to one.\n\n    Returns:\n        str: The formatted string with each line prefixed by '> ' and\n        with balanced code block delimiters.\n    \"\"\"\n"}, {"task_id": 492, "code_type": "method", "code_language": "python", "test_code": "import os\nimport unittest\n\n\nclass TestSaveContentToFile(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up a temporary file path for testing.\"\"\"\n        self.test_file_path = 'test_output.txt'\n\n    def tearDown(self):\n        \"\"\"Clean up the test file after each test.\"\"\"\n        if os.path.exists(self.test_file_path):\n            os.remove(self.test_file_path)\n\n    def test_basic_content(self):\n        \"\"\"Test with basic content and check if it saves correctly.\"\"\"\n        content = \"Hello,  World!  \"\n        expected = \"Hello, World!\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_multiple_spaces_and_empty_lines(self):\n        \"\"\"Test handling of multiple spaces and empty lines.\"\"\"\n        content = \"\"\"\n\n        This is a    test.\n\n        Another line.      \n        \"\"\"\n        expected = \"This is a test. Another line.\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_only_whitespace(self):\n        \"\"\"Test if only whitespace is handled correctly.\"\"\"\n        content = \"    \\n  \\n   \"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_empty_content(self):\n        \"\"\"Test if empty content is saved correctly.\"\"\"\n        content = \"\"\n        expected = \"\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)\n\n    def test_content_with_special_characters(self):\n        \"\"\"Test if content with special characters is handled correctly.\"\"\"\n        content = \"This is a test!   \ud83d\ude0a  Let's see if it works.\"\n        expected = \"This is a test! \ud83d\ude0a Let's see if it works.\"\n        save_content_to_file(content, self.test_file_path)\n        with open(self.test_file_path, 'r', encoding='utf-8') as file:\n            result = file.read().strip()\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below def save_content_to_file(content: str, path: str) -> None:\n    \"\"\"\n    Saves the provided content to a specified file after cleaning up\n    redundant whitespace.\n\n    Args:\n        content (str): The text content to be saved to the file.\n        path (str): The file path where the content will be saved.\n\n    Returns:\n        None\n    \"\"\""}, {"task_id": 493, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestWrapContentGenerator(unittest.TestCase):\n\n    def test_empty_content(self):\n        \"\"\"Test with empty content.\"\"\"\n        result = list(wrap_content_generator(\"\"))\n        self.assertEqual(result, [])\n\n    def test_single_line_content(self):\n        \"\"\"Test with a single line of content within default width.\"\"\"\n        result = list(wrap_content_generator(\"Hello, world!\"))\n        self.assertEqual(result, [\"Hello, world!\"])\n\n    def test_multi_line_content(self):\n        \"\"\"Test with multiple lines of content each fitting within default width.\"\"\"\n        content = \"Hello\\nWorld\\nPython\"\n        result = list(wrap_content_generator(content))\n        self.assertEqual(result, [\"Hello\", \"World\", \"Python\"])\n\n    def test_long_line(self):\n        \"\"\"Test with a single long line that exceeds the default width.\"\"\"\n        content = \"This is a very long line that should definitely be wrapped around the default width of 80 characters.\"\n        result = list(wrap_content_generator(content))\n        self.assertTrue(len(max(result, key=len)) <= 80)\n\n    def test_custom_width(self):\n        \"\"\"Test with a custom width.\"\"\"\n        content = \"This is a test for custom width setting.\"\n        result = list(wrap_content_generator(content, width=10))\n        self.assertTrue(all(len(line) <= 10 for line in result))\n\n    def test_only_whitespaces(self):\n        \"\"\"Test content that contains only whitespace characters.\"\"\"\n        result = list(wrap_content_generator(\"     \"))\n        self.assertEqual(result, [\"\\n\"])", "prompt": "please write a python function , the function signature as below import textwrap\n\n\ndef wrap_content_generator(content: str, width=80):\n    \"\"\"\n    Wrap the text content to the specified maximum width and generate these lines line by line\n\n    Args:\n        content (str): The content to be wrapped and yielded line by line.\n        width (str): The maximum width of the lines, default is 80 characters.\n\n    Yields:\n        str: Each line of the content wrapped to the specified width.\n    \"\"\"\n"}, {"task_id": 494, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCleanDictionary(unittest.TestCase):\n\n    def test_valid_strings(self):\n        \"\"\" Test a dictionary with valid strings. \"\"\"\n        input_dict = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        expected_output = {\n            'key1': 'valid string',\n            'key2': 'another valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_none_and_nan(self):\n        \"\"\" Test a dictionary with None and NaN values. \"\"\"\n        input_dict = {\n            'key1': None,\n            'key2': np.nan,\n            'key3': 'valid string'\n        }\n        expected_output = {\n            'key3': 'valid string'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n    def test_whitespace_strings(self):\n        \"\"\" Test a dictionary with whitespace strings. \"\"\"\n        input_dict = {\n            'key1': '   ',\n            'key2': '',\n            'key3': 'valid'\n        }\n        expected_output = {\n            'key3': 'valid'\n        }\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n\n\n    def test_empty_dictionary(self):\n        \"\"\" Test an empty dictionary. \"\"\"\n        input_dict = {}\n        expected_output = {}\n        self.assertEqual(clean_dictionary(input_dict), expected_output)\n", "prompt": "please write a python function , the function signature as below from typing import Dict\n\n\ndef clean_dictionary(input_dict:Dict) -> Dict:\n    \"\"\"\n    Cleans the input dictionary by removing keys with invalid values.Valid values are non-NaN, non-None, and non-whitespace strings.\n\n    Args:\n        input_dict (Dict): A dictionary to be cleaned.\n\n    Returns:\n        Dict: A new dictionary containing only valid values.\n    \"\"\""}, {"task_id": 495, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFilterContentWithContext(unittest.TestCase):\n\n    def test_single_keyword_match(self):\n        \"\"\"Test a single keyword match with context lines.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to filter content for a single keyword.\")\n\n    def test_multiple_keywords(self):\n        \"\"\"Test multiple keywords with overlapping context.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Another keyword is here.\n        Line four.\"\"\"\n        keywords = [\"keyword\", \"Another\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Another keyword is here.\n        Line four.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to filter content for multiple keywords.\")\n\n    def test_no_keyword_match(self):\n        \"\"\"Test when no keywords match.\"\"\"\n        content = \"\"\"Line one.\n        Line two.\n        Line three.\"\"\"\n        keywords = [\"missing\"]\n        expected_output = \"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output, \"Failed to return empty string for no matches.\")\n\n\n    def test_lines_before_and_after(self):\n        \"\"\"Test functionality with specified lines before and after.\"\"\"\n        content = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\n        Line four.\n        Line five.\"\"\"\n        keywords = [\"keyword\"]\n        expected_output = \"\"\"Line one.\n        This line contains a keyword.\n        Line three.\"\"\"\n        result = filter_content_with_context(content, keywords, lines_before=1, lines_after=1)\n        self.assertEqual(result.strip(), expected_output.strip(), \"Failed to correctly include context lines.\")\n", "prompt": "please write a python function , the function signature as below import re\nfrom typing import List\n\n\ndef filter_content_with_context(\n        content: str,\n        keywords: List[str],\n        lines_before: int = 1,\n        lines_after: int = 1\n) -> str:\n    \"\"\"\n    Filters website content to include lines containing any of the specified keywords as whole words,\n    along with a specified number of lines before and after for context. This version uses regular expressions\n    to ensure exact, whole word matching and respects case sensitivity.\n\n    Args:\n        content (str): The full text content of the website.\n        keywords (List[str]): A list of strings to search for within the content.\n        lines_before (int): Number of lines to include before a matching line.\n        lines_after (int): Number of lines to include after a matching line.\n\n    Returns:\n        str: A string containing the filtered content with additional context.\n    \"\"\"\n"}, {"task_id": 496, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestPascalTriangleRow(unittest.TestCase):\n\n    def test_row_0(self):\n        \"\"\" Test the 0th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(0), [1])\n\n    def test_row_1(self):\n        \"\"\" Test the 1st row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(1), [1, 1])\n\n    def test_row_2(self):\n        \"\"\" Test the 2nd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(2), [1, 2, 1])\n\n    def test_row_3(self):\n        \"\"\" Test the 3rd row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(3), [1, 3, 3, 1])\n\n    def test_row_4(self):\n        \"\"\" Test the 4th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(4), [1, 4, 6, 4, 1])\n\n    def test_row_5(self):\n        \"\"\" Test the 5th row of Pascal's Triangle. \"\"\"\n        self.assertEqual(pascal_triangle_row(5), [1, 5, 10, 10, 5, 1])\n", "prompt": "please write a python function , the function signature as below import math\nfrom typing import List\n\n\ndef pascal_triangle_row(i: int) -> List:\n    \"\"\"\n    Generates the ith row of Pascal's Triangle.\n\n    Args:\n        i (int): Row index (0-indexed)\n\n    Returns:\n        List: A list representing the ith row of Pascal's Triangle\n    \"\"\"\n"}, {"task_id": 497, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestBroadcastIndex(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Set up sample data for testing.\"\"\"\n        # Data for a standard case\n        self.big_index = [0, 2, 1]\n        self.big_shape = (3, 4, 5)\n        self.shape = (4, 5)\n\n        # Prepare an output index for the standard case\n        self.out_index = [0] * len(self.shape)\n\n    def test_standard_case(self):\n        \"\"\"Test standard broadcasting behavior.\"\"\"\n        broadcast_index(self.big_index, self.big_shape, self.shape, self.out_index)\n        self.assertEqual(self.out_index, [2, 1], \"Failed to correctly broadcast standard case.\")\n\n    def test_shape_with_one_dimension(self):\n        \"\"\"Test case where shape contains a dimension of size 1.\"\"\"\n        shape_with_one = (1, 5)\n        out_index_with_one = [0] * len(shape_with_one)\n        broadcast_index(self.big_index, self.big_shape, shape_with_one, out_index_with_one)\n        self.assertEqual(out_index_with_one, [0, 1], \"Failed to handle shape with one dimension.\")\n\n    def test_empty_shape(self):\n        \"\"\"Test case with an empty shape.\"\"\"\n        empty_shape = ()\n        out_index_empty = []\n        broadcast_index(self.big_index, self.big_shape, empty_shape, out_index_empty)\n        self.assertEqual(out_index_empty, [], \"Failed to handle empty shape.\")\n\n    def test_bigger_shape(self):\n        \"\"\"Test case where the big_shape is larger than the shape.\"\"\"\n        big_index = [1, 2, 3]\n        big_shape = (4, 5, 6)\n        shape = (6,)\n        out_index_big = [0] * len(shape)\n        broadcast_index(big_index, big_shape, shape, out_index_big)\n        self.assertEqual(out_index_big, [3], \"Failed to handle bigger shape case.\")\n\n    def test_shape_with_multiple_ones(self):\n        \"\"\"Test case with multiple dimensions of size 1 in shape.\"\"\"\n        shape_multiple_ones = (1, 4, 1)\n        out_index_multiple_ones = [0] * len(shape_multiple_ones)\n        broadcast_index(self.big_index, self.big_shape, shape_multiple_ones, out_index_multiple_ones)\n        self.assertEqual(out_index_multiple_ones, [0, 2, 0], \"Failed to handle shape with multiple ones.\")", "prompt": "please write a python function , the function signature as below from typing import List, Tuple\n\nIndex = List[int]\nShape = Tuple[int, ...]\nOutIndex = List[int]\n\n\ndef broadcast_index(\n        big_index: Index,\n        big_shape: Shape,\n        shape: Shape,\n        out_index: OutIndex\n) -> None:\n    \"\"\"\n    Convert a `big_index` into `big_shape` to a smaller `out_index`\n    following broadcasting rules. The `out_index` may be larger or\n    have more dimensions than the `shape` given. Additional dimensions\n    may need to be mapped to 0 or removed.\n\n    Args:\n        big_index (Index): Multidimensional index of the larger tensor.\n        big_shape (Shape): Shape of the larger tensor.\n        shape (Shape): Shape of the smaller tensor.\n        out_index (OutIndex): Multidimensional index of the smaller tensor.\n\n    Returns:\n        None: The function modifies `out_index` in place.\n    \"\"\""}, {"task_id": 498, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestComputeMD5(unittest.TestCase):\n\n    def test_empty_string(self):\n        \"\"\" Test the MD5 hash of an empty string. \"\"\"\n        self.assertEqual(compute_md5(''), 'd41d8cd98f00b204e9800998ecf8427e')\n\n    def test_simple_string(self):\n        \"\"\" Test the MD5 hash of a simple string. \"\"\"\n        self.assertEqual(compute_md5('Hello, World!'), '65a8e27d8879283831b664bd8b7f0ad4')\n\n    def test_numeric_string(self):\n        \"\"\" Test the MD5 hash of a numeric string. \"\"\"\n        self.assertEqual(compute_md5('123456'), 'e10adc3949ba59abbe56e057f20f883e')\n\n    def test_special_characters(self):\n        \"\"\" Test the MD5 hash of a string with special characters. \"\"\"\n        self.assertEqual(compute_md5('!@#$%^&*()'), '05b28d17a7b6e7024b6e5d8cc43a8bf7')\n\n    def test_long_string(self):\n        \"\"\" Test the MD5 hash of a long string. \"\"\"\n        long_string = 'a' * 1000  # A string of 1000 'a' characters\n        expected_hash = 'cabe45dcc9ae5b66ba86600cca6b8ba8'  # MD5 of 'aaaa....' (1000 'a's)\n        self.assertEqual(compute_md5(long_string), expected_hash)", "prompt": "please write a python function , the function signature as below import hashlib\n\n\ndef compute_md5(input_string: str) -> str:\n    \"\"\"\n    Computes and returns the MD5 hash of the input string.\n\n    Args:\n        input_string (str): The string to be hashed\n\n    Returns:\n        str: he MD5 hash of the input string in hexadecimal format\n    \"\"\"\n"}, {"task_id": 499, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCleanPattern(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Sets up a common regex pattern for testing.\"\"\"\n        self.pattern = r'(\\d+\\.?\\d*) kg'  # Regex pattern to match weight in kg\n\n    def test_valid_integer_weight(self):\n        \"\"\"Test case for valid integer weight.\"\"\"\n        input_string = \"The weight is 25 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 25.0)\n\n    def test_valid_float_weight(self):\n        \"\"\"Test case for valid float weight.\"\"\"\n        input_string = \"Weight measured at 15.75 kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 15.75)\n\n    def test_no_weight_found(self):\n        \"\"\"Test case where no weight is present.\"\"\"\n        input_string = \"No weight provided.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_invalid_float_conversion(self):\n        \"\"\"Test case for non-numeric weight.\"\"\"\n        input_string = \"The weight is thirty kg\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, '')\n\n    def test_weight_with_extra_text(self):\n        \"\"\"Test case for weight with additional text.\"\"\"\n        input_string = \"The total weight is 45.3 kg as per the last measurement.\"\n        result = clean_pattern(input_string, self.pattern)\n        self.assertEqual(result, 45.3)\n", "prompt": "please write a python function , the function signature as below import re\nfrom typing import Union\n\n\ndef clean_pattern(x: str, pattern: str) -> Union[str,float]:\n    \"\"\"\n    Extracts a numeric value from the input string based on the given regex pattern.\n\n    Args:\n        x (str or any): The input from which to extract the value. It will be converted to a string.\n        pattern (str): The regular expression pattern to use for matching.\n\n    Returns:\n        Union[str,float]: The extracted weight value if a match is found, otherwise an empty string.\n    \"\"\"\n"}, {"task_id": 500, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestConvertScoreToDecimal(unittest.TestCase):\n\n    def test_decimal_score(self):\n        \"\"\" Test a simple decimal score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"2.5\"), 2.5)\n\n    def test_fraction_score(self):\n        \"\"\" Test a fraction score. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"10/4\"), 2.5)\n\n    def test_integer_score(self):\n        \"\"\" Test an integer score represented as a string. \"\"\"\n        self.assertEqual(convert_score_to_decimal(\"5\"), 5.0)\n\n    def test_integer_divide_score(self):\n        self.assertEqual(convert_score_to_decimal(\"12/3\"), 4.0)", "prompt": "please write a python function , the function signature as below def convert_score_to_decimal(score_str: str) -> float:\n    \"\"\"\n    Converts the string representation of a score to its decimal value.\n    For example:\n        input: 10/4\n        output: 2.5\n    Args:\n        score_str (str): The score as a string, can be a decimal or a fraction\n\n    Returns:\n        float: The decimal value of the score as a float, or None if the input is invalid\n    \"\"\"\n"}, {"task_id": 501, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestConvertToShortFormat(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\" Test a standard input with mixed characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"f1_p1_g1_b1_c1\"), \"fpgbc\")\n\n    def test_multiple_segments(self):\n        \"\"\" Test input with multiple segments. \"\"\"\n        self.assertEqual(convert_to_short_format(\"a2_b3_c4\"), \"abc\")\n\n    def test_non_alpha_numeric(self):\n        \"\"\" Test input with non-alphanumeric characters. \"\"\"\n        self.assertEqual(convert_to_short_format(\"hello_world_test\"), \"hwt\")\n\n    def test_single_segment(self):\n        \"\"\" Test a single segment input. \"\"\"\n        self.assertEqual(convert_to_short_format(\"single\"), \"s\")\n", "prompt": "please write a python function , the function signature as below def convert_to_short_format(input_str) -> str:\n    \"\"\"\n    Converts a string concatenated with underscores to a short format.\n    For example:\n        input: f1_p1_g1_b1_c1\n        output: fpgbc\n    Args:\n        input_str (str): The input string with segments separated by underscores.\n\n    Returns:\n        str: A short format string derived from the first characters of each segment.\n    \"\"\"\n"}, {"task_id": 505, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCamelToSnake(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic CamelCase to snake_case conversion. \"\"\"\n        self.assertEqual(camel_to_snake(\"HelloWorld\"), \"hello_world\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a CamelCase string with multiple words. \"\"\"\n        self.assertEqual(camel_to_snake(\"ThisIsATest\"), \"this_is_a_test\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(camel_to_snake(\"ConvertThis123String\"), \"convert_this123_string\")\n\n    def test_leading_uppercase(self):\n        \"\"\" Test conversion with leading uppercase letters. \"\"\"\n        self.assertEqual(camel_to_snake(\"PythonFunction\"), \"python_function\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(camel_to_snake(\"\"), \"\")\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"\n    Convert a CamelCase string to snake_case.\n\n    Args:\n        camel_str (str): The CamelCase string to convert.\n\n    Returns:\n        str: The converted snake_case string.\n    \"\"\"\n"}, {"task_id": 506, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestSnakeToCamel(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\" Test basic snake_case to CamelCase conversion. \"\"\"\n        self.assertEqual(snake_to_camel(\"hello_world\"), \"HelloWorld\")\n\n    def test_multiple_words(self):\n        \"\"\" Test conversion of a snake_case string with multiple words. \"\"\"\n        self.assertEqual(snake_to_camel(\"this_is_a_test\"), \"ThisIsATest\")\n\n    def test_with_numbers(self):\n        \"\"\" Test conversion with numbers in the string. \"\"\"\n        self.assertEqual(snake_to_camel(\"convert_this_123_string\"), \"ConvertThis123String\")\n\n    def test_leading_trailing_underscores(self):\n        \"\"\" Test conversion with leading and trailing underscores. \"\"\"\n        self.assertEqual(snake_to_camel(\"_leading_and_trailing_\"), \"LeadingAndTrailing\")\n        self.assertEqual(snake_to_camel(\"___multiple___underscores___\"), \"MultipleUnderscores\")\n\n    def test_empty_string(self):\n        \"\"\" Test conversion of an empty string. \"\"\"\n        self.assertEqual(snake_to_camel(\"\"), \"\")", "prompt": "please write a python function , the function signature as below def snake_to_camel(snake_str: str) -> str:\n    \"\"\"\n    Convert a snake_case string to CamelCase.\n\n    Args:\n        snake_str (str): The snake_case string to convert.\n\n    Returns:\n        str: The converted CamelCase string.\n    \"\"\"\n"}, {"task_id": 507, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestStrongPassword(unittest.TestCase):\n    def test_valid_password(self):\n        \"\"\" Test a strong password that meets all criteria. \"\"\"\n        self.assertTrue(is_strong_password(\"StrongPass1\"))\n\n    def test_missing_lowercase(self):\n        \"\"\" Test a password missing a lowercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"STRONGPASS1\"))\n\n    def test_missing_uppercase(self):\n        \"\"\" Test a password missing an uppercase letter. \"\"\"\n        self.assertFalse(is_strong_password(\"strongpass1\"))\n\n    def test_missing_number(self):\n        \"\"\" Test a password missing a number. \"\"\"\n        self.assertFalse(is_strong_password(\"StrongPassword\"))\n\n    def test_too_short(self):\n        \"\"\" Test a password that is too short. \"\"\"\n        self.assertFalse(is_strong_password(\"Short1\"))\n\n    def test_valid_with_special_characters(self):\n        \"\"\" Test a password that includes special characters but is still strong. \"\"\"\n        self.assertTrue(is_strong_password(\"Strong!Password1\"))", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_strong_password(password: str) -> bool:\n    \"\"\"\n    Check if the provided password is strong.\n\n    A strong password must satisfy the following criteria:\n    - At least one lowercase letter\n    - At least one uppercase letter\n    - At least one number\n    - At least 8 characters long\n\n    Args:\n        password (str): The password to check.\n\n    Returns:\n        bool: True if the password is strong, False otherwise.\n    \"\"\"\n"}, {"task_id": 509, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestModExp(unittest.TestCase):\n    def test_case_1(self):\n        \"\"\" Test with base = 2, exponent = 10, modulus = 1000 \"\"\"\n        self.assertEqual(mod_exp(2, 10, 1000), 24)\n\n    def test_case_2(self):\n        \"\"\" Test with base = 3, exponent = 7, modulus = 50 \"\"\"\n        self.assertEqual(mod_exp(3, 7, 50), 37)\n\n    def test_case_3(self):\n        \"\"\" Test with base = 5, exponent = 0, modulus = 13 (any number^0 = 1) \"\"\"\n        self.assertEqual(mod_exp(5, 0, 13), 1)\n\n    def test_case_4(self):\n        \"\"\" Test with base = 7, exponent = 5, modulus = 20 \"\"\"\n        self.assertEqual(mod_exp(7, 5, 20), 7)  # 7^5 = 16807, 16807 % 20 = 7\n\n    def test_case_5(self):\n        \"\"\" Test with base = 10, exponent = 5, modulus = 6 \"\"\"\n        self.assertEqual(mod_exp(10, 5, 6), 4)  # 10^5 = 100000, 100000 % 6 = 4", "prompt": "please write a python function , the function signature as below def mod_exp(base:int, exponent:int, modulus:int) -> int:\n    \"\"\"\n    Perform modular exponentiation: (base^exponent) % modulus efficiently.\n\n    Args:\n        base (int): The base value.\n        exponent (int): The exponent value (should be non-negative).\n        modulus (int): The modulus value (should be positive).\n\n    Returns:\n        int: The result of (base^exponent) % modulus.\n    \"\"\""}, {"task_id": 510, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFindPowers(unittest.TestCase):\n\n    def test_valid_cases(self):\n        \"\"\"Test valid numbers with only 2's and 3's as prime factors.\"\"\"\n        self.assertEqual(find_powers(18), (1, 2))  # 18 = 2^1 * 3^2\n        self.assertEqual(find_powers(8), (3, 0))   # 8 = 2^3 * 3^0\n        self.assertEqual(find_powers(27), (0, 3))  # 27 = 2^0 * 3^3\n        self.assertEqual(find_powers(12), (2, 1))  # 12 = 2^2 * 3^1\n        self.assertEqual(find_powers(1), (0, 0))    # 1 = 2^0 * 3^0\n\n    def test_invalid_cases(self):\n        \"\"\"Test numbers with prime factors other than 2 and 3.\"\"\"\n        self.assertIsNone(find_powers(7))    # 7 is a prime factor\n        self.assertIsNone(find_powers(14))   # 14 = 2^1 * 7^1 (contains 7)\n        self.assertIsNone(find_powers(10))   # 10 = 2^1 * 5^1 (contains 5)\n\n\n    def test_large_numbers(self):\n        \"\"\"Test large numbers that have only 2 and 3 as prime factors.\"\"\"\n        self.assertEqual(find_powers(864), (5, 3))  # 864 = 2^5 * 3^3\n        self.assertEqual(find_powers(729), (0, 6))  # 729 = 2^0 * 3^6\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases for minimal inputs.\"\"\"\n        self.assertEqual(find_powers(2), (1, 0))   # 2 = 2^1 * 3^0\n        self.assertEqual(find_powers(3), (0, 1))   # 3 = 2^0 * 3^1", "prompt": "please write a python function , the function signature as below def find_powers(num: int) -> tuple:\n    \"\"\"\n    Find the powers of 2 and 3 that multiply to produce the given number.\n\n    Args:\n        num (int): A positive integer greater than zero.\n\n    Returns:\n        tuple: A tuple (n, m) where n is the power of 2 and m is the power of 3.\n           Returns None if the number is zero or if the number has prime factors other than 2 and 3.\n    \"\"\"\n"}, {"task_id": 511, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestHexToAnsi(unittest.TestCase):\n\n    def test_valid_colors(self):\n        \"\"\"Test valid hex color inputs.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#FF5733\"), \"\\x1b[38;2;255;87;51m\")\n        self.assertEqual(hex_to_ansi(\"#00FF00\"), \"\\x1b[38;2;0;255;0m\")\n        self.assertEqual(hex_to_ansi(\"#0000FF\"), \"\\x1b[38;2;0;0;255m\")\n\n    def test_black_and_white(self):\n        \"\"\"Test edge cases with black and white colors.\"\"\"\n        self.assertEqual(hex_to_ansi(\"#000000\"), \"\\x1b[38;2;0;0;0m\")  # Black\n        self.assertEqual(hex_to_ansi(\"#FFFFFF\"), \"\\x1b[38;2;255;255;255m\")  # White\n", "prompt": "please write a python function , the function signature as below def hex_to_ansi(hex_color: str) -> str:\n    \"\"\"\n    Convert a hexadecimal color code to an ANSI escape code.\n\n    Args:\n        hex_color (str): A string representing the hexadecimal color code, e.g., '#FF5733'.\n\n    Returns:\n        str: An ANSI escape code for the specified RGB color.\n    \"\"\"\n"}, {"task_id": 512, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestConvertToRingFormat(unittest.TestCase):\n\n    def test_no_holes(self):\n        \"\"\" Test with no holes provided. \"\"\"\n        holes = []\n        expected = [1] * 32  # All positions should be 1\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_single_hole(self):\n        \"\"\" Test with a single hole position. \"\"\"\n        holes = [5]\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_multiple_holes(self):\n        \"\"\" Test with multiple hole positions. \"\"\"\n        holes = [0, 2, 4, 8, 16]\n        expected = [1] * 32\n        for hole in holes:\n            expected[hole] = 0  # Set specified positions to 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_hole_out_of_bounds(self):\n        \"\"\" Test with some hole positions out of bounds. \"\"\"\n        holes = [-1, 32, 5, 10]  # -1 and 32 are out of bounds\n        expected = [1] * 32\n        expected[5] = 0  # Only position 5 and 10 should be 0\n        expected[10] = 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)\n\n    def test_all_holes(self):\n        \"\"\" Test with all positions as holes. \"\"\"\n        holes = list(range(32))  # All positions from 0 to 31\n        expected = [0] * 32  # All positions should be 0\n        result = convert_to_ring_format(holes)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef convert_to_ring_format(holes: List) -> List:\n    \"\"\"\n    Convert a list of hole positions to the ring format (list of 1s and 0s).\n\n    Args:\n        holes (list): A list of integers representing the positions of the holes (0-indexed).\n\n    Returns:\n        List: A list of length 32, where positions with holes are 0 and others are 1.\n\n    \"\"\"\n"}, {"task_id": 513, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestIsPhraseInStringIgnoreCase(unittest.TestCase):\n\n    def test_exact_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"hello world\", \"Hello World\"))\n\n    def test_variation_in_whitespace(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"hello world\", \"   hello    world   \"))\n        self.assertTrue(is_phrase_in_string_ignore_case(\"Hello World\", \"hello  world\"))\n\n    def test_partial_word_match_case_insensitive(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"Hello\", \"saying Hello there\"))\n\n    def test_different_cases(self):\n        self.assertTrue(is_phrase_in_string_ignore_case(\"HELLO\", \"hello there!\"))\n        self.assertTrue(is_phrase_in_string_ignore_case(\"world\", \"WORLD is great\"))\n\n    def test_non_existent_phrase(self):\n        self.assertFalse(is_phrase_in_string_ignore_case(\"goodbye\", \"Hello world\"))\n        self.assertFalse(is_phrase_in_string_ignore_case(\"hello\", \"goodbye world\"))\n\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef is_phrase_in_string_ignore_case(phrase: str, string: str) -> bool:\n    \"\"\"\n    Check if the given phrase exists in the target string, ignoring case and allowing for variations in whitespace.\n\n    Args:\n        phrase (str): The phrase to search for in the string.\n        string (str): The target string in which to search for the phrase.\n\n    Returns:\n        bool: True if the phrase is found as a whole word in the string, False otherwise.\n    \"\"\"\n"}, {"task_id": 514, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestExtractDateFromFilename(unittest.TestCase):\n\n    def test_date_extraction_success(self):\n        \"\"\"Test case where the date is successfully extracted.\"\"\"\n        file_name = \"report-2023-09-28.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_no_date_in_filename(self):\n        \"\"\"Test case where no date is present in the filename.\"\"\"\n        file_name = \"report.txt\"\n        self.assertIsNone(extract_date_from_filename(file_name))\n\n    def test_multiple_dates_in_filename(self):\n        \"\"\"Test case where multiple dates are present, should return the first one.\"\"\"\n        file_name = \"report-2023-09-28-backup-2023-10-01.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_date_at_start_of_filename(self):\n        \"\"\"Test case where the date is at the start of the filename.\"\"\"\n        file_name = \"2023-09-28-report.txt\"\n        expected_date = \"2023-09-28\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n\n    def test_incorrect_date_format(self):\n        \"\"\"Test case where the date format is incorrect.\"\"\"\n        file_name = \"report-2023-99-99.txt\"  # Invalid date\n        expected_date = \"2023-99-99\"\n        self.assertEqual(extract_date_from_filename(file_name), expected_date)\n", "prompt": "please write a python function , the function signature as below import re\n\n\ndef extract_date_from_filename(file_name: str):\n    \"\"\"\n    Extracts the date in the format YYYY-MM-DD from the given file name.\n\n    Args:\n        file_name (str): The name of the file which may contain a date.\n\n    Returns:\n        str or None: The extracted date string in YYYY-MM-DD format if found, else None.\n    \"\"\"\n"}, {"task_id": 515, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestFormatDateString(unittest.TestCase):\n\n    def test_valid_date_conversion(self):\n        \"\"\"Test case for a valid date string.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000 (UTC)\"\n        expected_date = \"2023-09-28_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)\n\n    def test_invalid_date_format(self):\n        \"\"\"Test case for an invalid date string format.\"\"\"\n        date_str = \"Invalid date format\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_missing_components(self):\n        \"\"\"Test case for a date string missing components.\"\"\"\n        date_str = \"Fri, 28 Sep 2023 14:45:00 +0000\"\n        self.assertIsNone(format_date_string(date_str))\n\n    def test_edge_case_date(self):\n        \"\"\"Test case for an edge case date string (e.g., leap year).\"\"\"\n        date_str = \"Sun, 29 Feb 2024 14:45:00 +0000 (UTC)\"\n        expected_date = \"2024-02-29_14:45:00\"\n        self.assertEqual(format_date_string(date_str), expected_date)", "prompt": "please write a python function , the function signature as below from datetime import datetime\n\ndef format_date_string(date_str:str):\n    \"\"\"\n    Converts a date string from the format '%a, %d %b %Y %H:%M:%S %z (%Z)'\n    to the format '%Y-%m-%d_%H:%M:%S'.\n\n    Args:\n        date_str (str): The input date string.\n\n    Returns:\n        str: The formatted date string in the format '%Y-%m-%d_%H:%M:%S'.\n        None: If the input date string is invalid.\n    \"\"\""}, {"task_id": 516, "code_type": "method", "code_language": "python", "test_code": "import os\nimport unittest\n\nimport yaml\n\n\nclass TestReadYaml(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a temporary YAML file for testing.\"\"\"\n        self.valid_yaml_file = 'test_valid.yaml'\n        self.invalid_yaml_file = 'test_invalid.yaml'\n        self.non_existent_file = 'non_existent.yaml'\n\n        # Valid YAML content\n        with open(self.valid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\n\")\n\n        # Invalid YAML content\n        with open(self.invalid_yaml_file, 'w') as file:\n            file.write(\"name: Example\\nversion: 1.0\\ndependencies:\\n  - package1\\n  - package2\\ninvalid_yaml: \\n - \")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary YAML files after testing.\"\"\"\n        if os.path.isfile(self.valid_yaml_file):\n            os.remove(self.valid_yaml_file)\n        if os.path.isfile(self.invalid_yaml_file):\n            os.remove(self.invalid_yaml_file)\n\n    def test_read_valid_yaml(self):\n        \"\"\"Test reading a valid YAML file.\"\"\"\n        expected_data = {\n            'name': 'Example',\n            'version': 1.0,\n            'dependencies': ['package1', 'package2']\n        }\n        result = read_yaml(self.valid_yaml_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_yaml(self.non_existent_file)\n\n\n    def test_empty_yaml_file(self):\n        \"\"\"Test reading an empty YAML file.\"\"\"\n        empty_yaml_file = 'test_empty.yaml'\n        with open(empty_yaml_file, 'w') as file:\n            file.write(\"\")  # Create an empty YAML file\n\n        result = read_yaml(empty_yaml_file)\n        self.assertIsNone(result)  # Expecting None for empty file\n\n        os.remove(empty_yaml_file)  # Cleanup after the test", "prompt": "please write a python function , the function signature as below import os\n\n\ndef read_yaml(file_path: str):\n    \"\"\"\n    Reads a YAML file and returns its content as a Python dictionary or list.\n\n    Args:\n        file_path (str): The path to the YAML file.\n\n    Returns:\n        dict or list: Parsed YAML content as a Python data structure.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        yaml.YAMLError: If there is an error parsing the YAML file.\n    \"\"\""}, {"task_id": 517, "code_type": "method", "code_language": "python", "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestReadJsonl(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create temporary JSON Lines files for testing.\"\"\"\n        self.valid_jsonl_file = 'test_valid.jsonl'\n        self.invalid_jsonl_file = 'test_invalid.jsonl'\n        self.non_existent_file = 'non_existent.jsonl'\n\n        # Valid JSON Lines content\n        with open(self.valid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": 25}\\n')\n            file.write('{\"name\": \"Charlie\", \"age\": 35}\\n')\n\n        # Invalid JSON Lines content\n        with open(self.invalid_jsonl_file, 'w') as file:\n            file.write('{\"name\": \"Alice\", \"age\": 30}\\n')\n            file.write('{\"name\": \"Bob\", \"age\": \"twenty-five}\\n')  # Missing closing quote\n\n    def tearDown(self):\n        \"\"\"Remove the temporary JSON Lines files after testing.\"\"\"\n        if os.path.isfile(self.valid_jsonl_file):\n            os.remove(self.valid_jsonl_file)\n        if os.path.isfile(self.invalid_jsonl_file):\n            os.remove(self.invalid_jsonl_file)\n\n    def test_read_valid_jsonl(self):\n        \"\"\"Test reading a valid JSON Lines file.\"\"\"\n        expected_data = [\n            {\"name\": \"Alice\", \"age\": 30},\n            {\"name\": \"Bob\", \"age\": 25},\n            {\"name\": \"Charlie\", \"age\": 35}\n        ]\n        result = read_jsonl(self.valid_jsonl_file)\n        self.assertEqual(result, expected_data)\n\n    def test_file_not_found(self):\n        \"\"\"Test for FileNotFoundError when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            read_jsonl(self.non_existent_file)\n\n    def test_empty_jsonl_file(self):\n        \"\"\"Test reading an empty JSON Lines file.\"\"\"\n        empty_jsonl_file = 'test_empty.jsonl'\n        with open(empty_jsonl_file, 'w') as file:\n            file.write(\"\")  # Create an empty JSON Lines file\n\n        result = read_jsonl(empty_jsonl_file)\n        self.assertEqual(result, [])  # Expecting an empty list for empty file\n\n        os.remove(empty_jsonl_file)  # Cleanup after the test", "prompt": "please write a python function , the function signature as below import json\nimport os\nfrom typing import List, Dict, Any\n\ndef read_jsonl(file_path: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Reads a JSON Lines file and returns its content as a list of dictionaries.\n\n    Args:\n        file_path (str): The path to the JSON Lines file.\n\n    Returns:\n        List[Dict[str, Any]]: A list of JSON objects parsed from the file.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If there is an error parsing a line in the JSON Lines file.\n    \"\"\""}, {"task_id": 518, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestConvertCsvValues(unittest.TestCase):\n\n    def test_valid_numeric_strings(self):\n        \"\"\"Test with valid numeric strings including commas.\"\"\"\n        row = {'value1': '1,234', 'value2': '5,678', 'value3': '-9,876'}\n        expected = {'value1': '1.234', 'value2': '5.678', 'value3': '-9.876'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_non_numeric_strings(self):\n        \"\"\"Test with non-numeric strings.\"\"\"\n        row = {'value1': 'not_a_number', 'value2': 'hello', 'value3': 'world'}\n        expected = {'value1': None, 'value2': None, 'value3': None}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_mixed_values(self):\n        \"\"\"Test with a mix of numeric and non-numeric strings.\"\"\"\n        row = {'value1': '1,234', 'value2': 'not_a_number', 'value3': '3,14159'}\n        expected = {'value1': '1.234', 'value2': None, 'value3': '3.14159'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)\n\n    def test_edge_cases(self):\n        \"\"\"Test edge cases with empty strings and negative numbers.\"\"\"\n        row = {'value1': '', 'value2': '0', 'value3': '-1,23'}\n        expected = {'value1': None, 'value2': '0', 'value3': '-1.23'}\n        result = convert_csv_values(row)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import Dict, Optional\n\ndef convert_csv_values(row: Dict[str, str]) -> Dict[str, Optional[str]]:\n    \"\"\"\n    Convert numeric values in a CSV row from string format to a standardized format.\n\n    Args:\n        row (Dict[str, str]): A dictionary representing a row of CSV data where\n                               keys are column names and values are strings.\n\n    Returns:\n        Dict[str, Optional[str]]: A new dictionary with values converted:\n                                   - Numeric strings have commas replaced with dots.\n                                   - Non-numeric strings are set to None.\n    \"\"\""}, {"task_id": 519, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestTransposeMatrix(unittest.TestCase):\n\n    def test_square_matrix(self):\n        \"\"\"Test transposing a square matrix.\"\"\"\n        matrix = [[1, 2], [3, 4]]\n        expected = [[1, 3], [2, 4]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_rectangular_matrix(self):\n        \"\"\"Test transposing a rectangular matrix.\"\"\"\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        expected = [[1, 4], [2, 5], [3, 6]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_empty_matrix(self):\n        \"\"\"Test transposing an empty matrix.\"\"\"\n        matrix = []\n        expected = []\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_matrix_with_empty_rows(self):\n        \"\"\"Test transposing a matrix with an empty row.\"\"\"\n        matrix = [[], []]\n        expected = []\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)\n\n    def test_single_element_matrix(self):\n        \"\"\"Test transposing a matrix with a single element.\"\"\"\n        matrix = [[5]]\n        expected = [[5]]\n        result = transpose_matrix(matrix)\n        self.assertEqual(result, expected)", "prompt": "please write a python function , the function signature as below from typing import List\n\ndef transpose_matrix(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Transpose a given matrix (2D array).\n\n    Args:\n        matrix (List[List[int]]): The input 2D array to be transposed.\n\n    Returns:\n        List[List[int]]: The transposed 2D array.\n    \"\"\""}, {"task_id": 520, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestComputeOutputIndex(unittest.TestCase):\n\n    def test_standard_case(self):\n        \"\"\"Test with two standard positive integers.\"\"\"\n        idx_1 = 3  # binary: 11\n        idx_2 = 5  # binary: 101\n        expected = 6  # 3 XOR 5 = 6\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_identical_indices(self):\n        \"\"\"Test with identical indices (should return 0).\"\"\"\n        idx_1 = 7  # binary: 111\n        idx_2 = 7  # binary: 111\n        expected = 0  # 7 XOR 7 = 0\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_zero_index(self):\n        \"\"\"Test with one index as zero.\"\"\"\n        idx_1 = 0  # binary: 0\n        idx_2 = 5  # binary: 101\n        expected = 5  # 0 XOR 5 = 5\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n\n    def test_large_numbers(self):\n        \"\"\"Test with large integer values.\"\"\"\n        idx_1 = 1024  # binary: 10000000000\n        idx_2 = 2048  # binary: 100000000000\n        expected = 3072  # 1024 XOR 2048 = 3072\n        result = compute_output_index(idx_1, idx_2)\n        self.assertEqual(result, expected)\n", "prompt": "please write a python function , the function signature as below def compute_output_index(idx_1: int, idx_2: int) -> int:\n    \"\"\"\n    Computes the output index from two given indices in the MultiVector's representation\n    of the G_n orthonormal basis.\n\n    This function interprets the integers as little-endian bitstrings, takes their XOR,\n    and interprets the result as an integer in little-endian.\n\n    Args:\n        idx_1 (int): Input index 1.\n        idx_2 (int): Input index 2.\n\n    Returns:\n        int: The computed output index.\n    \"\"\""}, {"task_id": 521, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestWordFilterCounter(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        text = \"I'll go to the school. I'll go to the park.\"\n        filter_words = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"I'll\": 2,\n            \"go\": 2,\n            \"to\": 2,\n            \"the\": 2,\n            \"school\": 1,\n            \"park\": 1,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_case_insensitivity(self):\n        text = \"i'll Go To The School. I'll Go to the park.\"\n        filter_words = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"I'll\": 2,\n            \"go\": 2,\n            \"to\": 2,\n            \"the\": 2,\n            \"school\": 1,\n            \"park\": 1,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n    def test_no_occurrences(self):\n        text = \"This is a completely different sentence.\"\n        filter_words = [\"I'll\", \"go\", \"to\", \"the\", \"school\", \"park\", \"play\"]\n        expected_output = {\n            \"I'll\": 0,\n            \"go\": 0,\n            \"to\": 0,\n            \"the\": 0,\n            \"school\": 0,\n            \"park\": 0,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n\n\n    def test_filter_words_with_special_characters(self):\n        text = \"I won't go to the school's park.\"\n        filter_words = [\"I'll\", \"go\", \"to\", \"the\", \"school's\", \"park\", \"play\"]\n        expected_output = {\n            \"I'll\": 0,\n            \"go\": 1,\n            \"to\": 1,\n            \"the\": 1,\n            \"school's\": 1,\n            \"park\": 1,\n            \"play\": 0\n        }\n        self.assertEqual(word_filter_counter(text, filter_words), expected_output)\n", "prompt": "please write a python function , the function signature as below import re\nfrom collections import Counter\nfrom typing import List, Dict\n\n\ndef word_filter_counter(text: str, filter_words: List[str]) -> Dict[str, int]:\n    \"\"\"\n    Counts the occurrences of specified words in the given text.\n\n    This function filters the words from the text based on the provided list,\n    counts their occurrences, and returns a dictionary with the words in the\n    order they were provided.\n\n    Args:\n        text (str): The input text from which to count words.\n        filter_words (List[str]): A list of words to filter and count.\n\n    Returns:\n        Dict[str, int]: A dictionary with the count of each filter word in the text,\n                         maintaining the order from filter_words.\n    \"\"\""}, {"task_id": 522, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestRotatePointCloud(unittest.TestCase):\n\n    def test_no_rotation(self):\n        \"\"\"Test when rotation angle is 0 (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 0\n        expected_output = point_cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_180_degree_rotation(self):\n        \"\"\"Test rotation of 180 degrees (\u03c0 radians) around Y axis.\"\"\"\n        point_cloud = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])\n        rotation_angle = np.pi  # 180 degrees\n        expected_output = np.array([[-1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])  # [1,0,0] -> [-1,0,0]\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_full_rotation(self):\n        \"\"\"Test rotation of 360 degrees (2\u03c0 radians) around Y axis (should return same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        rotation_angle = 2 * np.pi  # 360 degrees\n        expected_output = point_cloud  # Should return the same point cloud\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)\n\n    def test_negative_rotation(self):\n        \"\"\"Test rotation with a negative angle (-90 degrees).\"\"\"\n        point_cloud = np.array([[1.0, 0.0, 0.0]])\n        rotation_angle = -np.pi / 2  # -90 degrees\n        expected_output = np.array([[0.0, 0.0, -1.0]])  # [1,0,0] -> [0,0,-1]\n        np.testing.assert_array_almost_equal(rotate_point_cloud(point_cloud, rotation_angle), expected_output)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef rotate_point_cloud(point_cloud: np.ndarray, rotation_angle: float) -> np.ndarray:\n    \"\"\"\n    Rotate the point cloud around the Y axis by a given angle.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        rotation_angle (float): The angle (in radians) to rotate the point cloud.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the rotated point cloud.\n    \"\"\"\n"}, {"task_id": 523, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestTranslatePointCloud(unittest.TestCase):\n\n    def test_simple_translation(self):\n        \"\"\"Test a simple translation of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([1.0, 1.0, 1.0])\n        expected_output = np.array([[2.0, 3.0, 4.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_multiple_points_translation(self):\n        \"\"\"Test translation of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([1.0, 2.0, 3.0])\n        expected_output = np.array([[2.0, 4.0, 6.0], [5.0, 7.0, 9.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_zero_translation(self):\n        \"\"\"Test translation by a zero vector (should return the same point cloud).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        translation_vector = np.array([0.0, 0.0, 0.0])\n        expected_output = point_cloud  # No change expected\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_negative_translation(self):\n        \"\"\"Test translation with negative values.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([-1.0, -2.0, -3.0])\n        expected_output = np.array([[0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(translate_point_cloud(point_cloud, translation_vector), expected_output)\n\n    def test_invalid_translation_vector(self):\n        \"\"\"Test handling of an invalid translation vector shape.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        translation_vector = np.array([1.0, 2.0])  # Invalid shape, should raise an error\n        with self.assertRaises(ValueError) as context:\n            translate_point_cloud(point_cloud, translation_vector)\n        self.assertEqual(str(context.exception), \"translation_vector must be a 1D array of shape (3,)\")", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef translate_point_cloud(point_cloud: np.ndarray, translation_vector: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Translate the point cloud by a given vector.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        translation_vector (np.ndarray): A 1 x 3 numpy array or list representing the translation vector.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the translated point cloud.\n    \"\"\"\n"}, {"task_id": 524, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestScalePointCloud(unittest.TestCase):\n\n    def test_simple_scaling(self):\n        \"\"\"Test scaling of a single point.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = 2.0\n        expected_output = np.array([[2.0, 4.0, 6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_multiple_points_scaling(self):\n        \"\"\"Test scaling of multiple points.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.5\n        expected_output = np.array([[0.5, 1.0, 1.5], [2.0, 2.5, 3.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_zero_scaling(self):\n        \"\"\"Test scaling by a factor of zero (should return a point cloud of zeros).\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        scale_factor = 0.0\n        expected_output = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_negative_scaling(self):\n        \"\"\"Test scaling with a negative factor.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        scale_factor = -2.0\n        expected_output = np.array([[-2.0, -4.0, -6.0]])\n        np.testing.assert_array_almost_equal(scale_point_cloud(point_cloud, scale_factor), expected_output)\n\n    def test_invalid_point_cloud_shape(self):\n        \"\"\"Test handling of an invalid point cloud shape.\"\"\"\n        point_cloud = np.array([[1.0, 2.0]])  # Invalid shape, should raise an error\n        scale_factor = 2.0\n        with self.assertRaises(ValueError) as context:\n            scale_point_cloud(point_cloud, scale_factor)\n        self.assertEqual(str(context.exception), \"point_cloud must be a 2D array with shape (N, 3)\")", "prompt": "please write a python function , the function signature as below import numpy as np\n\ndef scale_point_cloud(point_cloud: np.ndarray, scale_factor: float) -> np.ndarray:\n    \"\"\"\n    Scale the point cloud by a given factor.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        scale_factor ( float): A float representing the scaling factor.\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the scaled point cloud.\n    \"\"\""}, {"task_id": 525, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestFlipPointCloud(unittest.TestCase):\n\n    def test_flip_x_axis(self):\n        \"\"\"Test flipping the point cloud across the x-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, -2.0, 3.0], [4.0, -5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=1), expected_output)\n\n    def test_flip_y_axis(self):\n        \"\"\"Test flipping the point cloud across the y-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[-1.0, 2.0, 3.0], [-4.0, 5.0, 6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)\n\n    def test_flip_z_axis(self):\n        \"\"\"Test flipping the point cloud across the z-axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\n        expected_output = np.array([[1.0, 2.0, -3.0], [4.0, 5.0, -6.0]])\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=2), expected_output)\n\n    def test_invalid_axis(self):\n        \"\"\"Test handling of an invalid axis.\"\"\"\n        point_cloud = np.array([[1.0, 2.0, 3.0]])\n        with self.assertRaises(ValueError) as context:\n            flip_point_cloud(point_cloud, axis=3)  # Invalid axis\n        self.assertEqual(str(context.exception), \"Axis must be 0 (x-axis), 1 (y-axis), or 2 (z-axis).\")\n\n    def test_empty_point_cloud(self):\n        \"\"\"Test flipping an empty point cloud.\"\"\"\n        point_cloud = np.array([]).reshape(0, 3)  # Empty point cloud with shape (0, 3)\n        expected_output = np.array([]).reshape(0, 3)  # Expect the output to be the same\n        np.testing.assert_array_almost_equal(flip_point_cloud(point_cloud, axis=0), expected_output)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef flip_point_cloud(point_cloud: np.ndarray, axis: int) -> np.ndarray:\n    \"\"\"\n    Flip the point cloud across a specified axis.\n\n    Args:\n        point_cloud (np.ndarray): A N x 3 numpy array representing the 3D point cloud.\n        axis (int): An integer specifying the axis to flip (0 for x, 1 for y, 2 for z).\n\n    Returns:\n        np.ndarray: A N x 3 numpy array of the flipped point cloud.\n    \"\"\"\n"}, {"task_id": 526, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestMinWindow(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a normal case where the minimum window exists.\"\"\"\n        s = \"ADOBECODEBANC\"\n        t = \"ABC\"\n        expected_output = \"BANC\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_no_window_exists(self):\n        \"\"\"Test where no window can satisfy the condition.\"\"\"\n        s = \"A\"\n        t = \"AA\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n    def test_empty_string(self):\n        \"\"\"Test with an empty input string s.\"\"\"\n        s = \"\"\n        t = \"ABC\"\n        expected_output = \"\"\n        self.assertEqual(min_window(s, t), expected_output)\n\n\n    def test_multiple_valid_windows(self):\n        \"\"\"Test with multiple valid windows to ensure the smallest one is returned.\"\"\"\n        s = \"AA\"\n        t = \"AA\"\n        expected_output = \"AA\"\n        self.assertEqual(min_window(s, t), expected_output)\n", "prompt": "please write a python function , the function signature as below from collections import Counter\n\n\ndef min_window(s: str, t: str) -> str:\n    \"\"\"\n    Find the minimum window substring in `s` that contains all characters of `t`.\n\n    Args:\n        s (str): The input string in which to search for the substring.\n        t (str): The target string whose characters must be included in the substring.\n\n    Returns:\n        str: The minimum window substring of `s` that contains all characters of `t`.Returns an empty string if no such substring exists.\n    \"\"\"\n"}, {"task_id": 527, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestPointInsideTriangle(unittest.TestCase):\n\n    def test_point_inside_triangle(self):\n        \"\"\"Test case where point is inside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 2)  # Inside the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_on_edge(self):\n        \"\"\"Test case where point is on the edge of the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (2.5, 0)  # On the edge of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_outside_triangle(self):\n        \"\"\"Test case where point is outside the triangle.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (6, 2)  # Outside the triangle\n        self.assertFalse(is_point_inside_triangle(point[0], point[1], *triangle_vertices))\n\n    def test_point_at_vertex(self):\n        \"\"\"Test case where point is at one of the triangle's vertices.\"\"\"\n        triangle_vertices = (0, 0, 5, 0, 2.5, 5)\n        point = (0, 0)  # At the vertex of the triangle\n        self.assertTrue(is_point_inside_triangle(point[0], point[1], *triangle_vertices))", "prompt": "please write a python function , the function signature as below def is_point_inside_triangle(px: float, py: float, x1: float, y1: float, x2: float, y2: float, x3: float, y3: float):\n    \"\"\"\n    Check if a point is inside a triangle defined by three vertices.\n\n    Args:\n        px (float): The x-coordinate of the point to check.\n        py (float): The y-coordinate of the point to check.\n        x1 (float): The x-coordinate of the first vertex of the triangle.\n        y1 (float): The y-coordinate of the first vertex of the triangle.\n        x2 (float): The x-coordinate of the second vertex of the triangle.\n        y2 (float): The y-coordinate of the second vertex of the triangle.\n        x3 (float): The x-coordinate of the third vertex of the triangle.\n        y3 (float): The y-coordinate of the third vertex of the triangle.\n\n    Returns:\n        bool: True if the point (px, py) is inside or on the edge of the triangle formed by the vertices (x1, y1), (x2, y2), (x3, y3); False otherwise.\n    \"\"\"\n"}, {"task_id": 546, "code_type": "method", "code_language": "python", "test_code": "import unittest\nimport sys\nimport io\nfrom unittest.mock import patch\n\n\nclass TestReadTsvFromStdin(unittest.TestCase):\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_basic_tsv_input(self, mock_stdin):\n        mock_stdin.write(\"col1\\tcol2\\tcol3\\nval1\\tval2\\tval3\\n\")\n        mock_stdin.seek(0)  # Move to the start of the StringIO object\n        expected_output = [['col1', 'col2', 'col3'], ['val1', 'val2', 'val3']]\n        self.assertEqual(read_tsv_from_stdin(), expected_output)\n\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_single_column(self, mock_stdin):\n        mock_stdin.write(\"col1\\nval1\\nval2\\n\")\n        mock_stdin.seek(0)\n        expected_output = [['col1'], ['val1'], ['val2']]\n        self.assertEqual(read_tsv_from_stdin(), expected_output)\n\n    @patch('sys.stdin', new_callable=io.StringIO)\n    def test_empty_input(self, mock_stdin):\n        mock_stdin.write(\"\")\n        mock_stdin.seek(0)\n        expected_output = []\n        self.assertEqual(read_tsv_from_stdin(), expected_output)", "prompt": "please write a python function , the function signature as below import csv\nimport sys\n\n\ndef read_tsv_from_stdin():\n    \"\"\"\n    Reads tab-separated values (TSV) from standard input and returns a list of rows.\n\n    Each row is represented as a list of strings. If rows have unequal lengths,\n    they are padded with empty strings to ensure all rows have the same length.\n\n    Returns:\n        list: A list of lists, where each inner list represents a row of data.\n    \"\"\"\n"}, {"task_id": 547, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestCalculateColumnWidths(unittest.TestCase):\n\n    def test_standard_case(self):\n        data = [[\"Name\", \"Age\", \"City\"],\n                [\"Alice\", \"22\", \"New York\"],\n                [\"Bob\", \"30\", \"San Francisco\"]]\n        expected = [5, 3, 13]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_empty_list(self):\n        data = []\n        with self.assertRaises(IndexError):\n            calculate_column_widths(data)\n\n    def test_single_element(self):\n        data = [[\"Name\"]]\n        expected = [4]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_varied_length(self):\n        data = [[\"a\", \"bb\", \"ccc\"],\n                [\"dddd\", \"ee\", \"f\"]]\n        expected = [4, 2, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_all_empty_strings(self):\n        data = [[\"\", \"\", \"\"],\n                [\"\", \"\", \"\"]]\n        expected = [0, 0, 0]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_mixed_content(self):\n        data = [[\"1234\", \"567\", \"890\"],\n                [\"abc\", \"defg\", \"h\"]]\n        expected = [4, 4, 3]\n        self.assertEqual(calculate_column_widths(data), expected)\n\n    def test_single_column_multiple_rows(self):\n        data = [[\"one\"],\n                [\"two\"],\n                [\"three\"]]\n        expected = [5]\n        self.assertEqual(calculate_column_widths(data), expected)\n", "prompt": "please write a python function , the function signature as below from typing import List\n\n\ndef calculate_column_widths(data: List[List[str]]) -> List[int]:\n    \"\"\"\n    Calculate the maximum width of each column in a list of lists where each sub-list represents a row of table data.\n\n    Args:\n        data (List[List[str]]): A two-dimensional list containing rows of data, where each inner list contains string elements representing the values in each column.\n\n    Returns:\n        List[int]: A list containing the maximum width (in characters) of each column across all rows. The width of a column is defined by the longest string present in that column.\n    \"\"\"\n"}, {"task_id": 548, "code_type": "method", "code_language": "python", "test_code": "import os\nimport unittest\n\n\nclass TestReadTxtAddJsonBracket(unittest.TestCase):\n\n    def setUp(self):\n        # Create temporary files for testing\n        self.valid_file = 'test_valid.txt'\n        self.invalid_file = 'test_invalid.txt'\n        self.empty_file = 'test_empty.txt'\n\n        with open(self.valid_file, 'w', encoding='utf-8') as f:\n            f.write('{\"name\": \"Alice\"}\\n{\"name\": \"Bob\"}\\n')\n\n        with open(self.invalid_file, 'w', encoding='utf-8') as f:\n            f.write('{\"name\": \"Alice\"\\n{\"name\": \"Bob\"}\\n')  # Missing closing brace\n\n        with open(self.empty_file, 'w', encoding='utf-8') as f:\n            f.write('')  # Empty file\n\n    def tearDown(self):\n        # Remove temporary files after testing\n        os.remove(self.valid_file)\n        os.remove(self.invalid_file)\n        os.remove(self.empty_file)\n\n\n    def test_invalid_json_file(self):\n        result = read_txt_add_json_bracket(self.invalid_file)\n        self.assertEqual(result, [])  # Expect empty list due to JSONDecodeError\n\n    def test_empty_file(self):\n        result = read_txt_add_json_bracket(self.empty_file)\n        self.assertEqual(result, [])  # Expect empty list for empty input\n\n    def test_file_not_found(self):\n        result = read_txt_add_json_bracket('non_existent_file.txt')\n        self.assertEqual(result, [])  # Expect empty list for file not found\n\n    def test_single_valid_json_object(self):\n        single_valid_file = 'test_single_valid.txt'\n        with open(single_valid_file, 'w', encoding='utf-8') as f:\n            f.write('{\"name\": \"Charlie\"}\\n')\n\n        expected_output = [\n            {\"name\": \"Charlie\"}\n        ]\n        result = read_txt_add_json_bracket(single_valid_file)\n        self.assertEqual(result, expected_output)\n\n        os.remove(single_valid_file)  # Clean up temporary file", "prompt": "please write a python function , the function signature as below import json\n\n\ndef read_txt_add_json_bracket(filename:str):\n    \"\"\"\n    Reads a text file, wraps its content in JSON brackets, and parses it into a Python object.\n\n    Args:\n        filename (str): The path to the text file to be read.\n\n    Returns:\n        list: A list parsed from the JSON content wrapped in brackets.\n\n    Raises:\n        FileNotFoundError: If the specified file does not exist.\n        json.JSONDecodeError: If the content cannot be parsed as JSON.\n    \"\"\""}, {"task_id": 549, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\nclass TestGetTInLog10Kelvin(unittest.TestCase):\n\n    # Existing test cases here...\n\n    def test_scalar_input_high_temperature(self):\n        \"\"\"Test with a high scalar input.\"\"\"\n        T_keV = 100.0\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_scalar_input_low_temperature(self):\n        \"\"\"Test with a low scalar input.\"\"\"\n        T_keV = 0.01\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_large_range(self):\n        \"\"\"Test with a tuple of temperatures over a large range.\"\"\"\n        T_keV = (0.1, 1.0, 10.0, 100.0, 1000.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_tuple_input_repeated_values(self):\n        \"\"\"Test with a tuple of repeated temperature values.\"\"\"\n        T_keV = (1.0, 1.0, 1.0)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n    def test_scalar_input_non_integer(self):\n        \"\"\"Test with a non-integer scalar input.\"\"\"\n        T_keV = 2.5\n        expected_result = np.log10(T_keV / k_B_over_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input_floating_point(self):\n        \"\"\"Test with a tuple of floating-point temperatures.\"\"\"\n        T_keV = (1.5, 2.5, 3.5)\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n\n\n    def test_large_tuple_input(self):\n        \"\"\"Test with a large tuple of temperature values.\"\"\"\n        T_keV = tuple(np.arange(1, 1001, 1))  # Temperatures from 1 keV to 1000 keV\n        expected_results = tuple(np.log10(t / k_B_over_keV) for t in T_keV)\n        result = get_T_in_log10_Kelvin(T_keV)\n        self.assertEqual(result, expected_results)\n", "prompt": "please write a python function , the function signature as below from typing import Union, Tuple\n\nimport numpy as np\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef get_T_in_log10_Kelvin(T_keV: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from keV to log10(K) for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_keV (float or tuple): The temperature in keV. Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in log10(K) corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n"}, {"task_id": 550, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\nclass TestConvertLog10KToKeV(unittest.TestCase):\n\n    def test_scalar_input(self):\n        \"\"\"Test conversion of a single scalar log10(K) value.\"\"\"\n        T_log10_K = 3.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_tuple_input(self):\n        \"\"\"Test conversion of a tuple of log10(K) values.\"\"\"\n        T_log10_K = (2.0, 3.0, 4.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_zero_input(self):\n        \"\"\"Test conversion of log10(K) = 0.\"\"\"\n        T_log10_K = 0.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_negative_input(self):\n        \"\"\"Test conversion of a negative log10(K) value.\"\"\"\n        T_log10_K = -1.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_large_tuple_input(self):\n        \"\"\"Test conversion of a large tuple of log10(K) values.\"\"\"\n        T_log10_K = (1.0, 2.0, 3.0, 4.0, 5.0)\n        expected_results = tuple(10 ** t * k_B_over_keV for t in T_log10_K)\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertEqual(result, expected_results)\n\n    def test_single_large_value(self):\n        \"\"\"Test conversion of a large log10(K) value.\"\"\"\n        T_log10_K = 10.0\n        expected_result = 10 ** T_log10_K * k_B_over_keV\n        result = convert_log10_K_to_keV(T_log10_K)\n        self.assertAlmostEqual(result, expected_result, places=6)\n\n    def test_invalid_input(self):\n        \"\"\"Test conversion with invalid input (string).\"\"\"\n        T_log10_K = \"invalid\"\n        with self.assertRaises(ValueError):\n            convert_log10_K_to_keV(T_log10_K)\n", "prompt": "please write a python function , the function signature as below from typing import Tuple, Union\n\nimport numpy as np\n\n# Define the constant for conversion: Boltzmann constant in keV/K\nk_B_over_keV = 8.617333262145e-5  # eV/K to keV/K\n\n\ndef convert_log10_K_to_keV(T_log10_K: Union[float, Tuple]):\n    \"\"\"\n    Converts temperature from log10(K) to keV for a given input (scalar or tuple).k_B_over_keV = 8.617333262145e-5\n\n    Args:\n        T_log10_K (float or tuple): The temperature in log10(K). Can be a scalar or a tuple of temperatures.\n\n    Returns:\n        float or tuple: The temperature(s) in keV corresponding to the input.\n\n    Raises:\n        ValueError: If the input is not a scalar (int or float) or a tuple.\n    \"\"\"\n"}, {"task_id": 551, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestGetMidsFromEdges(unittest.TestCase):\n\n    def test_basic_case(self):\n        \"\"\"Test with a standard range of edges.\"\"\"\n        edges = np.array([1, 2, 3, 4])\n        expected_mids = np.array([1.5, 2.5, 3.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_single_interval(self):\n        \"\"\"Test with two edges (single interval).\"\"\"\n        edges = np.array([5, 10])\n        expected_mids = np.array([7.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_multiple_intervals(self):\n        \"\"\"Test with multiple intervals.\"\"\"\n        edges = np.array([0, 1, 2, 3, 4, 5])\n        expected_mids = np.array([0.5, 1.5, 2.5, 3.5, 4.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_negative_edges(self):\n        \"\"\"Test with negative edges.\"\"\"\n        edges = np.array([-5, -3, -1, 1])\n        expected_mids = np.array([-4.0, -2.0, 0.0])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_zero_edges(self):\n        \"\"\"Test with edges including zero.\"\"\"\n        edges = np.array([0, 1, 2])\n        expected_mids = np.array([0.5, 1.5])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_float_edges(self):\n        \"\"\"Test with floating-point edges.\"\"\"\n        edges = np.array([0.0, 1.5, 3.0])\n        expected_mids = np.array([0.75, 2.25])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)\n\n    def test_empty_array(self):\n        \"\"\"Test with an empty array.\"\"\"\n        edges = np.array([])\n        expected_mids = np.array([])\n        np.testing.assert_array_equal(get_mids_from_edges(edges), expected_mids)", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef get_mids_from_edges(edges: np.ndarray):\n    \"\"\"\n    Calculate the midpoints from a given array of edges.\n    For example:\n        input: [0, 1, 2]\n        output: [0.5, 1.5]\n\n    Args:\n        edges (np.ndarray): An array of edge values.\n\n    Returns:\n        np.ndarray: An array of midpoints calculated from the edges.\n    \"\"\"\n"}, {"task_id": 552, "code_type": "method", "code_language": "python", "test_code": "import unittest\n\n\nclass TestAreSetsEqual(unittest.TestCase):\n\n    def test_identical_sets(self):\n        \"\"\"Test with two identical sets of floats.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.0, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2))\n\n    def test_different_length_sets(self):\n        \"\"\"Test with two sets of different lengths.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.0}\n        self.assertFalse(are_sets_equal(set1, set2))\n\n    def test_sets_with_close_values(self):\n        \"\"\"Test with two sets that are close within the tolerance.\"\"\"\n        set1 = {1.0, 2.00001, 3.0}\n        set2 = {1.0, 2.00002, 3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_sets_with_large_difference(self):\n        \"\"\"Test with two sets that have large differences beyond tolerance.\"\"\"\n        set1 = {1.0, 2.0, 3.0}\n        set2 = {1.0, 2.5, 3.0}\n        self.assertFalse(are_sets_equal(set1, set2))\n\n    def test_sets_with_negative_values(self):\n        \"\"\"Test with two sets containing negative floats.\"\"\"\n        set1 = {-1.0, -2.0, -3.0}\n        set2 = {-1.0, -2.000001, -3.0}\n        self.assertTrue(are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6))\n\n    def test_empty_sets(self):\n        \"\"\"Test with two empty sets.\"\"\"\n        set1 = set()\n        set2 = set()\n        self.assertTrue(are_sets_equal(set1, set2))\n", "prompt": "please write a python function , the function signature as below import numpy as np\n\n\ndef are_sets_equal(set1, set2, rtol=1e-5, atol=1e-6):\n    \"\"\"\n    Compares two sets of floats for equality within a relative and absolute tolerance.\n\n    Args:\n        set1: The first set of floats.\n        set2: The second set of floats.\n        rtol: The relative tolerance (default: 1e-5).\n        atol: The absolute tolerance (default: 1e-6).\n\n    Returns:\n        True if the sets are equal within the specified tolerances, False otherwise.\n    \"\"\""}, {"task_id": 555, "code_type": "method", "code_language": "python", "test_code": "import math\nimport unittest\n\n\nclass TestQuaternionToAngle(unittest.TestCase):\n\n    def test_identity_quaternion(self):\n        \"\"\"Test the identity quaternion (no rotation).\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)\n        expected_angle = 0.0\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_180_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a 180-degree rotation.\"\"\"\n        quaternion = (0.0, 0.0, 1.0, 0.0)  # 180 degrees around Z axis\n        expected_angle = math.pi  # 180 degrees in radians\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n    def test_360_degrees_rotation(self):\n        \"\"\"Test a quaternion representing a full 360-degree rotation.\"\"\"\n        quaternion = (1.0, 0.0, 0.0, 0.0)  # Full rotation\n        expected_angle = 0.0  # 360 degrees is equivalent to 0 degrees\n        self.assertAlmostEqual(quaternion_to_angle(quaternion), expected_angle)\n\n\n    def test_non_unit_quaternion(self):\n        \"\"\"Test a non-unit quaternion (should still give correct angle).\"\"\"\n        quaternion = (0.5, 0.5, 0.5, 0.5)  # This is not normalized\n        # Normalize the quaternion first\n        norm = math.sqrt(sum(x ** 2 for x in quaternion))\n        normalized_quaternion = tuple(x / norm for x in quaternion)\n        expected_angle = 2 * math.acos(normalized_quaternion[0])  # Should be same angle\n        self.assertAlmostEqual(quaternion_to_angle(normalized_quaternion), expected_angle)\n\n    def test_invalid_quaternion(self):\n        \"\"\"Test that an invalid quaternion raises a ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            quaternion_to_angle((1.0, 0.0, 0.0))  # Only 3 components", "prompt": "please write a python function , the function signature as below import math\nfrom typing import Tuple\n\n\ndef quaternion_to_angle(quaternion: Tuple[float]) -> float:\n    \"\"\"\n    Converts a quaternion to a rotation angle in radians.\n\n    Args:\n        quaternion (Tuple[float]): A tuple or list containing the quaternion components (w, x, y, z)\n\n    Returns:\n        float: The rotation angle in radians\n    \"\"\"\n"}, {"task_id": 557, "code_type": "method", "code_language": "python", "test_code": "import math\nimport unittest\n\n\nclass TestRadiansToDegrees(unittest.TestCase):\n    def test_zero_radians(self):\n        \"\"\"Test conversion of 0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(0), 0, places=5)\n\n    def test_pi_over_two_radians(self):\n        \"\"\"Test conversion of \u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi / 2), 90, places=5)\n\n    def test_pi_radians(self):\n        \"\"\"Test conversion of \u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(math.pi), 180, places=5)\n\n    def test_three_pi_over_two_radians(self):\n        \"\"\"Test conversion of 3\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(3 * math.pi / 2), 270, places=5)\n\n    def test_two_pi_radians(self):\n        \"\"\"Test conversion of 2\u03c0 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(2 * math.pi), 360, places=5)\n\n    def test_negative_pi_over_two_radians(self):\n        \"\"\"Test conversion of -\u03c0/2 radians\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(-math.pi / 2), -90, places=5)\n\n    def test_large_radians(self):\n        \"\"\"Test conversion of a large angle (4\u03c0 radians)\"\"\"\n        self.assertAlmostEqual(radians_to_degrees(4 * math.pi), 720, places=5)", "prompt": "please write a python function , the function signature as below def radians_to_degrees(radians: float) -> int:\n    \"\"\"\n    Convert an angle from radians to degrees.\n\n    Args:\n        radians (float): The angle in radians to convert.\n\n    Returns:\n        int: The angle in degrees.\n    \"\"\"\n"}, {"task_id": 558, "code_type": "method", "code_language": "python", "test_code": "import math\nimport unittest\n\n\nclass TestDegreesToRadians(unittest.TestCase):\n    def test_zero_degrees(self):\n        \"\"\"Test conversion of 0 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(0), 0, places=5)\n\n    def test_ninety_degrees(self):\n        \"\"\"Test conversion of 90 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(90), math.pi / 2, places=5)\n\n    def test_one_eighty_degrees(self):\n        \"\"\"Test conversion of 180 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(180), math.pi, places=5)\n\n    def test_two_seventy_degrees(self):\n        \"\"\"Test conversion of 270 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(270), 3 * math.pi / 2, places=5)\n\n    def test_three_sixty_degrees(self):\n        \"\"\"Test conversion of 360 degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(360), 2 * math.pi, places=5)\n\n    def test_negative_degrees(self):\n        \"\"\"Test conversion of negative degrees\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(-90), -math.pi / 2, places=5)\n\n    def test_large_degrees(self):\n        \"\"\"Test conversion of a large angle (720 degrees)\"\"\"\n        self.assertAlmostEqual(degrees_to_radians(720), 4 * math.pi, places=5)\n", "prompt": "please write a python function , the function signature as below import math\n\n\ndef degrees_to_radians(degrees: int) -> float:\n    \"\"\"\n    Convert an angle from degrees to radians.\n\n    Args:\n        degrees (int): The angle in degrees to convert.\n\n    Returns:\n        float: The angle in radians.\n    \"\"\"\n"}]