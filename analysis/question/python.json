[
  {
    "task_id": 1,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n    Args:\n        value (): input value str\n    Returns: convert result\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestSmartConvert(unittest.TestCase):\n    def test_convert_integer(self):\n        self.assertEqual(numerical_str_convert(\"123\"), 123, \"Should convert to integer\")\n\n    def test_convert_float(self):\n        self.assertEqual(numerical_str_convert(\"123.45\"), 123.45, \"Should convert to float\")\n\n    def test_convert_non_numeric_string(self):\n        self.assertEqual(numerical_str_convert(\"abc\"), \"abc\", \"Should remain a string\")\n\n    def test_convert_negative_integer(self):\n        self.assertEqual(numerical_str_convert(\"-456\"), -456, \"Should convert to negative integer\")\n\n    def test_convert_negative_float(self):\n        self.assertEqual(numerical_str_convert(\"-456.78\"), -456.78, \"Should convert to negative float\")\n",
    "prompt": "please write a python function the function signature as below from typing import Union\n\n\ndef numerical_str_convert(value: str) -> Union[int, float, str]:\n    \"\"\"\n    convert the input string, first see if it is an integer, if it is converted to an integer, if it is not, see if it is a floating point number, if yes, convert to a floating point number, if neither, return the original string\n    Args:\n        value (): input value str\n    Returns: convert result\n    \"\"\"\n"
  },
  {
    "task_id": 2,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def generate_powershell_install_script() -> str:\n    \"\"\"\n    The name of the program to be installed is obtained by user input, and a PowerShell script is generated, which can be directly run to download these programs\n    Returns: script_file_name\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import patch\n\n\ndef get_mock_input(input_values):\n    \"\"\" Generator to return values for each call to input() \"\"\"\n    for value in input_values:\n        yield value\n\n\nclass TestGeneratePowerShellInstallScript(unittest.TestCase):\n    def check_script_contents(self, expected_programs):\n        \"\"\" Helper function to check the contents of the generated PowerShell script \"\"\"\n        script_filename = 'install_programs.ps1'\n        with open(script_filename, 'r') as file:\n            lines = file.readlines()\n\n        # Check installation lines for programs\n        install_lines = [line.strip() for line in lines if line.strip().startswith('choco install')]\n        self.assertEqual(len(install_lines), len(expected_programs))\n        for program in expected_programs:\n            self.assertIn(f\"choco install {program} -y\", install_lines)\n\n    @patch('builtins.input', side_effect=get_mock_input([\"firefox\", \"done\"]))\n    def test_single_program(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"firefox\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"nodejs\", \"python\", \"git\", \"done\"]))\n    def test_multiple_programs(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"nodejs\", \"python\", \"git\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"done\"]))\n    def test_no_programs(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"NodeJS\", \"Python3\", \"done\"]))\n    def test_case_sensitivity(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"NodeJS\", \"Python3\"])\n\n    @patch('builtins.input', side_effect=get_mock_input([\"sql server\", \"visual studio code\", \"done\"]))\n    def test_special_characters(self, mock_input):\n        generate_powershell_install_script()\n        self.check_script_contents([\"sql server\", \"visual studio code\"])\n",
    "prompt": "please write a python function the function signature as below def generate_powershell_install_script() -> str:\n    \"\"\"\n    The name of the program to be installed is obtained by user input, and a PowerShell script is generated, which can be directly run to download these programs\n    Returns: script_file_name\n    \"\"\"\n"
  },
  {
    "task_id": 4,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import math\n\n\ndef quaternion_to_yaw(w: float, x: float, y: float, z: float) -> float:\n    \"\"\"\n    The quaternion is converted to a selected yaw Angle around the z-axis\n    Args:\n        w (float): The scalar component of the quaternion.\n        x (float): The x-component of the quaternion vector part.\n        y (float): The y-component of the quaternion vector part.\n        z (float): The z-component of the quaternion vector part.\n\n    Returns: The yaw angle in radians.\n    \"\"\"\n",
    "test_code": "import unittest\nimport math\n\n\nclass TestQuaternionToYaw(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Quaternion for no rotation\n        w, x, y, z = 1, 0, 0, 0\n        expected_yaw = 0\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed zero rotation test.js\")\n\n    def test_90_degrees_rotation(self):\n        # Quaternion for 90 degrees rotation around z-axis\n        w, x, y, z = math.cos(math.pi / 4), 0, 0, math.sin(math.pi / 4)\n        expected_yaw = math.pi / 2\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 90 degrees rotation test.js\")\n\n    def test_180_degrees_rotation(self):\n        # Quaternion for 180 degrees rotation around z-axis\n        w, x, y, z = 0, 0, 0, 1\n        expected_yaw = math.pi\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 180 degrees rotation test.js\")\n\n    def test_270_degrees_rotation(self):\n        # Quaternion for 270 degrees (or -90 degrees) rotation around z-axis\n        w, x, y, z = math.cos(-math.pi / 4), 0, 0, math.sin(-math.pi / 4)\n        expected_yaw = -math.pi / 2\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed 270 degrees rotation test.js\")\n\n    def test_negative_rotation(self):\n        # Quaternion for negative rotation around z-axis\n        w, x, y, z = math.cos(-math.pi / 6), 0, 0, math.sin(-math.pi / 6)\n        expected_yaw = -math.pi / 3\n        result = quaternion_to_yaw(w, x, y, z)\n        self.assertAlmostEqual(result, expected_yaw, msg=\"Failed negative rotation test.js\")\n",
    "prompt": "please write a python function the function signature as below import math\n\n\ndef quaternion_to_yaw(w: float, x: float, y: float, z: float) -> float:\n    \"\"\"\n    The quaternion is converted to a selected yaw Angle around the z-axis\n    Args:\n        w (float): The scalar component of the quaternion.\n        x (float): The x-component of the quaternion vector part.\n        y (float): The y-component of the quaternion vector part.\n        z (float): The z-component of the quaternion vector part.\n\n    Returns: The yaw angle in radians.\n    \"\"\"\n"
  },
  {
    "task_id": 5,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n    Args:\n        matrixA (): matrix A\n        matrixB (): matrix B\n\n    Returns: matrixA matrixB multiplication result\n\n    \"\"\"",
    "test_code": "import unittest\n\n\nclass TestMatrixMultiplication(unittest.TestCase):\n    def test_standard_matrices(self):\n        mat1 = [[1, 2], [3, 4]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[19, 22], [43, 50]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should correctly multiply standard matrices\")\n\n    def test_incompatible_dimensions(self):\n        mat1 = [[1, 2, 3], [4, 5, 6]]\n        mat2 = [[1, 2], [3, 4]]\n        with self.assertRaises(ValueError):\n            matrix_multiply(mat1, mat2)\n\n    def test_empty_matrices(self):\n        mat1 = []\n        mat2 = []\n        expected = []\n        self.assertEqual(matrix_multiply(mat1, mat2), expected, \"Should handle empty matrices without error\")\n\n    def test_identity_matrix(self):\n        mat1 = [[1, 0], [0, 1]]\n        mat2 = [[5, 6], [7, 8]]\n        expected = [[5, 6], [7, 8]]\n        self.assertEqual(matrix_multiply(mat1, mat2), expected,\n                         \"Multiplying by the identity matrix should yield the original.py matrix\")\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef matrix_multiply(matrixA: List[List[int]], matrixB: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Implementing matrix multiplication\n    Args:\n        matrixA (): matrix A\n        matrixB (): matrix B\n\n    Returns: matrixA matrixB multiplication result\n\n    \"\"\""
  },
  {
    "task_id": 6,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings, for example, D:\\downlaod\\text.py is simplified to D_download_text.py\n    Args:\n        path (str): windows file path str\n    Returns:\n        simplify path str\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestSimplifyWindowsPath(unittest.TestCase):\n    def test_simple_path(self):\n        self.assertEqual(simplify_windows_path(\"C:\\\\Users\\\\User\\\\file.txt\"), \"C_Users_User_file.txt\")\n\n    def test_path_with_spaces(self):\n        self.assertEqual(simplify_windows_path(\"E:\\\\New Folder\\\\my file.docx\"), \"E_New Folder_my file.docx\")\n\n    def test_path_with_drive_only(self):\n        self.assertEqual(simplify_windows_path(\"F:\\\\\"), \"F_\")\n\n    def test_path_with_special_characters(self):\n        self.assertEqual(simplify_windows_path(\"D:\\\\data\\\\new-year@2020\\\\report#1.pdf\"), \"D_data_new-year@2020_report#1.pdf\")\n\n    def test_nested_directories(self):\n        self.assertEqual(simplify_windows_path(\"G:\\\\folder1\\\\folder2\\\\folder3\\\\file.jpeg\"), \"G_folder1_folder2_folder3_file.jpeg\")",
    "prompt": "please write a python function the function signature as below def simplify_windows_path(path: str) -> str:\n    \"\"\"\n    simplify file paths in windows systems into name strings, for example, D:\\downlaod\\text.py is simplified to D_download_text.py\n    Args:\n        path (str): windows file path str\n    Returns:\n        simplify path str\n    \"\"\"\n"
  },
  {
    "task_id": 7,
    "code_type": "class",
    "code_language": "python",
    "code_signature": "import logging\n\n\nclass Logger:\n    def __init__(self, name, level=logging.DEBUG):\n        \"\"\"\n        Initializes a new logger instance.\n\n        :param name: Name of the logger, typically __name__ to reference the module name.\n        :param level: Logging level, default is DEBUG.\n        \"\"\"\n\n    def log(self, level, message):\n        \"\"\"\n        Logs a message with the given level.\n\n        :param level: Logging level for the message (e.g., logging.INFO).\n        :param message: Log message.\n        \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogger(unittest.TestCase):\n    def setUp(self):\n        self.logger_name = 'test_logger'\n        self.logger = Logger(self.logger_name)\n\n    @patch('logging.Logger.debug')\n    def test_debug_logging(self, mock_debug):\n        message = \"This is a debug message\"\n        self.logger.log(logging.DEBUG, message)\n        mock_debug.assert_called_once_with(message)\n\n    @patch('logging.Logger.info')\n    def test_info_logging(self, mock_info):\n        message = \"This is an info message\"\n        self.logger.log(logging.INFO, message)\n        mock_info.assert_called_once_with(message)\n\n    @patch('logging.Logger.warning')\n    def test_warning_logging(self, mock_warning):\n        message = \"This is a warning message\"\n        self.logger.log(logging.WARNING, message)\n        mock_warning.assert_called_once_with(message)\n\n    @patch('logging.Logger.error')\n    def test_error_logging(self, mock_error):\n        message = \"This is an error message\"\n        self.logger.log(logging.ERROR, message)\n        mock_error.assert_called_once_with(message)\n\n    @patch('logging.Logger.critical')\n    def test_critical_logging(self, mock_critical):\n        message = \"This is a critical message\"\n        self.logger.log(logging.CRITICAL, message)\n        mock_critical.assert_called_once_with(message)",
    "prompt": "please write a python class this class signature as below import logging\n\n\nclass Logger:\n    def __init__(self, name, level=logging.DEBUG):\n        \"\"\"\n        Initializes a new logger instance.\n\n        :param name: Name of the logger, typically __name__ to reference the module name.\n        :param level: Logging level, default is DEBUG.\n        \"\"\"\n\n    def log(self, level, message):\n        \"\"\"\n        Logs a message with the given level.\n\n        :param level: Logging level for the message (e.g., logging.INFO).\n        :param message: Log message.\n        \"\"\"\n"
  },
  {
    "task_id": 8,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting data\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted data\n\n    Returns: decrypted data\n\n    \"\"\"",
    "test_code": "import unittest\n\n\nclass TestDecryptFunction(unittest.TestCase):\n    def test_basic_functionality(self):\n        self.assertEqual(perform_polynomial_decryption(4, 5, [1, 2, 3, 4], [5, 6, 7, 8]), [4, 4, 4, 4])\n\n    def test_zero_secret_key(self):\n        self.assertEqual(perform_polynomial_decryption(3, 7, [0, 0, 0], [6, 13, 20]), [6, 6, 6])\n\n    def test_zero_ciphertext(self):\n        self.assertEqual(perform_polynomial_decryption(3, 9, [1, 2, 3], [0, 0, 0]), [8, 7, 6])\n\n    def test_large_values(self):\n        self.assertEqual(perform_polynomial_decryption(2, 1000, [500, 500], [1000, 1000]), [500, 500])\n\n\ndef perform_polynomial_decryption(degree, modulus, key, encrypted_data):\n    # Decrypts the polynomial based encryption by reversing the encryption steps\n    decrypted_data = [0] * degree\n\n    for index in range(degree):\n        # Reversing encryption: subtract key and take modulo\n        decrypted_data[index] = (encrypted_data[index] - key[index]) % modulus\n\n    return decrypted_data\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef perform_polynomial_decryption(degree: int, modulus: int, key: List[int], encrypted_data: List[int]) -> List[int]:\n    \"\"\"\n    Implement decryption based on polynomials and keys\n    Args:\n        degree (int): The highest degree of a polynomial is added by one\n        modulus (int): Modulus to use when encrypting data\n        key (List[int]): An array of encrypted keys\n        encrypted_data (List[int]): An array of encrypted data\n\n    Returns: decrypted data\n\n    \"\"\""
  },
  {
    "task_id": 9,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\"",
    "test_code": "import unittest\n\n\ndef is_point_on_line(A, B, C):\n    (x_a, y_a), (x_b, y_b), (x_c, y_c) = A, B, C\n    if x_a == x_b:  # Check for vertical line\n        return x_c == x_a\n    return (y_c - y_a) * (x_b - x_a) == (y_b - y_a) * (x_c - x_a)\n\n\nclass TestPointOnLine(unittest.TestCase):\n    def test_point_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_line(self):\n        A = (0, 0)\n        B = (10, 10)\n        C = (5, 6)\n        self.assertFalse(is_point_on_line(A, B, C))\n\n    def test_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_horizontal_line(self):\n        A = (0, 5)\n        B = (10, 5)\n        C = (5, 5)\n        self.assertTrue(is_point_on_line(A, B, C))\n\n    def test_point_not_on_vertical_line(self):\n        A = (5, 0)\n        B = (5, 10)\n        C = (6, 5)\n        self.assertFalse(is_point_on_line(A, B, C))\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef is_point_on_line(A: List[int], B: List[int], C: List[int]) -> bool:\n    \"\"\"\n    Check whether A point is on a line formed by two points, such as point C is on a line formed by points A and B\n    Args:\n        A (List[int]): point A xy\n        B (List[int]): point B xy\n        C (List[int]): point C xy\n\n    Returns: is C in line of A B\n\n    \"\"\""
  },
  {
    "task_id": 11,
    "code_type": "class",
    "code_language": "python",
    "code_signature": "class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n",
    "test_code": "import unittest\n\nfrom total_python.t11.adapted import Trie\n\n\nclass TestTrie(unittest.TestCase):\n    def setUp(self):\n        self.trie = Trie()\n        self.trie.insert(\"apple\")\n        self.trie.insert(\"app\")\n        self.trie.insert(\"apricot\")\n        self.trie.insert(\"banana\")\n        self.trie.insert(\"carrot\")\n        self.trie.insert(\"car\")\n        self.trie.insert(\"care\")\n        self.trie.insert(\"\")\n        self.trie.insert(\"Hello\")\n        self.trie.insert(\"hello\")\n\n    def test_basic_search(self):\n        self.assertTrue(self.trie.search(\"apple\"))\n        self.assertTrue(self.trie.search(\"app\"))\n        self.assertTrue(self.trie.search(\"apricot\"))\n\n    def test_unsuccessful_search(self):\n        self.assertFalse(self.trie.search(\"bandana\"))\n\n    def test_prefix_search(self):\n        self.assertTrue(self.trie.starts_with(\"car\"))\n        self.assertTrue(self.trie.starts_with(\"care\"))\n        self.assertFalse(self.trie.starts_with(\"cat\"))\n\n    def test_empty_string(self):\n        self.assertTrue(self.trie.search(\"\"))\n        self.assertTrue(self.trie.starts_with(\"\"))\n\n    def test_case_sensitivity(self):\n        self.assertTrue(self.trie.search(\"Hello\"))\n        self.assertTrue(self.trie.search(\"hello\"))\n        self.assertFalse(self.trie.search(\"HELLO\"))\n",
    "prompt": "please write a python class this class signature as below class Trie:\n    \"\"\"\n    Implement a dictionary tree for fast string retrieval and storage\n    \"\"\"\n\n    def insert(self, word):\n        pass\n\n    def search(self, word):\n        pass\n\n    def starts_with(self, prefix):\n        pass\n\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n"
  },
  {
    "task_id": 12,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation data with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n",
    "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestCalculateDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Both agents are at the same point\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 0.0)\n\n    def test_horizontal_distance(self):\n        # Agents are horizontally apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 3, \"y\": 0}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 3.0)\n\n    def test_vertical_distance(self):\n        # Agents are vertically apart\n        observations = {\n            \"agent1\": {\"x\": 0, \"y\": 0},\n            \"agent2\": {\"x\": 0, \"y\": 4}\n        }\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), 4.0)\n\n    def test_diagonal_distance(self):\n        # Agents are diagonally apart\n        observations = {\n            \"agent1\": {\"x\": 1, \"y\": 2},\n            \"agent2\": {\"x\": 4, \"y\": 6}\n        }\n        expected_distance = np.sqrt((4 - 1) ** 2 + (6 - 2) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)\n\n    def test_negative_coordinates(self):\n        # Agents have negative coordinates\n        observations = {\n            \"agent1\": {\"x\": -1, \"y\": -1},\n            \"agent2\": {\"x\": -4, \"y\": -5}\n        }\n        expected_distance = np.sqrt((-4 + 1) ** 2 + (-5 + 1) ** 2)\n        self.assertAlmostEqual(calculate_distance(\"agent1\", \"agent2\", observations), expected_distance)",
    "prompt": "please write a python function the function signature as below def calculate_distance(agent1: str, agent2: str, observations: dict) -> float:\n    \"\"\"\n    Calculates the Euclidean distance between two agents based on their coordinates in the observations.\n\n    Args:\n        agent1 (str): String representation of agent1's identifier.\n        agent2 (str): String representation of agent2's identifier.\n        observations (dict): Dictionary containing observation data with agent identifiers as keys.Each value is a dictionary with 'x' and 'y' keys representing coordinates.\n\n    Returns:\n        float: Euclidean distance between the two agents.\n    \"\"\"\n"
  },
  {
    "task_id": 13,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "",
    "test_code": "import unittest\n\n\nclass TestParseMarkdownTable(unittest.TestCase):\n    def test_standard_table(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        | Row1Col1 | Row1Col2 | Row1Col3 |\n        | Row2Col1 | Row2Col2 | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_inconsistent_columns(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 |\n        |----------|----------|\n        | Row1     | Row1Col2 | ExtraCol |\n        | Row2     |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2'),\n            ('Row1', 'Row1Col2', 'ExtraCol'),\n            ('Row2',)\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_empty_cells(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          | Row1Col2 |          |\n        | Row2Col1 |          | Row2Col3 |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', 'Row1Col2', ''),\n            ('Row2Col1', '', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_all_empty_rows(self):\n        md_table = \"\"\"\n        | Header 1 | Header 2 | Header 3 |\n        |----------|----------|----------|\n        |          |          |          |\n        |          |          |          |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('', '', ''),\n            ('', '', '')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n    def test_excessive_whitespace(self):\n        md_table = \"\"\"\n        |  Header 1  |  Header 2  |  Header 3  |\n        |------------|------------|------------|\n        |  Row1Col1  |  Row1Col2  |  Row1Col3  |\n        |  Row2Col1  |  Row2Col2  |  Row2Col3  |\n        \"\"\"\n        expected = [\n            ('Header 1', 'Header 2', 'Header 3'),\n            ('Row1Col1', 'Row1Col2', 'Row1Col3'),\n            ('Row2Col1', 'Row2Col2', 'Row2Col3')\n        ]\n        result = parse_markdown_table(md_table)\n        self.assertEqual(result, expected)\n\n\ndef parse_markdown_table(md_table):\n    \"\"\"\n    Parses a Markdown formatted table into a list of tuples, each tuple representing a row.\n\n    Args:\n        md_table (str): A string representing a Markdown table.\n\n    Returns:\n        list of tuples: A list where each tuple represents a row in the table.\n    \"\"\"\n    # Split the input string into lines and strip whitespace\n    lines = md_table.strip().split('\\n')\n\n    # Filter out the separator line for the header (which usually contains \"---\")\n    lines = [line for line in lines if not line.strip().startswith('|---')]\n\n    # Initialize the list to store each row as a tuple\n    table_data = []\n\n    # Process each line\n    for line in lines:\n        # Strip leading and trailing spaces and pipes, then split by \"|\"\n        row = line.strip('| \\n').split('|')\n        # Strip spaces from each cell, handle empty cells, and create a tuple\n        table_data.append(tuple(cell.strip() for cell in row if cell.strip() or cell == ''))\n\n    return table_data\n",
    "prompt": "please write a python function the function signature as below "
  },
  {
    "task_id": 14,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef find_json_files_with_keyword(directory:str, keyword:str) ->List[str]:\n    \"\"\"\n    Select all json files containing the keyword from the specified directory, and return all matching json file names in the form of a list\n\n    Args:\n        directory (str): Path to the directory where JSON files are stored.\n        keyword (str): Keyword to search for within the JSON files.\n\n    Returns:\n        list: A list of filenames (str) of JSON files containing the keyword.\n    \"\"\"",
    "test_code": "import unittest\nfrom unittest.mock import patch, mock_open\n\n\nclass TestFindJsonFilesWithKeyword(unittest.TestCase):\n    @patch('os.walk')\n    @patch('builtins.open', new_callable=mock_open, read_data='{\"key\": \"value with keyword\"}')\n    @patch('json.load', return_value={\"key\": \"value with keyword\"})\n    def test_keyword_in_single_file(self, mock_json_load, mock_file, mock_os_walk):\n        mock_os_walk.return_value = [\n            ('/some/folder', (), ('test.js.json',)),\n        ]\n        expected = ['test.js.json']\n        result = find_json_files_with_keyword('/some/folder', 'keyword')\n        self.assertEqual(result, expected)\n\n    @patch('os.walk')\n    @patch('builtins.open', new_callable=mock_open, read_data='{\"key\": \"no keyword here\"}')\n    @patch('json.load', return_value={\"key\": \"no keyword here\"})\n    def test_keyword_not_in_file(self, mock_json_load, mock_file, mock_os_walk):\n        mock_os_walk.return_value = [\n            ('/some/folder', (), ('test.js.json',)),\n        ]\n        expected = []\n        result = find_json_files_with_keyword('/some/folder', 'wc')\n        self.assertEqual(result, expected)\n\n    @patch('os.walk')\n    def test_no_json_files_in_directory(self, mock_os_walk):\n        mock_os_walk.return_value = [\n            ('/some/folder', (), ('test.js.txt', 'image.png')),\n        ]\n        expected = []\n        result = find_json_files_with_keyword('/some/folder', 'keyword')\n        self.assertEqual(result, expected)\n\n    @patch('os.walk')\n    @patch('builtins.open', new_callable=mock_open, read_data='{\"key\": \"keyword present here\"}')\n    @patch('json.load', return_value={\"key\": \"keyword present here\"})\n    def test_multiple_json_files(self, mock_json_load, mock_file, mock_os_walk):\n        mock_os_walk.return_value = [\n            ('/some/folder', (), ('file1.json', 'file2.json')),\n        ]\n        expected = ['file1.json', 'file2.json']\n        result = find_json_files_with_keyword('/some/folder', 'keyword')\n        self.assertEqual(result, expected)\n\n    @patch('os.walk')\n    @patch('builtins.open', new_callable=mock_open, read_data='{\"key\": \"error expected\"}')\n    @patch('json.load', side_effect=Exception(\"Failed to load JSON\"))\n    def test_json_parsing_error(self, mock_json_load, mock_file, mock_os_walk):\n        mock_os_walk.return_value = [\n            ('/some/folder', (), ('corrupt.json',)),\n        ]\n        expected = []  # Assuming the function does not crash and handles errors gracefully\n        result = find_json_files_with_keyword('/some/folder', 'keyword')\n        self.assertEqual(result, expected)",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef find_json_files_with_keyword(directory:str, keyword:str) ->List[str]:\n    \"\"\"\n    Select all json files containing the keyword from the specified directory, and return all matching json file names in the form of a list\n\n    Args:\n        directory (str): Path to the directory where JSON files are stored.\n        keyword (str): Keyword to search for within the JSON files.\n\n    Returns:\n        list: A list of filenames (str) of JSON files containing the keyword.\n    \"\"\""
  },
  {
    "task_id": 17,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\"",
    "test_code": "import unittest\n\n\nclass TestHaversineDistance(unittest.TestCase):\n\n    def test_same_point(self):\n        # Same point should return a distance of 0\n        lat, lon = 52.2296756, 21.0122287\n        result = haversine_distance(lat, lon, lat, lon)\n        self.assertAlmostEqual(result, 0.0, places=6)\n\n    def test_small_distance(self):\n        # Points that are very close together (few meters apart)\n        lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n        lat2, lon2 = 52.2296756, 21.0122297  # Very close to the previous point\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 0.0001, places=4)  # Expected small distance\n\n    def test_large_distance(self):\n        # Points that are far apart\n        lat1, lon1 = 52.2296756, 21.0122287  # Warsaw, Poland\n        lat2, lon2 = 41.8919300, 12.5113300  # Rome, Italy\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 1315.514, places=2)  # Approx distance in km\n\n    def test_equator_distance(self):\n        # Points on the equator\n        lat1, lon1 = 0.0, 0.0  # Gulf of Guinea (Equator and Prime Meridian intersection)\n        lat2, lon2 = 0.0, 90.0  # On the Equator, 90 degrees east\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 10007.54, places=2)  # Approx quarter of Earth's circumference\n\n    def test_pole_to_pole(self):\n        # Distance from North Pole to South Pole\n        lat1, lon1 = 90.0, 0.0  # North Pole\n        lat2, lon2 = -90.0, 0.0  # South Pole\n        result = haversine_distance(lat1, lon1, lat2, lon2)\n        self.assertAlmostEqual(result, 20015.09, places=2)  # Approx half of Earth's circumference\n",
    "prompt": "please write a python function the function signature as below def haversine_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the distance between two points on the earth based on their latitude and longitude\n    Args:\n        lat1 (float): Latitude of the first point in degrees.\n        lon1 (float): Longitude of the first point in degrees.\n        lat2 (float): Latitude of the second point in degrees.\n        lon2 (float): Longitude of the second point in degrees.\n\n    Returns:\n        Distance between the two points in kilometers.\n    \"\"\""
  },
  {
    "task_id": 18,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestFloatToRGB(unittest.TestCase):\n\n    def test_pure_red(self):\n        # Value at the lower boundary (0.0) should return pure red\n        result = float_to_rgb(0.0)\n        self.assertEqual(result, (255, 0, 0))\n\n    def test_pure_green(self):\n        # Value at the upper boundary (1.0) should return pure green\n        result = float_to_rgb(1.0)\n        self.assertEqual(result, (0, 255, 0))\n\n    def test_midpoint(self):\n        # Value at 0.5 should return an equal mix of red and green, resulting in yellow\n        result = float_to_rgb(0.5)\n        self.assertEqual(result, (127, 127, 0))\n\n    def test_quarter_point(self):\n        # Value at 0.25 should return more red than green\n        result = float_to_rgb(0.25)\n        self.assertEqual(result, (191, 63, 0))\n\n    def test_invalid_value(self):\n        # Value outside the range [0, 1] should raise a ValueError\n        with self.assertRaises(ValueError):\n            float_to_rgb(1.5)",
    "prompt": "please write a python function the function signature as below def float_to_rgb(value: float) -> tuple:\n    \"\"\"\n    convert a floating point number between 0 and 1 to a color from red to green in the color format RGB\n    Args:\n        value (float): a float between 0 and 1.\n\n    Returns:\n        a tuple representing the RGB color.\n    \"\"\"\n"
  },
  {
    "task_id": 19,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def contains_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n",
    "test_code": "import re\nimport unittest\n\n\nclass TestPhoneNumberDetection(unittest.TestCase):\n    def test_with_international_prefix(self):\n        self.assertTrue(contains_phone_number(\"+1-800-555-1234\"), \"Should detect international prefix\")\n\n    def test_with_standard_dashes(self):\n        self.assertTrue(contains_phone_number(\"800-555-1234\"), \"Should detect standard format with dashes\")\n\n    def test_with_spaces(self):\n        self.assertTrue(contains_phone_number(\"800 555 1234\"), \"Should detect standard format with spaces\")\n\n    def test_without_phone_number(self):\n        self.assertFalse(contains_phone_number(\"Hello, world!\"), \"Should not detect any phone number\")\n\n    def test_with_text_containing_numbers(self):\n        self.assertTrue(contains_phone_number(\"Call me at 800-555-1234 today!\"), \"Should detect phone number in text\")",
    "prompt": "please write a python function the function signature as below def contains_phone_number(s: str) -> bool:\n    \"\"\"\n    determines whether the string contains a phone number; a possible format for a phone number is +1-800-555-1234, 555-555-1234, 555 555 1234\n    Args:\n        s (str): input str maybe contain phone number\n\n    Returns: weather this str contain phone number\n\n    \"\"\"\n"
  },
  {
    "task_id": 20,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def process_markdown(s: str) -> str:\n    \"\"\"\n    processing the content of the Markdown file, remove unnecessary asterisks from the string and keep only the outermost asterisks. For example,\"*some*text*\" becomes \"* sometime *\"\n\n    Args:\n        s (str): The input string containing markdown-style asterisks.\n\n    Returns:\n        str: The processed string with asterisks removed, except for the first and last ones.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestProcessMarkdown(unittest.TestCase):\n\n\n    def test_single_asterisk_pair(self):\n        content = \"This is a *test.js* string.\"\n        expected = \"This is a *test.js* string.\"\n        self.assertEqual(process_markdown(content), expected)\n\n    def test_nested_asterisks(self):\n        content = \"Example of **nested *asterisks***.\"\n        expected = \"Example of *nested asterisks*.\"\n        self.assertEqual(process_markdown(content), expected)\n\n    def test_multiple_asterisk_pairs(self):\n        content = \"*Multiple* pairs of *asterisks* in *one* sentence.\"\n        expected = \"*Multiple pairs of asterisks in one* sentence.\"\n        self.assertEqual(process_markdown(content), expected)\n\n    def test_asterisks_with_no_text(self):\n        content = \"Asterisks with ** no text.\"\n        expected = \"Asterisks with ** no text.\"\n        self.assertEqual(process_markdown(content), expected)\n\n    def test_asterisks_around_spaces(self):\n        content = \"Asterisks around * *spaces* * are tricky.\"\n        expected = \"Asterisks around * spaces * are tricky.\"\n        self.assertEqual(process_markdown(content), expected)",
    "prompt": "please write a python function the function signature as below def process_markdown(s: str) -> str:\n    \"\"\"\n    processing the content of the Markdown file, remove unnecessary asterisks from the string and keep only the outermost asterisks. For example,\"*some*text*\" becomes \"* sometime *\"\n\n    Args:\n        s (str): The input string containing markdown-style asterisks.\n\n    Returns:\n        str: The processed string with asterisks removed, except for the first and last ones.\n    \"\"\"\n"
  },
  {
    "task_id": 21,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef compare_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestCompareFiles(unittest.TestCase):\n    def test_identical_files(self):\n        # Mock data for two identical files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLine2\\nLine3\\n\"\n        mocker = mock_open(read_data=file1_content)\n        mocker.side_effect = [mocker.return_value, mock_open(read_data=file2_content).return_value]\n        with patch('builtins.open', mocker):\n            result = compare_files('file1.txt', 'file2.txt')\n            self.assertEqual(len(result), 0, \"There should be differences detected\")\n\n    def test_files_with_differences(self):\n        # Mock data for two different files\n        file1_content = \"Line1\\nLine2\\nLine3\\n\"\n        file2_content = \"Line1\\nLineChanged\\nLine3\\n\"\n        mocker = mock_open(read_data=file1_content)\n        mocker.side_effect = [mocker.return_value, mock_open(read_data=file2_content).return_value]\n        with patch('builtins.open', mocker):\n            result = compare_files('file1.txt', 'file2.txt')\n            self.assertNotEqual(len(result), 0, \"There should be differences detected\")\n\n    def test_nonexistent_file(self):\n        # Test when one of the files does not exist\n        with patch('builtins.open', side_effect=FileNotFoundError(\"File not found\")):\n            with self.assertRaises(FileNotFoundError):\n                compare_files('nonexistent.txt', 'file2.txt')\n\n    def test_file_reading_error(self):\n        # Test when there's an error reading the file\n        with patch('builtins.open', side_effect=IOError(\"Error reading file\")):\n            with self.assertRaises(IOError):\n                compare_files('file1.txt', 'file2.txt')\n\n    def test_multiple_lines_of_differences(self):\n        # Test files with multiple differences\n        file1_content = \"Line1\\nLine2\\nLine3\\nLine4\\n\"\n        file2_content = \"Line1\\nLine2 changed\\nLine3\\nLine4 modified\\n\"\n        mocker = mock_open(read_data=file1_content)\n        mocker.side_effect = [mocker.return_value, mock_open(read_data=file2_content).return_value]\n        with patch('builtins.open', mocker):\n            result = compare_files('file1.txt', 'file2.txt')\n            self.assertTrue(len(result) > 1, \"Multiple differences should be reported\")\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef compare_files(file1_path: str, file2_path: str) -> List[str]:\n    \"\"\"\n    Compare the contents of two files and print the differences in unified diff format.\n\n    Args:\n    file1_path (str): Path to the first file.\n    file2_path (str): Path to the second file.\n\n    Returns:\n    List[str]: A list containing the lines of differences, if any.\n\n    Raises:\n    FileNotFoundError: If either file does not exist.\n    IOError: If there is an error reading the files.\n    \"\"\"\n"
  },
  {
    "task_id": 22,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Tuple\n\n\ndef calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    calculate the Euclidean distance between two points in a 2D space.\n\n    Args:\n        point1 (Tuple[float, float]): The first point as a tuple of coordinates (x1, y1).\n        point2 (Tuple[float, float]): The second point as a tuple of coordinates (x2, y2).\n\n    Returns:\n        float: The Euclidean distance between the two points.\n\n    \"\"\"\n",
    "test_code": "import unittest\nfrom typing import Tuple\n\nclass TestCalculateEuclideanDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        # Basic logic functionality test.js\n        point1 = (0, 0)\n        point2 = (3, 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should calculate the distance correctly\")\n\n    def test_negative_coordinates(self):\n        # Test with negative coordinates\n        point1 = (-1, -1)\n        point2 = (-4, -5)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle negative coordinates correctly\")\n\n    def test_zero_distance(self):\n        # Boundary test.js: points are the same\n        point1 = (2, 3)\n        point2 = (2, 3)\n        expected_distance = 0.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should return 0 when both points are the same\")\n\n    def test_large_coordinates(self):\n        # Boundary test.js: large coordinates\n        point1 = (1e6, 1e6)\n        point2 = (1e6 + 3, 1e6 + 4)\n        expected_distance = 5.0\n        self.assertEqual(calculate_euclidean_distance(point1, point2), expected_distance, \"Should handle large coordinates correctly\")\n\n    def test_invalid_input(self):\n        # Exception handling test.js: invalid input (non-tuple)\n        with self.assertRaises(TypeError):\n            calculate_euclidean_distance(\"invalid\", (0, 0))\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
    "prompt": "please write a python function the function signature as below from typing import Tuple\n\n\ndef calculate_euclidean_distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float:\n    \"\"\"\n    calculate the Euclidean distance between two points in a 2D space.\n\n    Args:\n        point1 (Tuple[float, float]): The first point as a tuple of coordinates (x1, y1).\n        point2 (Tuple[float, float]): The second point as a tuple of coordinates (x2, y2).\n\n    Returns:\n        float: The Euclidean distance between the two points.\n\n    \"\"\"\n"
  },
  {
    "task_id": 23,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Union\n\n\ndef get_line_segment_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestLineSegmentIntersection(unittest.TestCase):\n    def test_intersecting_lines(self):\n        self.assertEqual(\n            get_line_segment_intersection(((1, 1), (4, 4)), ((1, 4), (4, 1))),\n            (2.5, 2.5),\n            \"Should find intersection at (2.5, 2.5)\"\n        )\n\n    def test_parallel_lines(self):\n        self.assertIsNone(\n            get_line_segment_intersection(((1, 1), (4, 4)), ((2, 2), (5, 5))),\n            \"Should return None for parallel lines\"\n        )\n\n    def test_no_intersection(self):\n        self.assertIsNone(\n            get_line_segment_intersection(((1, 1), (2, 2)), ((3, 3), (4, 4))),\n            \"Should return None when there is no intersection\"\n        )\n\n    def test_intersection_in_middle(self):\n        result = get_line_segment_intersection(((0, 0), (4, 4)), ((0, 4), (4, 0)))\n        self.assertIsNotNone(result, \"Should find an intersection at the middle (2, 2)\")\n        self.assertAlmostEqual(result[0], 2, places=7, msg=\"X coordinate should be close to 2\")\n        self.assertAlmostEqual(result[1], 2, places=7, msg=\"Y coordinate should be close to 2\")\n\n    def test_identical_segments(self):\n        self.assertIsNone(\n            get_line_segment_intersection(((1, 1), (4, 4)), ((1, 1), (4, 4))),\n            \"Should return None for identical segments\"\n        )\n\n",
    "prompt": "please write a python function the function signature as below from typing import Union\n\n\ndef get_line_segment_intersection(seg1: tuple, seg2: tuple) -> Union[tuple, None]:\n    \"\"\"\n    calculate the intersection point of two line segments, if it exists.\n\n    Args:\n        seg1 (tuple): Coordinates of the first line segment, defined as ((x1, y1), (x2, y2)).\n        seg2 (tuple): Coordinates of the second line segment, defined as ((x3, y3), (x4, y4)).\n\n    Returns:\n        Union[tuple, None]: The (x, y) coordinates of the intersection point if the line segments intersect,\n                            otherwise None.\n    \"\"\"\n"
  },
  {
    "task_id": 24,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n",
    "test_code": "import unittest\nimport os\nimport json\nimport yaml\n\n\nclass TestConvertYamlToJson(unittest.TestCase):\n\n    def setUp(self):\n        # Create temporary YAML files for testing\n        self.simple_yaml = 'simple.yaml'\n        self.nested_yaml = 'nested.yaml'\n        self.empty_yaml = 'empty.yaml'\n        self.list_yaml = 'list.yaml'\n        self.invalid_yaml = 'invalid.yaml'\n\n        with open(self.simple_yaml, 'w') as file:\n            file.write(\"name: John Doe\\nage: 30\\n\")\n\n        with open(self.nested_yaml, 'w') as file:\n            file.write(\"person:\\n  name: Jane Doe\\n  age: 25\\n  address:\\n    city: New York\\n    zip: 10001\\n\")\n\n        with open(self.empty_yaml, 'w') as file:\n            file.write(\"\")\n\n        with open(self.list_yaml, 'w') as file:\n            file.write(\"- item1\\n- item2\\n- item3\\n\")\n\n        with open(self.invalid_yaml, 'w') as file:\n            file.write(\"{ invalid: YAML: structure }\\n\")\n\n    def tearDown(self):\n        # Remove temporary files after testing\n        os.remove(self.simple_yaml)\n        os.remove(self.nested_yaml)\n        os.remove(self.empty_yaml)\n        os.remove(self.list_yaml)\n        os.remove(self.invalid_yaml)\n\n        if os.path.exists('output.json'):\n            os.remove('output.json')\n\n    def test_simple_yaml_conversion(self):\n        convert_yaml_to_json(self.simple_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, {\"name\": \"John Doe\", \"age\": 30})\n\n    def test_nested_yaml_conversion(self):\n        convert_yaml_to_json(self.nested_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        expected_data = {\n            \"person\": {\n                \"name\": \"Jane Doe\",\n                \"age\": 25,\n                \"address\": {\n                    \"city\": \"New York\",\n                    \"zip\": 10001\n                }\n            }\n        }\n        self.assertEqual(data, expected_data)\n\n    def test_empty_yaml_conversion(self):\n        convert_yaml_to_json(self.empty_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, None)  # YAML.safe_load() returns None for empty files\n\n    def test_list_yaml_conversion(self):\n        convert_yaml_to_json(self.list_yaml, 'output.json')\n        with open('output.json', 'r') as jf:\n            data = json.load(jf)\n        self.assertEqual(data, [\"item1\", \"item2\", \"item3\"])\n\n    def test_invalid_yaml_conversion(self):\n        with self.assertRaises(yaml.YAMLError):\n            convert_yaml_to_json(self.invalid_yaml, 'output.json')\n",
    "prompt": "please write a python function the function signature as below def convert_yaml_to_json(yaml_file: str, json_file: str) -> None:\n    \"\"\"\n    convert yaml format files to json format files\n    Args:\n        yaml_file (str): path to the input YAML file.\n        json_file (str): path to the output JSON file.\n\n    Returns:\n\n    \"\"\"\n"
  },
  {
    "task_id": 25,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file data based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n",
    "test_code": "import unittest\nimport json\nimport tempfile\nimport os\n\nclass TestClassifyJsonObjectsByPid(unittest.TestCase):\n    def setUp(self):\n        # Create a temporary directory\n        self.temp_dir = tempfile.mkdtemp()\n\n        # Create temporary files for testing\n        self.source_file = os.path.join(self.temp_dir, 'source.json')\n        self.match_file = os.path.join(self.temp_dir, 'match.json')\n        self.mismatch_file = os.path.join(self.temp_dir, 'mismatch.json')\n\n        # Example data\n        self.data = [\n            {\"name\": \"Alice\", \"pid\": 1},\n            {\"name\": \"Bob\", \"pid\": 2},\n            {\"name\": \"Charlie\", \"pid\": 3}\n        ]\n        self.pid_list = [1, 3]\n\n        # Write example data to source file\n        with open(self.source_file, 'w') as f:\n            json.dump(self.data, f)\n\n    def test_all_match(self):\n        # Test where all items match\n        classify_json_objects_by_pid(self.source_file, [1, 2, 3], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 3)\n        self.assertEqual(len(mismatches), 0)\n\n    def test_no_match(self):\n        # Test where no items match\n        classify_json_objects_by_pid(self.source_file, [4, 5], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n\n    def test_partial_match(self):\n        # Test where some items match\n        classify_json_objects_by_pid(self.source_file, self.pid_list, self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 2)\n        self.assertEqual(len(mismatches), 1)\n\n    def test_empty_pid_list(self):\n        # Test with an empty PID list\n        classify_json_objects_by_pid(self.source_file, [], self.match_file, self.mismatch_file)\n        with open(self.match_file, 'r') as f:\n            matches = json.load(f)\n        with open(self.mismatch_file, 'r') as f:\n            mismatches = json.load(f)\n        self.assertEqual(len(matches), 0)\n        self.assertEqual(len(mismatches), 3)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef classify_json_objects_by_pid(source_file: str, pid_list: List[int], match_file: str, mismatch_file: str) -> None:\n    \"\"\"\n    read the JSON file data based on whether the pid field in the object is included in a specified pid_list. These objects are then classified into two categories based on matches and mismatches and saved in different files\n    Args:\n        source_file (str): Path to the source JSON file.\n        pid_list (list): List of pids to match.\n        match_file (str): Path to save matching objects JSON.\n        mismatch_file (str): Path to save mismatching objects JSON.\n\n    Returns:\n\n    \"\"\"\n"
  },
  {
    "task_id": 26,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestConvertToCommaSeparated(unittest.TestCase):\n    def test_basic_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"apple;banana*orange/mango\"), \"apple,banana,orange,mango\",\n                         \"Failed to convert basic separators.\")\n\n    def test_mixed_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"grapes;lemon/melon*kiwi;litchi\"), \"grapes,lemon,melon,kiwi,litchi\",\n                         \"Failed to convert mixed separators in a string.\")\n\n    def test_no_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"watermelon\"), \"watermelon\",\n                         \"Failed when no separators are present.\")\n\n    def test_repeated_separators(self):\n        self.assertEqual(convert_to_comma_separated(\"pear;;apple**banana//orange\"), \"pear,,apple,,banana,,orange\",\n                         \"Failed to handle repeated separators correctly.\")\n\n    def test_multiple_types(self):\n        self.assertEqual(convert_to_comma_separated(\"papaya;guava*fig/tomato:carrot-lettuce\"),\n                         \"papaya,guava,fig,tomato,carrot,lettuce\",\n                         \"Failed to handle multiple types of separators.\")\n",
    "prompt": "please write a python function the function signature as below def convert_to_comma_separated(input_string: str) -> str:\n    \"\"\"\n    convert input strings that contain multiple separators (for example, * ; /) to comma-separated formatted strings\n\n    Args:\n        input_string (str): The input string containing various separators like *, ;, /, -, :\n\n    Returns:\n        str: A comma-separated string where all specified separators have been replaced with commas.\n    \"\"\"\n"
  },
  {
    "task_id": 27,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged data\n\n    \"\"\"\n",
    "test_code": "import json\nimport os\nimport unittest\n\n\nclass TestConcatenateJsonArrays(unittest.TestCase):\n\n    def setUp(self):\n        # Set up a test.js directory and test.js files\n        self.test_dir = 'test_json'\n        os.makedirs(self.test_dir, exist_ok=True)\n        # Create test.js JSON files\n        self.create_test_file('array1.json', [1, 2, 3])\n        self.create_test_file('array2.json', ['a', 'b', 'c'])\n        self.create_test_file('not_array.json', {'key': 'value'})\n        self.create_test_file('empty.json', [])\n        self.create_test_file('non_json.txt', \"This is not a JSON file.\")\n\n    def tearDown(self):\n        # Clean up: Remove created files and directory\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def create_test_file(self, filename, content):\n        # Helper method to create JSON files\n        with open(os.path.join(self.test_dir, filename), 'w') as f:\n            json.dump(content, f)\n\n    def test_concatenate_valid_json_arrays(self):\n        # Test with valid JSON arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertCountEqual(result, [1, 2, 3, 'a', 'b', 'c'])\n\n    def test_ignore_non_array_json(self):\n        # Test that non-array JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn('key', result)\n\n    def test_ignore_non_json_files(self):\n        # Test that non-JSON files are ignored\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn(\"This is not a JSON file.\", result)\n\n    def test_handle_empty_arrays(self):\n        # Test concatenation includes empty arrays\n        result = concatenate_json_arrays(self.test_dir)\n        self.assertNotIn([], result)\n\n    def test_empty_directory(self):\n        # Test with no JSON files in the directory\n        empty_dir = 'empty_test_json'\n        os.makedirs(empty_dir, exist_ok=True)\n        result = concatenate_json_arrays(empty_dir)\n        self.assertEqual(result, [])\n        os.rmdir(empty_dir)\n",
    "prompt": "please write a python function the function signature as below import os\nimport json\nfrom typing import List\n\n\ndef concatenate_json_arrays(directory: str) -> List:\n    \"\"\"\n    concatenate the root-level array JSON files in the specified directory\n    Args:\n        directory (str): directory dir path\n\n    Returns: merged data\n\n    \"\"\"\n"
  },
  {
    "task_id": 28,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.print format eg: Byte 0: 1 1 0 0 1 1 0 0 \\nByte 1: 1 1 1 1 0 0 0 0\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n",
    "test_code": "import unittest\nfrom io import StringIO\nimport sys\n\n\n\nclass TestPrintMemoryBits(unittest.TestCase):\n\n    def setUp(self):\n        # Capture the output during each test\n        self.held_stdout = StringIO()\n        sys.stdout = self.held_stdout\n\n    def tearDown(self):\n        # Restore the normal stdout\n        sys.stdout = sys.__stdout__\n\n    def test_single_byte(self):\n        memory_section = bytes([0b10101010])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"Byte 0: 1 0 1 0 1 0 1 0\"\n        self.assertEqual(output, expected_output)\n\n    def test_multiple_bytes(self):\n        memory_section = bytes([0b11001100, 0b11110000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"Byte 0: 1 1 0 0 1 1 0 0 \\nByte 1: 1 1 1 1 0 0 0 0\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_zeros(self):\n        memory_section = bytes([0b00000000])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"Byte 0: 0 0 0 0 0 0 0 0\"\n        self.assertEqual(output, expected_output)\n\n    def test_all_ones(self):\n        memory_section = bytes([0b11111111])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"Byte 0: 1 1 1 1 1 1 1 1\"\n        self.assertEqual(output, expected_output)\n\n    def test_mixed_bytes(self):\n        memory_section = bytes([0b01010101, 0b10000001])\n        print_memory_bits(memory_section)\n        output = self.held_stdout.getvalue().strip()\n        expected_output = \"Byte 0: 0 1 0 1 0 1 0 1 \\nByte 1: 1 0 0 0 0 0 0 1\"\n        self.assertEqual(output, expected_output)\n",
    "prompt": "please write a python function the function signature as below def print_memory_bits(memory_section: bytes):\n    \"\"\"\n    Prints the status of each bit (0 or 1) in the given section of memory.print format eg: Byte 0: 1 1 0 0 1 1 0 0 \\nByte 1: 1 1 1 1 0 0 0 0\n\n    Args:\n        memory_section (bytes): A bytes object representing the section of memory to be read.\n\n    Returns:\n\n    \"\"\"\n"
  },
  {
    "task_id": 31,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\"",
    "test_code": "import unittest\n\n\nclass TestCalculateRedProportion(unittest.TestCase):\n\n    def test_all_red_pixels(self):\n        # All pixels are fully red\n        pixels = [(255, 0, 0), (255, 0, 0), (255, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 1.0)\n\n    def test_no_red_pixels(self):\n        # No red component in any pixel\n        pixels = [(0, 255, 0), (0, 0, 255), (0, 255, 255)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_mixed_red_pixels(self):\n        # Mixed colors with some red components\n        pixels = [(100, 50, 50), (50, 100, 50), (200, 0, 0)]\n        total_red = 100 + 50 + 200\n        total_intensity = 100 + 50 + 50 + 50 + 100 + 50 + 200 + 0 + 0\n        expected_proportion = total_red / total_intensity\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, expected_proportion)\n\n    def test_empty_pixel_list(self):\n        # Empty list of pixels\n        pixels = []\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)\n\n    def test_all_black_pixels(self):\n        # All pixels are black\n        pixels = [(0, 0, 0), (0, 0, 0), (0, 0, 0)]\n        result = calculate_red_proportion(pixels)\n        self.assertAlmostEqual(result, 0.0)",
    "prompt": "please write a python function the function signature as below from typing import List, Tuple\n\n\ndef calculate_red_proportion(pixels: List[Tuple[int, int, int]]) -> float:\n    \"\"\"\n    Analyze a list of pixels, each represented by rgb, and calculate the proportion of red in the list.\n\n    Args:\n        pixels (List[Tuple[int, int, int]]): A list of pixels, where each pixel is represented as a tuple of (R, G, B).\n\n    Returns:\n        float: The proportion of red in the list of pixels, as a value between 0 and 1.\n    \"\"\""
  },
  {
    "task_id": 32,
    "code_type": "class",
    "code_language": "python",
    "code_signature": "import ctypes\n\n\nclass CRC64:\n    \"\"\"\n    Generated by GPT-4\n    \"\"\"\n\n    POLY64REV = 0xC96C5795D7870F42\n    crc64_tab = []\n\n    @classmethod\n    def crc64_init_table(cls):\n        pass\n\n    @staticmethod\n    def crc64_update(crc, byte):\n        pass\n\n    @classmethod\n    def compute(cls, input_integer):\n        pass\n",
    "test_code": "import unittest\n\n# Assuming the CRC64 class has already been defined as provided\n\nclass TestCRC64(unittest.TestCase):\n\n    def test_crc64_initialization(self):\n        # Test the initialization of the CRC64 table\n        CRC64.crc64_init_table()\n        self.assertTrue(len(CRC64.crc64_tab) == 256)\n        self.assertTrue(all(isinstance(x, int) for x in CRC64.crc64_tab))\n\n    def test_crc64_update(self):\n        # Test the crc64_update method with known values\n        CRC64.crc64_init_table()\n        initial_crc = 0xFFFFFFFFFFFFFFFF\n        byte = 0x01\n        updated_crc = CRC64.crc64_update(initial_crc, byte)\n        expected_crc = (CRC64.crc64_tab[0xFE] ^ (initial_crc >> 8)) & 0xFFFFFFFFFFFFFFFF\n        self.assertEqual(updated_crc, expected_crc)\n\n    def test_crc64_compute_positive_integer(self):\n        # Test compute method with a positive integer\n        result = CRC64.compute(1234567890)\n        # Expected CRC64 value calculated manually or from a trusted source\n        expected_result = 0xB0F9361BAEB8A24E\n        self.assertEqual(result, expected_result)\n\n    def test_crc64_compute_negative_integer(self):\n        # Test compute method with a negative integer\n        result = CRC64.compute(-1234567890)\n        # Expected CRC64 value calculated manually or from a trusted source\n        expected_result = 0x865B548A1C95DB76\n        self.assertEqual(result, expected_result)\n\n    def test_crc64_compute_zero(self):\n        # Test compute method with zero\n        result = CRC64.compute(0)\n        expected_result = 0xB90956C775A41001  # Example result for CRC64 of zero\n        self.assertEqual(result, expected_result)",
    "prompt": "please write a python class this class signature as below import ctypes\n\n\nclass CRC64:\n    \"\"\"\n    Generated by GPT-4\n    \"\"\"\n\n    POLY64REV = 0xC96C5795D7870F42\n    crc64_tab = []\n\n    @classmethod\n    def crc64_init_table(cls):\n        pass\n\n    @staticmethod\n    def crc64_update(crc, byte):\n        pass\n\n    @classmethod\n    def compute(cls, input_integer):\n        pass\n"
  },
  {
    "task_id": 33,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import pandas as pd\n\n\ndef xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and data of the DataFrame\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the XML file.\n    \"\"\"\n",
    "test_code": "import unittest\nimport pandas as pd\nfrom io import StringIO\nimport xml.etree.ElementTree as ET\n\nclass TestXmlToDataFrame(unittest.TestCase):\n    def test_single_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>John</name>\n                            <age>30</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'John', 'age': '30'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_multiple_sequences(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Alice</name>\n                            <age>25</age>\n                        </sequence>\n                        <sequence>\n                            <name>Bob</name>\n                            <age>22</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Alice', 'age': '25'}, {'name': 'Bob', 'age': '22'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_empty_sequence(self):\n        xml_data = \"\"\"<root>\n                        <sequence></sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_mixed_content(self):\n        xml_data = \"\"\"<root>\n                        <sequence>\n                            <name>Chris</name>\n                        </sequence>\n                        <sequence>\n                            <age>28</age>\n                        </sequence>\n                      </root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame([{'name': 'Chris', 'age': None}, {'name': None, 'age': '28'}])\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_no_sequences(self):\n        xml_data = \"\"\"<root></root>\"\"\"\n        xml_input = StringIO(xml_data)\n        df = xml_to_dataframe(xml_input)\n        expected = pd.DataFrame()\n        pd.testing.assert_frame_equal(df, expected)\n",
    "prompt": "please write a python function the function signature as below import pandas as pd\n\n\ndef xml_to_dataframe(xml_file: str) -> pd.DataFrame:\n    \"\"\"\n    convert the XML file into a pandas DataFrame, where each <sequence>tag is treated as a row record in the XML, and the tag and text content of each sub-element are treated as columns and data of the DataFrame\n\n    Args:\n        xml_file (str): Path to the XML file.\n\n    Returns:\n        pd.DataFrame: DataFrame containing the data from the XML file.\n    \"\"\"\n"
  },
  {
    "task_id": 35,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestPointInPolygon(unittest.TestCase):\n    def setUp(self):\n        # Define some polygons to use in tests\n        self.square = [(0, 0), (0, 10), (10, 10), (10, 0)]\n        self.triangle = [(0, 0), (5, 10), (10, 0)]\n        self.concave = [(0, 0), (5, 5), (10, 0), (5, 10), (0, 10)]\n\n    def test_point_inside_square(self):\n        # Point inside the square\n        self.assertTrue(is_point_in_polygon((5, 5), self.square))\n\n    def test_point_outside_square(self):\n        # Point outside the square\n        self.assertFalse(is_point_in_polygon((15, 5), self.square))\n\n    def test_point_on_edge_of_triangle(self):\n        # Point on the edge of the triangle\n        self.assertFalse(is_point_in_polygon((5, 0), self.triangle))\n\n    def test_point_inside_concave_polygon(self):\n        # Point inside concave polygon\n        self.assertTrue(is_point_in_polygon((5, 9), self.concave))\n\n    def test_point_outside_concave_polygon(self):\n        # Point outside concave polygon\n        self.assertFalse(is_point_in_polygon((5, 1), self.concave))",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef is_point_in_polygon(point: tuple, polygon: List[tuple]) -> bool:\n    \"\"\"\n    Determine if the point (x, y) is inside the given polygon.\n    The polygon is defined as a list of tuples (x, y) representing the vertices.\n\n    Args:\n    point: A tuple (x, y) representing the point to check.\n    polygon: A list of tuples (x, y) representing the vertices of the polygon.\n\n    Returns:\n    bool: True if the point is inside the polygon, False otherwise.\n    \"\"\"\n"
  },
  {
    "task_id": 36,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List, Union\n\ndef floyd_warshall_shortest_paths(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\"",
    "test_code": "import unittest\n\nclass TestFloydWarshallShortestPaths(unittest.TestCase):\n    def test_basic_functionality(self):\n        # Basic test.js case with a simple graph\n        matrix = [\n            [0, 3, float('inf'), 7],\n            [8, 0, 2, float('inf')],\n            [5, float('inf'), 0, 1],\n            [2, float('inf'), float('inf'), 0]\n        ]\n        expected = [\n            [0, 3, 5, 6],\n            [5, 0, 2, 3],\n            [3, 6, 0, 1],\n            [2, 5, 7, 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Basic functionality test.js failed\")\n\n    def test_single_vertex_graph(self):\n        # Test case with a single vertex graph (1x1 matrix)\n        matrix = [\n            [0]\n        ]\n        expected = [\n            [0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Single vertex graph test.js failed\")\n\n    def test_two_vertices_graph(self):\n        # Test case with two vertices\n        matrix = [\n            [0, 1],\n            [1, 0]\n        ]\n        expected = [\n            [0, 1],\n            [1, 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Two vertices graph test.js failed\")\n\n    def test_large_infinite_weights(self):\n        # Test case with infinite weights\n        matrix = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        expected = [\n            [0, float('inf')],\n            [float('inf'), 0]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Large infinite weights test.js failed\")\n\n    def test_negative_cycle(self):\n        # Test case with a negative cycle\n        matrix = [\n            [0, 1, float('inf')],\n            [float('inf'), 0, -1],\n            [-1, float('inf'), 0]\n        ]\n        expected = [\n            [-1, 0, -1],\n            [-2, -1, -2],\n            [-2, -1, -2]\n        ]\n        result = floyd_warshall_shortest_paths(matrix)\n        self.assertEqual(result, expected, \"Negative cycle test.js failed\")\n\n\n",
    "prompt": "please write a python function the function signature as below from typing import List, Union\n\ndef floyd_warshall_shortest_paths(adjacency_matrix: List[List[Union[int, float]]]) -> List[List[Union[int, float]]]:\n    \"\"\"\n    Implements Floyd-Warshall algorithm to find the shortest paths between all pairs of vertices\n    in a graph represented by an adjacency matrix.\n\n    Args:\n        adjacency_matrix (List[List[Union[int, float]]]): The adjacency matrix representing the graph,\n        where adjacency_matrix[i][j] is the weight of the edge from vertex i to vertex j. If there is\n        no edge, the weight should be represented as float('inf').\n\n    Returns:\n        List[List[Union[int, float]]]: The matrix representing the shortest paths between all pairs of vertices.\n        shortest_paths[i][j] will hold the shortest distance from vertex i to vertex j.\n    \"\"\""
  },
  {
    "task_id": 37,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass QuadratureRule:\n    def __init__(self, x, w):\n        self.x = np.array(x)\n        self.w = np.array(w)\n\n\nclass TestOrthogonalPolynomial(unittest.TestCase):\n    def test_lanczos_basic(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 2\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n\n    def test_lanczos_n_greater_than_length(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 4\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_n_zero(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.333, 0.333, 0.334]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 0\n\n        with self.assertRaises(ValueError):\n            lanczos(n, quadrature_rule)\n\n    def test_lanczos_weights_nonuniform(self):\n        x = [0.0, 0.5, 1.0]\n        w = [0.1, 0.4, 0.5]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 3\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))\n\n    def test_lanczos_single_node(self):\n        x = [0.5]\n        w = [1.0]\n        quadrature_rule = QuadratureRule(x, w)\n        n = 1\n        alpha, beta, gamma, _ = lanczos(n, quadrature_rule)\n\n        self.assertEqual(len(alpha), n)\n        self.assertEqual(len(beta), n - 1)\n        self.assertEqual(len(gamma), n)\n        self.assertTrue(np.all(gamma > 0))",
    "prompt": "please write a python function the function signature as below from typing import Tuple\n\nimport numpy as np\n\n\nclass QuadratureRule:\n    def __init__(self, x: np.ndarray, w: np.ndarray):\n        self.x = x\n        self.w = w\n\n\ndef lanczos(n: int, quadrature_rule: QuadratureRule) -> Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n    implements the Lanczos function for the recursive relation coefficient algorithm for computing orthogonal polynomials\n    Args:\n        n (int): the number of orthogonal polynomials to generate\n        quadrature_rule (QuadratureRule): An object containing x (nodes) and w (weights) for the quadrature.\n    Returns:\n        Tuple[np.ndarray, np.ndarray, np.ndarray, QuadratureRule]:\n    \"\"\"\n"
  },
  {
    "task_id": 38,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def rainbowHexGenerator(num_intermediates: int, include_endpoints=False):\n    \"\"\"\n    generates a color spectrum list containing the main rainbow colors and the gradient colors between them. The function takes two parameters: num_intermediates specifies the number of intermediate colors to be generated between each two major colors;include_endpoints determines whether to add a gradient from the last color back to the first color at the end of the color spectrum\n    Args:\n        num_intermediates (int): The number of intermediate colors that need to be generated between each pair of main rainbow colors. If set to 0, no intermediate colors are generated, and only the original seven rainbow colors are returned. If set to a positive integer, the function generates a specified number of transition colors between adjacent colors, creating a smoother color gradient.\n\n        include_endpoints (bool): Do you add a transition from the last color (purple) back to the first color (red) at the end of the spectrum\n\n\n    Returns:\n        The list contains a series of hexadecimal color codes that represent the colors of rainbows and the gradient colors between them\n\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestRainbowHexGenerator(unittest.TestCase):\n    def setUp(self):\n        self.rainbow_colors = [\n            \"#FF0000\",  # Red\n            \"#FF7F00\",  # Orange\n            \"#FFFF00\",  # Yellow\n            \"#00FF00\",  # Green\n            \"#0000FF\",  # Blue\n            \"#4B0082\",  # Indigo\n            \"#8A2BE2\"  # Violet\n        ]\n\n    def test_no_intermediates(self):\n        # Test with zero intermediates\n        result = rainbowHexGenerator(0)\n        expected = self.rainbow_colors\n        self.assertEqual(result, expected, \"Should return main rainbow colors without intermediates\")\n\n    def test_one_intermediate(self):\n        # Test with one intermediate color between each main color\n        result = rainbowHexGenerator(1)\n        # Check if the length is correct (7 main + 6 intermediates)\n        self.assertEqual(len(result), 13, \"Should have 13 colors with one intermediate\")\n\n    def test_include_endpoints(self):\n        # Test including the endpoint (wrap-around) interpolation\n        result = rainbowHexGenerator(1, include_endpoints=True)\n        # Check if the length is correct (7 main + 7 intermediates including wrap-around)\n        self.assertEqual(len(result), 14, \"Should have 14 colors with wrap-around interpolation\")\n\n    def test_high_number_of_intermediates(self):\n        # Test with a high number of intermediates to check gradient smoothness\n        result = rainbowHexGenerator(10)\n        # Check if the length is correct (7 main + 60 intermediates)\n        self.assertEqual(len(result), 67, \"Should have 67 colors with 10 intermediates each\")\n\n",
    "prompt": "please write a python function the function signature as below def rainbowHexGenerator(num_intermediates: int, include_endpoints=False):\n    \"\"\"\n    generates a color spectrum list containing the main rainbow colors and the gradient colors between them. The function takes two parameters: num_intermediates specifies the number of intermediate colors to be generated between each two major colors;include_endpoints determines whether to add a gradient from the last color back to the first color at the end of the color spectrum\n    Args:\n        num_intermediates (int): The number of intermediate colors that need to be generated between each pair of main rainbow colors. If set to 0, no intermediate colors are generated, and only the original seven rainbow colors are returned. If set to a positive integer, the function generates a specified number of transition colors between adjacent colors, creating a smoother color gradient.\n\n        include_endpoints (bool): Do you add a transition from the last color (purple) back to the first color (red) at the end of the spectrum\n\n\n    Returns:\n        The list contains a series of hexadecimal color codes that represent the colors of rainbows and the gradient colors between them\n\n    \"\"\"\n"
  },
  {
    "task_id": 40,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from music21 import pitch\n\n\ndef adjust_to_c_major(note_name: str) -> str:\n    \"\"\"\n    Adjusts a given musical note to the nearest note in the C major scale.\n    Args:\n        note_name (str): The name of the note to adjust.\n\n    Returns:\n        str: The adjusted note name with octave if applicable, or the input note if already in C major.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestAdjustToCMajor(unittest.TestCase):\n    def test_note_already_in_c_major(self):\n        self.assertEqual(adjust_to_c_major(\"C4\"), \"C4\")\n        self.assertEqual(adjust_to_c_major(\"G3\"), \"G3\")\n\n    def test_note_not_in_c_major(self):\n        self.assertEqual(adjust_to_c_major(\"C#4\"), \"D4\")\n        self.assertEqual(adjust_to_c_major(\"F#3\"), \"G3\")\n\n    def test_invalid_note_name(self):\n        self.assertEqual(adjust_to_c_major(\"H2\"), \"C4\")\n\n    def test_edge_case_near_c_major(self):\n        self.assertEqual(adjust_to_c_major(\"B#3\"), \"C4\")\n        self.assertEqual(adjust_to_c_major(\"E#4\"), \"F4\")",
    "prompt": "please write a python function the function signature as below from music21 import pitch\n\n\ndef adjust_to_c_major(note_name: str) -> str:\n    \"\"\"\n    Adjusts a given musical note to the nearest note in the C major scale.\n    Args:\n        note_name (str): The name of the note to adjust.\n\n    Returns:\n        str: The adjusted note name with octave if applicable, or the input note if already in C major.\n    \"\"\"\n"
  },
  {
    "task_id": 41,
    "code_type": "class",
    "code_language": "python",
    "code_signature": "class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n",
    "test_code": "import unittest\n\n\nclass TestBloomFilter(unittest.TestCase):\n\n    def setUp(self):\n        # Initialize BloomFilter with reasonable size and hash count for testing\n        self.bf = BloomFilter(1000, 5)\n\n    def test_add_and_check_presence(self):\n        # Test that added elements are reported as present\n        test_item = \"hello world\"\n        self.bf.add(test_item)\n        self.assertIn(test_item, self.bf)\n\n    def test_check_absence(self):\n        # Test that an unadded element is not present\n        self.assertNotIn(\"random item\", self.bf)\n\n    def test_false_positives(self):\n        # Adding some elements and check for a false positive\n        items_to_add = [\"item1\", \"item2\", \"item3\"]\n        for item in items_to_add:\n            self.bf.add(item)\n        # Check for an item not added, expecting a very low chance of false positive due to size and hash count\n        self.assertNotIn(\"item4\", self.bf)\n\n    def test_collision_handling(self):\n        # Test how the Bloom filter handles hash collisions by adding similar items\n        self.bf.add(\"item123\")\n        self.bf.add(\"item124\")\n        self.assertIn(\"item123\", self.bf)\n        self.assertIn(\"item124\", self.bf)\n\n    def test_empty_bloom_filter(self):\n        # Ensure that an empty Bloom Filter reports no items\n        self.assertNotIn(\"anything\", self.bf)",
    "prompt": "please write a python class this class signature as below class BloomFilter:\n    \"\"\"\n    Implement a bloom filter class with an add method that adds an element to the Bloom filter.Callers can check for the presence of an element directly using the in keyword\n    \"\"\"\n\n    def __init__(self, size, hash_count):\n        pass\n\n    def add(self, item):\n        # Add an item to the bloom filter\n        pass\n"
  },
  {
    "task_id": 42,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def replace_phone_numbers(text):\n    \"\"\"\n    replace all phones in the string with the string [PHONE_NUM]\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestReplacePhoneNumbers(unittest.TestCase):\n    def test_basic_number(self):\n        msg = \"Call me at 123-456-7890.\"\n        expected = \"Call me at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_international_number(self):\n        msg = \"Contact us at 44 123 456 789.\"\n        expected = \"Contact us at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_number_with_parentheses(self):\n        msg = \"Our office number is 123 456-7890.\"\n        expected = \"Our office number is [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_number_with_dots(self):\n        msg = \"Fax us at 123.456.7890.\"\n        expected = \"Fax us at [PHONE_NUM].\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n\n    def test_no_phone_number(self):\n        msg = \"Hello, please reply to this email.\"\n        expected = \"Hello, please reply to this email.\"\n        self.assertEqual(replace_phone_numbers(msg), expected)\n",
    "prompt": "please write a python function the function signature as below def replace_phone_numbers(text):\n    \"\"\"\n    replace all phones in the string with the string [PHONE_NUM]\n\n    Args:\n        text (str): The input string that may contain phone numbers.\n\n    Returns:\n        str: The modified string with phone numbers replaced by '[PHONE_NUM]'.\n    \"\"\"\n"
  },
  {
    "task_id": 43,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Tuple\n\n\ndef rgb_to_hsv(r, g, b) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns: HSV value\n\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestRGBtoHSV(unittest.TestCase):\n\n    def test_rgb_to_hsv_red(self):\n        # Test conversion of pure red color\n        r, g, b = 255, 0, 0\n        expected_result = (0, 1, 1)  # Hue should be 0, Saturation 1, Value 1 for red\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_green(self):\n        # Test conversion of pure green color\n        r, g, b = 0, 255, 0\n        expected_result = (120, 1, 1)  # Hue should be 120, Saturation 1, Value 1 for green\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_blue(self):\n        # Test conversion of pure blue color\n        r, g, b = 0, 0, 255\n        expected_result = (240, 1, 1)  # Hue should be 240, Saturation 1, Value 1 for blue\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_white(self):\n        # Test conversion of white color\n        r, g, b = 255, 255, 255\n        expected_result = (0, 0, 1)  # Hue is undefined, typically 0; Saturation 0, Value 1 for white\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)\n\n    def test_rgb_to_hsv_black(self):\n        # Test conversion of black color\n        r, g, b = 0, 0, 0\n        expected_result = (0, 0, 0)  # Hue is undefined, typically 0; Saturation 0, Value 0 for black\n        result = rgb_to_hsv(r, g, b)\n        self.assertEqual(result, expected_result)",
    "prompt": "please write a python function the function signature as below from typing import Tuple\n\n\ndef rgb_to_hsv(r, g, b) -> Tuple[int, int, int]:\n    \"\"\"\n    convert RGB color to HSV color\n    Args:\n        r (int): rgb read value\n        g (int): rgb green value\n        b (int): rgb blue value\n\n    Returns: HSV value\n\n    \"\"\"\n"
  },
  {
    "task_id": 44,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def string_side_by_side(string1: str, string2: str, column_width=20) -> str:\n    \"\"\"\n    Display the two strings side by side so that their rows are left aligned, and make sure that each row fits into the specified column width\n    Args:\n        string1 (str): string1\n        string2 (str): string2\n        column_width (int): width of each line\n\n    Returns:\n        str: format lines\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestStringSideBySide(unittest.TestCase):\n\n    def test_equal_length_strings(self):\n        str1 = \"Hello\\nWorld\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2)\n        expected = \"Hello                | Python              \\nWorld                | Code                \"\n        self.assertEqual(result, expected)\n\n    def test_first_string_longer(self):\n        str1 = \"Hello\\nWorld\\nTest\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2)\n        expected = \"Hello                | Python              \\nWorld                | Code                \\nTest                 |                     \"\n        self.assertEqual(result, expected)\n\n    def test_second_string_longer(self):\n        str1 = \"Hello\\nWorld\"\n        str2 = \"Python\\nCode\\nTest\"\n        result = string_side_by_side(str1, str2)\n        expected = \"Hello                | Python              \\nWorld                | Code                \\n                     | Test                \"\n        self.assertEqual(result, expected)\n\n    def test_empty_first_string(self):\n        str1 = \"\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2)\n        expected = \"                     | Python              \\n                     | Code                \"\n        self.assertEqual(result, expected)\n\n    def test_custom_column_width(self):\n        str1 = \"Hello\\nWorld\"\n        str2 = \"Python\\nCode\"\n        result = string_side_by_side(str1, str2, column_width=10)\n        expected = \"Hello      | Python    \\nWorld      | Code      \"\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below def string_side_by_side(string1: str, string2: str, column_width=20) -> str:\n    \"\"\"\n    Display the two strings side by side so that their rows are left aligned, and make sure that each row fits into the specified column width\n    Args:\n        string1 (str): string1\n        string2 (str): string2\n        column_width (int): width of each line\n\n    Returns:\n        str: format lines\n    \"\"\"\n"
  },
  {
    "task_id": 45,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def get_current_date_info(test_date=None) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestGetCurrentDateInfo(unittest.TestCase):\n\n    def test_beginning_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 1))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 1,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_middle_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 15))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 3,\n            'day_of_the_week': 'Sunday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_end_of_month(self):\n        result = get_current_date_info(datetime.date(2023, 1, 31))\n        expected = {\n            'year': 2023,\n            'month': 'January',\n            'week_of_the_month': 6,\n            'day_of_the_week': 'Tuesday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_leap_year(self):\n        result = get_current_date_info(datetime.date(2024, 2, 29))\n        expected = {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n        self.assertEqual(result, expected)\n\n    def test_change_of_year(self):\n        result = get_current_date_info(datetime.date(2022, 12, 31))\n        expected = {\n            'year': 2022,\n            'month': 'December',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Saturday'\n        }\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below def get_current_date_info(test_date=None) -> dict:\n    \"\"\"\n    Returns the current time information including year, month, week of the month, and day of.eg {\n            'year': 2024,\n            'month': 'February',\n            'week_of_the_month': 5,\n            'day_of_the_week': 'Thursday'\n        }\n\n    Args:\n        test_date (datetime.date): The date to compute information for, defaults to today's date if not provided.\n\n    Returns:\n        dict: A dictionary containing the year, month, week of the month, and day of the week.\n    \"\"\"\n"
  },
  {
    "task_id": 46,
    "code_type": "class",
    "code_language": "python",
    "code_signature": "class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n",
    "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Setup basic tree structure for testing.\"\"\"\n        # Tree structure:\n        #      1\n        #     / \\\n        #    2   3\n        #   / \\\n        #  4   5\n        self.tree = BinaryTree(TreeNode(1))\n        self.tree.root.left = TreeNode(2, TreeNode(4), TreeNode(5))\n        self.tree.root.right = TreeNode(3)\n\n    def test_preorder_traversal(self):\n        \"\"\"Test preorder traversal.\"\"\"\n        result = self.tree.preorder_traversal(self.tree.root)\n        self.assertEqual(result, [1, 2, 4, 5, 3])\n\n    def test_inorder_traversal(self):\n        \"\"\"Test inorder traversal.\"\"\"\n        result = self.tree.inorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 2, 5, 1, 3])\n\n    def test_postorder_traversal(self):\n        \"\"\"Test postorder traversal.\"\"\"\n        result = self.tree.postorder_traversal(self.tree.root)\n        self.assertEqual(result, [4, 5, 2, 3, 1])\n\n    def test_empty_tree(self):\n        \"\"\"Test traversals on an empty tree.\"\"\"\n        empty_tree = BinaryTree()\n        self.assertEqual(empty_tree.preorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.inorder_traversal(empty_tree.root), [])\n        self.assertEqual(empty_tree.postorder_traversal(empty_tree.root), [])\n\n    def test_single_node_tree(self):\n        \"\"\"Test all traversals on a tree with only one node.\"\"\"\n        single_node_tree = BinaryTree(TreeNode(10))\n        self.assertEqual(single_node_tree.preorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.inorder_traversal(single_node_tree.root), [10])\n        self.assertEqual(single_node_tree.postorder_traversal(single_node_tree.root), [10])\n",
    "prompt": "please write a python class this class signature as below class TreeNode:\n    \"\"\"\n    binary tree node\n    \"\"\"\n\n    def __init__(self, value=0, left=None, right=None):\n        pass\n\n\nclass BinaryTree:\n    \"\"\"\n    binary tree\n    \"\"\"\n\n    def __init__(self, root=None):\n        pass\n\n    def preorder_traversal(self, node, result=None):\n        pass\n\n    def inorder_traversal(self, node, result=None):\n        pass\n\n    def postorder_traversal(self, node, result=None):\n        pass\n"
  },
  {
    "task_id": 47,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import datetime\n\n\ndef find_nth_weekday_of_specific_year(y: int, m: int, n: int, k: int) -> datetime.datetime:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime.datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom datetime import datetime\n\n\nclass TestFindNthWeekdayOfSpecificYear(unittest.TestCase):\n\n    def test_regular_occurrence(self):\n        # Test for the 2nd Monday of May 2023\n        result = find_nth_weekday_of_specific_year(2023, 5, 2, 0)\n        expected = datetime(2023, 5, 8)\n        self.assertEqual(result, expected)\n\n    def test_last_occurrence(self):\n        # Test for the 5th Monday of May 2023, which doesn't exist, should return the last Monday\n        result = find_nth_weekday_of_specific_year(2023, 5, 5, 0)\n        expected = datetime(2023, 5, 29)\n        self.assertEqual(result, expected)\n\n    def test_out_of_range(self):\n        # Test for the 10th Monday of May 2023, which definitely doesn't exist, should return the last Monday\n        result = find_nth_weekday_of_specific_year(2023, 5, 10, 0)\n        expected = datetime(2023, 5, 29)\n        self.assertEqual(result, expected)\n\n    def test_first_day_is_weekday(self):\n        # Test for when the first day of the month is the weekday in question, 1st Tuesday of August 2023\n        result = find_nth_weekday_of_specific_year(2023, 8, 1, 1)\n        expected = datetime(2023, 8, 1)\n        self.assertEqual(result, expected)\n\n    def test_edge_year_transition(self):\n        # Test for the 1st Friday of December 2023, checking the transition to a new year boundary condition\n        result = find_nth_weekday_of_specific_year(2023, 12, 1, 4)\n        expected = datetime(2023, 12, 1)\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below import datetime\n\n\ndef find_nth_weekday_of_specific_year(y: int, m: int, n: int, k: int) -> datetime.datetime:\n    \"\"\"\n    Calculates the date of the nth occurrence of a specific weekday (k) in a given month (m) and year (y).\n    If the nth occurrence does not exist within the month, it returns the last occurrence of that weekday in the month.\n    This function extends the capability to handle edge cases where the nth weekday might not be present,\n    by providing the closest previous weekday in such cases\n    Args:\n        y (int): The year for which the date is to be calculated.\n        m (int): The month for which the date is to be calculated, where January is 1 and December is 12.\n        n (int): The nth occurrence of the weekday within the month. For example, 1 for the first occurrence, 2 for the second, etc.\n        k (int): The weekday, where Monday is 0 and Sunday is 6.\n\n    Returns:\n        datetime.datetime: The calculated date of the nth occurrence of the weekday in the given month and year.\n      If the nth occurrence does not exist, returns the date of the last occurrence of that weekday in the month.\n    \"\"\"\n"
  },
  {
    "task_id": 51,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\nimport numpy as np\n\n\ndef change_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (list): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n",
    "test_code": "import unittest\nimport numpy as np\n\nclass TestChangeReferenceFrame(unittest.TestCase):\n    def setUp(self):\n        # Basic setup for tests, initialize some common point clouds and frames\n        self.point_cloud = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        self.ref_frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([0, 1, 0])]\n\n    def test_identity_transformation(self):\n        # Test with an identity transformation where the reference frame is the standard basis\n        result = change_reference_frame(self.point_cloud, self.ref_frame_points)\n        np.testing.assert_array_almost_equal(result, self.point_cloud - np.array([0, 0, 0]))\n\n    def test_translation(self):\n        # Only translation no rotation; move the origin\n        frame_points = [np.array([1, 1, 1]), np.array([2, 1, 1]), np.array([1, 2, 1])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[-1. , 0.,  1.], [ 2. , 3.,  4.], [ 5.,  6. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_rotation(self):\n        # Rotation about z-axis by 90 degrees\n        frame_points = [np.array([0, 0, 0]), np.array([0, 1, 0]), np.array([0, 1, 1])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.array([[2. , 3.,  1.], [ 5. , 6.,  4.], [ 8.,  9. , 7.]])\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_non_orthonormal_frame(self):\n        # Use non-orthonormal frame to see how function handles it (should normalize internally)\n        frame_points = [np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([1, 1, 0])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        # Manually compute expected result\n        u = np.array([1, 0, 0])\n        v = np.array([0, 1, 0])\n        w = np.cross(u, v)\n        rotation_matrix = np.column_stack((u, v, w))\n        expected = np.dot(self.point_cloud, rotation_matrix.T)\n        np.testing.assert_array_almost_equal(result, expected)\n\n    def test_inverted_frame(self):\n        # Inverting the frame to see if negatives are handled\n        frame_points = [np.array([0, 0, 0]), np.array([-1, 0, 0]), np.array([0, -1, 0])]\n        result = change_reference_frame(self.point_cloud, frame_points)\n        expected = np.dot(self.point_cloud, np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]))\n        np.testing.assert_array_almost_equal(result, expected)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\nimport numpy as np\n\n\ndef change_reference_frame(point_cloud: np.array, ref_frame_points: List[np.array]) -> np.array:\n    \"\"\"\n    Transforms a point cloud to a new reference frame defined by three points.\n\n    Parameters:\n        point_cloud (np.array): The Nx3 array of points in the original reference frame.\n        ref_frame_points (list): A list of three points (np.array), defining the new reference frame.\n\n    Returns:\n        np.array: Transformed point cloud in the new reference frame.\n    \"\"\"\n"
  },
  {
    "task_id": 52,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestRenameFilePath(unittest.TestCase):\n    def test_rename_with_colon_in_filename(self):\n        # Test path with colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_without_colon_in_filename(self):\n        # Test path without colon in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\report2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_multiple_colons_in_filename(self):\n        # Test path with multiple colons in the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\project:report:2023.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\project_report_2023.txt'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_end_of_filename(self):\n        # Test path with a colon at the end of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\backup:'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\backup_'\n        self.assertEqual(rename_file_path(path), expected)\n\n    def test_rename_with_colon_at_start_of_filename(self):\n        # Test path with a colon at the start of the filename\n        path = 'C:\\\\Users\\\\example\\\\Documents\\\\:initial_setup.txt'\n        expected = 'C:\\\\Users\\\\example\\\\Documents\\\\_initial_setup.txt'\n        self.assertEqual(rename_file_path(path), expected)\n",
    "prompt": "please write a python function the function signature as below def rename_file_path(path: str) -> str:\n    \"\"\"\n    Renames a Windows file path by replacing colons in the filename with underscores.\n\n    Parameters:\n        path (str): The original file path.\n\n    Returns:\n        str: The modified file path with colons in the filename replaced by underscores.\n    \"\"\"\n"
  },
  {
    "task_id": 53,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): data object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n",
    "test_code": "import unittest\nimport sys\n\nclass TestSizeInBytes(unittest.TestCase):\n\n    def test_size_of_integer(self):\n        # Test the size of an integer\n        integer_value = 42\n        expected_size = sys.getsizeof(integer_value)\n        result_size = size_in_bytes(integer_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_string(self):\n        # Test the size of a string\n        string_value = \"Hello, world!\"\n        expected_size = sys.getsizeof(string_value)\n        result_size = size_in_bytes(string_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_list(self):\n        # Test the size of a list\n        list_value = [1, 2, 3, 4, 5]\n        expected_size = sys.getsizeof(list_value)\n        result_size = size_in_bytes(list_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_dictionary(self):\n        # Test the size of a dictionary\n        dict_value = {'key1': 'value1', 'key2': 'value2'}\n        expected_size = sys.getsizeof(dict_value)\n        result_size = size_in_bytes(dict_value)\n        self.assertEqual(result_size, expected_size)\n\n    def test_size_of_custom_object(self):\n        # Test the size of a custom object\n        class CustomObject:\n            def __init__(self):\n                self.attr1 = 'a'\n                self.attr2 = 123\n        custom_obj = CustomObject()\n        expected_size = sys.getsizeof(custom_obj)  # Note: Does not include size of attributes unless explicitly calculated\n        result_size = size_in_bytes(custom_obj)\n        self.assertEqual(result_size, expected_size)",
    "prompt": "please write a python function the function signature as below def size_in_bytes(obj) -> int:\n    \"\"\"\n    computes and returns the size of an object in bytes in memory\n\n    Args:\n        obj (any): data object\n\n    Returns: the size of this object in bytes in memory\n\n    \"\"\"\n"
  },
  {
    "task_id": 54,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestRemoveTripleBackticks(unittest.TestCase):\n\n    def test_remove_triple_backticks_basic(self):\n        # Test basic functionality\n        input_strings = ['Here is ```code``` example', 'Another ```example``` here', 'No backticks here']\n        expected_output = ['Here is code example', 'Another example here', 'No backticks here']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_strings_with_multiple_instances(self):\n        # Test strings containing multiple instances of triple backticks\n        input_strings = ['Multiple ```backticks``` in ```one``` string']\n        expected_output = ['Multiple backticks in one string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_empty_strings(self):\n        # Test with empty strings\n        input_strings = ['']\n        expected_output = ['']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_no_triple_backticks(self):\n        # Test strings that do not contain triple backticks\n        input_strings = ['Just a normal string', 'Another normal string']\n        expected_output = ['Just a normal string', 'Another normal string']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)\n\n    def test_edge_cases(self):\n        # Test edge cases like strings made entirely of triple backticks\n        input_strings = ['```', '```more```', 'text``````']\n        expected_output = ['', 'more', 'text']\n        self.assertEqual(remove_triple_backticks(input_strings), expected_output)",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef remove_triple_backticks(string_list: List[str]) -> List[str]:\n    \"\"\"\n    process a list of strings, removing the three consecutive backticks from each string\n    Args:\n        string_list (List[str]): The list of strings to process.\n\n    Returns:\n        A new list with all instances of three consecutive backticks removed from each string.\n    \"\"\"\n"
  },
  {
    "task_id": 55,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.Return the minimum number of moves to make every value in nums unique.\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestMinRemovalsToMakeUnique(unittest.TestCase):\n    def test_basic_array(self):\n        \"\"\"Test with a basic array where multiple removals are needed.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([3, 3, 1, 2, 2, 1]), 3)\n\n    def test_all_identical(self):\n        \"\"\"Test an array where all elements are identical.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([4, 4, 4, 4]), 3)\n\n    def test_all_unique(self):\n        \"\"\"Test an array where all elements are already unique.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 3, 4]), 0)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([]), 0)\n\n    def test_complex_case(self):\n        \"\"\"Test a more complex case with a larger array.\"\"\"\n        self.assertEqual(min_removals_to_make_unique([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]), 6)",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef min_removals_to_make_unique(nums: List[int]) -> int:\n    \"\"\"\n    You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.Return the minimum number of moves to make every value in nums unique.\n    Args:\n        nums (List[int]): integer array of nums\n\n    Returns:\n        minimum number of moves to make every value in nums unique\n    \"\"\"\n"
  },
  {
    "task_id": 56,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestFindShiftJISNotGBK(unittest.TestCase):\n\n    def setUp(self):\n        # Pre-calculate the list once since it's computationally expensive\n        self.shiftjis_not_gbk = find_shiftjis_not_gbk()\n\n    def test_known_shiftjis_character_not_in_gbk(self):\n        # Test known characters (example values provided might not actually be in one and not the other; please adjust accordingly based on actual encoding tables)\n        known_shiftjis_only = '\u30f1'  # An example character, ensure this is correct as per your encodings\n        self.assertNotIn(known_shiftjis_only, self.shiftjis_not_gbk)\n\n    def test_character_in_both_encodings(self):\n        # Test characters known to be in both encodings\n        common_character = '\u6c34'  # Common in both, ensure accuracy\n        self.assertNotIn(common_character, self.shiftjis_not_gbk)\n\n    def test_character_in_neither_encoding(self):\n        # Character not typically found in either encoding\n        neither_encoding_char = '\\U0001F4A9'  # Emoji, not in basic Shift-JIS or GBK\n        self.assertNotIn(neither_encoding_char, self.shiftjis_not_gbk)\n\n    def test_bounds_of_bmp(self):\n        # Characters at the edge of the BMP should be checked\n        edge_of_bmp = '\\uffff'  # Last character in BMP\n        # Since this test.js is situational, we check based on the known state; may not be necessary\n        if edge_of_bmp in self.shiftjis_not_gbk:\n            self.assertIn(edge_of_bmp, self.shiftjis_not_gbk)\n        else:\n            self.assertNotIn(edge_of_bmp, self.shiftjis_not_gbk)\n\n    def test_empty_input_handling(self):\n        # Checking function's behavior with empty input scenario, modifying function required\n        self.assertTrue(len(self.shiftjis_not_gbk) > 0)  # Expect non-zero length list, confirming function runs",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef find_shiftjis_not_gbk() -> List:\n    \"\"\"\n    find all the characters that can be represented in Shift-JIS, but not in GBK, and return them as an array\n\n    Returns:\n        list: A list of characters that are unique to Shift-JIS, not encodable in GBK.\n    \"\"\"\n"
  },
  {
    "task_id": 57,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestConvertPngToIco(unittest.TestCase):\n    @patch('PIL.Image.open')\n    def test_single_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_multiple_icon_sizes(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico', [(16, 16), (32, 32), (64, 64)])\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(16, 16), (32, 32), (64, 64)])\n\n    @patch('PIL.Image.open')\n    def test_default_icon_size(self, mock_open):\n        mock_image = mock_open.return_value.__enter__.return_value\n        convert_png_to_ico('source.png', 'output.ico')\n        mock_image.save.assert_called_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_file_handling(self, mock_open):\n        mock_image = MagicMock()\n        mock_open.return_value.__enter__.return_value = mock_image\n        convert_png_to_ico('source.png', 'output.ico')\n        # Check if save was called correctly\n        mock_image.save.assert_called_once_with('output.ico', format='ICO', sizes=[(32, 32)])\n\n    @patch('PIL.Image.open')\n    def test_invalid_image_path(self, mock_open):\n        mock_open.side_effect = FileNotFoundError\n        with self.assertRaises(FileNotFoundError):\n            convert_png_to_ico('invalid.png', 'output.ico')\n",
    "prompt": "please write a python function the function signature as below def convert_png_to_ico(png_file_path, ico_file_path, icon_sizes=[(32, 32)]):\n    \"\"\"\n    convert png images to ico files\n    Args:\n        png_file_path (str): Path to the source PNG image file.\n        ico_file_path (str): Path to save the ICO file.\n        icon_sizes (list): List of tuples specifying the sizes to include in the ICO file.\n\n    Returns:\n\n    \"\"\"\n"
  },
  {
    "task_id": 58,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom math import isclose\n\n\nclass TestProbabilityOfRedBalls(unittest.TestCase):\n\n    def test_all_red_balls(self):\n        # Scenario where all balls in the jar are red\n        result = probability_of_red_balls(15, 10, 0)\n        self.assertTrue(isclose(result, 1.0), \"Test with all red balls failed\")\n\n    def test_no_red_balls(self):\n        # Scenario where there are no red balls in the jar\n        result = probability_of_red_balls(0, 0, 10)\n        self.assertTrue(isclose(result, 1.0), \"Test with no red balls failed\")\n\n    def test_half_red_balls(self):\n        # Scenario where half of the drawn balls are expected to be red\n        result = probability_of_red_balls(7, 10, 10)\n        expected_result = probability_of_red_balls(7, 10, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with half red balls failed\")\n\n    def test_some_red_balls(self):\n        # Scenario with some red balls in the jar, expecting a few red draws\n        result = probability_of_red_balls(5, 5, 10)\n        expected_result = probability_of_red_balls(5, 5, 10)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with some red balls failed\")\n\n    def test_extreme_case(self):\n        # Extreme scenario where the probability is low for the chosen n\n        result = probability_of_red_balls(15, 1, 99)\n        expected_result = probability_of_red_balls(15, 1, 99)  # Calculate manually or from another tool\n        self.assertTrue(isclose(result, expected_result), \"Test with extreme case failed\")",
    "prompt": "please write a python function the function signature as below def probability_of_red_balls(n: int, x: int, y: int) -> float:\n    \"\"\"\n    Calculate the probability that n red balls will be drawn when 15 balls are randomly returned from a jar containing x red balls and y blue balls.\n\n    Args:\n        n (int): Number of red balls to be drawn.\n        x (int): Number of red balls in the jar.\n        y (int): Number of blue balls in the jar.\n\n    Returns:\n        float: The probability of drawing exactly n red balls.\n    \"\"\"\n"
  },
  {
    "task_id": 59,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestProbabilityRedBalls(unittest.TestCase):\n    def test_all_red(self):\n        # Case where all balls are red\n        self.assertEqual(probability_red_balls(5, 5, 0), 1)\n\n    def test_no_red(self):\n        # Case where no red balls are available\n        self.assertEqual(probability_red_balls(1, 0, 5), 0)\n\n    def test_typical_case(self):\n        # Typical scenario\n        self.assertAlmostEqual(probability_red_balls(2, 10, 5), comb(10, 2) / comb(15, 2))\n\n    def test_impossible_case(self):\n        # More balls requested than available\n        self.assertEqual(probability_red_balls(6, 5, 4), 0)\n\n    def test_high_combinations(self):\n        # Test with higher number of combinations\n        self.assertAlmostEqual(probability_red_balls(3, 20, 30), comb(20, 3) / comb(50, 3))",
    "prompt": "please write a python function the function signature as below def probability_red_balls(x: int, n: int, m: int) -> float:\n    \"\"\"\n    calculate the probability that x balls will be randomly drawn from a jar containing n red balls and m blue balls, and all of them will be red balls\n    Args:\n        x (int): Number of balls to draw.\n        n (int): Number of red balls in the jar.\n        m (int): Number of blue balls in the jar.\n\n    Returns:\n        The probability that all x drawn balls are red.\n    \"\"\"\n"
  },
  {
    "task_id": 60,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef find_common_columns(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n",
    "test_code": "import unittest\nimport pandas as pd\nimport os\n\n\nclass TestCommonColumns(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory\n        self.test_dir = \"test_dir\"\n        os.makedirs(self.test_dir, exist_ok=True)\n\n    def tearDown(self):\n        # Remove created files and directory after each test.js\n        for filename in os.listdir(self.test_dir):\n            os.remove(os.path.join(self.test_dir, filename))\n        os.rmdir(self.test_dir)\n\n    def test_all_same_columns(self):\n        # All CSV files have the same columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"A,B,C\\n4,5,6\"\n        data3 = \"A,B,C\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(find_common_columns(self.test_dir)), set(['C', 'B', 'A']))\n\n    def test_no_common_columns(self):\n        # No common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"D,E,F\\n4,5,6\"\n        data3 = \"G,H,I\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(find_common_columns(self.test_dir), [])\n\n    def test_some_common_columns(self):\n        # Some common columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"C,D,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(find_common_columns(self.test_dir), ['C'])\n\n    def test_mixed_common_and_unique_columns(self):\n        # Mixed common and unique columns\n        data1 = \"A,B,C\\n1,2,3\"\n        data2 = \"B,C,D\\n4,5,6\"\n        data3 = \"B,C,E\\n7,8,9\"\n        filenames = ['file1.csv', 'file2.csv', 'file3.csv']\n        datas = [data1, data2, data3]\n        for filename, data in zip(filenames, datas):\n            with open(os.path.join(self.test_dir, filename), 'w') as f:\n                f.write(data)\n        self.assertEqual(set(find_common_columns(self.test_dir)), set(['B', 'C']))\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef find_common_columns(directory: str) -> List:\n    \"\"\"\n    find the common columns of all csv files in a directory and return these column names as a list\n    Args:\n        directory (str): directory path\n\n    Returns:\n        same column list\n    \"\"\"\n"
  },
  {
    "task_id": 62,
    "code_type": "class",
    "code_language": "python",
    "code_signature": "class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the data structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n",
    "test_code": "import unittest\n\n\nclass TestBinaryTree(unittest.TestCase):\n\n    def test_empty_tree(self):\n        bt = BinaryTree()\n        self.assertEqual(bt.inorder_traversal(), [])\n        self.assertEqual(bt.preorder_traversal(), [])\n        self.assertEqual(bt.postorder_traversal(), [])\n\n    def test_single_node_tree(self):\n        bt = BinaryTree()\n        bt.insert(10)\n        self.assertEqual(bt.inorder_traversal(), [10])\n        self.assertEqual(bt.preorder_traversal(), [10])\n        self.assertEqual(bt.postorder_traversal(), [10])\n\n    def test_balanced_tree(self):\n        bt = BinaryTree()\n        elements = [8, 3, 10, 1, 6, 9, 14]\n        for elem in elements:\n            bt.insert(elem)\n        self.assertEqual(bt.inorder_traversal(), [1, 3, 6, 8, 9, 10, 14])\n        self.assertEqual(bt.preorder_traversal(), [8, 3, 1, 6, 10, 9, 14])\n        self.assertEqual(bt.postorder_traversal(), [1, 6, 3, 9, 14, 10, 8])\n\n    def test_left_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(10, 0, -1):  # Inserts 10, 9, ..., 1\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [10-i for i in range(10)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(1, 11)])\n\n    def test_right_heavy_tree(self):\n        bt = BinaryTree()\n        for i in range(1, 11):  # Inserts 1, 2, ..., 10\n            bt.insert(i)\n        self.assertEqual(bt.inorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.preorder_traversal(), [i for i in range(1, 11)])\n        self.assertEqual(bt.postorder_traversal(), [i for i in range(10, 0, -1)])",
    "prompt": "please write a python class this class signature as below class TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n\nclass BinaryTree:\n    \"\"\"\n    implement the tree in the data structure and implement its three traversal methods\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        pass\n\n    def _insert(self, node, key):\n        pass\n\n    def inorder_traversal(self):\n        pass\n\n    def _inorder_traversal(self, node, result):\n        pass\n\n    def preorder_traversal(self):\n        pass\n\n    def _preorder_traversal(self, node, result):\n        pass\n\n    def postorder_traversal(self):\n        pass\n\n    def _postorder_traversal(self, node, result):\n        pass\n"
  },
  {
    "task_id": 63,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import pandas as pd\n\n\ndef dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    Args:\n        df (DataFrame): DataFrame type data\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import patch, mock_open\nimport pandas as pd\n\n\nclass TestDataframeToMarkdown(unittest.TestCase):\n    def setUp(self):\n        # Create a sample DataFrame\n        self.data = {'Name': ['Alice', 'Bob'], 'Age': [25, 30]}\n        self.df = pd.DataFrame(self.data)\n\n    @patch('builtins.open', new_callable=mock_open)\n    def test_write_to_file(self, mock_file):\n        # Test that the function writes the correct markdown to a file\n        expected_markdown = \"| Name | Age |\\n| --- | --- |\\n| Alice | 25 |\\n| Bob | 30 |\\n\"\n        result = dataframe_to_markdown(self.df, 'dummy_path.md')\n        mock_file().write.assert_called_once_with(expected_markdown)\n        self.assertEqual(result, expected_markdown)\n\n    def test_empty_dataframe(self):\n        # Test how the function handles an empty DataFrame\n        df_empty = pd.DataFrame()\n        expected_markdown = \"|  |\\n|  |\\n\"\n        result = dataframe_to_markdown(df_empty, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_single_row_dataframe(self):\n        # Test with a DataFrame that contains only one row\n        df_single_row = pd.DataFrame({'Name': ['Alice'], 'Age': [30]})\n        expected_markdown = \"| Name | Age |\\n| --- | --- |\\n| Alice | 30 |\\n\"\n        result = dataframe_to_markdown(df_single_row, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_non_string_columns(self):\n        # Test with non-string data types in the DataFrame\n        df_non_string = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30], 'Height': [5.5, 6.0]})\n        expected_markdown = \"| Name | Age | Height |\\n| --- | --- | --- |\\n| Alice | 25 | 5.5 |\\n| Bob | 30 | 6.0 |\\n\"\n        result = dataframe_to_markdown(df_non_string, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n\n    def test_special_characters(self):\n        # Test handling of special characters in DataFrame\n        df_special_chars = pd.DataFrame(\n            {'Name': ['Alice', 'Bob'], 'Comments': ['Good@Work!', 'Excellent & Commendable']})\n        expected_markdown = \"| Name | Comments |\\n| --- | --- |\\n| Alice | Good@Work! |\\n| Bob | Excellent & Commendable |\\n\"\n        result = dataframe_to_markdown(df_special_chars, 'dummy_path.md')\n        self.assertEqual(result, expected_markdown)\n",
    "prompt": "please write a python function the function signature as below import pandas as pd\n\n\ndef dataframe_to_markdown(df: pd.DataFrame, md_path: str) -> str:\n    \"\"\"\n    convert a DataFrame object to a table in markdown format\n    Args:\n        df (DataFrame): DataFrame type data\n        md_path (str): output md file path\n\n    Returns:\n        markdown file content str\n    \"\"\"\n"
  },
  {
    "task_id": 64,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n",
    "test_code": "import unittest\nimport os\n\n\nclass TestCsvToSqlInsert(unittest.TestCase):\n\n    def setUp(self):\n        # Create sample CSV files for testing\n        self.test_files = {\n            'test1.csv': 'id,name,age\\n1,Alice,30\\n2,Bob,25',\n            'test2.csv': 'product_id,product_name,price\\n101,Widget,9.99\\n102,Gadget,12.49',\n            'test3.csv': 'user_id,email\\n3,test@example.com\\n4,user@domain.com',\n            'test4.csv': 'order_id,order_date,total\\n1001,2024-09-01,59.99',\n            'test5.csv': 'quote_id,quote\\n1,\"It\\'s a beautiful day.\"\\n2,\"She said, \"\"Hello!\"\"\"'\n        }\n        # Create the files on disk\n        for filename, content in self.test_files.items():\n            with open(filename, 'w') as f:\n                f.write(content)\n\n    def tearDown(self):\n        # Remove the test files after tests\n        for filename in self.test_files:\n            os.remove(filename)\n\n    def test_simple_csv(self):\n        expected_sql = (\n            \"INSERT INTO test1 (id, name, age) VALUES (1, 'Alice', 30);\\n\"\n            \"INSERT INTO test1 (id, name, age) VALUES (2, 'Bob', 25);\"\n        )\n        result = csv_to_sql_insert('test1.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_product_csv(self):\n        expected_sql = (\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES (101, 'Widget', '9.99');\\n\"\n            \"INSERT INTO test2 (product_id, product_name, price) VALUES (102, 'Gadget', '12.49');\"\n        )\n        result = csv_to_sql_insert('test2.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_email_csv(self):\n        expected_sql = (\n            \"INSERT INTO test3 (user_id, email) VALUES (3, 'test@example.com');\\n\"\n            \"INSERT INTO test3 (user_id, email) VALUES (4, 'user@domain.com');\"\n        )\n        result = csv_to_sql_insert('test3.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_date_and_decimal_csv(self):\n        expected_sql = (\n            \"INSERT INTO test4 (order_id, order_date, total) VALUES (1001, '2024-09-01', '59.99');\"\n        )\n        result = csv_to_sql_insert('test4.csv')\n        self.assertEqual(result, expected_sql)\n\n    def test_quotes_in_csv(self):\n        expected_sql = (\n            \"INSERT INTO test5 (quote_id, quote) VALUES (1, 'It''s a beautiful day.');\\n\"\n            \"INSERT INTO test5 (quote_id, quote) VALUES (2, 'She said, \\\"Hello!\\\"');\"\n        )\n        result = csv_to_sql_insert('test5.csv')\n        self.assertEqual(result, expected_sql)",
    "prompt": "please write a python function the function signature as below import csv\nimport os\n\n\ndef csv_to_sql_insert(csv_file_path: str) -> str:\n    \"\"\"\n    Converts the contents of a csv file into an SQL insert statement with a table name with the suffix removed\n    Args:\n        csv_file_path (str): csv file path\n\n    Returns:\n        str: parsed sql str\n    \"\"\"\n"
  },
  {
    "task_id": 65,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef find_duplicate_ips(files: List[str], ignored_ips: set) -> dict:\n    \"\"\"\n    find duplicate IP addresses across multiple files, excluding any IPs in the ignored list.\n    Args:\n        files (list): List of file paths to search.\n        ignored_ips (set): Set of IP addresses to ignore.\n\n    Returns:\n        dict: A dictionary where each key is a duplicated IP address and the value is a list of filenames where the IP appears.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestFindDuplicateIps(unittest.TestCase):\n    def setUp(self):\n        self.files = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\n        self.ignored_ips = {\"192.168.1.1\", \"10.0.0.2\"}\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n192.168.1.1\\n192.168.0.1\\n\")\n    def test_duplicates_with_ignored(self, mock_file, mock_isfile):\n        # Setup\n        mock_isfile.return_value = True\n        expected_result = {'192.168.0.1': ['file1.txt']}\n\n        # Execution\n        result = find_duplicate_ips(self.files[:1], self.ignored_ips)\n\n        # Assertion\n        self.assertEqual(result, expected_result)\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n192.168.0.1\\n\")\n    def test_single_file_duplicates(self, mock_file, mock_isfile):\n        mock_isfile.return_value = True\n        expected_result = {'192.168.0.1': ['file1.txt']}\n        result = find_duplicate_ips(self.files[:1], set())\n        self.assertEqual(result, expected_result)\n\n    @patch('os.path.isfile')\n    def test_non_existent_file(self, mock_isfile):\n        mock_isfile.return_value = False\n        result = find_duplicate_ips([\"nonexistent.txt\"], self.ignored_ips)\n        self.assertEqual(result, {})\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n10.0.0.1\\n192.168.0.1\\n\")\n    def test_multiple_files_one_ignored(self, mock_file, mock_isfile):\n        mock_isfile.side_effect = [True, True, True]\n        expected_result = {'192.168.0.1': ['file1.txt', 'file2.txt']}\n        result = find_duplicate_ips(self.files, self.ignored_ips)\n        self.assertEqual(result, expected_result)\n\n    @patch('os.path.isfile')\n    @patch('builtins.open', new_callable=mock_open, read_data=\"192.168.0.1\\n192.168.0.1\\n192.168.0.1\\n\")\n    def test_multiple_occurrences_single_file(self, mock_file, mock_isfile):\n        mock_isfile.return_value = True\n        expected_result = {'192.168.0.1': ['file1.txt']}\n        result = find_duplicate_ips(self.files[:1], set())\n        self.assertEqual(result, expected_result)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef find_duplicate_ips(files: List[str], ignored_ips: set) -> dict:\n    \"\"\"\n    find duplicate IP addresses across multiple files, excluding any IPs in the ignored list.\n    Args:\n        files (list): List of file paths to search.\n        ignored_ips (set): Set of IP addresses to ignore.\n\n    Returns:\n        dict: A dictionary where each key is a duplicated IP address and the value is a list of filenames where the IP appears.\n    \"\"\"\n"
  },
  {
    "task_id": 66,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Iterable, List\n\n\nclass Course:\n    def __init__(self, course_id, must_courses=None, recommend_courses=None):\n        self.id = course_id\n        self.must_courses = must_courses if must_courses is not None else []\n        self.recommend_courses = recommend_courses if recommend_courses is not None else []\n\n\nclass LeveledCourse:\n    def __init__(self, course: Course, level: int):\n        self.course = course\n        self.level = level\n\n\ndef topological_sort(courses: Iterable[Course]) -> List[LeveledCourse]:\n    \"\"\"\n    Performs a topological sort on a collection of courses using Kahn's algorithm.\n\n    Args:\n    courses (Iterable[Course]): A collection of courses, where each course is assumed to have an 'id',\n                                and optionally 'must_courses' and 'recommend_courses' lists of course ids.\n\n    Returns:\n    List[LeveledCourse]: A list of courses sorted in topological order, each wrapped in a LeveledCourse\n                         object that also contains the level (i.e., distance from start in topological sort).\n\n    Raises:\n    ValueError: If there is a cycle detected in the courses, which prevents a complete topological sort.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestTopologicalSort(unittest.TestCase):\n\n    def test_empty_list(self):\n        \"\"\" Test sorting with no courses \"\"\"\n        courses = []\n        self.assertEqual(topological_sort(courses), [])\n\n    def test_single_course(self):\n        \"\"\" Test sorting with one course that has no dependencies \"\"\"\n        courses = [Course(\"101\")]\n        sorted_courses = topological_sort(courses)\n        self.assertEqual(len(sorted_courses), 1)\n        self.assertEqual(sorted_courses[0].course.id, \"101\")\n\n    def test_basic_dependency(self):\n        \"\"\" Test sorting where one course directly depends on another \"\"\"\n        courses = [Course(\"101\"), Course(\"102\", [\"101\"])]\n        sorted_courses = topological_sort(courses)\n        self.assertEqual([course.course.id for course in sorted_courses], [\"101\", \"102\"])\n\n    def test_complex_dependency(self):\n        \"\"\" Test a complex scenario with multiple dependencies \"\"\"\n        courses = [\n            Course(\"Math\"),\n            Course(\"Advanced Math\", [\"Math\"]),\n            Course(\"Physics\", [\"Math\"], [\"Advanced Math\"]),\n            Course(\"Chemistry\")\n        ]\n        sorted_courses = topological_sort(courses)\n        ids = [course.course.id for course in sorted_courses]\n        self.assertTrue(ids.index(\"Math\") < ids.index(\"Advanced Math\"))\n        self.assertTrue(ids.index(\"Math\") < ids.index(\"Physics\"))\n\n    def test_cycle_detection(self):\n        \"\"\" Test detection of cycles in course prerequisites \"\"\"\n        courses = [Course(\"101\", [\"102\"]), Course(\"102\", [\"101\"])]\n        with self.assertRaises(ValueError):\n            topological_sort(courses)",
    "prompt": "please write a python function the function signature as below from typing import Iterable, List\n\n\nclass Course:\n    def __init__(self, course_id, must_courses=None, recommend_courses=None):\n        self.id = course_id\n        self.must_courses = must_courses if must_courses is not None else []\n        self.recommend_courses = recommend_courses if recommend_courses is not None else []\n\n\nclass LeveledCourse:\n    def __init__(self, course: Course, level: int):\n        self.course = course\n        self.level = level\n\n\ndef topological_sort(courses: Iterable[Course]) -> List[LeveledCourse]:\n    \"\"\"\n    Performs a topological sort on a collection of courses using Kahn's algorithm.\n\n    Args:\n    courses (Iterable[Course]): A collection of courses, where each course is assumed to have an 'id',\n                                and optionally 'must_courses' and 'recommend_courses' lists of course ids.\n\n    Returns:\n    List[LeveledCourse]: A list of courses sorted in topological order, each wrapped in a LeveledCourse\n                         object that also contains the level (i.e., distance from start in topological sort).\n\n    Raises:\n    ValueError: If there is a cycle detected in the courses, which prevents a complete topological sort.\n    \"\"\"\n"
  },
  {
    "task_id": 67,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n",
    "test_code": "import unittest\nimport xml.etree.ElementTree as ET\nfrom io import StringIO\n\n\nclass TestParseXamlToDict(unittest.TestCase):\n    def test_valid_strings(self):\n        xaml_data = \"\"\"<root>\n                         <String Key=\"Username\">Alice</String>\n                         <String Key=\"Password\">secret</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Alice', 'Password': 'secret'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_missing_key_attribute(self):\n        xaml_data = \"\"\"<root>\n                         <String>Alice</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_empty_string_values(self):\n        xaml_data = \"\"\"<root>\n                         <String Key=\"Username\"></String>\n                         <String Key=\"Password\"></String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': '', 'Password': ''}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_no_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Data>Some data</Data>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n\n    def test_nested_string_tags(self):\n        xaml_data = \"\"\"<root>\n                         <Container>\n                           <String Key=\"Username\">Bob</String>\n                         </Container>\n                         <String Key=\"Location\">Earth</String>\n                       </root>\"\"\"\n        xaml_input = StringIO(xaml_data)\n        expected = {'Username': 'Bob', 'Location': 'Earth'}\n        result = parse_xaml_to_dict(xaml_input)\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below from typing import Dict\n\n\ndef parse_xaml_to_dict(xaml_file: str) -> Dict[str, str]:\n    \"\"\"\n    parse the XAML file, extract the key-value pairs within the String element, and return the result in a dictionary\n    Args:\n        xaml_file (str): Path to the XAML file.\n\n    Returns:\n        A dictionary containing the key-value pairs extracted from 'String' elements.\n    \"\"\"\n"
  },
  {
    "task_id": 68,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef divide_list(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestDivideList(unittest.TestCase):\n    def test_even_division(self):\n        lst = [1, 2, 3, 4, 5, 6]\n        n = 3\n        expected = [[1, 2], [3, 4], [5, 6]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_uneven_division(self):\n        lst = [1, 2, 3, 4, 5, 6, 7]\n        n = 3\n        expected = [[1, 2, 3], [4, 5], [6, 7]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_more_parts_than_items(self):\n        lst = [1, 2, 3]\n        n = 5\n        expected = [[1], [2], [3], [], []]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_single_element(self):\n        lst = [1]\n        n = 1\n        expected = [[1]]\n        self.assertEqual(divide_list(lst, n), expected)\n\n    def test_empty_list(self):\n        lst = []\n        n = 3\n        expected = [[], [], []]\n        self.assertEqual(divide_list(lst, n), expected)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef divide_list(lst: List, n: int) -> List:\n    \"\"\"\n    divide a list evenly into n parts and return a list of these parts. If the list length is not divisible by n, additional elements are added to the previous sections one by one\n    Args:\n        lst (List): The list to be divided.\n        n (int): The number of parts to divide the list into.\n\n    Returns:\n        A list containing n sublists, where each sublist represents a part of the original list.\n    \"\"\"\n"
  },
  {
    "task_id": 70,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestCodeBlockRemover(unittest.TestCase):\n\n    def test_single_code_block(self):\n        markdown = \"\"\"\n        This is a markdown with a code block.\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['print(\"Hello, World!\")']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_multiple_code_blocks(self):\n        markdown = \"\"\"\n        First code block:\n\n        ```python\n        print(\"Hello, World!\")\n        ```\n\n        Second code block:\n\n        ```javascript\n        console.log(\"Hello, World!\");\n        ```\n        \"\"\"\n        expected = [\n            'print(\"Hello, World!\")',\n            'console.log(\"Hello, World!\");'\n        ]\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_no_code_block(self):\n        markdown = \"\"\"\n        This markdown has no code blocks.\n\n        Just some plain text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_empty_code_block(self):\n        markdown = \"\"\"\n        Here is an empty code block:\n\n        ```python\n        ```\n\n        End of markdown.\n        \"\"\"\n        expected = ['']\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n\n    def test_malformed_code_block(self):\n        markdown = \"\"\"\n        This code block is missing ending:\n\n        ```python\n        print(\"Hello, World!\")\n\n        And some more text.\n        \"\"\"\n        expected = []\n        result = code_block_remover(markdown)\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef code_block_remover(markdown_string: str) -> List[str]:\n    \"\"\"\n    extracts the contents of the code block from the given Markdown string.\n\n    Args:\n        markdown_string (str): The input markdown string.\n\n    Returns:\n        list: A list of strings, each representing the content of a code block.\n              Returns an empty list if no code blocks are found.\n    \"\"\"\n"
  },
  {
    "task_id": 71,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import numpy as np\n\n\ndef read_columns(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical data.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n",
    "test_code": "import unittest\nimport numpy as np\nimport os\n\n\ndef read_columns(file_name):\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical data.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n    # Initialize a variable to track the last slash line index\n    last_slash_index = None\n\n    with open(file_name) as f:\n        lines = f.readlines()\n\n    # Find the index of the last line that contains the \"/\" character\n    for i, line in enumerate(lines):\n        if \"/\" in line:\n            last_slash_index = i\n\n    # If no \"/\" character was found, raise an error\n    if last_slash_index is None:\n        raise ValueError(\"File does not contain '/' character\")\n\n    # Read the remaining lines in the file, starting from the line after the last \"/\"\n    data_lines = lines[last_slash_index + 1:]\n\n    # Remove any empty lines or lines that start with a comment character\n    data_lines = [line.strip() for line in data_lines if line.strip() and not line.strip().startswith('!')]\n\n    # If no valid lines remain, return an empty array\n    if not data_lines:\n        return np.array([])\n\n    # Get the row and column count by counting the number of columns in the first line\n    col_count = len(data_lines[0].split())\n\n    # Create an empty numpy array of the required size\n    arr = np.zeros((len(data_lines), col_count))\n\n    # Loop through the lines in the file\n    for i, line in enumerate(data_lines):\n        # Split the line into numbers and convert them to floats\n        nums = [float(x) for x in line.split()]\n        # Store the numbers in the array\n        arr[i, :] = nums\n\n    # Return the array\n    return arr\n\n\nclass TestReadColumns(unittest.TestCase):\n\n    def setUp(self):\n        # Setup a temporary directory to use for each test\n        self.test_file = 'test_file.txt'\n\n    def tearDown(self):\n        # Clean up the temporary file after each test\n        if os.path.exists(self.test_file):\n            os.remove(self.test_file)\n\n    def test_basic_functionality(self):\n        # Test reading a file with a valid structure and numerical data\n        content = \"\"\"Line 1\nLine 2\n/\n1.0 2.0 3.0\n4.0 5.0 6.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_columns(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_no_slash_character(self):\n        # Test that a ValueError is raised if no '/' character is found\n        content = \"\"\"Line 1\nLine 2\nLine 3\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n\n    def test_file_with_comments_and_empty_lines(self):\n        # Test handling of comments and empty lines\n        content = \"\"\"Line 1\n/\n! This is a comment\n1.0 2.0 3.0\n\n4.0 5.0 6.0\n! Another comment\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        result = read_columns(self.test_file)\n        expected_result = np.array([[1.0, 2.0, 3.0],\n                                    [4.0, 5.0, 6.0]])\n        np.testing.assert_array_equal(result, expected_result)\n\n    def test_different_number_of_columns(self):\n        # Test that the function handles different number of columns correctly\n        content = \"\"\"Line 1\n/\n1.0 2.0\n3.0 4.0\n5.0 6.0 7.0\n\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n\n    def test_empty_file(self):\n        # Test handling of an empty file\n        content = \"\"\"\"\"\"\n        with open(self.test_file, 'w') as f:\n            f.write(content)\n\n        with self.assertRaises(ValueError):\n            read_columns(self.test_file)\n",
    "prompt": "please write a python function the function signature as below import numpy as np\n\n\ndef read_columns(file_name: str) -> np.array:\n    \"\"\"\n    Reads numerical columns from a file starting from the line after the last line containing '/'.\n\n    Args:\n        file_name (str): The name of the file to read.\n\n    Returns:\n        numpy.ndarray: A 2D numpy array containing the numerical data.\n\n    Raises:\n        ValueError: If the file does not contain any '/' character.\n    \"\"\"\n"
  },
  {
    "task_id": 72,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import numpy as np\n\n\ndef get_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n    Args:\n        K ((3,3) np.array): camera intrinsic matrix\n        d (float): depth (distance along z-axis)\n        x (float): pixel x coordinate\n        y (float): pixel y coordinate\n\n    Returns:\n        np.array: x, y, z 3D point coordinates in camera RDF coordinates\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestGet3DCoordinates(unittest.TestCase):\n    def setUp(self):\n        # Define a common intrinsic matrix for testing\n        self.K = np.array([[1000, 0, 320],\n                           [0, 1000, 240],\n                           [0, 0, 1]])\n\n    def test_center_coordinates(self):\n        \"\"\" Test with center pixel coordinates where x and y should map to zero in NDC. \"\"\"\n        result = get_3d_coordinates(self.K, 100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 100]))\n\n    def test_boundary_coordinates(self):\n        \"\"\" Test with boundary values in the image frame. \"\"\"\n        result = get_3d_coordinates(self.K, 50, 640, 480)\n        expected_x = (640 - 320) / 1000 * 50\n        expected_y = (480 - 240) / 1000 * 50\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 50]))\n\n    def test_negative_depth(self):\n        \"\"\" Test with a negative depth to see if it handles incorrect input properly. \"\"\"\n        result = get_3d_coordinates(self.K, -100, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, -100]))\n\n    def test_zero_depth(self):\n        \"\"\" Test with zero depth which should lead to a zero-length vector. \"\"\"\n        result = get_3d_coordinates(self.K, 0, 320, 240)\n        np.testing.assert_array_almost_equal(result, np.array([0.0, 0.0, 0.0]))\n\n    def test_non_integer_values(self):\n        \"\"\" Test with non-integer pixel coordinates. \"\"\"\n        result = get_3d_coordinates(self.K, 100, 320.5, 240.5)\n        expected_x = (320.5 - 320) / 1000 * 100\n        expected_y = (240.5 - 240) / 1000 * 100\n        np.testing.assert_array_almost_equal(result, np.array([expected_x, expected_y, 100]))",
    "prompt": "please write a python function the function signature as below import numpy as np\n\n\ndef get_3d_coordinates(K: np.array, d: float, x: float, y: float) -> np.array:\n    \"\"\"\n    converts 2D pixel coordinates into 3D world coordinates using camera intrinsic parameters and depth.\n    Args:\n        K ((3,3) np.array): camera intrinsic matrix\n        d (float): depth (distance along z-axis)\n        x (float): pixel x coordinate\n        y (float): pixel y coordinate\n\n    Returns:\n        np.array: x, y, z 3D point coordinates in camera RDF coordinates\n    \"\"\"\n"
  },
  {
    "task_id": 73,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestDictOfListsToListOfDicts(unittest.TestCase):\n    def test_standard_conversion(self):\n        \"\"\"Test standard conversion with equal length lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\", \"Bob\", \"Charlie\"],\n            \"age\": [25, 30, 35],\n            \"city\": [\"New York\", \"Los Angeles\", \"Chicago\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'},\n            {'name': 'Bob', 'age': 30, 'city': 'Los Angeles'},\n            {'name': 'Charlie', 'age': 35, 'city': 'Chicago'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_unequal_list_lengths(self):\n        \"\"\"Test the function with lists of unequal lengths to trigger ValueError.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\", \"Bob\"],\n            \"age\": [25, 30, 35]\n        }\n        with self.assertRaises(ValueError):\n            dict_of_lists_to_list_of_dicts(dict_of_lists)\n\n    def test_empty_lists(self):\n        \"\"\"Test the function with empty lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [],\n            \"age\": [],\n            \"city\": []\n        }\n        expected_result = []\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_empty_dictionary(self):\n        \"\"\"Test the function with an empty dictionary.\"\"\"\n        dict_of_lists = {}\n        expected_result = []\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_lists(self):\n        \"\"\"Test the function with single-element lists.\"\"\"\n        dict_of_lists = {\n            \"name\": [\"Alice\"],\n            \"age\": [25],\n            \"city\": [\"New York\"]\n        }\n        expected_result = [\n            {'name': 'Alice', 'age': 25, 'city': 'New York'}\n        ]\n        result = dict_of_lists_to_list_of_dicts(dict_of_lists)\n        self.assertEqual(result, expected_result)\n",
    "prompt": "please write a python function the function signature as below from typing import Dict, List\n\n\ndef dict_of_lists_to_list_of_dicts(dict_of_lists: Dict) -> List[Dict]:\n    \"\"\"\n    Convert a dictionary of lists into a list of dictionaries.\n    Args:\n        dict_of_lists (dict): A dictionary where each key has a list as its value.\n\n    Returns:\n        list of dicts: A list where each item is a dictionary formed by corresponding elements of lists in the input dictionary.\n    \"\"\"\n"
  },
  {
    "task_id": 74,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\"",
    "test_code": "import unittest\n\nclass TestConvertDecimalToBinary(unittest.TestCase):\n    def test_invalid_bit_length(self):\n        with self.assertRaises(ValueError):\n            convert_decimal_to_binary(3.14, 16)  # Invalid bit length, should raise ValueError\n\n    def test_basic_32_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 32),\n                         '01000000010010001111010111000011',\n                         \"3.14 should be correctly converted to 32-bit binary\")\n\n    def test_basic_64_bit_conversion(self):\n        self.assertEqual(convert_decimal_to_binary(3.14, 64),\n                         '0100000000001001000111101011100001010001111010111000010100011111',\n                         \"3.14 should be correctly converted to 64-bit binary\")\n\n    def test_32_bit_edge_case(self):\n        self.assertEqual(convert_decimal_to_binary(float('inf'), 32),\n                         '01111111100000000000000000000000',\n                         \"Infinity should be correctly converted to 32-bit binary\")\n\n    def test_64_bit_edge_case(self):\n        self.assertEqual(convert_decimal_to_binary(float('-inf'), 64),\n                         '1111111111110000000000000000000000000000000000000000000000000000',\n                         \"Negative infinity should be correctly converted to 64-bit binary\")\n\nif __name__ == '__main__':\n    unittest.main()\n",
    "prompt": "please write a python function the function signature as below import struct\nfrom typing import Union\n\ndef convert_decimal_to_binary(decimal_value: float, bit_length: int) -> Union[str, None]:\n    \"\"\"\n    Converts a decimal number to its binary representation in either 32-bit or 64-bit format.\n\n    Args:\n        decimal_value (float): The decimal number to convert.\n        bit_length (int): The desired bit length for the binary representation (32 or 64).\n\n    Returns:\n        Union[str, None]: The binary string representation of the decimal number if the bit length\n                          is valid, otherwise `None`.\n    \"\"\""
  },
  {
    "task_id": 75,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def rename_files(directory:str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\"",
    "test_code": "import re\nimport unittest\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\n\n\n\nclass TestRenameFiles(unittest.TestCase):\n\n    def setUp(self):\n        # Create a temporary directory for each test\n        self.test_dir = tempfile.mkdtemp()\n\n    def tearDown(self):\n        # Remove the temporary directory after each test\n        shutil.rmtree(self.test_dir)\n\n    def create_png_files(self, filenames):\n        for filename in filenames:\n            file_path = Path(self.test_dir) / filename\n            file_path.touch()  # Create an empty file\n\n    def test_basic_renaming(self):\n        # Test renaming in a basic scenario with simple filenames\n        filenames = [\"image1.png\", \"image2.png\", \"image3.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'image3001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_reset_counter_for_different_base_names(self):\n        # Test that the counter resets for different base names\n        filenames = [\"image1.png\", \"picture1.png\", \"image2.png\", \"picture2.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['image1001.png', 'image2001.png', 'picture1001.png', 'picture2001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_no_png_files(self):\n        # Test handling of directories with no PNG files\n        filenames = [\"file1.txt\", \"file2.jpg\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = filenames  # No changes expected\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)\n\n    def test_empty_directory(self):\n        # Test handling of an empty directory\n        rename_files(self.test_dir)\n        expected_files = []  # No files to rename\n        result_files = os.listdir(self.test_dir)\n        self.assertEqual(result_files, expected_files)\n\n    def test_files_with_existing_numbers(self):\n        # Test renaming files that already have numbers in their names\n        filenames = [\"file001.png\", \"file002.png\", \"file003.png\"]\n        self.create_png_files(filenames)\n\n        rename_files(self.test_dir)\n\n        expected_files = ['file001001.png', 'file002001.png', 'file003001.png']\n        result_files = sorted(os.listdir(self.test_dir))\n        self.assertEqual(result_files, expected_files)",
    "prompt": "please write a python function the function signature as below def rename_files(directory:str):\n    \"\"\"\n    Renames PNG files in a specified directory by appending a sequence number to each file.\n    The files are sorted alphabetically, and each base name is assigned sequential numbers.\n\n    Args:\n        directory (str): The path to the directory containing PNG files to be renamed.\n\n    Returns:\n        None\n    \"\"\""
  },
  {
    "task_id": 76,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\"",
    "test_code": "import unittest\n\nclass TestRemoveCommonIndentation(unittest.TestCase):\n\n    def test_empty_string(self):\n        # Testing edge case with an empty string\n        self.assertEqual(remove_common_indentation(\"\"), \"\", \"Should return an empty string\")\n\n    def test_single_line_string(self):\n        # Testing a single line with no indentation\n        self.assertEqual(remove_common_indentation(\"No indentation here\"), \"No indentation here\", \"Should return the same string as input\")\n\n    def test_multiple_lines_with_uniform_indentation(self):\n        # Testing basic logic with uniform indentation across multiple lines\n        input_text = \"    Line one\\n    Line two\\n    Line three\"\n        expected_output = \"Line one\\nLine two\\nLine three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove common leading indentation\")\n\n    def test_multiple_lines_with_mixed_indentation(self):\n        # Testing lines with mixed indentation levels\n        input_text = \"    Line one\\n  Line two\\n    Line three\"\n        expected_output = \"  Line one\\nLine two\\n  Line three\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should remove the minimum common indentation\")\n\n    def test_lines_with_only_whitespace(self):\n        # Testing lines that contain only whitespace characters\n        input_text = \"    \\n    \\n  \\n\"\n        expected_output = \"    \\n    \\n  \\n\"\n        self.assertEqual(remove_common_indentation(input_text), expected_output, \"Should handle lines with only whitespace correctly\")\n\n",
    "prompt": "please write a python function the function signature as below def remove_common_indentation(multiline_text: str) -> str:\n    \"\"\"\n    Removes the common leading indentation from each line in a given multi-line string,\n    preserving the relative indentation of the text.\n\n    Args:\n        multiline_text (str): The input string containing multiple lines.\n\n    Returns:\n        str: The sanitized string with common leading indentation removed.\n    \"\"\""
  },
  {
    "task_id": 77,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from datetime import datetime\nfrom typing import Optional\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\"",
    "test_code": "class TestFormatTimestampToString(unittest.TestCase):\n    def test_basic_functionality(self):\n        \"\"\"Test basic functionality with a known timestamp.\"\"\"\n        timestamp = 1655364000.0  # Corresponds to Thu Jun 16 12:00:00 PM UTC 2022\n        # Assuming the local timezone is UTC\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the timestamp\")\n\n    def test_default_format(self):\n        \"\"\"Test using the default format string.\"\"\"\n        timestamp = 1655364000.0\n        expected_date_str = 'Thu Jun 16 03:20:00 PM +0800 2022'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Default format should match the expected date string\")\n\n    def test_custom_format(self):\n        \"\"\"Test with a custom format string.\"\"\"\n        timestamp = 1655364000.0\n        custom_format = '%Y-%m-%d %H:%M:%S'\n        expected_date_str = '2022-06-16 15:20:00'\n        self.assertEqual(format_timestamp_to_string(timestamp, custom_format), expected_date_str, \"Should correctly format the timestamp using the custom format\")\n\n    def test_invalid_timestamp(self):\n        \"\"\"Test with an invalid (negative) timestamp.\"\"\"\n        timestamp = -1.0\n        with self.assertRaises(ValueError):\n            format_timestamp_to_string(timestamp)\n\n    def test_edge_case_boundary_value(self):\n        \"\"\"Test with an edge case timestamp (e.g., Unix epoch start).\"\"\"\n        timestamp = 0.0  # Unix epoch start\n        expected_date_str = 'Thu Jan 01 08:00:00 AM +0800 1970'\n        self.assertEqual(format_timestamp_to_string(timestamp), expected_date_str, \"Should correctly format the Unix epoch start time\")",
    "prompt": "please write a python function the function signature as below from datetime import datetime\nfrom typing import Optional\n\ndef format_timestamp_to_string(timestamp: float, date_format: Optional[str] = '%a %b %d %I:%M:%S %p %z %Y') -> str:\n    \"\"\"\n    Formats the given timestamp as a string according to the specified format, using the system's local time zone.\n\n    Args:\n        timestamp (float): The time value representing the seconds since the epoch.\n        date_format (Optional[str]): The format string to use for formatting the timestamp.\n                                     Defaults to '%a %b %d %I:%M:%S %p %z %Y'.\n\n    Returns:\n        str: The formatted date and time string.\n    \"\"\""
  },
  {
    "task_id": 78,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n",
    "test_code": "import unittest\nimport numpy as np\n\nclass TestEulerToRotationMatrix(unittest.TestCase):\n    def test_zero_rotation(self):\n        # Test with zero rotation for all axes\n        R = euler_to_rotation_matrix(0, 0, 0)\n        np.testing.assert_array_almost_equal(R, np.identity(3))\n\n    def test_rotation_about_x(self):\n        # Test rotation about the x-axis\n        R = euler_to_rotation_matrix(90, 0, 0)\n        expected = np.array([\n            [1, 0, 0],\n            [0, 0, -1],\n            [0, 1, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_y(self):\n        # Test rotation about the y-axis\n        R = euler_to_rotation_matrix(0, 90, 0)\n        expected = np.array([\n            [0, 0, 1],\n            [0, 1, 0],\n            [-1, 0, 0]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_rotation_about_z(self):\n        # Test rotation about the z-axis\n        R = euler_to_rotation_matrix(0, 0, 90)\n        expected = np.array([\n            [0, -1, 0],\n            [1, 0, 0],\n            [0, 0, 1]\n        ])\n        np.testing.assert_array_almost_equal(R, expected)\n\n    def test_combined_rotation(self):\n        # Test combined rotation\n        R = euler_to_rotation_matrix(30, 45, 60)\n        # Expected result manually calculated or verified via a reliable source\n        expected = np.array([[ 0.35355339, -0.5732233,   0.73919892], [ 0.61237244 , 0.73919892,  0.28033009], [-0.70710678 , 0.35355339,  0.61237244]])\n        np.testing.assert_array_almost_equal(R, np.array(expected), decimal=5)",
    "prompt": "please write a python function the function signature as below import numpy as np\n\n\ndef euler_to_rotation_matrix(roll: float, pitch: float, yaw: float) -> np.array:\n    \"\"\"\n    Convert Euler angles (roll, pitch, yaw) to a rotation matrix.\n\n    Args:\n        roll (float): Rotation around the x-axis in degrees.\n        pitch (float): Rotation around the y-axis in degrees.\n        yaw (float): Rotation around the z-axis in degrees.\n\n    Returns:\n        np.array: A 3x3 rotation matrix.\n    \"\"\"\n"
  },
  {
    "task_id": 79,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\"\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestDateRangeString(unittest.TestCase):\n    def test_same_month(self):\n        # Test dates within the same month\n        result = date_range_string(\"2023-08-01\", \"2023-08-15\")\n        self.assertEqual(result, \"August 1 to 15, 2023\")\n\n    def test_different_months_same_year(self):\n        # Test dates across different months within the same year\n        result = date_range_string(\"2023-08-30\", \"2023-09-05\")\n        self.assertEqual(result, \"August 30 to September 5, 2023\")\n\n    def test_different_years(self):\n        # Test dates across different years\n        result = date_range_string(\"2023-12-30\", \"2024-01-02\")\n        self.assertEqual(result, \"December 30, 2023 to January 2, 2024\")\n\n    def test_incorrect_date_format(self):\n        # Test incorrect date formats\n        with self.assertRaises(ValueError) as context:\n            date_range_string(\"2023/08/01\", \"2023/08/15\")\n        self.assertTrue(\"Date must be in 'YYYY-MM-DD' format.\" in str(context.exception))\n\n    def test_start_date_after_end_date(self):\n        # Test logical error where start date is after end date\n        with self.assertRaises(ValueError) as context:\n            date_range_string(\"2023-08-15\", \"2023-08-01\")\n        self.assertTrue(\"start_date cannot be after end_date.\" in str(context.exception))",
    "prompt": "please write a python function the function signature as below def date_range_string(start_date: str, end_date: str) -> str:\n    \"\"\"\n    Generates a string based on the entered start and end dates. If the start date and end date are in the same month, only one month will be displayed. If not, the start and end months will be displayed separately. For example, if you enter the start date and end date as,\"2023-08-01\" and \"2023-08-15\" respectively, you will finally output \"August 1 to 15, 2023\"\n\n    Args:\n        start_date (str): The start date in 'YYYY-MM-DD' format.\n        end_date (str): The end date in 'YYYY-MM-DD' format.\n\n    Returns:\n        str: A string representing the date range in a human-readable format.\n    \"\"\"\n"
  },
  {
    "task_id": 80,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from strings and handle spaces and empty characters to make the modified string comply with windows file name rules\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestSanitizeFilename(unittest.TestCase):\n    def test_remove_illegal_chars(self):\n        # Test removing characters illegal in Windows filenames\n        result = sanitize_filename(\"test.js<filename>?*.txt\")\n        self.assertEqual(result, \"testfilename.txt\")\n\n    def test_replace_multiple_spaces(self):\n        # Test replacing multiple spaces with a single space\n        result = sanitize_filename(\"new  document   file.txt\")\n        self.assertEqual(result, \"new document file.txt\")\n\n    def test_remove_trailing_periods(self):\n        # Test removing trailing periods\n        result = sanitize_filename(\"example.\")\n        self.assertEqual(result, \"example\")\n\n    def test_complex_filename(self):\n        # Test a complex filename with multiple issues\n        result = sanitize_filename(\"  test.js*file<>name  with  ?illegal|chars.txt  \")\n        self.assertEqual(result, \"testfilename with illegalchars.txt\")\n\n    def test_empty_filename(self):\n        # Test sanitizing an empty filename\n        result = sanitize_filename(\"\")\n        self.assertEqual(result, \"\")\n",
    "prompt": "please write a python function the function signature as below def sanitize_filename(filename: str) -> str:\n    \"\"\"\n    remove illegal characters from strings and handle spaces and empty characters to make the modified string comply with windows file name rules\n\n    Args:\n        filename (str): The original filename string to be sanitized.\n\n    Returns:\n        str: A sanitized string that is safe to use as a Windows filename.\n    \"\"\"\n"
  },
  {
    "task_id": 81,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestFindClosestElement(unittest.TestCase):\n\n    def test_empty_list(self):\n        with self.assertRaises(ValueError, msg=\"Should raise ValueError for empty list\"):\n            find_closest_element(5, [])\n\n    def test_basic_functionality(self):\n        self.assertEqual(find_closest_element(5, [1, 3, 7, 8, 9]), 3, \"Should return 3 as it is the first closest element to 5\")\n\n    def test_exact_match(self):\n        self.assertEqual(find_closest_element(7, [1, 3, 7, 8, 9]), 7, \"Should return 7 as it exactly matches the target\")\n\n    def test_multiple_closest_values(self):\n        self.assertEqual(find_closest_element(5, [4, 6, 8, 9]), 4, \"Should return 4 as it is the first closest element to 5\")\n\n    def test_float_values(self):\n        self.assertEqual(find_closest_element(5.5, [1.1, 3.3, 7.7, 8.8]), 3.3, \"Should return 3.3 as it is the first closest element to 5.5\")\n\n",
    "prompt": "please write a python function the function signature as below from typing import List, Union\n\n\ndef find_closest_element(target: Union[int, float], elements: List[Union[int, float]]) -> Union[int, float]:\n    \"\"\"\n    Finds and returns the element from the given list that is closest to the specified target value.\n\n    Args:\n        target (Union[int, float]): The target number to which we want to find the closest element.\n        elements (List[Union[int, float]]): A list of numerical elements from which the closest element is to be found.\n\n    Returns:\n        Union[int, float]: The element from the list that is closest to the target value.\n    \"\"\"\n"
  },
  {
    "task_id": 82,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestGraphCycles(unittest.TestCase):\n    def test_empty_graph(self):\n        g = Graph([])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for an empty graph.\")\n\n    def test_graph_no_cycles(self):\n        g = Graph([(1, 2), (2, 3)])\n        self.assertEqual(g.cycles_by_size(), defaultdict(list),\n                         \"Failed: Expected an empty defaultdict for a graph with no cycles.\")\n\n    def test_simple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertIn(list(results[3][0].nodes()), [[1, 2, 3]], \"Failed: Expected cycle nodes to match.\")\n\n    def test_multiple_cycles(self):\n        g = Graph([(1, 2), (2, 3), (3, 1), (3, 4), (4, 1)])\n        results = g.cycles_by_size()\n        self.assertEqual(len(results[3]), 1, \"Failed: Expected one cycle of length 3.\")\n        self.assertEqual(len(results[4]), 1, \"Failed: Expected one cycle of length 4.\")\n",
    "prompt": "please write a python function the function signature as below from typing import List, Dict, Any\n\nimport networkx as nx\n\n\nclass Graph:\n    def __init__(self, edges):\n        self.graph = nx.DiGraph(edges)\n\n    def cycles_by_size(self, filter_repeat_nodes=True) -> Dict[Any, List]:\n        \"\"\"\n        Finds all unique cycles in the graph that are larger than size 2, optionally filtering out cycles with repeated nodes.\n\n        Args:\n            filter_repeat_nodes (bool): If True, filters out cycles where any node appears more than once.\n\n        Returns:\n            Dict[int, List[nx.Graph]]: A dictionary mapping each cycle size to a list of subgraph objects representing\n                each unique cycle of that size.\n        \"\"\"\n"
  },
  {
    "task_id": 83,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestRotateListElements(unittest.TestCase):\n\n    def test_basic_rotation(self):\n        self.assertEqual(rotate_list_elements([1, 2, 3, 4]), [2, 3, 4, 1], \"Should rotate the list elements correctly\")\n\n    def test_single_element_list(self):\n        self.assertEqual(rotate_list_elements([10]), [10], \"Single element list should remain unchanged\")\n\n    def test_empty_list(self):\n        self.assertEqual(rotate_list_elements([]), [], \"Empty list should remain unchanged\")\n\n    def test_two_element_list(self):\n        self.assertEqual(rotate_list_elements([5, 9]), [9, 5], \"Should correctly rotate a two-element list\")\n\n    def test_large_list(self):\n        large_list = list(range(1, 1001))\n        rotated_list = rotate_list_elements(large_list)\n        self.assertEqual(rotated_list, list(range(2, 1001)) + [1], \"Should correctly rotate a large list\")\n\n\n\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef rotate_list_elements(elements: List[int]) -> List[int]:\n    \"\"\"\n    Rotate the elements of the list to the left by one position. The first element\n    is moved to the end of the list, and all other elements are shifted one position to the left.\n\n    Args:\n        elements (List[int]): A list of integers to be rotated.\n\n    Returns:\n        List[int]: The rotated list with elements shifted to the left by one position.\n    \"\"\"\n"
  },
  {
    "task_id": 84,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\"",
    "test_code": "import unittest\n\n\nclass TestFindMinWindowSubstring(unittest.TestCase):\n\n    def test_empty_source_string(self):\n        # Test with an empty source string\n        self.assertEqual(find_min_window_substring(\"\", \"abc\"), \"\", \"Should return an empty string when source is empty\")\n\n    def test_empty_target_string(self):\n        # Test with an empty target string\n        self.assertEqual(find_min_window_substring(\"abc\", \"\"), \"\", \"Should return an empty string when target is empty\")\n\n    def test_no_valid_window(self):\n        # Test when there is no valid window\n        self.assertEqual(find_min_window_substring(\"abcdef\", \"xyz\"), \"\",\n                         \"Should return an empty string when no valid window exists\")\n\n    def test_exact_match_window(self):\n        # Test when the entire source string is the exact match\n        self.assertEqual(find_min_window_substring(\"abcd\", \"abcd\"), \"abcd\",\n                         \"Should return the entire string when it is an exact match\")\n\n    def test_minimal_valid_window(self):\n        # Test with a minimal valid window case\n        self.assertEqual(find_min_window_substring(\"ADOBECODEBANC\", \"ABC\"), \"BANC\",\n                         \"Should return 'BANC' as the smallest window containing all characters of 'ABC'\")\n\n\n",
    "prompt": "please write a python function the function signature as below from collections import Counter\nfrom typing import Optional\n\n\ndef find_min_window_substring(source: str, target: str) -> Optional[str]:\n    \"\"\"\n    Finds the smallest window in the source string that contains all characters of the target string.\n\n    Args:\n        source (str): The source string in which to search for the window.\n        target (str): The target string containing the characters to be matched.\n\n    Returns:\n        Optional[str]: The smallest window in the source string that contains all characters of the target string.\n                       Returns an empty string if no such window exists.\n    \"\"\""
  },
  {
    "task_id": 85,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import pandas as pd\n\n\ndef naive_ffill(df: pd.DataFrame, column: str) -> None:\n    \"\"\"\n    Forward fills missing values in a specified column of a pandas DataFrame using a naive method.\n\n    Args:\n    df (pd.DataFrame): The DataFrame containing the data.\n    column (str): The name of the column in which to forward fill missing values.\n\n    Returns:\n    None: The function modifies the DataFrame in place.\n    \"\"\"",
    "test_code": "import unittest\nimport pandas as pd\n\nclass TestNaiveFfill(unittest.TestCase):\n\n    def test_basic_forward_fill(self):\n        df = pd.DataFrame({'A': [1, None, 3, None, 5]})\n        naive_ffill(df, 'A')\n        expected = pd.DataFrame({'A': [1, 1, 3, 3, 5]})\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_no_missing_values(self):\n        df = pd.DataFrame({'A': [1, 2, 3, 4, 5]})\n        naive_ffill(df, 'A')\n        expected = pd.DataFrame({'A': [1, 2, 3, 4, 5]})\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_all_missing_values(self):\n        df = pd.DataFrame({'A': [None, None, None, None, None]})\n        naive_ffill(df, 'A')\n        expected = pd.DataFrame({'A': [None, None, None, None, None]})\n        pd.testing.assert_frame_equal(df, expected)\n\n    def test_non_existent_column(self):\n        df = pd.DataFrame({'A': [1, 2, 3]})\n        with self.assertRaises(KeyError):\n            naive_ffill(df, 'B')\n\n    def test_multiple_columns(self):\n        df = pd.DataFrame({'A': [1, None, 3], 'B': [None, 2, None]})\n        naive_ffill(df, 'A')\n        expected = pd.DataFrame({'A': [1, 1, 3], 'B': [None, 2, None]})\n        pd.testing.assert_frame_equal(df, expected)",
    "prompt": "please write a python function the function signature as below import pandas as pd\n\n\ndef naive_ffill(df: pd.DataFrame, column: str) -> None:\n    \"\"\"\n    Forward fills missing values in a specified column of a pandas DataFrame using a naive method.\n\n    Args:\n    df (pd.DataFrame): The DataFrame containing the data.\n    column (str): The name of the column in which to forward fill missing values.\n\n    Returns:\n    None: The function modifies the DataFrame in place.\n    \"\"\""
  },
  {
    "task_id": 86,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        self.assertEqual(bresenham_line(1, 5, 5, 5), [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5)])\n\n    def test_vertical_line(self):\n        self.assertEqual(bresenham_line(3, 2, 3, 6), [(3, 2), (3, 3), (3, 4), (3, 5), (3, 6)])\n\n    def test_diagonal_line(self):\n        self.assertEqual(bresenham_line(2, 2, 6, 6), [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6)])\n\n    def test_steep_slope(self):\n        self.assertEqual(bresenham_line(1, 1, 4, 6), [(1, 1), (2, 2), (2, 3), (3, 4), (3, 5), (4, 6)])\n\n    def test_negative_slope(self):\n        self.assertEqual(bresenham_line(5, 1, 1, 5), [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5)])\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[tuple]:\n    \"\"\"\n    Generates integer coordinates on the line from (x1, y1) to (x2, y2) using Bresenham's line algorithm.\n\n    Bresenham's algorithm calculates the points of an approximately straight line between two given points on a grid.\n    It is particularly well-suited for computer graphics where an efficient, integer-based algorithm is needed to\n    determine which points should be rasterized to represent the line.\n\n    Args:\n        x1 (int): The x-coordinate of the starting point of the line.\n        y1 (int): The y-coordinate of the starting point of the line.\n        x2 (int): The x-coordinate of the ending point of the line.\n        y2 (int): The y-coordinate of the ending point of the line.\n\n    Returns:\n        list of tuples: A list where each tuple contains the x and y coordinates of a point on the line.\n    \"\"\"\n"
  },
  {
    "task_id": 211,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List, Dict\n\n\ndef extract_parameters_from_file(file_path:str) -> List[Dict]:\n    \"\"\"\n    extract the names, descriptions, and units of the parameters from a Fortran file, put this information in the form of a list, where each element is a dictionary, and return the list\n\n    Args:\n        file_path (str): Path to the Fortran file.\n\n    Returns:\n        list of dict: A list of dictionaries, each containing the variable name,\n                  description, and units of a parameter.\n\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractParametersFromFile(unittest.TestCase):\n    def test_standard_case(self):\n        \"\"\" Test with a well-formed Fortran file content. \"\"\"\n        file_content = \"real(r8), target, allocatable :: temp(3) ! Temperature profile, [K]\"\n        m = mock_open(read_data=file_content)\n        with patch('builtins.open', m):\n            result = extract_parameters_from_file('dummy.f90')\n            expected = [{'variable_name': 'temp', 'description': 'Temperature profile', 'units': 'K'}]\n            self.assertEqual(result, expected)\n\n    def test_multiple_parameters(self):\n        \"\"\" Test with multiple parameters in file content. \"\"\"\n        file_content = \"\"\"\n        real(r8), target, allocatable :: temp ! Ambient temperature, [C]\n        real(r8), target, allocatable :: pressure(10) ! Atmospheric pressure, [atm]\n        \"\"\"\n        m = mock_open(read_data=file_content)\n        with patch('builtins.open', m):\n            result = extract_parameters_from_file('dummy.f90')\n            expected = [\n                {'variable_name': 'temp', 'description': 'Ambient temperature', 'units': 'C'},\n                {'variable_name': 'pressure', 'description': 'Atmospheric pressure', 'units': 'atm'}\n            ]\n            self.assertEqual(result, expected)\n\n    def test_no_parameters(self):\n        \"\"\" Test with no parameter declarations in file content. \"\"\"\n        file_content = \"This file contains no relevant parameters.\"\n        m = mock_open(read_data=file_content)\n        with patch('builtins.open', m):\n            result = extract_parameters_from_file('dummy.f90')\n            self.assertEqual(result, [])\n\n    def test_incorrect_format(self):\n        \"\"\" Test with incorrectly formatted parameter declarations. \"\"\"\n        file_content = \"real(r8), target, allocatable :: temp ! Incorrect format here\"\n        m = mock_open(read_data=file_content)\n        with patch('builtins.open', m):\n            result = extract_parameters_from_file('dummy.f90')\n            self.assertEqual(result, [])\n\n    def test_complex_structure(self):\n        \"\"\" Test with complex and correct declarations. \"\"\"\n        file_content = \"\"\"\n        real(r8), target, allocatable :: temp(5, 10) ! Grid temperature, [K]\n        real(r8), target, allocatable :: velocity ! Wind velocity, [m/s]\n        \"\"\"\n        m = mock_open(read_data=file_content)\n        with patch('builtins.open', m):\n            result = extract_parameters_from_file('dummy.f90')\n            expected = [\n                {'variable_name': 'temp', 'description': 'Grid temperature', 'units': 'K'},\n                {'variable_name': 'velocity', 'description': 'Wind velocity', 'units': 'm/s'}\n            ]\n            self.assertEqual(result, expected)",
    "prompt": "please write a python function the function signature as below from typing import List, Dict\n\n\ndef extract_parameters_from_file(file_path:str) -> List[Dict]:\n    \"\"\"\n    extract the names, descriptions, and units of the parameters from a Fortran file, put this information in the form of a list, where each element is a dictionary, and return the list\n\n    Args:\n        file_path (str): Path to the Fortran file.\n\n    Returns:\n        list of dict: A list of dictionaries, each containing the variable name,\n                  description, and units of a parameter.\n\n    \"\"\"\n"
  },
  {
    "task_id": 213,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\"",
    "test_code": "import unittest\n\nimport numpy as np\n\n\nclass TestIm2Col(unittest.TestCase):\n\n    def test_single_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 3, 5, 6, 7, 9, 10, 11],\n            [2, 3, 4, 6, 7, 8, 10, 11, 12],\n            [5, 6, 7, 9, 10, 11, 13, 14, 15],\n            [6, 7, 8, 10, 11, 12, 14, 15, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_single_channel_no_padding_stride_2(self):\n        image = np.array([\n            [[1, 2, 3, 4],\n             [5, 6, 7, 8],\n             [9, 10, 11, 12],\n             [13, 14, 15, 16]]\n        ])  # Shape (1, 4, 4)\n        filter_height = 2\n        filter_width = 2\n        stride = 2\n        padding = 0\n\n        expected_output = np.array([\n            [1, 3, 9, 11],\n            [2, 4, 10, 12],\n            [5, 7, 13, 15],\n            [6, 8, 14, 16]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n\n    def test_multi_channel_no_padding_stride_1(self):\n        image = np.array([\n            [[1, 2, 3],\n             [4, 5, 6],\n             [7, 8, 9]],\n            [[9, 8, 7],\n             [6, 5, 4],\n             [3, 2, 1]]\n        ])  # Shape (2, 3, 3), 2 channels\n        filter_height = 2\n        filter_width = 2\n        stride = 1\n        padding = 0\n\n        expected_output = np.array([\n            [1, 2, 4, 5],\n            [2, 3, 5, 6],\n            [4, 5, 7, 8],\n            [5, 6, 8, 9],\n            [9, 8, 6, 5],\n            [8, 7, 5, 4],\n            [6, 5, 3, 2],\n            [5, 4, 2, 1]\n        ])\n        output = im2col(image, filter_height, filter_width, stride, padding)\n        np.testing.assert_array_equal(output, expected_output)\n",
    "prompt": "please write a python function the function signature as below import numpy as np\n\ndef im2col(image, filter_height, filter_width, stride=1, padding=0):\n    \"\"\"\n    Apply the im2col operation to an input image.\n\n    Parameters:\n    - image (numpy array): The input image of shape (C, H, W) where:\n        C: Number of channels\n        H: Height of the image\n        W: Width of the image\n    - filter_height (int): Height of the filter\n    - filter_width (int): Width of the filter\n    - stride (int): Stride of the filter\n    - padding (int): Number of pixels to pad the input image\n\n    Returns:\n    - col (numpy array): A 2D array where each column is a flattened filter region\n    \"\"\""
  },
  {
    "task_id": 214,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads data from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReadMappingFile(unittest.TestCase):\n    def test_valid_mappings(self):\n        # Setup a mock file with valid content\n        file_content = \"'^abc$','xyz'\\n'^def$','uvw'\"\n        m_open = mock_open(read_data=file_content)\n        with patch('builtins.open', m_open):\n            result = read_mapping_file('fake_path.txt')\n            # Verify that the function reads the file and processes the content correctly\n            self.assertEqual(len(result), 2)\n            self.assertEqual(result[0][0].pattern, '^abc$')\n            self.assertEqual(result[0][1], 'xyz')\n            self.assertEqual(result[1][0].pattern, '^def$')\n            self.assertEqual(result[1][1], 'uvw')\n\n    def test_invalid_format(self):\n        # Test handling of a file with incorrect format (missing comma)\n        file_content = \"'pattern' 'replacement'\"\n        m_open = mock_open(read_data=file_content)\n        with patch('builtins.open', m_open):\n            with self.assertRaises(ValueError):\n                read_mapping_file('fake_path.txt')\n\n    def test_empty_file(self):\n        # Test handling of an empty file\n        m_open = mock_open(read_data=\"\")\n        with patch('builtins.open', m_open):\n            result = read_mapping_file('fake_path.txt')\n            self.assertEqual(result, [])\n\n    def test_file_not_found(self):\n        # Test file not found error\n        with patch('builtins.open', side_effect=FileNotFoundError):\n            with self.assertRaises(FileNotFoundError):\n                read_mapping_file('nonexistent_path.txt')\n\n    def test_comma_in_replacement(self):\n        # Test handling of a comma within the replacement string\n        file_content = \"'^abc$','xy,z'\"\n        m_open = mock_open(read_data=file_content)\n        with patch('builtins.open', m_open):\n            result = read_mapping_file('fake_path.txt')\n            self.assertEqual(len(result), 1)\n            self.assertEqual(result[0][0].pattern, '^abc$')\n            self.assertEqual(result[0][1], 'xy,z')\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef read_mapping_file(mapping_file_path: str) -> List:\n    \"\"\"\n    Reads data from the given mapping file and returns a list where each element is a tuple containing the compiled regular expression and replacement strings\n    Args:\n        mapping_file_path (str): Path to the file containing regex mappings.\n\n    Returns:\n        list of tuples: Each tuple contains a compiled regex object and a corresponding replacement string.\n    \"\"\"\n"
  },
  {
    "task_id": 215,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReplaceWordsInFile(unittest.TestCase):\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_single_word(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"hi world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_replace_multiple_words(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\", \"world\": \"earth\"}\n        expected_output = \"hi earth\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"hello world\")\n    def test_no_replacement(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"goodbye\": \"bye\"}\n        expected_output = \"hello world\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"\")\n    def test_empty_file(self, mock_file):\n        file_path = \"dummy_path.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n\n    def test_file_not_found(self):\n        file_path = \"nonexistent.txt\"\n        replacement_dict = {\"hello\": \"hi\"}\n        expected_output = \"Error: The file was not found.\"\n\n        result = replace_words_in_file(file_path, replacement_dict)\n        self.assertEqual(result, expected_output)\n",
    "prompt": "please write a python function the function signature as below def replace_words_in_file(file_path: str, replacement_dict: dict) -> str:\n    \"\"\"\n    Read a text file, replace words according to a dictionary map, and return the modified text.\n\n    Parameters:\n    - file_path (str): The path to the text file.\n    - replacement_dict (dict): A dictionary where the keys are words to be replaced, and the values are the replacement words.\n\n    Returns:\n    - str: The text with the words replaced.\n    \"\"\"\n"
  },
  {
    "task_id": 216,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\"",
    "test_code": "import unittest\nfrom unittest.mock import patch, MagicMock\n\n\nclass TestGetLocalIp(unittest.TestCase):\n    def setUp(self):\n        # Sample IP command output for a wlan0 interface\n        self.sample_output = \"3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\\n\" \\\n                             \"    inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic wlan0\\n\" \\\n                             \"       valid_lft 86394sec preferred_lft 86394sec\\n\"\n\n    @patch('subprocess.run')\n    def test_successful_ip_retrieval(self, mock_run):\n        # Configure the mock to return a successful output\n        mock_run.return_value = MagicMock(stdout=self.sample_output, check=True)\n        # Test function with wlan0 interface\n        ip = get_local_ip('wlan0')\n        self.assertEqual(ip, '192.168.1.100')\n\n    @patch('subprocess.run')\n    def test_no_ip_found(self, mock_run):\n        # Configure the mock to simulate no IP found on the interface\n        mock_run.return_value = MagicMock(stdout=\"3: wlan0: <NO-CARRIER,BROADCAST,MULTICAST,UP>\", check=True)\n        with self.assertRaises(RuntimeError) as context:\n            get_local_ip('wlan0')\n        self.assertIn(\"No local IP found\", str(context.exception))\n\n    @patch('subprocess.run')\n    def test_command_failure(self, mock_run):\n        # Simulate a subprocess failure\n        mock_run.side_effect = subprocess.CalledProcessError(1, ['ip', 'addr', 'show', 'wlan0'])\n        with self.assertRaises(RuntimeError) as context:\n            get_local_ip('wlan0')\n        self.assertIn(\"Failed to retrieve IP address\", str(context.exception))\n\n    @patch('subprocess.run')\n    def test_different_interface(self, mock_run):\n        # Configure the mock for a different interface\n        mock_run.return_value = MagicMock(\n            stdout=\"3: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500\\n    inet 10.0.0.1/24\", check=True)\n        ip = get_local_ip('eth0')\n        self.assertEqual(ip, '10.0.0.1')\n",
    "prompt": "please write a python function the function signature as below def get_local_ip(interface: str = 'wlan0') -> str:\n    \"\"\"\n    gets the IPv4 address of the local computer on a specific network interface, such as wlan0, which is usually a wireless network interface\n    Args:\n        interface (str): The network interface to query. Default is 'wlan0'.\n\n    Returns:\n        str: The local IP address, or a message indicating no IP was found.\n    \"\"\""
  },
  {
    "task_id": 217,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import socket\n\ndef get_local_ip():\n    \"\"\"\n    Get the local IP address of the current machine by creating a temporary socket.\n    It tries to connect to a remote address, but no actual connection is made.\n\n    Returns:\n    - str: The local IP address or an error message if unable to determine.\n    \"\"\"",
    "test_code": "import unittest\nfrom unittest.mock import patch, Mock\nimport socket\n\nclass TestGetLocalIP(unittest.TestCase):\n\n    @patch('socket.socket')\n    def test_normal_case(self, mock_socket):\n        # Simulate a normal case where the socket successfully retrieves an IP address\n        mock_socket_instance = mock_socket.return_value.__enter__.return_value\n        mock_socket_instance.getsockname.return_value = ('192.168.1.1', 0)\n\n        result = get_local_ip()\n        self.assertEqual(result, '192.168.1.1')\n\n    @patch('socket.socket')\n    def test_socket_error(self, mock_socket):\n        # Simulate a socket error\n        mock_socket.side_effect = socket.error(\"Socket error\")\n\n        result = get_local_ip()\n        self.assertEqual(result, \"Unable to determine local IP\")\n\n    @patch('socket.socket')\n    def test_general_exception(self, mock_socket):\n        # Simulate a general exception\n        mock_socket.side_effect = Exception(\"General error\")\n\n        result = get_local_ip()\n        self.assertEqual(result, \"Unable to determine local IP\")\n\n    @patch('socket.socket')\n    def test_no_ip_address(self, mock_socket):\n        # Simulate a case where no IP address is returned\n        mock_socket_instance = mock_socket.return_value.__enter__.return_value\n        mock_socket_instance.getsockname.return_value = ('', 0)\n\n        result = get_local_ip()\n        self.assertEqual(result, '')\n\n    @patch('socket.socket')\n    def test_invalid_address(self, mock_socket):\n        # Test with an invalid address, simulating an exception in connect()\n        mock_socket_instance = mock_socket.return_value.__enter__.return_value\n        mock_socket_instance.connect.side_effect = socket.error(\"Invalid address\")\n\n        result = get_local_ip()\n        self.assertEqual(result, \"Unable to determine local IP\")\n",
    "prompt": "please write a python function the function signature as below import socket\n\ndef get_local_ip():\n    \"\"\"\n    Get the local IP address of the current machine by creating a temporary socket.\n    It tries to connect to a remote address, but no actual connection is made.\n\n    Returns:\n    - str: The local IP address or an error message if unable to determine.\n    \"\"\""
  },
  {
    "task_id": 219,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n\n    Parameters:\n    - records (list of tuples): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n    - list of tuples: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestCheckDividendVariances(unittest.TestCase):\n\n    def test_no_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.22),\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_one_inconsistency(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('GOOG', '2023-09-02', 0.00)\n        ]\n        expected_output = [('AAPL', '2023-09-01')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_multiple_inconsistencies(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22),\n            ('AAPL', '2023-09-01', 0.23),  # Different amount\n            ('MSFT', '2023-09-01', 0.56),\n            ('MSFT', '2023-09-01', 0.60),  # Different amount\n            ('GOOG', '2023-09-02', 0.00),\n            ('TSLA', '2023-09-03', 0.10),\n            ('TSLA', '2023-09-03', 0.10),  # Same amount, no inconsistency\n            ('TSLA', '2023-09-03', 0.15)  # Different amount\n        ]\n        expected_output = [('AAPL', '2023-09-01'), ('MSFT', '2023-09-01'), ('TSLA', '2023-09-03')]\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_single_record(self):\n        records = [\n            ('AAPL', '2023-09-01', 0.22)\n        ]\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n\n    def test_empty_list(self):\n        records = []\n        expected_output = []\n        self.assertEqual(check_dividend_variances(records), expected_output)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef check_dividend_variances(records: List) -> List:\n    \"\"\"\n    Check for ticker symbols with the same ex-dividend date but different dividend amounts.\n\n    Parameters:\n    - records (list of tuples): Each tuple contains (ticker, ex_dividend_date, dividend_amount).\n\n    Returns:\n    - list of tuples: Each tuple contains (ticker, ex_dividend_date) that have different dividend amounts.\n    \"\"\"\n"
  },
  {
    "task_id": 220,
    "code_type": "class",
    "code_language": "python",
    "code_signature": "from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n",
    "test_code": "import unittest\nfrom collections import deque\n\nclass TestUniqueDeque(unittest.TestCase):\n\n    def test_add_unique_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertTrue(ud.add(2))\n        self.assertTrue(ud.add(3))\n        self.assertEqual(len(ud), 3)\n        self.assertEqual(list(ud), [1, 2, 3])\n\n    def test_add_duplicate_elements(self):\n        ud = UniqueDeque()\n        self.assertTrue(ud.add(1))\n        self.assertFalse(ud.add(1))  # Duplicate add should return False\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [1])\n\n    def test_delete_elements(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        ud.add(3)\n        self.assertTrue(ud.delete(2))\n        self.assertFalse(ud.delete(2))  # Deleting non-existing element should return False\n        self.assertEqual(len(ud), 2)\n        self.assertEqual(list(ud), [1, 3])\n\n    def test_contains(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        self.assertTrue(ud.contains(1))\n        self.assertFalse(ud.contains(2))\n        ud.delete(1)\n        self.assertFalse(ud.contains(1))\n\n    def test_iter_and_len(self):\n        ud = UniqueDeque()\n        ud.add(1)\n        ud.add(2)\n        self.assertEqual(len(ud), 2)\n        items = list(iter(ud))\n        self.assertEqual(items, [1, 2])\n        ud.delete(1)\n        self.assertEqual(len(ud), 1)\n        self.assertEqual(list(ud), [2])",
    "prompt": "please write a python class this class signature as below from collections import deque\n\n\nclass UniqueDeque:\n\n    def add(self, item):\n        \"\"\"\n        Add an item to the deque if it is not already present.\n\n        Parameters:\n        - item: The item to add.\n\n        Returns:\n        - bool: True if the item was added, False if it was already present.\n        \"\"\"\n        pass\n\n    def delete(self, item):\n        \"\"\"\n        Remove an item from the deque if it exists.\n\n        Parameters:\n        - item: The item to remove.\n\n        Returns:\n        - bool: True if the item was removed, False if it was not found.\n        \"\"\"\n        pass\n\n    def contains(self, item):\n        \"\"\"\n        Check if an item is present in the deque.\n\n        Parameters:\n        - item: The item to check.\n\n        Returns:\n        - bool: True if the item is present, False otherwise.\n        \"\"\"\n        pass\n"
  },
  {
    "task_id": 221,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestExtractParseDicts(unittest.TestCase):\n    def test_extract_single_valid_dictionary(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}])\n\n    def test_extract_multiple_dictionaries(self):\n        mock_content = '{\"name\": \"John\", \"age\": 30}\\n{\"city\": \"New York\", \"country\": \"USA\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{\"name\": \"John\", \"age\": 30}, {\"city\": \"New York\", \"country\": \"USA\"}])\n\n    def test_invalid_dictionary_format(self):\n        mock_content = '{\"name\": \"John\", \"age\": \"thirty\"}'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [{'name': 'John', 'age': 'thirty'}])\n\n    def test_empty_file(self):\n        with patch('builtins.open', mock_open(read_data='')):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [])\n\n    def test_file_with_no_dictionaries(self):\n        mock_content = 'This is just some text without any dictionaries.'\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            result = extract_parse_dicts('dummy_path')\n            self.assertEqual(result, [])\n",
    "prompt": "please write a python function the function signature as below from typing import Dict, List\n\n\ndef extract_parse_dicts(file_path: str) -> List[Dict]:\n    \"\"\"\n    extract and parse strings containing Python dictionary syntax from a given file\n    Args:\n        file_path (str): The path to the file from which to extract dictionary strings.\n\n    Returns:\n        list: A list of dictionaries extracted and parsed from the file.\n    \"\"\"\n"
  },
  {
    "task_id": 224,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n",
    "test_code": "import os\nimport shutil\nimport tempfile\nimport unittest\n\n\nclass TestEmptyDirectory(unittest.TestCase):\n    def setUp(self):\n        # Set up a temporary directory with some files and directories\n        self.test_dir = tempfile.mkdtemp()\n        # Create some files and directories\n        os.mkdir(os.path.join(self.test_dir, 'subdir'))\n        with open(os.path.join(self.test_dir, 'file1.txt'), 'w') as f:\n            f.write(\"Hello\")\n        with open(os.path.join(self.test_dir, 'subdir', 'file2.txt'), 'w') as f:\n            f.write(\"World\")\n\n    def tearDown(self):\n        # Remove the temporary directory after each test.js\n        shutil.rmtree(self.test_dir)\n\n    def test_empty_directory_success(self):\n        \"\"\" Test that the directory is emptied successfully \"\"\"\n        empty_directory(self.test_dir)\n        self.assertEqual(os.listdir(self.test_dir), [])  # Directory should be empty\n\n    def test_non_existing_directory(self):\n        \"\"\" Test that the correct error is raised when the directory does not exist \"\"\"\n        with self.assertRaises(ValueError) as context:\n            empty_directory('/non/existing/directory')\n        self.assertTrue(\"The specified directory does not exist\" in str(context.exception))\n\n    def test_not_a_directory(self):\n        \"\"\" Test that the function raises an error if the path is not a directory \"\"\"\n        # Create a temporary file\n        temp_file = tempfile.mktemp()\n        with open(temp_file, 'w') as f:\n            f.write(\"Hello\")\n        try:\n            with self.assertRaises(ValueError) as context:\n                empty_directory(temp_file)\n            self.assertTrue(\"The specified path is not a directory\" in str(context.exception))\n        finally:\n            os.remove(temp_file)\n\n    def test_empty_directory_with_subdirectories(self):\n        \"\"\" Test emptying a directory that includes subdirectories \"\"\"\n        empty_directory(self.test_dir)\n        self.assertFalse(os.listdir(self.test_dir))  # Directory and subdirectory should be empty\n\n    def test_empty_already_empty_directory(self):\n        \"\"\" Test emptying a directory that is already empty \"\"\"\n        empty_directory(self.test_dir)  # First emptying\n        empty_directory(self.test_dir)  # Empty again\n        self.assertEqual(os.listdir(self.test_dir), [])  # Still should be empty\n",
    "prompt": "please write a python function the function signature as below def empty_directory(directory_path:str):\n    \"\"\"\n    empty all files and subdirectories in the specified directory\n    Args:\n        directory_path (str): Path to the directory whose contents are to be emptied.\n\n    Returns:\n        None or ValueError: If the specified path does not exist or is not a directory.\n    \"\"\"\n"
  },
  {
    "task_id": 227,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Parameters:\n    - image_path (str): Path to the image file.\n\n    Returns:\n    - int: The number of unique colors in the image.\n    \"\"\"",
    "test_code": "import unittest\n\n\nclass TestCountUniqueColor(unittest.TestCase):\n\n    def test_case1(self):\n        picture_path = \"./picture1_2_color.png\"\n        expected_color_num = 2\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case2(self):\n        picture_path = \"./picture2_1_color.png\"\n        expected_color_num = 1\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case3(self):\n        picture_path = \"./picture3_2_color.png\"\n        expected_color_num = 31\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n\n    def test_case4(self):\n        picture_path = \"./picture4_5_color.png\"\n        expected_color_num = 524\n        output = count_unique_colors(picture_path)\n        self.assertEqual(output, expected_color_num)\n",
    "prompt": "please write a python function the function signature as below def count_unique_colors(image_path: str) -> int:\n    \"\"\"\n    Count the number of unique colors in an image.\n\n    Parameters:\n    - image_path (str): Path to the image file.\n\n    Returns:\n    - int: The number of unique colors in the image.\n    \"\"\""
  },
  {
    "task_id": 229,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Tuple\n\n\ndef get_file_size(size_in_bytes, unit=None) -> Tuple[int, float]:\n    \"\"\"\n    Convert file size from bytes to a more readable format (e.g. KB, MB, GB)\n    Args:\n        size_in_bytes (int): File size in bytes.\n        unit (str, optional): The unit to convert the size to ('B', 'KB', 'MB', 'GB').\n\n    Returns:\n        tuple: A tuple containing the formatted size string and the size converted to the specified or chosen unit as float.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestGetFileSize(unittest.TestCase):\n\n    def test_auto_unit_selection(self):\n        \"\"\" Test automatic unit selection based on file size \"\"\"\n        # Test that units are correctly auto-selected based on size\n        self.assertEqual(get_file_size(500), ('500 B', 500))  # Bytes\n        self.assertEqual(get_file_size(2000), ('1.95 KB', 1.953125))  # Kilobytes\n        self.assertEqual(get_file_size(3 * 1024 ** 2), ('3.00 MB', 3.0))  # Megabytes\n        self.assertEqual(get_file_size(5 * 1024 ** 3), ('5.00 GB', 5.0))  # Gigabytes\n\n    def test_specific_unit(self):\n        \"\"\" Test output when specific units are requested \"\"\"\n        # Test for each unit conversion\n        self.assertEqual(get_file_size(1024, 'KB'), ('1.00 KB', 1.0))\n\n    def test_invalid_unit(self):\n        \"\"\" Test behavior when an invalid unit is provided \"\"\"\n        with self.assertRaises(ValueError):\n            get_file_size(1024, 'xyz')  # Should raise ValueError for invalid unit\n\n    def test_large_file_size(self):\n        \"\"\" Test with very large file size \"\"\"\n        # Testing a large number, should format to gigabytes\n        self.assertEqual(get_file_size(10 * 1024 ** 4), ('10240.00 GB', 10240.0))\n\n    def test_zero_bytes(self):\n        \"\"\" Test with zero bytes \"\"\"\n        # Edge case for zero bytes\n        self.assertEqual(get_file_size(0), ('0 B', 0))\n",
    "prompt": "please write a python function the function signature as below from typing import Tuple\n\n\ndef get_file_size(size_in_bytes, unit=None) -> Tuple[int, float]:\n    \"\"\"\n    Convert file size from bytes to a more readable format (e.g. KB, MB, GB)\n    Args:\n        size_in_bytes (int): File size in bytes.\n        unit (str, optional): The unit to convert the size to ('B', 'KB', 'MB', 'GB').\n\n    Returns:\n        tuple: A tuple containing the formatted size string and the size converted to the specified or chosen unit as float.\n    \"\"\"\n"
  },
  {
    "task_id": 230,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import emoji\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestMoveEmojisToEnd(unittest.TestCase):\n\n    def test_single_emoji_at_start(self):\n        \"\"\" Test string with a single emoji at the start \"\"\"\n        input_text = \"\ud83d\ude0a Hello, world!\"\n        expected_output = \" Hello, world!\ud83d\ude0a\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_multiple_emojis_mixed(self):\n        \"\"\" Test string with multiple emojis mixed in text \"\"\"\n        input_text = \"Ready \ud83d\ude0a to start \ud83d\ude80 your day? \ud83c\udf1e\"\n        expected_output = \"Ready  to start  your day? \ud83d\ude0a\ud83d\ude80\ud83c\udf1e\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_all_emojis(self):\n        \"\"\" Test string that contains only emojis \"\"\"\n        input_text = \"\ud83d\ude0a\ud83d\ude80\ud83c\udf1e\ud83c\udf89\"\n        expected_output = \"\ud83d\ude0a\ud83d\ude80\ud83c\udf1e\ud83c\udf89\"  # Output should remain the same as input\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_no_emojis(self):\n        \"\"\" Test string with no emojis \"\"\"\n        input_text = \"Hello, world!\"\n        expected_output = \"Hello, world!\"  # Output should remain the same as input\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n\n    def test_emojis_and_whitespace(self):\n        \"\"\" Test string with emojis and whitespace characters \"\"\"\n        input_text = \"\ud83d\ude80 Are we \ud83d\ude0a ready? \ud83c\udf1e  \"\n        expected_output = \" Are we  ready?   \ud83d\ude80\ud83d\ude0a\ud83c\udf1e\"\n        self.assertEqual(move_emojis_to_end(input_text), expected_output)\n",
    "prompt": "please write a python function the function signature as below import emoji\n\n\ndef move_emojis_to_end(text: str):\n    \"\"\"\n    Move the emoj expression in the string to the end of the text\n\n    Args:\n        text (str): The input string containing text and possibly emojis.\n\n    Returns:\n        str: The modified string with all emojis moved to the end.\n    \"\"\"\n"
  },
  {
    "task_id": 231,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def read_log(log_file_path: str) -> tuple:\n    \"\"\"\n\n    Args:\n        log_file_path (str): The path to the log file to read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n           - The first list contains the 'train_loss' values.\n           - The second list contains the 'test_acc1' values.\n    \"\"\"\n",
    "test_code": "import json\nimport unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestReadLog(unittest.TestCase):\n\n    def test_read_correct_data(self):\n        \"\"\" Test reading correctly formatted JSON lines \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 89.0, \"train_loss\": 0.70}'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"dummy_path.json\")\n            self.assertEqual(train_loss, [0.75, 0.70])\n            self.assertEqual(test_acc1, [88.5, 89.0])\n\n    def test_file_not_found(self):\n        \"\"\" Test behavior when the file does not exist \"\"\"\n        with patch('builtins.open', side_effect=FileNotFoundError):\n            train_loss, test_acc1 = read_log(\"nonexistent_path.json\")\n            self.assertEqual(train_loss, [])\n            self.assertEqual(test_acc1, [])\n\n    def test_invalid_json(self):\n        \"\"\" Test behavior when file contains invalid JSON \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\nInvalid JSON Line'\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            with patch('json.loads', side_effect=json.JSONDecodeError(\"Expecting value\", \"doc\", 0)):\n                train_loss, test_acc1 = read_log(\"dummy_path.json\")\n                self.assertEqual(train_loss, [])\n                self.assertEqual(test_acc1, [])\n\n    def test_empty_file(self):\n        \"\"\" Test reading an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data=\"\")):\n            train_loss, test_acc1 = read_log(\"empty_file.json\")\n            self.assertEqual(train_loss, [])\n            self.assertEqual(test_acc1, [])\n\n    def test_partial_data_entries(self):\n        \"\"\" Test file with missing fields in some entries \"\"\"\n        mock_file_content = '{\"test_acc1\": 88.5, \"train_loss\": 0.75}\\n' \\\n                            '{\"test_acc1\": 90.0}'  # Missing train_loss\n        with patch('builtins.open', mock_open(read_data=mock_file_content)):\n            train_loss, test_acc1 = read_log(\"partial_data_file.json\")\n            self.assertEqual(train_loss, [0.75])  # Only one complete entry\n            self.assertEqual(test_acc1, [88.5, 90.0])\n",
    "prompt": "please write a python function the function signature as below def read_log(log_file_path: str) -> tuple:\n    \"\"\"\n\n    Args:\n        log_file_path (str): The path to the log file to read.\n\n    Returns:\n        tuple: A tuple containing two lists:\n           - The first list contains the 'train_loss' values.\n           - The second list contains the 'test_acc1' values.\n    \"\"\"\n"
  },
  {
    "task_id": 232,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n",
    "test_code": "import unittest\n\n<<<<<<< HEAD\nclass TestConvertHmsToMilliseconds(unittest.TestCase):\n\n    def test_basic_conversion(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"1h20min30s\"), 4830000, \"Should convert 1h20min30s to 4830000 milliseconds\")\n\n    def test_no_hours_or_minutes(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"30s\"), 30000, \"Should convert 30s to 30000 milliseconds\")\n\n    def test_invalid_format(self):\n        self.assertIsNone(convert_hms_to_milliseconds(\"1hour20minutes\"), \"Should return None for invalid time format\")\n\n    def test_edge_case_max_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"23h59min59s\"), 86399000, \"Should convert 23h59min59s to 86399000 milliseconds\")\n\n    def test_exceeding_one_day(self):\n        self.assertEqual(convert_hms_to_milliseconds(\"24h1min\"), 86460000,\n                         \"Should correctly convert 24h1min to 86460000 milliseconds\")\n\n\n=======\n\nclass TestConvertTimeHmsStringToMs(unittest.TestCase):\n    def test_correct_conversion(self):\n        # Test conversion for a correct input\n        self.assertEqual(convert_time_hms_string_to_ms(\"2h15m30s\"), (2 * 3600 + 15 * 60 + 30) * 1000)\n\n    def test_missing_components(self):\n        # Test conversion when some components are missing\n        self.assertEqual(convert_time_hms_string_to_ms(\"45m\"), 45 * 60 * 1000)\n        self.assertEqual(convert_time_hms_string_to_ms(\"30s\"), 30 * 1000)\n        self.assertEqual(convert_time_hms_string_to_ms(\"3h\"), 3 * 3600 * 1000)\n\n    def test_no_components(self):\n        # Test conversion with no valid time components\n        with self.assertRaises(ValueError):\n            convert_time_hms_string_to_ms(\"\")\n\n    def test_exceed_one_day(self):\n        # Test input that exceeds one day\n        with self.assertRaises(ValueError):\n            convert_time_hms_string_to_ms(\"25h\")\n\n    def test_incorrect_format(self):\n        # Test input with incorrect format\n        with self.assertRaises(ValueError):\n            convert_time_hms_string_to_ms(\"2h15m30\")\n>>>>>>> main\n",
    "prompt": "please write a python function the function signature as below from typing import Optional\n\n\ndef convert_hms_to_milliseconds(time_str: str) -> Optional[int]:\n    \"\"\"\n    Convert a time duration string in the format 'XhYminZs' to milliseconds.\n\n    This function takes a string representing a time duration, where hours, minutes, and seconds\n    are optionally provided, and converts this duration into the equivalent number of milliseconds.\n\n    Args:\n        time_str (str): A string representing the time duration, e.g., '1h20min30s'.\n\n    Returns:\n        Optional[int]: The equivalent duration in milliseconds, or None if the input is invalid.\n    \"\"\"\n"
  },
  {
    "task_id": 233,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestRemoveComments(unittest.TestCase):\n\n    def test_single_line_comment(self):\n        \"\"\" Test string with a comment on a single line \"\"\"\n        input_string = \"Hello, world! # This is a comment\"\n        expected_output = \"Hello, world! \"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_multi_line_comments(self):\n        \"\"\" Test string with multiple lines, each containing comments \"\"\"\n        input_string = \"Hello, world!\\n# This is a comment\\nPython is fun! # another comment\"\n        expected_output = \"Hello, world!\\n\\nPython is fun! \"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_no_comments(self):\n        \"\"\" Test string with no comments \"\"\"\n        input_string = \"Hello, world!\\nPython is fun!\"\n        expected_output = \"Hello, world!\\nPython is fun!\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_empty_string(self):\n        \"\"\" Test an empty string \"\"\"\n        input_string = \"\"\n        expected_output = \"\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n\n    def test_comments_only(self):\n        \"\"\" Test string where all lines are comments \"\"\"\n        input_string = \"# comment only line\\n#another comment line\"\n        expected_output = \"\\n\"\n        self.assertEqual(remove_comments(input_string), expected_output)\n",
    "prompt": "please write a python function the function signature as below def remove_comments(string: str) -> str:\n    \"\"\"\n    Removes comments from the provided string. Comments start with a '#' and end at the newline.\n    Args:\n        string (str): The input string containing potential comments.\n\n    Returns:\n        str: The string with all comments removed.\n    \"\"\"\n"
  },
  {
    "task_id": 235,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestCalculateBearing(unittest.TestCase):\n    def test_north_bearing(self):\n        # From equator directly north\n        self.assertAlmostEqual(calculate_bearing(0, 0, 10, 0), 0)\n\n    def test_east_bearing(self):\n        # From prime meridian directly east\n        self.assertAlmostEqual(calculate_bearing(0, 0, 0, 10), 90)\n\n    def test_south_bearing(self):\n        # From a point directly south\n        self.assertAlmostEqual(calculate_bearing(10, 0, 0, 0), 180)\n\n    def test_west_bearing(self):\n        # From a point directly west\n        self.assertAlmostEqual(calculate_bearing(0, 10, 0, 0), 270)\n\n    def test_across_prime_meridian(self):\n        # From a point west of the prime meridian to a point east\n        self.assertAlmostEqual(calculate_bearing(0, -1, 0, 1), 90)",
    "prompt": "please write a python function the function signature as below def calculate_bearing(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    calculate the azimuth between two points on the earth. This function accepts the latitude and longitude of the two points as a parameter and returns the azimuth from the first point to the second point in degrees\n    Args:\n        lat1 (float): Latitude of the starting point in decimal degrees.\n        lon1 (float): Longitude of the starting point in decimal degrees.\n        lat2 (float): Latitude of the ending point in decimal degrees.\n        lon2 (float): Longitude of the ending point in decimal degrees.\n\n    Returns:\n        float: Bearing in degrees from the starting point to the ending point, ranging from 0 to 360.\n    \"\"\"\n"
  },
  {
    "task_id": 240,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from datetime import timedelta\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg.\"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n    Args:\n        time_string ():A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom datetime import timedelta\n\n\nclass TestGenTimeoutTimedelta(unittest.TestCase):\n\n    def test_complete_time_string(self):\n        \"\"\" Test a string containing all time units \"\"\"\n        result = gen_timeout_timedelta(\"1d 2h 3m 4s 500ms\")\n        self.assertEqual(result.days, 1)\n        self.assertEqual(result.seconds, (2 * 3600) + (3 * 60) + 4)\n        self.assertEqual(result.microseconds, 500000)\n\n    def test_partial_time_string(self):\n        \"\"\" Test a string containing only some time units \"\"\"\n        result = gen_timeout_timedelta(\"2h 30m\")\n        self.assertEqual(result.days, 0)\n        self.assertEqual(result.seconds, (2 * 3600) + (30 * 60))\n        self.assertEqual(result.microseconds, 0)\n\n    def test_empty_time_string(self):\n        \"\"\" Test an empty string which should raise ValueError \"\"\"\n        with self.assertRaises(ValueError):\n            gen_timeout_timedelta(\"\")\n\n    def test_incorrect_format(self):\n        \"\"\" Test a string with an incorrect format \"\"\"\n        with self.assertRaises(ValueError):\n            gen_timeout_timedelta(\"5 days 4 hours\")\n\n    def test_no_time_units(self):\n        \"\"\" Test a string that specifies numbers but no units \"\"\"\n        with self.assertRaises(ValueError):\n            gen_timeout_timedelta(\"1 2 3 4 5\")",
    "prompt": "please write a python function the function signature as below from datetime import timedelta\n\n\ndef gen_timeout_timedelta(time_string: str) -> timedelta:\n    \"\"\"\n    Converts a time duration string into a timedelta object.\n    The input string can include days (d), hours (h), minutes (m), seconds (s), and milliseconds (ms).\n    eg.\"1d 2h 3m 4s 500ms\"\n    Each unit should be specified by an integer followed by its corresponding unit letter.\n    Args:\n        time_string ():A string representing the time duration.\n\n    Returns:\n        timedelta: A timedelta object representing the input duration.\n    \"\"\"\n"
  },
  {
    "task_id": 241,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import mock_open, patch\n\n\nclass TestGetMinDistance(unittest.TestCase):\n\n    def test_basic_functionality(self):\n        \"\"\" Test basic functionality with expected input \"\"\"\n        mock_content = \"hello world\\napple banana apple\\norange apple banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (1, 1))\n\n    def test_words_on_same_line_multiple_times(self):\n        \"\"\" Test where words appear multiple times on the same line \"\"\"\n        mock_content = \"apple apple banana apple banana banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (0, 1))\n\n    def test_words_not_present(self):\n        \"\"\" Test case where one or both words are not present \"\"\"\n        mock_content = \"apple orange pear\\norange pear apple\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_empty_file(self):\n        \"\"\" Test an empty file \"\"\"\n        with patch('builtins.open', mock_open(read_data='')):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (None, float('inf')))\n\n    def test_multiple_lines_with_varying_distances(self):\n        \"\"\" Test multiple lines with varying distances between words \"\"\"\n        mock_content = \"apple banana\\napple orange orange banana\\napple orange orange orange banana\"\n        with patch('builtins.open', mock_open(read_data=mock_content)):\n            line_number, distance = get_min_seq_num_and_distance('dummy_file.txt', 'apple', 'banana')\n            self.assertEqual((line_number, distance), (0, 1))\n",
    "prompt": "please write a python function the function signature as below from typing import Tuple\n\n\ndef get_min_seq_num_and_distance(file_path: str, word1: str, word2: str) -> Tuple[int, int]:\n    \"\"\"\n    Finds the minimum distance between two words in a text file, considering each line as a separate sequence.\n    Args:\n        file_path (str): The path to the file to read.\n        word1 (str): The first word to search for.\n        word2 (str): The second word to search for.\n\n    Returns:\n        tuple: A tuple containing the line number with the minimum distance and the minimum distance itself.\n          Returns (None, float('inf')) if one or both words are not found in any line.\n    \"\"\"\n"
  },
  {
    "task_id": 244,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Callable\n\n\ndef method_arg_type_check(method_obj: Callable, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected data types, based on the method's signature.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n    Returns:\n\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass MyClass:\n    def my_method(self, arg1: int, arg2: str, optional_arg: float = 3.14):\n        pass\n\nclass TestMethodArgTypeCheck(unittest.TestCase):\n    def test_correct_types(self):\n        \"\"\" Test with correct argument types. \"\"\"\n        try:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, \"hello\", optional_arg=3.14)\n        except ValueError:\n            self.fail(\"method_arg_type_check() raised ValueError unexpectedly!\")\n\n    def test_incorrect_type_for_arg1(self):\n        \"\"\" Test with incorrect type for arg1. \"\"\"\n        with self.assertRaises(ValueError) as context:\n            method_arg_type_check(MyClass.my_method, MyClass(), \"10\", \"hello\", optional_arg=3.14)\n        self.assertIn(\"arg1 should be of type int\", str(context.exception))\n\n    def test_incorrect_type_for_arg2(self):\n        \"\"\" Test with incorrect type for arg2. \"\"\"\n        with self.assertRaises(ValueError) as context:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, 10, optional_arg=3.14)\n        self.assertIn(\"arg2 should be of type str\", str(context.exception))\n\n    def test_incorrect_type_for_optional_arg(self):\n        \"\"\" Test with incorrect type for optional_arg. \"\"\"\n        with self.assertRaises(ValueError) as context:\n            method_arg_type_check(MyClass.my_method, MyClass(), 10, \"hello\", optional_arg=\"pi\")\n        self.assertIn(\"optional_arg should be of type float\", str(context.exception))\n\n    def test_missing_argument(self):\n        \"\"\" Test with missing required argument. \"\"\"\n        with self.assertRaises(TypeError):\n            method_arg_type_check(MyClass.my_method, MyClass(), 10)  # Missing arg2",
    "prompt": "please write a python function the function signature as below from typing import Callable\n\n\ndef method_arg_type_check(method_obj: Callable, *args, **kwargs):\n    \"\"\"\n    Checks that the arguments passed to a given method object (e.g., method of a class) comply with their\n    expected data types, based on the method's signature.py.py.py.js.js.js. If there's a discrepancy, it raises a ValueError.\n    Args:\n        method_obj (Callable): The method for which arguments are checked.\n        *args (): Positional arguments passed to the method.\n        **kwargs (): Keyword arguments passed to the method.\n\n    Returns:\n\n    \"\"\"\n"
  },
  {
    "task_id": 248,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive data in the given dictionary based on the given key_to_remove list\n    Args:\n        data (Dict): original data dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        removed dict\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestSanitizeData(unittest.TestCase):\n    def test_empty_dict(self):\n        \"\"\" Test with an empty dictionary. \"\"\"\n        data = {}\n        expected = {}\n        self.assertEqual(sanitize_data(data), expected)\n\n    def test_remove_default_keys(self):\n        \"\"\" Test removing default keys from a nested structure. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"email\": \"johndoe@example.com\",\n            \"metadata\": {\"submitted_at\": \"2021-07-10\", \"status\": \"pending\"},\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        expected = {\n            \"name\": \"John Doe\",\n            \"comments\": [\"Good\", \"Needs review\"]\n        }\n        self.assertEqual(sanitize_data(data), expected)\n\n    def test_specified_key_to_remove(self):\n        \"\"\" Test removing a specified key from the dictionary. \"\"\"\n        data = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\",\n            \"email\": \"johndoe@example.com\"\n        }\n        expected = {\n            \"name\": \"John Doe\",\n            \"location\": \"Earth\"\n        }\n        self.assertEqual(sanitize_data(data, key_to_remove={\"email\"}), expected)\n\n    def test_list_of_dicts(self):\n        \"\"\" Test a list containing dictionaries. \"\"\"\n        data = [\n            {\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n            {\"name\": \"Bob\", \"email\": \"bob@example.com\"}\n        ]\n        expected = [\n            {\"name\": \"Alice\"},\n            {\"name\": \"Bob\"}\n        ]\n        self.assertEqual(sanitize_data(data), expected)\n\n    def test_non_dict_non_list(self):\n        \"\"\" Test with non-dict and non-list data types. \"\"\"\n        data = \"Hello, world!\"\n        expected = \"Hello, world!\"\n        self.assertEqual(sanitize_data(data), expected)",
    "prompt": "please write a python function the function signature as below from typing import Dict, List\n\n\ndef sanitize_data(data: Dict, key_to_remove: List = None) -> Dict:\n    \"\"\"\n    remove the corresponding sensitive data in the given dictionary based on the given key_to_remove list\n    Args:\n        data (Dict): original data dict\n        key_to_remove (List): key_to_remove list\n\n    Returns:\n        removed dict\n    \"\"\"\n"
  },
  {
    "task_id": 249,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestExtractTextFromPDF(unittest.TestCase):\n    def test_empty_file(self):\n        pdf_path = \"./testcase1_empty.pdf\"\n        expected = \" \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n    def test_normal_file(self):\n        pdf_path = \"./testcase2_normal.pdf\"\n        expected = \"Hello World  \\n\"\n        output = extract_text_from_pdf(pdf_path)\n        self.assertEqual(output, expected)\n\n\nimport PyPDF2\n\n\ndef extract_text_from_pdf(file_path):\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n    # Initialize a text container\n    extracted_text = \"\"\n\n    # Open the PDF file\n    with open(file_path, \"rb\") as file:\n        # Create a PDF reader object\n        pdf_reader = PyPDF2.PdfReader(file)\n\n        # Loop through each page in the PDF\n        for page in pdf_reader.pages:\n            # Extract text from each page and add it to the text container\n            extracted_text += page.extract_text() + \"\\n\"\n\n    return extracted_text\n",
    "prompt": "please write a python function the function signature as below def extract_text_from_pdf(file_path: str) -> str:\n    \"\"\"\n    Extracts text from a given PDF file.\n\n    Args:\n    file_path (str): The path to the PDF file from which to extract text.\n\n    Returns:\n    str: The extracted text from the PDF.\n    \"\"\"\n"
  },
  {
    "task_id": 250,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestInvertDictionary(unittest.TestCase):\n\n    def test_normal_dictionary(self):\n        \"\"\"Test inversion of a dictionary without duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 2, 'c': 3}\n        expected = {1: 'a', 2: 'b', 3: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_dictionary_with_duplicates(self):\n        \"\"\"Test inversion of a dictionary with duplicate values.\"\"\"\n        original_dict = {'a': 1, 'b': 1, 'c': 2}\n        expected = {1: ['a', 'b'], 2: 'c'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_empty_dictionary(self):\n        \"\"\"Test inversion of an empty dictionary.\"\"\"\n        original_dict = {}\n        expected = {}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_non_string_keys(self):\n        \"\"\"Test inversion of a dictionary with non-string keys.\"\"\"\n        original_dict = {1: 'apple', 2: 'banana', 3: 'apple'}\n        expected = {'apple': [1, 3], 'banana': 2}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n\n    def test_mixed_types(self):\n        \"\"\"Test inversion of a dictionary with mixed key and value types.\"\"\"\n        original_dict = {'a': 1, 2: 'two', 'three': 3}\n        expected = {1: 'a', 'two': 2, 3: 'three'}\n        result = invert_dictionary(original_dict)\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below from typing import Dict\n\n\ndef invert_dictionary(original_dict: Dict) -> Dict:\n    \"\"\"\n    Invert the keys and values in a dictionary. If multiple keys have the same value,\n    the new dictionary's values will be a list of these keys.\n    Args:\n        original_dict (dict): The dictionary to invert.\n\n    Returns:\n        A new dictionary with values and keys inverted.\n    \"\"\"\n"
  },
  {
    "task_id": 252,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding data into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n",
    "test_code": "import unittest\nimport json\n\nclass TestBitSequenceEncoder(unittest.TestCase):\n    def test_basic_encoding(self):\n        \"\"\" Test encoding with simple dictionary containing 'bits'. \"\"\"\n        data = {'name': 'Processor', 'bits': 255}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"bits\": \"11111111\"}')\n\n    def test_nested_encoding(self):\n        \"\"\" Test encoding with nested dictionary containing 'bits'. \"\"\"\n        data = {'component': {'name': 'ALU', 'bits': 128}, 'bits': 1}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"component\": {\"name\": \"ALU\", \"bits\": \"10000000\"}, \"bits\": \"00000001\"}')\n\n    def test_non_bits_key(self):\n        \"\"\" Test encoding with dictionary not containing 'bits' key. \"\"\"\n        data = {'name': 'Processor', 'value': 123}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Processor\", \"value\": 123}')\n\n    def test_no_bits_conversion_needed(self):\n        \"\"\" Test encoding with dictionary where 'bits' key needs no conversion. \"\"\"\n        data = {'name': 'Unit', 'bits': 'Already binary'}\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"name\": \"Unit\", \"bits\": \"Already binary\"}')\n\n    def test_complex_structure_with_bits(self):\n        \"\"\" Test encoding a complex dictionary structure containing multiple 'bits' keys. \"\"\"\n        data = {\n            'processor': {'bits': 3, 'type': 'A'},\n            'memory': {'bits': 255, 'size': 16},\n            'ports': {'count': 2, 'bits': 128}\n        }\n        result = json.dumps(data, cls=BitSequenceEncoder)\n        self.assertEqual(result, '{\"processor\": {\"bits\": \"00000011\", \"type\": \"A\"}, \"memory\": {\"bits\": \"11111111\", \"size\": 16}, \"ports\": {\"count\": 2, \"bits\": \"10000000\"}}')\n",
    "prompt": "please write a python function the function signature as below import json\n\n\nclass BitSequenceEncoder(json.JSONEncoder):\n    \"\"\"\n    Write a JSON decoding class that inherits from json.JSONEncoder. When encoding data into json format, the main functional bits of this class specifically handle keys identified as bits, and convert them to binary form if their value is an integer\n\n    \"\"\"\n\n    def encode(self, obj):\n        pass\n"
  },
  {
    "task_id": 253,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom unittest.mock import patch\n\n\nclass TestLogFunction(unittest.TestCase):\n    @patch('builtins.print')\n    def test_log_string(self, mock_print):\n        \"\"\" Test logging a simple string \"\"\"\n        log(\"Hello, world!\")\n        mock_print.assert_called_once_with(\"Hello, world!\")\n\n    @patch('builtins.print')\n    def test_log_number(self, mock_print):\n        \"\"\" Test logging a number \"\"\"\n        log(123.456)\n        mock_print.assert_called_once_with(123.456)\n\n    @patch('builtins.print')\n    def test_log_dictionary(self, mock_print):\n        \"\"\" Test logging a dictionary as JSON \"\"\"\n        log({\"key\": \"value\", \"number\": 42})\n        expected_json_output = '{\\n    \"key\": \"value\",\\n    \"number\": 42\\n}'\n        mock_print.assert_called_once_with(expected_json_output)\n\n    @patch('builtins.print')\n    def test_log_list(self, mock_print):\n        \"\"\" Test logging a list as JSON \"\"\"\n        log([1, 2, 3, 4, 5])\n        expected_json_output = '[\\n    1,\\n    2,\\n    3,\\n    4,\\n    5\\n]'\n        mock_print.assert_called_once_with(expected_json_output)\n\n    @patch('builtins.print')\n    def test_log_unsupported_type(self, mock_print):\n        \"\"\" Test logging an unsupported type \"\"\"\n        log(self)\n        expected_error_message = f\"Error: Unsupported type {type(self).__name__} for logging.\"\n        mock_print.assert_called_once_with(expected_error_message)\n",
    "prompt": "please write a python function the function signature as below def log(item: any) -> any:\n    \"\"\"\n    Logs an item by printing it. Handles strings, numbers, lists, and dictionaries by printing\n    them directly or as a JSON-formatted string. Other types are reported as errors.\n    Args:\n        item (any): The item to be logged. Can be of any type.\n\n    Returns:\n        item: The item to be logged. Can be of any type.\n    \"\"\"\n"
  },
  {
    "task_id": 255,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n",
    "test_code": "import unittest\nfrom io import BytesIO\nfrom PIL import Image\n\n\n\nclass TestConvertImageToBits(unittest.TestCase):\n\n    def create_image(self, mode, size, color):\n        \"\"\"\n        Helper method to create an in-memory image.\n\n        Args:\n            mode (str): The color mode of the image (e.g., '1' for binary, 'L' for grayscale).\n            size (tuple): A tuple of the image size (width, height).\n            color (int or tuple): The color to fill the image. 255 for white, 0 for black in '1' mode.\n\n        Returns:\n            Image: A PIL Image object.\n        \"\"\"\n        image = Image.new(mode, size, color)\n        return image\n\n    def test_all_white_image(self):\n        image = self.create_image('1', (4, 4), 255)\n        expected_bits = [1] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_all_black_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        expected_bits = [0] * 16\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_checkerboard_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if (x + y) % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         0, 1, 0, 1,\n                         1, 0, 1, 0,\n                         0, 1, 0, 1]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_horizontal_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if y % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 1, 1, 1,\n                         0, 0, 0, 0,\n                         1, 1, 1, 1,\n                         0, 0, 0, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)\n\n    def test_vertical_stripes_image(self):\n        image = self.create_image('1', (4, 4), 0)\n        pixels = image.load()\n        for y in range(4):\n            for x in range(4):\n                if x % 2 == 0:\n                    pixels[x, y] = 255\n        expected_bits = [1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0,\n                         1, 0, 1, 0]\n        with BytesIO() as img_bytes:\n            image.save(img_bytes, format='PNG')\n            img_bytes.seek(0)\n            result = convert_image_to_bits(img_bytes)\n        self.assertEqual(result, expected_bits)",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef convert_image_to_bits(image_path: str) -> List:\n    \"\"\"\n    Convert a picture to an array of binary bits. Convert it to black and white mode (only 0s and 1s, corresponding to black and white), convert the white pixel (value 255) to 1, convert the black pixel to 0, and finally store these bits in an array and return\n\n\n    Args:\n        image_path (str): The path to the image file.\n\n    Returns:\n        list: A list of bits (0 or 1) representing the image.\n    \"\"\"\n"
  },
  {
    "task_id": 256,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestBitsToBytes(unittest.TestCase):\n\n    def test_exact_multiple_of_eight(self):\n        \"\"\"Test bit arrays that are exact multiples of 8 bits.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1]\n        expected = bytearray([0b10110010, 0b01001111])  # Corrected to match actual byte values\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_incomplete_byte_discarded(self):\n        \"\"\"Test bit arrays where the last bits do not make up a full byte.\"\"\"\n        bits = [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]  # Last two bits should be discarded\n        expected = bytearray([0b10110010])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_empty_bit_array(self):\n        \"\"\"Test an empty bit array.\"\"\"\n        bits = []\n        expected = bytearray()\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_single_full_byte(self):\n        \"\"\"Test bit arrays that exactly make one byte.\"\"\"\n        bits = [1, 1, 1, 1, 1, 1, 1, 1]  # Represents the byte 0xFF\n        expected = bytearray([0xFF])\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)\n\n    def test_no_bits_discarded(self):\n        \"\"\"Test bit arrays with multiple of 8 bits and no extra bits.\"\"\"\n        bits = [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1]\n        expected = bytearray([0xCC, 0x77])  # Corrected the second byte from 0xB7 to 0x77\n        result = bits_to_bytes(bits)\n        self.assertEqual(result, expected)",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef bits_to_bytes(bits: List[int]) -> bytearray:\n    \"\"\"\n    convert an array of binary bits to an array of bytes. Traversing through each bit, composing these bits into bytes, forming a byte every 8 bits, and then storing these bytes in an array and returning it. If the length of the bit array is not a multiple of 8, the last incomplete byte will be discarded.\n\n    Args:\n        bits (List[int]): The input array of bits (each element should be 0 or 1).\n\n    Returns:\n        An array of bytes constructed from the bits.\n    \"\"\"\n"
  },
  {
    "task_id": 258,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> int:\n    \"\"\"\n    given a character set, extract the position of a specific character from a byte array. First, determine whether the desired character exists in the character set, and if so, calculate the character's position in the byte array, and extract the character's bits\n    Args:\n        byte_array (bytes): The byte array to search within.\n        char (str): The character to find in the byte array.\n        charset (str): The character encoding of the byte array.\n\n    Returns:\n        The position if the character is found otherwise None\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestExtractCharacterBits(unittest.TestCase):\n    def test_character_in_byte_array(self):\n        byte_array = b\"Hello, world!\"\n        char = 'w'\n        position, bits = extract_character_bits(byte_array, char)\n        self.assertEqual(position, 7)\n        self.assertEqual(bits, '01110111')\n\n    def test_character_not_in_byte_array(self):\n        byte_array = b\"Hello, world!\"\n        char = 'x'\n        result = extract_character_bits(byte_array, char)\n        self.assertIsNone(result)\n\n    def test_non_utf8_encoding(self):\n        byte_array = b\"\\xff\\xfe\\xfd\\xfc\"\n        char = '\\xff'\n        result = extract_character_bits(byte_array, char, charset='latin1')\n        self.assertIsNotNone(result)\n        position, bits = result\n        self.assertEqual(position, 0)\n        self.assertEqual(bits, '11111111')\n\n    def test_multibyte_character(self):\n        byte_array = \"\u3053\u3093\u306b\u3061\u306f\".encode('utf-8')\n        char = '\u306b'\n        position, bits = extract_character_bits(byte_array, char)\n        self.assertEqual(position, 2)\n        self.assertEqual(bits, '11100010 10000001 10000010')\n\n    def test_empty_byte_array(self):\n        byte_array = b\"\"\n        char = 'a'\n        result = extract_character_bits(byte_array, char)\n        self.assertIsNone(result)\n",
    "prompt": "please write a python function the function signature as below def extract_character_bits(byte_array: bytes, char: str, charset='utf-8') -> int:\n    \"\"\"\n    given a character set, extract the position of a specific character from a byte array. First, determine whether the desired character exists in the character set, and if so, calculate the character's position in the byte array, and extract the character's bits\n    Args:\n        byte_array (bytes): The byte array to search within.\n        char (str): The character to find in the byte array.\n        charset (str): The character encoding of the byte array.\n\n    Returns:\n        The position if the character is found otherwise None\n    \"\"\"\n"
  },
  {
    "task_id": 259,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestIsCompliantFourDigit(unittest.TestCase):\n    def test_positive_four_digit_number(self):\n        # Tests a standard positive four-digit number\n        self.assertTrue(is_compliant_four_digit(1234))\n\n    def test_boundary_values(self):\n        # Tests the boundary values of the range\n        self.assertTrue(is_compliant_four_digit(1000))\n        self.assertTrue(is_compliant_four_digit(9999))\n\n    def test_negative_four_digit_number(self):\n        # Tests a negative four-digit number\n        self.assertFalse(is_compliant_four_digit(-1234))\n\n    def test_non_integer_input(self):\n        # Tests inputs that are not integers (string, float)\n        self.assertFalse(is_compliant_four_digit('1234'))\n        self.assertFalse(is_compliant_four_digit(1234.0))\n\n    def test_out_of_range_number(self):\n        # Tests numbers that are out of the four-digit range\n        self.assertFalse(is_compliant_four_digit(999))\n        self.assertFalse(is_compliant_four_digit(10000))",
    "prompt": "please write a python function the function signature as below def is_compliant_four_digit(number: int) -> bool:\n    \"\"\"\n    determine whether a number is a compliant four-digit number\n    Args:\n        number (int): The number to check.\n\n    Returns:\n        True if the number is a compliant four-digit number, False otherwise.\n    \"\"\"\n"
  },
  {
    "task_id": 260,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def clean_csv(input_file_path: str, output_file_path: str):\n    \"\"\"\n    process the csv file and delete rows that end with two consecutive empty columns\n    Args:\n        input_file_path (str): Path to the input CSV file.\n        output_file_path (str): Path to the output CSV file where cleaned data will be stored.\n\n    Returns:\n\n    \"\"\"\n",
    "test_code": "import unittest\nimport csv\nimport os\n\n\nclass TestCleanCSV(unittest.TestCase):\n\n    def setUp(self):\n        \"\"\"Create a sample CSV file for testing.\"\"\"\n        self.input_file_path = 'test_input.csv'\n        self.output_file_path = 'test_output.csv'\n        self.sample_data = [\n            ['Name', 'Age', 'City', 'State'],\n            ['Alice', '25', '', ''],\n            ['Bob', '30', 'New York', 'NY'],\n            ['Charlie', '', '', ''],\n            ['David', '45', 'Los Angeles', '', '']\n        ]\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows(self.sample_data)\n\n    def tearDown(self):\n        \"\"\"Clean up files created during the test.js.\"\"\"\n        os.remove(self.input_file_path)\n        os.remove(self.output_file_path)\n\n    def test_clean_csv(self):\n        \"\"\"Test the cleaning functionality of the CSV.\"\"\"\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n\n        expected = [\n            ['Name', 'Age', 'City', 'State'],\n            ['Bob', '30', 'New York', 'NY'],\n        ]\n        self.assertEqual(result, expected)\n\n    def test_empty_file(self):\n        \"\"\"Test with an empty input file.\"\"\"\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            file.write('')\n        clean_csv(self.input_file_path, self.output_file_path)\n        self.assertFalse(os.path.getsize(self.output_file_path))\n\n    def test_all_rows_invalid(self):\n        \"\"\"Test when all rows should be filtered out.\"\"\"\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows([['John', '', ''], ['Jane', '', '']])\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n        self.assertEqual(result, [])\n\n    def test_no_rows_filtered(self):\n        \"\"\"Test with no rows ending with two consecutive empty columns.\"\"\"\n        data = [['Paul', '42', 'Denver', 'CO'], ['Sara', '35', 'Boston', 'MA']]\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows(data)\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n        self.assertEqual(result, data)\n\n    def test_mixed_rows(self):\n        \"\"\"Test a file containing a mix of valid and invalid rows.\"\"\"\n        data = [\n            ['Eve', '', ''],\n            ['Adam', '28', 'Seattle', 'WA'],\n            ['Noah', '32', '', '']\n        ]\n        expected = [\n            ['Adam', '28', 'Seattle', 'WA']\n        ]\n        with open(self.input_file_path, 'w', newline='', encoding='utf-8') as file:\n            writer = csv.writer(file)\n            writer.writerows(data)\n        clean_csv(self.input_file_path, self.output_file_path)\n        with open(self.output_file_path, 'r', newline='', encoding='utf-8') as file:\n            reader = csv.reader(file)\n            result = list(reader)\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below def clean_csv(input_file_path: str, output_file_path: str):\n    \"\"\"\n    process the csv file and delete rows that end with two consecutive empty columns\n    Args:\n        input_file_path (str): Path to the input CSV file.\n        output_file_path (str): Path to the output CSV file where cleaned data will be stored.\n\n    Returns:\n\n    \"\"\"\n"
  },
  {
    "task_id": 262,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestAverageOfLevels(unittest.TestCase):\n\n    def test_empty_tree(self):\n        root = None\n        expected = []\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_single_node_tree(self):\n        root = TreeNode(5)\n        expected = [5.0]\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_balanced_tree_two_levels(self):\n        root = TreeNode(3)\n        root.left = TreeNode(9)\n        root.right = TreeNode(20)\n        expected = [3.0, 14.5]  # Level 0: 3; Level 1: (9+20)/2 = 14.5\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_unbalanced_tree(self):\n        root = TreeNode(1)\n        root.right = TreeNode(2)\n        root.right.right = TreeNode(3)\n        expected = [1.0, 2.0, 3.0]  # Level 0: 1; Level 1: 2; Level 2: 3\n        self.assertEqual(average_of_levels(root), expected)\n\n    def test_tree_multiple_levels(self):\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.right.right = TreeNode(8)\n        expected = [1.0, 2.5, 5.67]  # Level 0: 1; Level 1: (2+3)/2 = 2.5; Level 2: (4+5+8)/3 \u2248 5.67\n        self.assertAlmostEqual(average_of_levels(root)[2], expected[2], places=2)\n        self.assertEqual(average_of_levels(root)[:2], expected[:2])",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef average_of_levels(root: TreeNode) -> List[float]:\n    \"\"\"\n    Given the root of a binary tree, return the average value of the nodes on each level in the form of an array.\n\n    Args:\n        root (TreeNode): The root of the binary tree.\n\n    Returns:\n        List[float]: A list containing the average values of each level.\n    \"\"\"\n"
  },
  {
    "task_id": 263,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\"",
    "test_code": "import unittest\n\nclass TestMatrixTraversal(unittest.TestCase):\n    def setUp(self):\n        self.mt = MatrixTraversal()\n\n    def test_empty_matrix(self):\n        # \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u7a7a\u77e9\u9635\n        self.assertEqual(self.mt.spiral_traversal([]), [], \"Should return an empty list for an empty matrix\")\n\n    def test_single_element_matrix(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5355\u5143\u7d20\u77e9\u9635\n        matrix = [[42]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [42], \"Should return the single element in the matrix\")\n\n    def test_single_row_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u884c\u77e9\u9635\n        matrix = [[1, 2, 3, 4, 5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single row\")\n\n    def test_single_column_matrix(self):\n        # \u8fb9\u754c\u503c\u6d4b\u8bd5\uff1a\u5355\u5217\u77e9\u9635\n        matrix = [[1], [2], [3], [4], [5]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 4, 5], \"Should return all elements in a single column\")\n\n    def test_general_case(self):\n        # \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u591a\u884c\u591a\u5217\u77e9\u9635\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        self.assertEqual(self.mt.spiral_traversal(matrix), [1, 2, 3, 6, 9, 8, 7, 4, 5], \"Should return elements in spiral order for a general case matrix\")\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\nclass MatrixTraversal:\n    def spiral_traversal(self, matrix: List[List[int]]) -> List[int]:\n        \"\"\"\n        Traverse a given m x n matrix in a spiral order and return all elements as a list.\n\n        The function starts at the top-left corner of the matrix and traverses it in a\n        clockwise spiral order, moving right across the top row, down the right column,\n        left across the bottom row, and up the left column, repeating this process\n        until all elements are traversed.\n\n        Args:\n            matrix (List[List[int]]): A 2D list representing the matrix with m rows and n columns.\n\n        Returns:\n            List[int]: A list of integers representing the elements of the matrix\n            in the order they were traversed.\n        \"\"\""
  },
  {
    "task_id": 266,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested data structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): data object\n\n    Returns:\n        after converted data\n    \"\"\"\n",
    "test_code": "import unittest\nfrom enum import Enum\nfrom numbers import Number\n\n\nclass TestHandleNestedData(unittest.TestCase):\n    def test_simple_dictionary(self):\n        data = {\"name\": b\"Alice\", \"age\": \"30\"}\n        expected = {\"name\": \"Alice\", \"age\": 30}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_nested_dictionary(self):\n        data = {\"user\": {\"name\": b\"Bob\", \"details\": {\"age\": \"25\", \"height\": \"175.5\"}}}\n        expected = {\"user\": {\"name\": \"Bob\", \"details\": {\"age\": 25, \"height\": 175.5}}}\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_list_of_mixed_data_types(self):\n        data = [\"100\", b\"200\", 300.0, \"400.5\"]\n        expected = [100, \"200\", 300.0, 400.5]\n        self.assertEqual(handle_nested_data(data), expected)\n\n    def test_incorrect_byte_decoding(self):\n        data = {\"invalid_bytes\": b\"\\xff\\xfe\\xfd\\xfc\"}\n        with self.assertRaises(UnicodeDecodeError):\n            handle_nested_data(data)\n\n    def test_complex_nested_structure(self):\n        data = {\n            \"team\": [\n                {\"name\": b\"Charlie\", \"scores\": [\"1000\", \"2000.2\"]},\n                {\"name\": b\"Daisy\", \"skills\": [b\"Coding\", \"Design\"], \"age\": \"22\"}\n            ]\n        }\n        expected = {\n            \"team\": [\n                {\"name\": \"Charlie\", \"scores\": [1000, 2000.2]},\n                {\"name\": \"Daisy\", \"skills\": [\"Coding\", \"Design\"], \"age\": 22}\n            ]\n        }\n        self.assertEqual(handle_nested_data(data), expected)",
    "prompt": "please write a python function the function signature as below from typing import Dict\n\n\ndef handle_nested_data(data: Dict) -> Dict:\n    \"\"\"\n    handle nested data structures (e.g., dictionaries, lists, and enumerations), decode bytes to UTF8-strings, and convert numbers to integers or floating point numbers\n    Args:\n        data (Dict): data object\n\n    Returns:\n        after converted data\n    \"\"\"\n"
  },
  {
    "task_id": 267,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestExtractSldTld(unittest.TestCase):\n    def test_standard_fqdn(self):\n        # Test a typical FQDN\n        self.assertEqual(extract_sld_tld(\"www.example.com\"), (\"example\", \"com\"))\n\n    def test_fqdn_with_subdomains(self):\n        # Test an FQDN with multiple subdomains\n        self.assertEqual(extract_sld_tld(\"blog.subdomain.example.com\"), (\"example\", \"com\"))\n\n    def test_single_level_domain(self):\n        # Test a domain that is missing a TLD or SLD\n        with self.assertRaises(ValueError):\n            extract_sld_tld(\"localhost\")\n\n    def test_edge_case_empty_string(self):\n        # Test with an empty string\n        with self.assertRaises(ValueError):\n            extract_sld_tld(\"\")\n\n    def test_numeric_tld(self):\n        # Test a numeric TLD, which can occur in private networks\n        self.assertEqual(extract_sld_tld(\"server.example.123\"), (\"example\", \"123\"))",
    "prompt": "please write a python function the function signature as below from typing import Tuple\n\n\ndef extract_sld_tld(fqdn: str) -> Tuple[str, str]:\n    \"\"\"\n    extract the second-level and top-level domain names from the fully qualified domain name FQDN and return them\n    Args:\n        fqdn (str): The fully qualified domain name.\n\n    Returns:\n        A tuple containing the second-level domain and top-level domain.\n    \"\"\"\n"
  },
  {
    "task_id": 268,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\"",
    "test_code": "import unittest\n\n\nclass TestCanCompleteCircuit(unittest.TestCase):\n\n    def test_possible_single_station(self):\n        gas = [5]\n        cost = [4]\n        expected = 0\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_impossible_single_station(self):\n        gas = [4]\n        cost = [5]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_two_stations_possible(self):\n        gas = [1, 2]\n        cost = [2, 1]\n        expected = 1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_possible(self):\n        gas = [1, 2, 3, 4, 5]\n        cost = [3, 4, 5, 1, 2]\n        expected = 3\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n\n    def test_circular_route_impossible(self):\n        gas = [2, 3, 4]\n        cost = [3, 4, 3]\n        expected = -1\n        self.assertEqual(canCompleteCircuit(gas, cost), expected)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef canCompleteCircuit(gas: List[int], cost: List[int]) -> int:\n    \"\"\"\n    Determines if there exists a starting gas station's index where you can travel\n    around the circuit once in a clockwise direction.\n\n    Args:\n        gas (List[int]): List of integers representing the amount of gas at each station.\n        cost (List[int]): List of integers representing the cost of gas to travel from each station to the next.\n\n    Returns:\n        int: The starting gas station's index if the circuit can be completed, otherwise -1.\n    \"\"\""
  },
  {
    "task_id": 269,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check if the given IP address is compliant based on predefined criteria.\n\n    Args:\n    ip (str): The IP address in string format.\n\n    Returns:\n    bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestIsCompliantIP(unittest.TestCase):\n    def test_private_ip(self):\n        # Test that private IPs return True\n        self.assertTrue(is_compliant_ip('192.168.1.1'))\n\n    def test_public_ip(self):\n        # Test that public IPs return False\n        self.assertFalse(is_compliant_ip('8.8.8.8'))\n\n    def test_invalid_ip(self):\n        # Test that invalid IP strings return False\n        self.assertFalse(is_compliant_ip('999.999.999.999'))\n\n    def test_ipv6_private(self):\n        # Test an IPv6 private address\n        self.assertTrue(is_compliant_ip('fd00::'))\n\n    def test_ipv6_public(self):\n        # Test an IPv6 public address\n        self.assertFalse(is_compliant_ip('2001:4860:4860::8888'))",
    "prompt": "please write a python function the function signature as below def is_compliant_ip(ip: str) -> bool:\n    \"\"\"\n    Check if the given IP address is compliant based on predefined criteria.\n\n    Args:\n    ip (str): The IP address in string format.\n\n    Returns:\n    bool: True if the IP is compliant, False otherwise.\n    \"\"\"\n"
  },
  {
    "task_id": 281,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n",
    "test_code": "import unittest\n\nclass TestSquaredEuclideanDistance(unittest.TestCase):\n    def test_standard_vectors(self):\n        \"\"\"Test squared distance calculation for typical vectors.\"\"\"\n        vec1 = [1, 2, 3]\n        vec2 = [4, 5, 6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_of_different_lengths(self):\n        \"\"\"Test vectors of different lengths to ensure it raises ValueError.\"\"\"\n        vec1 = [1, 2, 3]\n        vec2 = [1, 2]\n        with self.assertRaises(ValueError):\n            squared_euclidean_distance(vec1, vec2)\n\n    def test_vectors_with_zeros(self):\n        \"\"\"Test vectors that include zero values.\"\"\"\n        vec1 = [0, 0, 0]\n        vec2 = [0, 0, 0]\n        expected_result = 0\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_vectors_with_negative_values(self):\n        \"\"\"Test vectors that include negative values.\"\"\"\n        vec1 = [-1, -2, -3]\n        vec2 = [-4, -5, -6]\n        expected_result = 27  # (3^2 + 3^2 + 3^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)\n\n    def test_single_element_vectors(self):\n        \"\"\"Test single element vectors.\"\"\"\n        vec1 = [5]\n        vec2 = [-5]\n        expected_result = 100  # (10^2)\n        result = squared_euclidean_distance(vec1, vec2)\n        self.assertEqual(result, expected_result)",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef euclidean_distance(vec1: List[int], vec2: List[int]) -> int:\n    \"\"\"\n    compute the squared Euclidean distance between two vectors\n    Args:\n        vec1 (List[int]): First vector.\n        vec2 (List[int]): Second vector.\n\n    Returns:\n        int: Euclidean distance between vec1 and vec2.\n    \"\"\"\n"
  },
  {
    "task_id": 282,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestFlattenArray(unittest.TestCase):\n    def test_deeply_nested_array(self):\n        \"\"\"Test a deeply nested array.\"\"\"\n        nested_array = [1, [2, [3, [4, [5]]]]]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(nested_array), expected_result)\n\n    def test_mixed_types(self):\n        \"\"\"Test an array with mixed data types.\"\"\"\n        mixed_array = [\"a\", [\"b\", 2, [True, [3.14]]], False]\n        expected_result = [\"a\", \"b\", 2, True, 3.14, False]\n        self.assertEqual(flatten_array(mixed_array), expected_result)\n\n    def test_empty_array(self):\n        \"\"\"Test an empty array.\"\"\"\n        empty_array = []\n        expected_result = []\n        self.assertEqual(flatten_array(empty_array), expected_result)\n\n    def test_array_with_empty_subarrays(self):\n        \"\"\"Test an array that includes empty subarrays.\"\"\"\n        complex_array = [1, [], [2, [], 3], [4, [5, [], 6], 7], []]\n        expected_result = [1, 2, 3, 4, 5, 6, 7]\n        self.assertEqual(flatten_array(complex_array), expected_result)\n\n    def test_no_nested_array(self):\n        \"\"\"Test an array that has no nested structure.\"\"\"\n        flat_array = [1, 2, 3, 4, 5]\n        expected_result = [1, 2, 3, 4, 5]\n        self.assertEqual(flatten_array(flat_array), expected_result)\n",
    "prompt": "please write a python function the function signature as below from typing import List\n\n\ndef flatten_array(multi_dim_array: List) -> List:\n    \"\"\"\n    convert a multi-dimensional array into a one-dimensional array\n    Args:\n        multi_dim_array (List): A multi-dimensional list (nested list).\n\n    Returns:\n        list: A one-dimensional list containing all elements of the input.\n    \"\"\"\n"
  },
  {
    "task_id": 286,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestFindLargestDivisible(unittest.TestCase):\n    def test_typical_case(self):\n        \"\"\"Test with a typical input where the largest divisible number should be found.\"\"\"\n        self.assertEqual(find_largest_divisible(50), 50)\n        self.assertEqual(find_largest_divisible(47), 45)\n\n    def test_no_divisible_found(self):\n        \"\"\"Test a case where no divisible number is found within the range.\"\"\"\n        self.assertIsNone(find_largest_divisible(4))\n\n    def test_exact_half_divisible(self):\n        \"\"\"Test when the half of n is exactly divisible by 5.\"\"\"\n        self.assertEqual(find_largest_divisible(10), 10)\n\n    def test_large_number(self):\n        \"\"\"Test with a large number to ensure performance and correctness.\"\"\"\n        self.assertEqual(find_largest_divisible(1000), 1000)\n\n    def test_lower_bound(self):\n        \"\"\"Test the function with the lowest bound that should find a divisible number.\"\"\"\n        self.assertEqual(find_largest_divisible(5), 5)\n",
    "prompt": "please write a python function the function signature as below from typing import Union\n\n\ndef find_largest_divisible(n: int) -> Union[int, None]:\n    \"\"\"\n    find the largest integer between a given number n and half of it that is divisible by 10 or 5\n    Args:\n        n (int): The upper bound of the range.\n\n    Returns:\n        The largest integer between n and half of n that is divisible by 5, or\n         None if no such number exists.\n    \"\"\"\n"
  },
  {
    "task_id": 288,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import List, Tuple\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    use Bresenham line algorithm  generate a straight line between two points, returning all the points that the line passes through\n    Args:\n        x1 (int):  Coordinates of the start point x.\n        y1 (int):  Coordinates of the start point y.\n        x2 (int):  Coordinates of the end point x.\n        y2 (int):  Coordinates of the start point y.\n\n    Returns:\n        list of tuples: A list of points (tuples of x and y coordinates) that the line passes through.\n    \"\"\"\n",
    "test_code": "import unittest\n\n\nclass TestBresenhamLineAlgorithm(unittest.TestCase):\n    def test_horizontal_line(self):\n        \"\"\"Test a horizontal line from left to right.\"\"\"\n        result = bresenham_line(1, 5, 10, 5)\n        expected = [(1, 5), (2, 5), (3, 5), (4, 5), (5, 5), (6, 5), (7, 5), (8, 5), (9, 5), (10, 5)]\n        self.assertEqual(result, expected)\n\n    def test_vertical_line(self):\n        \"\"\"Test a vertical line from top to bottom.\"\"\"\n        result = bresenham_line(7, 2, 7, 10)\n        expected = [(7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7), (7, 8), (7, 9), (7, 10)]\n        self.assertEqual(result, expected)\n\n    def test_diagonal_line(self):\n        \"\"\"Test a diagonal line.\"\"\"\n        result = bresenham_line(0, 0, 5, 5)\n        expected = [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]\n        self.assertEqual(result, expected)\n\n    def test_negative_slope_line(self):\n        \"\"\"Test a line with a negative slope.\"\"\"\n        result = bresenham_line(6, 8, 1, 3)\n        expected = [(6, 8), (5, 7), (4, 6), (3, 5), (2, 4), (1, 3)]\n        self.assertEqual(result, expected)\n\n    def test_steep_slope_line(self):\n        \"\"\"Test a line that is steeper than it is wide.\"\"\"\n        result = bresenham_line(2, 2, 3, 7)\n        expected = [(2, 2), (2, 3), (2, 4), (3, 5), (3, 6), (3, 7)]\n        self.assertEqual(result, expected)\n",
    "prompt": "please write a python function the function signature as below from typing import List, Tuple\n\n\ndef bresenham_line(x1: int, y1: int, x2: int, y2: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    use Bresenham line algorithm  generate a straight line between two points, returning all the points that the line passes through\n    Args:\n        x1 (int):  Coordinates of the start point x.\n        y1 (int):  Coordinates of the start point y.\n        x2 (int):  Coordinates of the end point x.\n        y2 (int):  Coordinates of the start point y.\n\n    Returns:\n        list of tuples: A list of points (tuples of x and y coordinates) that the line passes through.\n    \"\"\"\n"
  },
  {
    "task_id": 290,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the data in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted data as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n",
    "test_code": "import unittest\nimport json\n\n\nclass TestRDFJSONLDToNGSILDConversion(unittest.TestCase):\n    def test_basic_conversion(self):\n        \"\"\"Test a basic and correct conversion from JSON-LD to NGSI-LD.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_missing_id_and_type(self):\n        \"\"\"Test conversion when @id and @type are missing.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"speed\": {\"value\": 60, \"unitCode\": \"KMH\"}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"speed\", \"value\": {\"value\": 60, \"unitCode\": \"KMH\"}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_with_nested_objects(self):\n        \"\"\"Test conversion with nested objects.\"\"\"\n        rdf_jsonld = json.dumps({\n            \"@context\": \"http://schema.org/\",\n            \"@id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"@type\": \"Vehicle\",\n            \"location\": {\"latitude\": 48.8566, \"longitude\": 2.3522}\n        })\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:Vehicle:A123\",\n            \"type\": \"Vehicle\",\n            \"@context\": \"http://schema.org/\",\n            \"attributes\": [\n                {\"type\": \"Property\", \"name\": \"location\", \"value\": {\"latitude\": 48.8566, \"longitude\": 2.3522}}\n            ]\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n\n    def test_invalid_json_input(self):\n        \"\"\"Test the function's response to invalid JSON input.\"\"\"\n        rdf_jsonld = \"This is not a valid JSON\"\n        with self.assertRaises(json.JSONDecodeError):\n            rdf_jsonld_to_ngsild(rdf_jsonld)\n\n    def test_empty_jsonld(self):\n        \"\"\"Test the conversion of an empty JSON-LD document.\"\"\"\n        rdf_jsonld = json.dumps({})\n        expected_ngsild = {\n            \"id\": \"urn:ngsi-ld:unknown:id\",\n            \"type\": \"UnknownType\",\n            \"@context\": \"https://schema.lab.fiware.org/ld/context\",\n            \"attributes\": []\n        }\n        result = rdf_jsonld_to_ngsild(rdf_jsonld)\n        self.assertEqual(result, expected_ngsild)\n",
    "prompt": "please write a python function the function signature as below from typing import Dict\n\n\ndef rdf_jsonld_to_ngsild(rdf_jsonld: str) -> Dict:\n    \"\"\"\n    convert the data in RDF JSON-LD format to NGSI-LD format\n    Args:\n        rdf_jsonld (str): RDF JSON-LD formatted data as a string.\n\n    Returns:\n        Data formatted according to NGSI-LD specifications.\n    \"\"\"\n"
  },
  {
    "task_id": 291,
    "code_type": "method",
    "code_language": "python",
    "code_signature": "def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n",
    "test_code": "import unittest\nimport os\n\nclass TestPrependToEachLine(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Create a temporary file for testing.\"\"\"\n        self.test_file_path = \"test_file.txt\"\n        with open(self.test_file_path, 'w') as f:\n            f.write(\"Line 1\\nLine 2\\nLine 3\")\n\n    def tearDown(self):\n        \"\"\"Remove the temporary file after testing.\"\"\"\n        os.remove(self.test_file_path)\n\n    def test_prepend_string(self):\n        \"\"\"Test appending a simple string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"Test: \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Test: Line 1\\n\", \"Test: Line 2\\n\", \"Test: Line 3\"])\n\n    def test_prepend_empty_string(self):\n        \"\"\"Test appending an empty string.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"\")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"Line 1\\n\", \"Line 2\\n\", \"Line 3\"])\n\n    def test_prepend_special_characters(self):\n        \"\"\"Test appending special characters to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"#$%^&* \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"#$%^&* Line 1\\n\", \"#$%^&* Line 2\\n\", \"#$%^&* Line 3\"])\n\n    def test_prepend_numeric_string(self):\n        \"\"\"Test appending numeric string to the beginning of each line.\"\"\"\n        prepend_to_each_line(self.test_file_path, \"123 \")\n        with open(self.test_file_path, 'r') as f:\n            lines = f.readlines()\n            self.assertEqual(lines, [\"123 Line 1\\n\", \"123 Line 2\\n\", \"123 Line 3\"])\n\n    def test_file_not_found(self):\n        \"\"\"Test the response when the file does not exist.\"\"\"\n        with self.assertRaises(FileNotFoundError):\n            prepend_to_each_line(\"non_existent_file.txt\", \"Test: \")",
    "prompt": "please write a python function the function signature as below def prepend_to_each_line(file_path: str, prefix: str):\n    \"\"\"\n    Appends the specified string to the beginning of each line of the file.\n\n    Args:\n    file_path (str): Path to the file whose lines will be modified.\n    prefix (str): String to append to the beginning of each line.\n    \"\"\"\n"
  }
]