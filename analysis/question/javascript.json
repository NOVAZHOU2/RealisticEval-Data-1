[
  {
    "task_id": 87,
    "code_type": "method",
    "code_signature": "/**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n",
    "code_language": "javascript",
    "test_code": "describe('timestampToReadableDate', () => {\n    test('should convert UNIX timestamp to readable format', () => {\n        const timestamp = 1696516800;\n        expect(timestampToReadableDate(timestamp)).toBe('Oct 5, 22:40');\n    });\n\n    test('should handle timestamp at the start of the year', () => {\n        const timestamp = 1672531200;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n\n    test('should handle timestamp at the end of the year', () => {\n        const timestamp = 1672531199;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 7:59');\n    });\n\n    test('should handle timestamps in the leap year', () => {\n        const timestamp = 1583020800;\n        expect(timestampToReadableDate(timestamp)).toBe('Mar 1, 8:00');\n    });\n\n    test('should convert timestamp to readable format with single-digit day', () => {\n        const timestamp = 1675190400;\n        expect(timestampToReadableDate(timestamp)).toBe('Feb 1, 2:40');\n    });\n\n\n    test('should handle zero UNIX timestamp', () => {\n        const timestamp = 0;\n        expect(timestampToReadableDate(timestamp)).toBe('Jan 1, 8:00');\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00'.\n * for example:\n *      input: 1672531200 output: Jan 1, 8:00\n *      input: 1696516800 output: Oct 5, 22:40\n *\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 88,
    "code_type": "method",
    "code_signature": "/**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('isCronBetween2And4AM', () => {\n    test('should return true for specific hours 2, 3, and 4', () => {\n        expect(isCronBetween2And4AM('0 2,3,4 * * *')).toBe(true);\n    });\n\n    test('should return false for range that includes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 1-5 * * *')).toBe(false);\n    });\n\n    test('should return false for range that excludes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 0-1,5-23 * * *')).toBe(false);\n    });\n\n    test('should return true for wildcard in hour field', () => {\n        expect(isCronBetween2And4AM('0 * * * *')).toBe(false);\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 89,
    "code_type": "method",
    "code_signature": "/**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}",
    "code_language": "javascript",
    "test_code": "describe('timePassed function', () => {\n    const originalDateNow = Date.now;\n\n    beforeEach(() => {\n        // Freeze the Date.now() to a fixed timestamp\n        Date.now = jest.fn(() => 1609459200000); // January 1, 2021, 00:00:00\n    });\n\n    afterEach(() => {\n        // Restore original Date.now() function\n        Date.now = originalDateNow;\n    });\n\n    test('should correctly calculate time passed from 1 minute ago', () => {\n        const startTime = 1609459140000; // 1 minute earlier\n        expect(timePassed(startTime)).toBe(\"1:00\");\n    });\n\n    test('should handle the boundary of 59 seconds correctly', () => {\n        const startTime = 1609459194100; // 59 seconds and 900 milliseconds earlier\n        expect(timePassed(startTime)).toBe(\"0:05\");\n    });\n\n    test('should return 0:00 when start time is the same as current time', () => {\n        expect(timePassed(1609459200000)).toBe(\"0:00\");\n    });\n\n    test('should handle negative time differences (future start time)', () => {\n        const startTime = 1609459260000; // 1 minute into the future\n        expect(timePassed(startTime)).toMatch(/-/); // Expecting negative output or some error handling\n    });\n\n    test('should handle very large time differences correctly', () => {\n        const startTime = 1483228800000; // January 1, 2017, 00:00:00 (4 years difference)\n        expect(timePassed(startTime)).toBe(\"2103840:00\"); // Calculated minutes for 4 years\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 92,
    "code_type": "method",
    "code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nconst {JSDOM} = require('jsdom');\nconst dom = new JSDOM();\nconst {document} = dom.window;\n\nfunction replaceHtmlEntities(htmlString) {\n}",
    "code_language": "javascript",
    "test_code": "describe('replaceHtmlEntities', () => {\n    test('decodes standard HTML entities', () => {\n        const input = 'The &amp; symbol should become an &quot;and&quot; sign.';\n        const expected = 'The & symbol should become an \"and\" sign.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('returns empty string for empty input', () => {\n        const input = '';\n        const expected = '';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n\n    test('decodes multiple different entities in one string', () => {\n        const input = '&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;';\n        const expected = '<div>Hello & Welcome to the \\'World\\'!</div>';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('handles strings with no entities', () => {\n        const input = 'Just a normal string without entities.';\n        const expected = 'Just a normal string without entities.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nconst {JSDOM} = require('jsdom');\nconst dom = new JSDOM();\nconst {document} = dom.window;\n\nfunction replaceHtmlEntities(htmlString) {\n}",
    "addition_info": "/**\n * @jest-environment jsdom\n */"
  },
  {
    "task_id": 93,
    "code_type": "method",
    "code_signature": "/**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}",
    "code_language": "javascript",
    "test_code": "describe('getAllAlphabets', () => {\n    test('should return an array of 52 characters', () => {\n        const result = getAllAlphabets();\n        expect(result).toHaveLength(52);\n    });\n\n    test('should start with lowercase letters from a to z', () => {\n        const result = getAllAlphabets();\n        const lowercaseAlphabets = result.slice(0, 26);\n        expect(lowercaseAlphabets).toEqual([\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        ]);\n    });\n\n    test('should end with uppercase letters from A to Z', () => {\n        const result = getAllAlphabets();\n        const uppercaseAlphabets = result.slice(26);\n        expect(uppercaseAlphabets).toEqual([\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n        ]);\n    });\n\n    test('should return \"a\" as the first element', () => {\n        const result = getAllAlphabets();\n        expect(result[0]).toBe('a');\n    });\n\n    test('should return \"Z\" as the last element', () => {\n        const result = getAllAlphabets();\n        expect(result[result.length - 1]).toBe('Z');\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 94,
    "code_type": "method",
    "code_signature": "/**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('createCircleOfFifths', () => {\n    test('should return 12 notes in the circle', () => {\n        const result = createCircleOfFifths('C');\n        expect(result).toHaveLength(12);\n    });\n\n    test('should start with the given starting note', () => {\n        const startingNote = 'G';\n        const result = createCircleOfFifths(startingNote);\n        expect(result[0]).toBe(startingNote);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from C', () => {\n        const result = createCircleOfFifths('C');\n        const expectedCircle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from G', () => {\n        const result = createCircleOfFifths('G');\n        const expectedCircle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from F', () => {\n        const result = createCircleOfFifths('F');\n        const expectedCircle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];\n        expect(result).toEqual(expectedCircle);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 95,
    "code_type": "method",
    "code_signature": "/**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array} arr - The input array to search through.\n * @param {Function} comparisonFn - The comparison function to determine matches.\n * @returns {Array} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements(arr, comparisonFn) {\n}",
    "code_language": "javascript",
    "test_code": "describe('findMatchingElements', () => {\n    test('should return an empty array for an empty input array', () => {\n        const result = findMatchingElements([], (el) => el > 0);\n        expect(result).toEqual([]);\n    });\n\n    test('should return matching elements and their indices', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const comparisonFunction = (num) => num > 3;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 4, index: 3},\n            {element: 5, index: 4},\n        ]);\n    });\n\n    test('should return elements that are strings matching a specific condition', () => {\n        const inputArray = ['apple', 'banana', 'cherry', 'date'];\n        const comparisonFunction = (fruit) => fruit.startsWith('b');\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 'banana', index: 1},\n        ]);\n    });\n\n    test('should return multiple elements with the same value', () => {\n        const inputArray = [1, 2, 2, 3, 2, 4];\n        const comparisonFunction = (num) => num === 2;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: 2, index: 1},\n            {element: 2, index: 2},\n            {element: 2, index: 4},\n        ]);\n    });\n\n    test('should return matching objects based on a property', () => {\n        const inputArray = [\n            {name: 'Alice', age: 25},\n            {name: 'Bob', age: 30},\n            {name: 'Charlie', age: 30},\n        ];\n        const comparisonFunction = (person) => person.age === 30;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: {name: 'Bob', age: 30}, index: 1},\n            {element: {name: 'Charlie', age: 30}, index: 2},\n        ]);\n    });\n\n    test('should return no elements if no matches found', () => {\n        const inputArray = [1, 3, 5, 7];\n        const comparisonFunction = (num) => num % 2 === 0; // looking for even numbers\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([]);\n    });\n\n    test('should work with a comparison function that checks for negative numbers', () => {\n        const inputArray = [-1, -2, 0, 1, 2];\n        const comparisonFunction = (num) => num < 0;\n        const result = findMatchingElements(inputArray, comparisonFunction);\n        expect(result).toEqual([\n            {element: -1, index: 0},\n            {element: -2, index: 1},\n        ]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Finds matching elements and their indices in the input array\n * based on the specified comparison function.\n *\n * @param {Array} arr - The input array to search through.\n * @param {Function} comparisonFn - The comparison function to determine matches.\n * @returns {Array} - An array of objects, each containing the matched element and its index.\n */\nfunction findMatchingElements(arr, comparisonFn) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 96,
    "code_type": "method",
    "code_signature": "/**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('changedClef', () => {\n    test('should insert the clef at the correct position when the clef is not specified (default to \"bass\")', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc);\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should insert the clef at the correct position when a specific clef is provided', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"treble\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should handle cases where there is no newline after the key signature.js.py.py.py', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\";\n        const result = changedClef(abc, \"alto\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        expect(result).toBe(expected);\n    });\n\n    test('should not alter the ABC notation if the key signature.js.py.py.py is not found', () => {\n        const abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"tenor\");\n        expect(result).toBe(abc); // Expect the original string to be returned unchanged\n    });\n\n    test('should correctly handle ABC notation with multiple key signatures', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        const result = changedClef(abc, \"baritone\");\n        const expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        expect(result).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 97,
    "code_type": "class",
    "code_signature": "/**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param {*} element - The element to be added to the queue.\n     */\n    enqueue(element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns {*} The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns {*} The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns {boolean} True if the queue is empty, otherwise false.\n     */\n    isEmpty() {\n    }\n\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns {string} A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue() {\n    }\n}",
    "code_language": "javascript",
    "test_code": "describe('Queue Class', () => {\n    let queue;\n\n    beforeEach(() => {\n        queue = new Queue();\n    });\n\n    test('should initialize an empty queue', () => {\n        expect(queue.isEmpty()).toBe(true);\n    });\n\n    test('should enqueue elements to the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        queue.enqueue(3);\n        expect(queue.printQueue()).toBe('1 2 3');\n        expect(queue.isEmpty()).toBe(false);\n    });\n\n    test('should dequeue elements from the queue', () => {\n        queue.enqueue(1);\n        queue.enqueue(2);\n        const dequeuedElement = queue.dequeue();\n        expect(dequeuedElement).toBe(1);\n    });\n\n\n    test('should return the front element without removing it', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        const frontElement = queue.front();\n        expect(frontElement).toBe(10);\n    });\n\n    test('should check if the queue is empty', () => {\n        expect(queue.isEmpty()).toBe(true);\n        queue.enqueue(5);\n        expect(queue.isEmpty()).toBe(false);\n        queue.dequeue();\n        expect(queue.isEmpty()).toBe(true);\n    });\n});",
    "prompt": "please write a javascript class , the class signature as below /**\n * realize the basic functions of the question structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n    constructor() {\n        this.items = [];\n    }\n\n    /**\n     * Adds an element to the end of the queue.\n     * @param {*} element - The element to be added to the queue.\n     */\n    enqueue(element) {\n    }\n\n    /**\n     * Removes and returns the element from the front of the queue.\n     * @returns {*} The removed element from the front of the queue, or \"Underflow\" if the queue is empty.\n     */\n    dequeue() {\n    }\n\n    /**\n     * Returns the front element of the queue without removing it.\n     * @returns {*} The front element of the queue, or \"No elements in Queue\" if the queue is empty.\n     */\n    front() {\n    }\n\n    /**\n     * Checks if the queue is empty.\n     * @returns {boolean} True if the queue is empty, otherwise false.\n     */\n    isEmpty() {\n    }\n\n\n    /**\n     * Returns a string representation of all the elements in the queue.\n     * @returns {string} A string containing all elements in the queue, separated by spaces.\n     */\n    printQueue() {\n    }\n}",
    "addition_info": ""
  },
  {
    "task_id": 99,
    "code_type": "method",
    "code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n",
    "code_language": "javascript",
    "test_code": "describe('Sum Function Tests', () => {\n    test('should return the sum of a normal array of positive numbers', () => {\n        expect(sum([1, 2, 3, 4, 5])).toBe(15);\n    });\n\n    test('should return the sum of an array containing negative numbers', () => {\n        expect(sum([-1, -2, -3, -4, -5])).toBe(-15);\n    });\n\n    test('should return 0 for an empty array', () => {\n        expect(sum([])).toBe(0);\n    });\n\n    test('should return the sum of an array containing both positive and negative numbers', () => {\n        expect(sum([10, -10, 5, -5, 15])).toBe(15);\n    });\n\n    test('should return the sum of an array with floating point numbers', () => {\n        expect(sum([1.5, 2.5, 3.5])).toBe(7.5);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a model_answer_result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n",
    "addition_info": ""
  },
  {
    "task_id": 100,
    "code_type": "method",
    "code_signature": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n",
    "code_language": "javascript",
    "test_code": "describe('ConvertTime Function Tests', () => {\n    test('should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds', () => {\n        expect(convertTime('PT1H23M45.678S')).toBe('1h23m45s678ms');\n    });\n\n    test('should correctly convert duration with only seconds and milliseconds', () => {\n        expect(convertTime('PT45.5S')).toBe('45s500ms');\n    });\n\n    test('should correctly convert duration with hours and minutes, but no seconds', () => {\n        expect(convertTime('PT2H5M')).toBe('2h5m');\n    });\n\n    test('should correctly convert duration with only seconds, no milliseconds', () => {\n        expect(convertTime('PT20S')).toBe('20s');\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 101,
    "code_type": "method",
    "code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n",
    "code_language": "javascript",
    "test_code": "describe('isBreakTime Function Tests', () => {\n    test('should return true when current time is exactly at the start time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:00\")).toBe(true);\n    });\n\n    test('should return true when current time is within the break time range', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:30\")).toBe(true);\n    });\n\n    test('should return false when current time is exactly exceed the end time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"20:00\")).toBe(false);\n    });\n\n    test('should return false when current time is before the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"08:59\")).toBe(false);\n    });\n\n    test('should return false when current time is after the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:01\")).toBe(false);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n",
    "addition_info": ""
  },
  {
    "task_id": 103,
    "code_type": "method",
    "code_signature": "/**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str, maxLength) {\n}",
    "code_language": "javascript",
    "test_code": "describe('truncateStringWithReplacement', () => {\n    test('should return the original string if it is shorter than maxLength', () => {\n        const result = truncateStringWithReplacement('Hello World', 20);\n        expect(result).toBe('Hello World');\n    });\n\n    test('should truncate the string and replace the excess with ellipsis when longer than maxLength', () => {\n        const result = truncateStringWithReplacement('This is a long string that needs to be truncated.', 20);\n        expect(result).toBe('This is a long str...');\n    });\n\n    test('should truncate the string at maxLength and add ellipsis', () => {\n        const result = truncateStringWithReplacement('Short string', 10);\n        expect(result).toBe('Short str...');\n    });\n\n    test('should handle empty string correctly', () => {\n        const result = truncateStringWithReplacement('', 10);\n        expect(result).toBe('');\n    });\n\n    test('should return the original string when maxLength is equal to string length', () => {\n        const result = truncateStringWithReplacement('Exact length', 12);\n        expect(result).toBe('Exact length');\n    });\n\n    test('should replace excess part with ellipsis in a string with special characters', () => {\n        const result = truncateStringWithReplacement('This string has special characters: !@#$%^&*()', 30);\n        expect(result).toBe('This string has special c...');\n    });\n\n    test('should return ellipsis only when the maxLength is 0', () => {\n        const result = truncateStringWithReplacement('Hello, world!', 0);\n        expect(result).toBe('...');\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Truncate a string to the specified length, replacing the excess part with an ellipsis.\n *\n * @param {string} str - The string to truncate.\n * @param {number} maxLength - The maximum length of the resulting string.\n * @returns {string} - The truncated string with ellipsis if applicable.\n */\nfunction truncateStringWithReplacement(str, maxLength) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 104,
    "code_type": "method",
    "code_signature": "/**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n",
    "code_language": "javascript",
    "test_code": "describe('convertThreadToJSONFile Function Tests', () => {\n    test('should return a Blob object for a basic thread object', () => {\n        const thread1 = { id: 1, title: \"First Thread\", content: \"This is the first thread.\" };\n        const blob1 = convertThreadToJSONFile(thread1);\n        expect(blob1 instanceof Blob).toBe(true);\n        expect(blob1.type).toBe(\"application/json\");\n    });\n\n    test('should return a Blob object for an empty thread object', () => {\n        const thread2 = {};\n        const blob2 = convertThreadToJSONFile(thread2);\n        expect(blob2 instanceof Blob).toBe(true);\n        expect(blob2.size).toBe(2); // \"{}\" has a size of 2 bytes\n    });\n\n    test('should return a Blob object for a thread object with nested objects', () => {\n        const thread3 = { id: 2, title: \"Second Thread\", comments: [{ user: \"Alice\", comment: \"Great post!\" }] };\n        const blob3 = convertThreadToJSONFile(thread3);\n        expect(blob3 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with special characters', () => {\n        const thread4 = { id: 3, title: \"Thread & Special <Characters>\", content: 'This is a thread with special characters: <, >, &, \".' };\n        const blob4 = convertThreadToJSONFile(thread4);\n        expect(blob4 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with arrays', () => {\n        const thread5 = { id: 4, title: \"Thread with Array\", tags: [\"JavaScript\", \"JSON\", \"Blob\"] };\n        const blob5 = convertThreadToJSONFile(thread5);\n        expect(blob5 instanceof Blob).toBe(true);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n",
    "addition_info": ""
  },
  {
    "task_id": 106,
    "code_type": "method",
    "code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n",
    "code_language": "javascript",
    "test_code": "describe('isBase64Image', () => {\n    test('should return true for a valid PNG Base64 image string', () => {\n        const validPng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA';\n        expect(isBase64Image(validPng)).toBe(true);\n    });\n\n    test('should return true for a valid JPEG Base64 image string', () => {\n        const validJpeg = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAAAAAA';\n        expect(isBase64Image(validJpeg)).toBe(true);\n    });\n\n    test('should return false for a string without the image data prefix', () => {\n        const invalidFormat = 'data:text/plain;base64,SGVsbG8gd29ybGQ=';\n        expect(isBase64Image(invalidFormat)).toBe(false);\n    });\n\n    test('should return false for a string with invalid Base64 characters', () => {\n        const invalidBase64 = 'data:image/png;base64,invalidBase64String@#%';\n        expect(isBase64Image(invalidBase64)).toBe(false);\n    });\n\n    test('should return false for an empty string', () => {\n        expect(isBase64Image('')).toBe(false);\n    });\n\n    test('should return false for a null input', () => {\n        expect(isBase64Image(null)).toBe(false);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image question string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n",
    "addition_info": ""
  },
  {
    "task_id": 107,
    "code_type": "method",
    "code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n",
    "code_language": "javascript",
    "test_code": "describe('findMedian', () => {\n    // Example usage with a large array\n    test('should find the median of a large array with 10001 random elements', () => {\n        const largeArray = Array.from({ length: 10001 }, () => Math.floor(Math.random() * 10000));\n        const medianLargeArray = findMedian(largeArray);\n        // It's difficult to assert the exact median here due to randomness,\n        // but this test can check if the function completes without error\n        expect(typeof medianLargeArray).toBe('number');\n    });\n\n    // Test Case 1: Odd number of elements\n    test('should return 3 for an array with odd number of elements', () => {\n        const arr1 = [3, 1, 4, 1, 5, 9, 2];\n        const median1 = findMedian(arr1);\n        expect(median1).toBe(3);\n    });\n\n    // Test Case 2: Even number of elements\n    test('should return 6 for an array with even number of elements', () => {\n        const arr2 = [10, 2, 3, 5, 7, 8];\n        const median2 = findMedian(arr2);\n        expect(median2).toBe(6);\n    });\n\n    // Test Case 3: Array with duplicate elements\n    test('should return 2 for an array with duplicate elements', () => {\n        const arr3 = [1, 2, 2, 2, 3];\n        const median3 = findMedian(arr3);\n        expect(median3).toBe(2);\n    });\n\n    // Test Case 4: Array with negative numbers\n    test('should return 0 for an array with negative and positive numbers', () => {\n        const arr4 = [-5, -10, 0, 5, 10];\n        const median4 = findMedian(arr4);\n        expect(median4).toBe(0);\n    });\n\n    // Test Case 5: Array with a single element\n    test('should return the only element for an array with a single element', () => {\n        const arr5 = [42];\n        const median5 = findMedian(arr5);\n        expect(median5).toBe(42);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 108,
    "code_type": "method",
    "code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('reorderData', () => {\n\n    test('should reorder the question based on scores in ascending order', () => {\n        const imageScores = [90, 85, 95];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([85, 90, 95]);\n        expect(result.resultNames).toEqual([\"image2.png\", \"image1.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id2\", \"id1\", \"id3\"]);\n    });\n\n    test('should return the same order if scores are already in ascending order', () => {\n        const imageScores = [70, 75, 80];\n        const imageNames = [\"imageA.png\", \"imageB.png\", \"imageC.png\"];\n        const imageIDs = [\"idA\", \"idB\", \"idC\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([70, 75, 80]);\n        expect(result.resultNames).toEqual([\"imageA.png\", \"imageB.png\", \"imageC.png\"]);\n        expect(result.resultIDs).toEqual([\"idA\", \"idB\", \"idC\"]);\n    });\n\n    test('should handle an array with only one element', () => {\n        const imageScores = [50];\n        const imageNames = [\"imageSingle.png\"];\n        const imageIDs = [\"idSingle\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([50]);\n        expect(result.resultNames).toEqual([\"imageSingle.png\"]);\n        expect(result.resultIDs).toEqual([\"idSingle\"]);\n    });\n\n    test('should handle an empty array', () => {\n        const imageScores = [];\n        const imageNames = [];\n        const imageIDs = [];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([]);\n        expect(result.resultNames).toEqual([]);\n        expect(result.resultIDs).toEqual([]);\n    });\n\n    test('should reorder correctly when there are duplicate scores', () => {\n        const imageScores = [88, 88, 92];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([88, 88, 92]);\n        expect(result.resultNames).toEqual([\"image1.png\", \"image2.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id1\", \"id2\", \"id3\"]);\n    });\n\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.for example { resultScores, resultNames, resultIDs }\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 109,
    "code_type": "method",
    "code_signature": "/**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('getObjectById', () => {\n\n    test('should return the object with the matching id', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(2, list);\n        expect(result).toEqual({ id: 2, name: 'Object 2' });\n    });\n\n    test('should return null if no object with the matching id is found', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(4, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if the list is empty', () => {\n        const list = [];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if objects in the list do not have an id property', () => {\n        const list = [\n            { name: 'Object 1' },\n            { name: 'Object 2' },\n            { name: 'Object 3' }\n        ];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return the correct object when id is a string', () => {\n        const list = [\n            { id: 'a', name: 'Object A' },\n            { id: 'b', name: 'Object B' },\n            { id: 'c', name: 'Object C' }\n        ];\n        const result = getObjectById('b', list);\n        expect(result).toEqual({ id: 'b', name: 'Object B' });\n    });\n\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 110,
    "code_type": "method",
    "code_signature": "/**\n * Generate a random UUID of length 36\n * The UUID At least one uppercase letter,At least one lowercase letter,At least one digit\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('generateUUID', () => {\n\n    test('should return a string', () => {\n        const result = generateUUID();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a string of length 36', () => {\n        const result = generateUUID();\n        expect(result.length).toBe(36);\n    });\n\n\n    test('should generate different UUIDs on consecutive calls', () => {\n        const uuid1 = generateUUID();\n        const uuid2 = generateUUID();\n        expect(uuid1).not.toBe(uuid2);\n    });\n\n    test('should generate UUIDs that include uppercase', () => {\n        const result = generateUUID();\n        expect(/[A-Z]/.test(result)).toBe(true); // At least one uppercase letter\n    });\n    test('should generate UUIDs that include  lowercase letters', () => {\n        const result = generateUUID();\n        expect(/[a-z]/.test(result)).toBe(true); // At least one lowercase letter\n    });\n    test('should generate UUIDs that include digits', () => {\n        const result = generateUUID();\n        expect(/[0-9]/.test(result)).toBe(true); // At least one digit\n    });\n\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Generate a random UUID of length 36\n * The UUID At least one uppercase letter,At least one lowercase letter,At least one digit\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 111,
    "code_type": "method",
    "code_signature": "/**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('convertChatToMarkdown', () => {\n\n    test('should include the default title when no title is provided', () => {\n        const chat = [\"Hello\", \"Hi there!\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedStart = \"# ChatGPT Conversation\\n\\n**Human:**\\nHello\\n\\n***\\n\\n**Assistant:**\\nHi there!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should include the custom title when a title is provided', () => {\n        const chat = [\"How are you?\", \"I'm doing well, thank you!\"];\n        const title = \"Friendly Chat\";\n        const blob = convertChatToMarkdown(chat, title);\n        const expectedStart = \"# Friendly Chat\\n\\n**Human:**\\nHow are you?\\n\\n***\\n\\n**Assistant:**\\nI'm doing well, thank you!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should correctly alternate speakers between Human and Assistant', () => {\n        const chat = [\"Question?\", \"Answer.\", \"Another question?\", \"Another answer.\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedContent = `**Human:**\\nQuestion?\\n\\n***\\n\\n**Assistant:**\\nAnswer.\\n\\n***\\n\\n**Human:**\\nAnother question?\\n\\n***\\n\\n**Assistant:**\\nAnother answer.\\n\\n***\\n\\nExported on `;\n        return blob.text().then(text => {\n            expect(text.includes(expectedContent)).toBe(true);\n        });\n    });\n\n    test('should include the correct timestamp using getDate and getTime', () => {\n        const chat = [\"What's the time?\", \"It's now.\"];\n        const mockedDate = new Date(\"2024-01-01 12:00:00\");\n        global.Date = jest.fn(() => mockedDate);\n\n        const blob = convertChatToMarkdown(chat);\n        const expectedEnd = `Exported on 2024-01-01 12:00:00.`;\n        return blob.text().then(text => {\n            expect(text.endsWith(expectedEnd)).toBe(true);\n        });\n    });\n\n    test('should return a Blob of type text/markdown', () => {\n        const chat = [\"This is a test.js.\", \"Yes, it is.\"];\n        const blob = convertChatToMarkdown(chat);\n        expect(blob.type).toBe('text/markdown');\n    });\n\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 112,
    "code_type": "method",
    "code_signature": "/**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html) {}",
    "code_language": "javascript",
    "test_code": "describe('convertHtmlHeadingsToMarkdown', () => {\n    test('should convert <h1> to #', () => {\n        const input = '<h1>This is a Heading 1</h1>';\n        const output = '# This is a Heading 1';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h2> to ##', () => {\n        const input = '<h2>This is a Heading 2</h2>';\n        const output = '## This is a Heading 2';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h3> to ###', () => {\n        const input = '<h3>This is a Heading 3</h3>';\n        const output = '### This is a Heading 3';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h4> to ####', () => {\n        const input = '<h4>This is a Heading 4</h4>';\n        const output = '#### This is a Heading 4';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h5> to #####', () => {\n        const input = '<h5>This is a Heading 5</h5>';\n        const output = '##### This is a Heading 5';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n    test('should convert <h6> to ######', () => {\n        const input = '<h6>This is a Heading 6</h6>';\n        const output = '###### This is a Heading 6';\n        expect(convertHtmlHeadingsToMarkdown(input)).toBe(output);\n    });\n\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Converts HTML heading tags (h1-h6) to corresponding Markdown headings.\n *\n * @param {string} html - The HTML string containing headings.\n * @returns {string} - The converted Markdown string.\n */\nfunction convertHtmlHeadingsToMarkdown(html) {}",
    "addition_info": ""
  },
  {
    "task_id": 113,
    "code_type": "method",
    "code_signature": "/**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}",
    "code_language": "javascript",
    "test_code": "describe('getCSSFromSheet', () => {\n    let styleSheet;\n\n    beforeEach(() => {\n        // Create a style element with some CSS rules for testing\n        const style = document.createElement('style');\n        style.appendChild(document.createTextNode(`\n            body { background-color: red; }\n            p { color: blue; }\n        `));\n        document.head.appendChild(style);\n        styleSheet = style.sheet;\n    });\n\n    afterEach(() => {\n        // Clean up the document after each test\n        document.head.innerHTML = '';\n    });\n\n\n    test('Empty Stylesheet: should return an empty string', () => {\n        const emptyStyle = document.createElement('style');\n        document.head.appendChild(emptyStyle);\n        const emptyStyleSheet = emptyStyle.sheet;\n\n        const cssText = getCSSFromSheet(emptyStyleSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Invalid Input: should return an empty string for non-CSSStyleSheet input', () => {\n        expect(getCSSFromSheet(null)).toBe('');\n        expect(getCSSFromSheet({})).toBe('');\n        expect(getCSSFromSheet('not a stylesheet')).toBe('');\n    });\n\n    test('Cross-Origin Restrictions: should handle restricted stylesheets gracefully', () => {\n        // Simulate a cross-origin stylesheet\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'http://example.com/style.css';\n        document.head.appendChild(link);\n\n        // Accessing cssRules of a cross-origin stylesheet should throw an error\n        const restrictedSheet = link.sheet;\n\n        expect(() => {\n            getCSSFromSheet(restrictedSheet);\n        }).not.toThrow();  // The function should not throw an error\n\n        // Simulate behavior by returning an empty string\n        const cssText = getCSSFromSheet(restrictedSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Style Element with Inline CSS: should return CSS from inline style element', () => {\n        const styleElement = document.createElement('style');\n        styleElement.textContent = 'div { font-size: 16px; }';\n        document.head.appendChild(styleElement);\n\n        const cssText = getCSSFromSheet(styleElement.sheet);\n        expect(cssText).toBe('div {font-size: 16px;}');\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}",
    "addition_info": "/**\n * @jest-environment jsdom\n */"
  },
  {
    "task_id": 114,
    "code_type": "method",
    "code_signature": "/**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}",
    "code_language": "javascript",
    "test_code": "describe('sortByTimestamp function', () => {\n    test('should return an empty array when input is empty', () => {\n        expect(sortByTimestamp([])).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }];\n        expect(sortByTimestamp(singleElementArray)).toEqual([{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }]);\n    });\n\n    test('should sort an array of objects by timestamps correctly', () => {\n        const testData = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(testData)).toEqual(expected);\n    });\n\n    test('should not alter array if already sorted', () => {\n        const sortedArray = [\n            { id: 1, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 3, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(sortedArray)).toEqual(sortedArray);\n    });\n\n    test('should handle mixed format timestamps correctly', () => {\n        const mixedFormats = [\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" }\n        ];\n        expect(sortByTimestamp(mixedFormats)).toEqual(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}",
    "addition_info": ""
  },
  {
    "task_id": 115,
    "code_type": "method",
    "code_signature": "/**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('sortByKey function', () => {\n    test('should return an empty array when input is empty', () => {\n        const result = sortByKey([], 'name');\n        expect(result).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ name: 'Apple' }];\n        expect(sortByKey(singleElementArray, 'name')).toEqual([{ name: 'Apple' }]);\n    });\n\n    test('should sort an array of objects by the specified key', () => {\n        const testData = [\n            { name: 'banana' },\n            { name: 'apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(testData, 'name')).toEqual(expected);\n    });\n\n    test('should perform case-insensitive sorting', () => {\n        const mixedCaseArray = [\n            { name: 'banana' },\n            { name: 'Apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'Apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(mixedCaseArray, 'name')).toEqual(expected);\n    });\n\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 116,
    "code_type": "method",
    "code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}",
    "code_language": "javascript",
    "test_code": "describe('toroidalDiff', () => {\n    test('should return the direct difference when no wrapping is needed', () => {\n        const thisPoint = { x: 2, y: 3 };\n        const otherPoint = { x: 5, y: 6 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-3, -3]);\n    });\n\n    test('should handle wrapping around the x dimension', () => {\n        const thisPoint = { x: 9, y: 5 };\n        const otherPoint = { x: 1, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, 0]); // dx wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around the y dimension', () => {\n        const thisPoint = { x: 4, y: 9 };\n        const otherPoint = { x: 4, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, -2]); // dy wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around both x and y dimensions', () => {\n        const thisPoint = { x: 9, y: 9 };\n        const otherPoint = { x: 1, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, -2]); // Both dx and dy wrap around\n    });\n\n    test('should return the direct difference for points at the same position', () => {\n        const thisPoint = { x: 5, y: 5 };\n        const otherPoint = { x: 5, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, 0]); // No difference\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 117,
    "code_type": "method",
    "code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}",
    "code_language": "javascript",
    "test_code": "describe('rgbToHsl function', () => {\n    test('converts pure red to HSL', () => {\n        expect(rgbToHsl(255, 0, 0)).toEqual({h: 0, s: 100, l: 50});\n    });\n\n    test('converts black to HSL', () => {\n        expect(rgbToHsl(0, 0, 0)).toEqual({h: 0, s: 0, l: 0});\n    });\n\n    test('converts white to HSL', () => {\n        expect(rgbToHsl(255, 255, 255)).toEqual({h: 0, s: 0, l: 100});\n    });\n\n    test('converts a color on the edge of RGB range', () => {\n        expect(rgbToHsl(0, 255, 255)).toEqual({h: 180, s: 100, l: 50});\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 118,
    "code_type": "method",
    "code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}",
    "code_language": "javascript",
    "test_code": "describe('hslToRgb function', () => {\n    test('converts pure red hue correctly', () => {\n        expect(hslToRgb(0, 100, 50)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n\n    test('returns gray for zero saturation', () => {\n        expect(hslToRgb(240, 0, 50)).toEqual({ r: 128, g: 128, b: 128 });\n    });\n\n    test('returns white for full lightness', () => {\n        expect(hslToRgb(120, 50, 100)).toEqual({ r: 255, g: 255, b: 255 });\n    });\n\n    test('converts full saturation and mid lightness blue correctly', () => {\n        expect(hslToRgb(240, 100, 50)).toEqual({ r: 0, g: 0, b: 255 });\n    });\n\n    test('handles edge hue at 360 degrees correctly', () => {\n        expect(hslToRgb(360, 100, 50)).toEqual({ r: 255, g: 0, b: 0 }); // Should be the same as hue 0\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}",
    "addition_info": ""
  },
  {
    "task_id": 119,
    "code_type": "method",
    "code_signature": "/**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('getCookie function tests', () => {\n    beforeEach(() => {\n        // Clear cookies before each test\n        Object.defineProperty(window.document, 'cookie', {\n            writable: true,\n            value: '',\n        });\n    });\n\n    test('returns correct cookie value for existing cookie', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n\n    test('returns undefined if cookie does not exist', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('user')).toBeFalsy();\n    });\n\n\n    test('returns undefined when no cookies are set', () => {\n        expect(getCookie('username')).toBeFalsy();\n    });\n\n    test('handles multiple cookies and retrieves the correct one', () => {\n        document.cookie = \"user=JaneDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}",
    "addition_info": "/**\n * @jest-environment jsdom\n */"
  },
  {
    "task_id": 120,
    "code_type": "method",
    "code_signature": "/**\n * Extract table question from a document object containing HTML tables and return the question organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  ",
    "code_language": "javascript",
    "test_code": "const { JSDOM } = require('jsdom');\n\ndescribe('HTML to CSV Extraction Tests', () => {\n  const createMockDocument = (html) => {\n    const dom = new JSDOM(html);\n    return dom.window.document;\n  };\n\n  const extractCSVDataFromHTML = (document) => {\n    const rows = document.querySelectorAll('table.waffle tbody tr');\n    return Array.from(rows).map(row =>\n      Array.from(row.cells).map(cell => cell.textContent || \"\")\n    );\n  };\n\n  test('Table with multiple rows and columns', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td>Cell 2</td></tr>\n          <tr><td>Cell 3</td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"Cell 2\"], [\"Cell 3\", \"Cell 4\"]]);\n  });\n\n  test('Table with empty cells', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td></td></tr>\n          <tr><td></td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"\"], [\"\", \"Cell 4\"]]);\n  });\n\n  test('Table with only one row', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Single Cell 1</td><td>Single Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Single Cell 1\", \"Single Cell 2\"]]);\n  });\n\n  test('Table with only one column', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Column Cell 1</td></tr>\n          <tr><td>Column Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Column Cell 1\"], [\"Column Cell 2\"]]);\n  });\n\n  test('No table with the class \"waffle\" present', () => {\n    const testCaseHTML = `\n      <div>\n        <p>No table here!</p>\n      </div>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([]);\n  });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Extract table question from a document object containing HTML tables and return the question organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  ",
    "addition_info": ""
  },
  {
    "task_id": 121,
    "code_type": "method",
    "code_signature": "/**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n",
    "code_language": "javascript",
    "test_code": "describe('adjustArrayLength function tests', () => {\n    test('Array length equal to the target length', () => {\n        const result = adjustArrayLength(5, [1, 2, 3, 4, 5]);\n        expect(result).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test('Array length shorter than the target length', () => {\n        const result = adjustArrayLength(8, [1, 2, 3]);\n        expect(result).toEqual([1, 2, 3, 1, 2, 3, 1, 2]);\n    });\n\n    test('Array length shorter than the target length, target length is a multiple of array length', () => {\n        const result = adjustArrayLength(6, [10, 20]);\n        expect(result).toEqual([10, 20, 10, 20, 10, 20]);\n    });\n\n    test('Array length shorter than the target length, target length is not a multiple of array length', () => {\n        const result = adjustArrayLength(7, [7, 14, 21]);\n        expect(result).toEqual([7, 14, 21, 7, 14, 21, 7]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 122,
    "code_type": "method",
    "code_signature": "/**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n",
    "code_language": "javascript",
    "test_code": "describe('safeSplice', () => {\n    test('replaces removed elements with a new element', () => {\n        const inputArray = ['a', 'b', 'c', 'd', 'e'];\n        const expected = ['a', 'z', 'e'];\n        expect(safeSplice(inputArray, 3, 1, 'z')).toEqual(expected);\n    });\n    test('should remove specified elements and replace with new element', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 1;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 99, 4, 5]);\n    });\n\n    test('should handle removing elements from the end of the array', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 3;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        expect(result).toEqual([1, 2, 3]);\n    });\n\n    test('should handle the case where no elements are removed', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 0;\n        const indexToRemove = 2;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 2, 99, 3, 4, 5]);\n    });\n\n    test('should handle edge case with an empty input array', () => {\n        const inputArray = [];\n        const amountToRemove = 1;\n        const indexToRemove = 0;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([99]);\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 123,
    "code_type": "method",
    "code_signature": "/**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n",
    "code_language": "javascript",
    "test_code": "describe('scaleToRange function tests', () => {\n    test('simple scaling', () => {\n        const result = scaleToRange([1, 2, 3, 4, 5], 1, 5, 10, 50);\n        expect(result).toEqual([10, 20, 30, 40, 50]);\n    });\n\n    test('scaling with negative input range', () => {\n        const result = scaleToRange([-5, 0, 5], -5, 5, 0, 100);\n        expect(result).toEqual([0, 50, 100]);\n    });\n\n    test('scaling with negative output range', () => {\n        const result = scaleToRange([0, 50, 100], 0, 100, -100, 100);\n        expect(result).toEqual([-100, 0, 100]);\n    });\n\n    test('input array containing the same value', () => {\n        const result = scaleToRange([2, 2, 2], 1, 3, 0, 10);\n        expect(result).toEqual([5, 5, 5]);\n    });\n\n    test('input value out of range should throw an error', () => {\n        expect(() => {\n            scaleToRange([1, 2, 3, 6], 1, 5, 0, 10);\n        }).toThrow();\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 124,
    "code_type": "method",
    "code_signature": "/**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n",
    "code_language": "javascript",
    "test_code": "describe('shuffle function tests', () => {\n    test('shuffles an array of numbers', () => {\n        const array = [1, 2, 3, 4, 5];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n        expect(new Set(shuffledArray).size).toEqual(new Set(array).size); // Ensure no duplicates\n    });\n\n    test('shuffles an array of strings', () => {\n        const array = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with duplicate elements', () => {\n        const array = [1, 1, 2, 2, 3, 3];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with a single element', () => {\n        const array = [42];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray).toEqual(array);\n    });\n\n    test('shuffles an empty array', () => {\n        const array = [];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(0);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 125,
    "code_type": "method",
    "code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('compressHTML', () => {\n    test('should remove leading and trailing spaces around tags', () => {\n        const input = '  <div>  <p>Test</p>  </div>  ';\n        const expected = '<div><p>Test</p></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should replace multiple newlines with a single space', () => {\n        const input = '<div>\\n\\n<p>Test</p>\\n\\n</div>';\n        const expected = '<div> <p>Test</p> </div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should remove unnecessary spaces within text', () => {\n        const input = '<p>This    is a test</p>';\n        const expected = '<p>This is a test</p>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle empty strings', () => {\n        const input = '';\n        const expected = '';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should process complex nested HTML correctly', () => {\n        const input = '<div>   <span>    Text <i>    Italic </i> more text </span>   </div>';\n        const expected = '<div><span>Text <i>Italic</i> more text</span></div>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should not disrupt content within <pre> and <textarea> tags', () => {\n        const input = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>';\n        const expected = '<pre>\\n    function example() {\\n        console.log(\"example\");\\n    }\\n</pre>'; // assuming no changes in <pre> and <textarea>\n        expect(compressHTML(input)).toBe(expected);\n    });\n\n    test('should handle HTML with attributes correctly', () => {\n        const input = '<a href=\"http://example.com\"    title=\"Example\" >Link</a>';\n        const expected = '<a href=\"http://example.com\" title=\"Example\">Link</a>';\n        expect(compressHTML(input)).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <div>, <script>, and <style> tags.\n * For example:\n *      input: '   <div>   Content  </div>   '\n *      output: '<div> Content </div>'\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 126,
    "code_type": "method",
    "code_signature": "/**\n * Calculates the great-circle distance between two points on the Earth\n * using their latitude and longitude based on the Haversine formula.\n *\n * @param {number} lat1 - Latitude of the first point in degrees.\n * @param {number} lon1 - Longitude of the first point in degrees.\n * @param {number} lat2 - Latitude of the second point in degrees.\n * @param {number} lon2 - Longitude of the second point in degrees.\n * @returns {number} The distance between the two points in kilometers.\n */\nfunction calculateDistance(lat1, lon1, lat2, lon2) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('calculateDistance', () => {\n    test('calculates distance between two points in the same city', () => {\n        // Coordinates for two points in Los Angeles\n        const distance = calculateDistance(34.052235, -118.243683, 34.052236, -118.243684);\n        expect(distance).toBeCloseTo(0.00013, 4);  // The distance should be very small\n    });\n\n    test('calculates distance between two major cities', () => {\n        // Coordinates for Los Angeles and New York\n        const distance = calculateDistance(34.052235, -118.243683, 40.712776, -74.005974);\n        const expectedDistance = 3940;  // Known distance is approximately 3940 kilometers\n        const tolerance = 30;  // Tolerance of 30 kilometers\n        expect(distance).toBeGreaterThan(expectedDistance - tolerance);\n        expect(distance).toBeLessThan(expectedDistance + tolerance);\n    });\n\n    test('calculates distance between two points in different continents', () => {\n        // Coordinates for New York in the USA and London in the UK\n        const distance = calculateDistance(40.712776, -74.005974, 51.507351, -0.127758);\n        const expectedDistance = 5567;  // Known distance is approximately 3940 kilometers\n        const tolerance = 30;  // Tolerance of 30 kilometers\n        expect(distance).toBeGreaterThan(expectedDistance - tolerance);\n        expect(distance).toBeLessThan(expectedDistance + tolerance);\n    });\n\n    test('handles zero distance when the same coordinates are given', () => {\n        // Same coordinates for a location in Paris\n        const distance = calculateDistance(48.8566, 2.3522, 48.8566, 2.3522);\n        expect(distance).toBe(0);  // Distance should be zero\n    });\n\n    test('calculates correct distance with negative and positive longitude and latitude', () => {\n        // Coordinates for Sydney and Auckland\n        const distance = calculateDistance(-33.8688, 151.2093, -36.8485, 174.7633);\n        const expectedDistance = 2159;  // Known distance is approximately 3940 kilometers\n        const tolerance = 30;  // Tolerance of 30 kilometers\n        expect(distance).toBeGreaterThan(expectedDistance - tolerance);\n        expect(distance).toBeLessThan(expectedDistance + tolerance);\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the great-circle distance between two points on the Earth\n * using their latitude and longitude based on the Haversine formula.\n *\n * @param {number} lat1 - Latitude of the first point in degrees.\n * @param {number} lon1 - Longitude of the first point in degrees.\n * @param {number} lat2 - Latitude of the second point in degrees.\n * @param {number} lon2 - Longitude of the second point in degrees.\n * @returns {number} The distance between the two points in kilometers.\n */\nfunction calculateDistance(lat1, lon1, lat2, lon2) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 127,
    "code_type": "method",
    "code_signature": "/**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('separateOctaveAndRoot', () => {\n    test('correctly separates MIDI notes into octaves and root notes', () => {\n        const midiNotes = [60, 61, 62];  // C4, C#4, D4\n        const expected = {\n            octaveNotes: [5, 5, 5],  // All notes are in the 5th octave\n            rootNotes: [0, 1, 2]     // Root notes are C, C#, D\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('handles single MIDI note input', () => {\n        const midiNotes = [24];  // C1\n        const expected = {\n            octaveNotes: [2],  // 2nd octave\n            rootNotes: [0]     // C note\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('returns empty arrays for an empty input array', () => {\n        const midiNotes = [];\n        const expected = {\n            octaveNotes: [],\n            rootNotes: []\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('throws an error for invalid input types', () => {\n        const invalidInput = \"not an array\";\n        expect(() => separateOctaveAndRoot(invalidInput)).toThrow(TypeError);\n        expect(() => separateOctaveAndRoot([3.14])).toThrow(TypeError);\n    });\n\n    test('handles MIDI notes from different octaves', () => {\n        const midiNotes = [12, 25, 37];  // C1, C#2, D#3\n        const expected = {\n            octaveNotes: [1, 2, 3],  // 1st, 2nd, and 3rd octaves\n            rootNotes: [0, 1, 1]     // Root notes are C, C#, D#\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 129,
    "code_type": "method",
    "code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('validURL', () => {\n    test('validates a standard HTTP URL', () => {\n        const url = 'http://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('validates a secure HTTPS URL', () => {\n        const url = 'https://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('rejects a malformed URL', () => {\n        const url = 'htp:/www.example.com';\n        expect(validURL(url)).toBe(false);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 130,
    "code_type": "method",
    "code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('computePi', () => {\n    test('should calculate pi to 5 decimal places correctly', () => {\n        const digits = 5;\n        const expected = '3.14159';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 10 decimal places correctly', () => {\n        const digits = 10;\n        const expected = '3.1415926536';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 15 decimal places correctly', () => {\n        const digits = 15;\n        const expected = '3.141592653589793';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 20 decimal places correctly', () => {\n        const digits = 20;\n        const expected = '3.14159265358979323846';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 30 decimal places correctly', () => {\n        const digits = 30;\n        const expected = '3.141592653589793238462643383280';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 131,
    "code_type": "method",
    "code_signature": "/**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('checkCSSHighlightAndAdd', () => {\n    beforeEach(() => {\n        // Clean up the document head and ensure at least one style sheet exists before each test\n        document.head.innerHTML = '<style></style>';\n    });\n\n    test('should add a new style element with the highlight CSS rule if it does not exist', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the style element contains the correct CSS rule\n        const styleElement = document.querySelector('style');\n        expect(styleElement.sheet.cssRules[0].cssText).toContain(\"background-color: yellow;\");\n    });\n\n    test('should not add a new CSS rule if the CSS rule already exists', () => {\n        // Manually add the rule to simulate existing condition\n        document.styleSheets[0].insertRule(\".highlight { background-color: yellow; }\", 0);\n\n        checkCSSHighlightAndAdd();\n\n        // Check that only one rule is present\n        expect(document.styleSheets[0].cssRules.length).toBe(2);\n    });\n\n    test('should add only one rule even if called multiple times', () => {\n        checkCSSHighlightAndAdd();\n        checkCSSHighlightAndAdd();  // Call the function again\n\n        // Check that only one rule is present\n        expect(document.styleSheets[0].cssRules.length).toBe(2);\n    });\n\n    test('should correctly append the style element to the document head', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the style element is indeed appended to the head\n        const styleElement = document.head.querySelector('style');\n        expect(document.head.contains(styleElement)).toBe(true);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}",
    "addition_info": "/**\n * @jest-environment jsdom\n */"
  },
  {
    "task_id": 132,
    "code_type": "method",
    "code_signature": "/**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes question to a file synchronously.\n *\n * @param {string} filePath - The path to the file where question will be written.\n * @param {string} data - The question to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}",
    "code_language": "javascript",
    "test_code": "// Mock fs in your Jest tests\njest.mock('fs');\n\ndescribe('File Utility Functions', () => {\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('readFile should return file content as a string', () => {\n        const mockContent = 'Hello, world!';\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/file.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/file.txt', 'utf8');\n    });\n\n    test('readFile should return an empty string for an empty file', () => {\n        const mockContent = '';\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/emptyfile.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/emptyfile.txt', 'utf8');\n    });\n\n    test('readFile should throw an error if file cannot be read', () => {\n        fs.readFileSync.mockImplementation(() => {\n            throw new Error('File not found');\n        });\n\n        expect(() => readFile('/invalid/path.txt')).toThrow();\n    });\n\n    test('writeFile should throw an error if file cannot be written', () => {\n        fs.writeFileSync.mockImplementation(() => {\n            throw new Error('Permission denied');\n        });\n\n        expect(() => writeFile('/invalid/path.txt', 'data')).toThrow();\n    });\n    test('readFile should handle large files correctly', () => {\n        const mockContent = 'a'.repeat(10000); // 10,000 characters long string\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/largefile.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/largefile.txt', 'utf8');\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes question to a file synchronously.\n *\n * @param {string} filePath - The path to the file where question will be written.\n * @param {string} data - The question to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}",
    "addition_info": "const fs = require('fs');"
  },
  {
    "task_id": 135,
    "code_type": "method",
    "code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('isValidPortNumber', () => {\n    test('returns true for a valid port number in the middle of the range', () => {\n        expect(isValidPortNumber(8080)).toBe(true);\n    });\n\n    test('returns true for the lowest valid port number', () => {\n        expect(isValidPortNumber(1)).toBe(true);\n    });\n\n    test('returns true for the highest valid port number', () => {\n        expect(isValidPortNumber(65535)).toBe(true);\n    });\n\n    test('returns false for a port number below the valid range', () => {\n        expect(isValidPortNumber(0)).toBe(false);\n    });\n\n    test('returns false for a port number above the valid range', () => {\n        expect(isValidPortNumber(65536)).toBe(false);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 137,
    "code_type": "method",
    "code_signature": "/**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('mergeObjects', () => {\n    test('correctly merges two objects with non-conflicting keys', () => {\n        const obj1 = { name: \"Alice\" };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('properties from the second object overwrite properties from the first', () => {\n        const obj1 = { name: \"Alice\", age: 25 };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('merges objects with nested structures correctly', () => {\n        const obj1 = { user: { name: \"Alice\", age: 25 } };\n        const obj2 = { user: { age: 30 } };\n        const expected = { user: { age: 30 } };  // Note: obj2 does not merge deeply, it replaces the entire 'user' object\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 138,
    "code_type": "method",
    "code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('removePunctuation', () => {\n    test('removes punctuation from a simple sentence', () => {\n        const input = \"Hello, world!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('handles a string with no punctuation', () => {\n        const input = \"Hello world\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('converts mixed case letters to lowercase', () => {\n        const input = \"HeLLo WoRLd!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('removes a variety of punctuation', () => {\n        const input = \"Life, in a nutshell: eat, sleep, code!\";\n        const expected = \"life in a nutshell eat sleep code\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('trims whitespace from the ends of the string', () => {\n        const input = \"   What a wonderful world!   \";\n        const expected = \"what a wonderful world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 139,
    "code_type": "method",
    "code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('parseCategoriesFromSummary', () => {\n    test('extracts categories and cleans the summary correctly', () => {\n        const input = \"This is a summary. Categories: [Technology, Health]\";\n        const expected = {\n            summary: \"This is a summary.\",\n            categories: [\"Technology\", \"Health\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('returns empty categories and original summary when no categories are present', () => {\n        const input = \"This is a summary without categories.\";\n        const expected = {\n            summary: \"This is a summary without categories.\",\n            categories: []\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('ignores case of the category prefix', () => {\n        const input = \"Summary text. categories: [Education, Science]\";\n        const expected = {\n            summary: \"Summary text.\",\n            categories: [\"Education\", \"Science\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('handles extra spaces and malformed category strings correctly', () => {\n        const input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        const expected = {\n            summary: \"Details follow.\",\n            categories: [\"Business\", \"Finance\"]  // Note the removal of an empty string due to extra commas\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('removes the category string correctly even if it appears in the middle of the summary', () => {\n        const input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        const expected = {\n            summary: \"Beginning of summary. Continuation of summary.\",\n            categories: [\"Art\", \"Design\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized question.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 292,
    "code_type": "method",
    "code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments) {\n}",
    "code_language": "javascript",
    "test_code": "describe('calculateRemainingPayment', () => {\n  test('calculates remaining balance for typical loan conditions', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 24)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for high interest rate', () => {\n    expect(calculateRemainingPayment(10000, 0.1, 12)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for low interest rate', () => {\n    expect(calculateRemainingPayment(10000, 0.001, 60)).toBeCloseTo(0);\n  });\n\n  test('calculates remaining balance for very short term', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 1)).toBeCloseTo(0);\n  });\n\n\n  test('calculates remaining balance with no payments', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 0)).toBeCloseTo(10000);\n  });\n\n  test('calculates remaining balance for a long term', () => {\n    expect(calculateRemainingPayment(10000, 0.005, 360)).toBeCloseTo(0);\n  });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 293,
    "code_type": "method",
    "code_signature": "/**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n",
    "code_language": "javascript",
    "test_code": "describe('reorderData', () => {\n    test('sorts question correctly for basic inputs', () => {\n        const scores = [3, 1, 2];\n        const names = ['Image3', 'Image1', 'Image2'];\n        const ids = [103, 101, 102];\n        const expected = {\n            resultScores: [1, 2, 3],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('sorts question correctly with mixed scores', () => {\n        const scores = [5, 1, 3, 5, 2];\n        const names = ['Image5', 'Image1', 'Image3', 'Image6', 'Image2'];\n        const ids = [105, 101, 103, 106, 102];\n        const expected = {\n            resultScores: [1, 2, 3, 5, 5],\n            resultNames: ['Image1', 'Image2', 'Image3', 'Image5', 'Image6'],\n            resultIDs: [101, 102, 103, 105, 106]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles duplicate scores', () => {\n        const scores = [2, 2, 1];\n        const names = ['Image2', 'Image3', 'Image1'];\n        const ids = [102, 103, 101];\n        const expected = {\n            resultScores: [1, 2, 2],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles empty arrays', () => {\n        const scores = [];\n        const names = [];\n        const ids = [];\n        const expected = {\n            resultScores: [],\n            resultNames: [],\n            resultIDs: []\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Reorders image question based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n",
    "addition_info": ""
  },
  {
    "task_id": 298,
    "code_type": "method",
    "code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}",
    "code_language": "javascript",
    "test_code": "describe('setEurValue', () => {\n    test('formats standard values correctly', () => {\n        expect(setEurValue('250')).toBe('250');\n        expect(setEurValue('2500')).toBe('2.5k');\n    });\n\n    test('handles boundary values accurately', () => {\n        expect(setEurValue('999')).toBe('999');\n        expect(setEurValue('1000')).toBe('1.0k');\n        expect(setEurValue('999999')).toBe('1000.0k');\n        expect(setEurValue('1000000')).toBe('1.0m');\n    });\n\n    test('returns correct format for zero and negative inputs', () => {\n        expect(setEurValue('0')).toBe('0');\n    });\n\n    test('returns an empty string for invalid inputs', () => {\n        expect(setEurValue('hello')).toBe('');\n        expect(setEurValue(null)).toBe('');\n        expect(setEurValue(undefined)).toBe('');\n    });\n\n    test('ensures precision for large numbers', () => {\n        expect(setEurValue('10000000')).toBe('10.0m');\n        expect(setEurValue('987654321')).toBe('987.7m');\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 299,
    "code_type": "method",
    "code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n",
    "code_language": "javascript",
    "test_code": "describe('setEurValue', () => {\n    test('Birthday today, should be 24 years old', () => {\n        expect(calculateAge('2000-08-23')).toBe('2000-08-23 (24)')\n    });\n\n    test('Birthday has passed this year, should be 34 years old', () => {\n        expect(calculateAge('1990-01-15')).toBe('1990-01-15 (34)')\n    });\n\n    test('Birthday at the end of the year, should be 38 years old', () => {\n        expect(calculateAge('1985-12-31')).toBe('1985-12-31 (38)')\n    });\n\n    test('Recently turned 1 year old this year', () => {\n        expect(calculateAge('2023-05-05')).toBe('2023-05-05 (1)')\n    });\n\n\n    test('Invalid date input should return an empty string', () => {\n        expect(calculateAge('invalid-date')).toBe('')\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 300,
    "code_type": "method",
    "code_signature": "/**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('removeAds', () => {\n    beforeEach(() => {\n        // Reset the DOM before each test.js\n        document.body.innerHTML = '';\n    });\n\n    test('removes a single sponsored product', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Sponsored');\n    });\n\n    test('removes multiple sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(4);\n        expect(listItems[0].textContent).toBe('Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n\n    test('does not remove any items if there are no sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>Regular Item</li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Regular Item');\n        expect(listItems[1].textContent).toBe('Another Regular Item');\n    });\n\n    test('removes items with nested sponsored indicators', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>\n                    <div>\n                        <span class=\"css-16lshh0\">Sponsored</span>\n                    </div>\n                </li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n    });\n\n    test('does not remove items with similar but non-sponsored class names', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh1\">Not Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Not Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n});\n\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}",
    "addition_info": "/**\n * @jest-environment jsdom\n */"
  },
  {
    "task_id": 305,
    "code_type": "class",
    "code_signature": "/**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}",
    "code_language": "javascript",
    "test_code": "describe('SeededRandom', () => {\n    test('generates consistent numbers with the same seed', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(42);\n\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('generates different numbers with different seeds', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(24);\n\n        expect(seededRand1.rand()).not.toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('returns numbers between 0 and 1', () => {\n        const seededRand = new SeededRandom(123456);\n\n        for (let i = 0; i < 1000; i++) {\n            const randValue = seededRand.rand();\n            expect(randValue).toBeGreaterThanOrEqual(0);\n            expect(randValue).toBeLessThan(1);\n        }\n    });\n\n    test('produces different sequences with different seeds', () => {\n        const seededRand1 = new SeededRandom(123);\n        const seededRand2 = new SeededRandom(456);\n\n        const sequence1 = Array.from({ length: 5 }, () => seededRand1.rand());\n        const sequence2 = Array.from({ length: 5 }, () => seededRand2.rand());\n\n        expect(sequence1).not.toEqual(sequence2);\n    });\n\n    test('consistent sequence with the same seed over multiple calls', () => {\n        const seededRand = new SeededRandom(987654321);\n\n        const sequence1 = [seededRand.rand(), seededRand.rand(), seededRand.rand()];\n\n        // Re-initialize with the same seed to test.js consistency\n        const seededRand2 = new SeededRandom(987654321);\n        const sequence2 = [seededRand2.rand(), seededRand2.rand(), seededRand2.rand()];\n\n        expect(sequence1).toEqual(sequence2);\n    });\n});\n",
    "prompt": "please write a javascript class , the class signature as below /**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}",
    "addition_info": ""
  },
  {
    "task_id": 306,
    "code_type": "method",
    "code_signature": "/**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('getPrice', () => {\n    test('should return a number within the default range for a given recipe ID', () => {\n        const price = getPrice('recipe123');\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n\n    test('should return the same price for the same recipe ID', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe123');\n        expect(price1).toBe(price2);\n    });\n\n    test('should return different prices for different recipe IDs', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe456');\n        expect(price1).not.toBe(price2);\n    });\n\n    test('should return a price within a custom range', () => {\n        const minVal = 20;\n        const maxVal = 50;\n        const price = getPrice('recipe789', minVal, maxVal);\n        expect(price).toBeGreaterThanOrEqual(minVal);\n        expect(price).toBeLessThanOrEqual(maxVal);\n    });\n\n    test('should handle very long recipe IDs without error', () => {\n        const longRecipeId = 'recipe' + 'A'.repeat(1000);\n        const price = getPrice(longRecipeId);\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 308,
    "code_type": "method",
    "code_signature": "/**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('getCurrentDate', () => {\n    test('should return a string in the format YYYY-MM-DD', () => {\n        const date = getCurrentDate();\n        expect(typeof date).toBe('string');\n        expect(date).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n    });\n\n    test('should return the correct date for today', () => {\n        const expectedDate = new Date().toISOString().split('T')[0];\n        const actualDate = getCurrentDate();\n        expect(actualDate).toBe(expectedDate);\n    });\n\n    test('should return the correct year part in YYYY-MM-DD', () => {\n        const currentYear = new Date().getFullYear().toString();\n        const actualDate = getCurrentDate();\n        expect(actualDate.startsWith(currentYear)).toBe(true);\n    });\n\n    test('should return the correct month part in YYYY-MM-DD', () => {\n        const currentMonth = (`0${new Date().getMonth() + 1}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(5, 7)).toBe(currentMonth);\n    });\n\n    test('should return the correct day part in YYYY-MM-DD', () => {\n        const currentDay = (`0${new Date().getDate()}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(8, 10)).toBe(currentDay);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 313,
    "code_type": "method",
    "code_signature": "/**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}",
    "code_language": "javascript",
    "test_code": "/**\n * @jest-environment jsdom\n */\n\ndescribe('isBackgroundTooDarkOrBright', () => {\n    let mainElement;\n\n    beforeEach(() => {\n        // Create a 'main' element and append it to the document body\n        mainElement = document.createElement('main');\n        document.body.appendChild(mainElement);\n    });\n\n    afterEach(() => {\n        // Clean up by removing the 'main' element after each test.js\n        document.body.removeChild(mainElement);\n    });\n\n    test('should return \"dark\" for a dark background color', () => {\n        // Set a dark background color\n        mainElement.style.backgroundColor = 'rgb(30, 30, 30)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n\n    test('should return \"bright\" for a bright background color', () => {\n        // Set a bright background color\n        mainElement.style.backgroundColor = 'rgb(250, 250, 250)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('bright');\n    });\n\n    test('should return \"normal\" for a background color with normal brightness', () => {\n        // Set a background color with normal brightness\n        mainElement.style.backgroundColor = 'rgb(150, 150, 150)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a bright color with high red component', () => {\n        // Set a bright color with a high red component\n        mainElement.style.backgroundColor = 'rgb(255, 100, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a dark color with low green and blue components', () => {\n        // Set a dark color with low green and blue components\n        mainElement.style.backgroundColor = 'rgb(10, 10, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}",
    "addition_info": "/**\n * @jest-environment jsdom\n */"
  },
  {
    "task_id": 315,
    "code_type": "method",
    "code_signature": "/**\n * Extract the fileid from the given URL query args.If not find return null\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {\n}",
    "code_language": "javascript",
    "test_code": "describe('getFileIdFromUrl', () => {\n    test('should return the file ID when a valid URL with fileId is provided', () => {\n        const url = 'https://example.com/download?fileId=12345';\n        expect(getFileIdFromUrl(url)).toBe('12345');\n    });\n\n    test('should return null when the fileId query parameter is missing', () => {\n        const url = 'https://example.com/download';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n    test('should return null when the fileId query parameter is empty', () => {\n        const url = 'https://example.com/download?fileId=';\n        expect(getFileIdFromUrl(url)).toBeNull();\n    });\n\n\n\n    test('should return null for a malformed URL', () => {\n        const url = 'https://example.com/download?fileId=12345&otherParam';\n        expect(getFileIdFromUrl(url)).toBe('12345'); // Adjust this depending on your needs; the function should still work correctly.\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Extract the fileid from the given URL query args.If not find return null\n * For example:\n *      input: https://example.com/download?fileId=12345\n *      output: 12345\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 317,
    "code_type": "method",
    "code_signature": "/**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str) {}",
    "code_language": "javascript",
    "test_code": "describe('countLetters', () => {\n    test('should return 10 for the string \"Hello, World!\"', () => {\n        expect(countLetters(\"Hello, World!\")).toBe(10);\n    });\n\n    test('should return 0 for a string with no letters \"12345\"', () => {\n        expect(countLetters(\"12345\")).toBe(0);\n    });\n\n    test('should return 6 for the string \"abc 123 xyz!\"', () => {\n        expect(countLetters(\"abc 123 xyz!\")).toBe(6);\n    });\n\n    test('should return 0 for an empty string', () => {\n        expect(countLetters(\"\")).toBe(0);\n    });\n\n    test('should return 3 for the string \"A1B2C3!@#\"', () => {\n        expect(countLetters(\"A1B2C3!@#\")).toBe(3);\n    });\n\n    test('should return 5 for a string with mixed case \"AbCdE\"', () => {\n        expect(countLetters(\"AbCdE\")).toBe(5);\n    });\n\n    test('should return 8 for a string with special characters \"Hello@2024!\"', () => {\n        expect(countLetters(\"Hello@2024!\")).toBe(5);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Count the number of letters in a string.\n *\n * @param {string} str - The input string from which to count letters.\n * @returns {number} - The count of letters in the string.\n */\nfunction countLetters(str) {}",
    "addition_info": ""
  },
  {
    "task_id": 318,
    "code_type": "method",
    "code_signature": "/**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}",
    "code_language": "javascript",
    "test_code": "// Jest test cases for countNumbers function\ndescribe('countNumbers', () => {\n    test('should return the correct count for a string with multiple numbers', () => {\n        const result = countNumbers('There are 123 numbers in this string.');\n        expect(result).toBe(3); // '123' contains three numeric characters\n    });\n\n    test('should return 0 for a string with no numbers', () => {\n        const result = countNumbers('No numbers here!');\n        expect(result).toBe(0); // No numeric characters in 'No numbers here!'\n    });\n\n    test('should return the correct count for a string with mixed characters', () => {\n        const result = countNumbers('Room 101 and Room 102');\n        expect(result).toBe(6); // '101' and '102' together contain six numeric characters\n    });\n\n    test('should return the correct count for a string with only numbers', () => {\n        const result = countNumbers('1234567890');\n        expect(result).toBe(10); // '1234567890' contains ten numeric characters\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countNumbers('');\n        expect(result).toBe(0); // An empty string contains no numeric characters\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 319,
    "code_type": "method",
    "code_signature": "/**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}",
    "code_language": "javascript",
    "test_code": "describe('countDashes', () => {\n    test('should return 0 for a string with no dashes', () => {\n        const result = countDashes('hello world');\n        expect(result).toBe(0); // 'hello world' contains no dashes\n    });\n\n    test('should return 1 for a string with one dash', () => {\n        const result = countDashes('hello-world');\n        expect(result).toBe(1); // 'hello-world' contains one dash\n    });\n\n    test('should return 4 for a string with multiple dashes', () => {\n        const result = countDashes('a-b-c-d-e');\n        expect(result).toBe(4); // 'a-b-c-d-e' contains four dashes\n    });\n\n    test('should return 2 for a string with dashes at the beginning and end', () => {\n        const result = countDashes('-start-end-');\n        expect(result).toBe(3); // '-start-end-' contains two dashes\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countDashes('');\n        expect(result).toBe(0); // An empty string contains no dashes\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 320,
    "code_type": "method",
    "code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}",
    "code_language": "javascript",
    "test_code": "describe('getArrayAverage', () => {\n    test('should return the average of an array of positive integers', () => {\n        const result = getArrayAverage([1, 2, 3, 4, 5]);\n        expect(result).toBe(3); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    });\n\n    test('should return the average of an array with negative numbers', () => {\n        const result = getArrayAverage([-1, -2, -3, -4, -5]);\n        expect(result).toBe(-3); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    });\n\n    test('should return the average of an array with mixed positive and negative numbers', () => {\n        const result = getArrayAverage([1, -1, 2, -2, 3, -3]);\n        expect(result).toBe(0); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    });\n\n    test('should handle an empty array (edge case)', () => {\n        const result = getArrayAverage([]);\n        expect(result).toBeNaN(); // Division by zero, expected model_answer_result is NaN\n    });\n\n    test('should return the single element when the array contains one item', () => {\n        const result = getArrayAverage([7]);\n        expect(result).toBe(7); // The average of [7] is 7\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 322,
    "code_type": "method",
    "code_signature": "/**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}",
    "code_language": "javascript",
    "test_code": "describe('isValidEmail', () => {\n    test('should return true for a valid simple email', () => {\n        const result = isValidEmail('test@example.com');\n        expect(result).toBe(true); // 'test@example.com' is a valid email\n    });\n\n    test('should return true for a valid email with subdomain', () => {\n        const result = isValidEmail('user@mail.example.com');\n        expect(result).toBe(true); // 'user@mail.example.com' is a valid email\n    });\n\n    test('should return false for an email missing the @ symbol', () => {\n        const result = isValidEmail('invalid-email.com');\n        expect(result).toBe(false); // 'invalid-email.com' is missing the @ symbol\n    });\n\n    test('should return false for an email missing the domain part', () => {\n        const result = isValidEmail('user@.com');\n        expect(result).toBe(false); // 'user@.com' is missing a valid domain name\n    });\n\n    test('should return false for an email with spaces', () => {\n        const result = isValidEmail('user name@example.com');\n        expect(result).toBe(false); // 'user name@example.com' contains spaces\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 323,
    "code_type": "method",
    "code_signature": "/**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n",
    "code_language": "javascript",
    "test_code": "describe('isValidUsername', () => {\n    test('should return true for a valid username with letters, numbers, and underscores', () => {\n        const result = isValidUsername('user_123');\n        expect(result).toBe(true); // 'user_123' is a valid username\n    });\n\n    test('should return true for a valid username with only letters', () => {\n        const result = isValidUsername('username');\n        expect(result).toBe(true); // 'username' is a valid username\n    });\n\n    test('should return false for a username with special characters', () => {\n        const result = isValidUsername('user-name');\n        expect(result).toBe(false); // 'user-name' contains a hyphen\n    });\n\n    test('should return false for a username with spaces', () => {\n        const result = isValidUsername('user name');\n        expect(result).toBe(false); // 'user name' contains spaces\n    });\n\n    test('should return true for a valid username with only numbers', () => {\n        const result = isValidUsername('12345');\n        expect(result).toBe(true); // '12345' is a valid username\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 326,
    "code_type": "method",
    "code_signature": "/**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: days,\n *         hours: remainingHours,\n *         minutes: remainingMinutes,\n * }\n */\nfunction calculateTimeDifference(givenDate) {\n}",
    "code_language": "javascript",
    "test_code": "describe('calculateTimeDifference', () => {\n    test('should return correct time difference for a date in the past', () => {\n        const pastDate = new Date(Date.now() - 3 * 24 * 60 * 60 * 1000 - 5 * 60 * 1000); // 3 days and 5 minutes ago\n        const result = calculateTimeDifference(pastDate);\n        expect(result).toEqual({ days: 3, hours: 0, minutes: 5 });\n    });\n\n    test('should return correct time difference for a date that is exactly now', () => {\n        const now = new Date();\n        const result = calculateTimeDifference(now);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date just seconds ago', () => {\n        const justNow = new Date(Date.now() - 45 * 1000); // 45 seconds ago\n        const result = calculateTimeDifference(justNow);\n        expect(result).toEqual({ days: 0, hours: 0, minutes: 0 });\n    });\n\n\n    test('should return correct time difference for a date with only hours difference', () => {\n        const hoursAgo = new Date(Date.now() - 7 * 60 * 60 * 1000); // 7 hours ago\n        const result = calculateTimeDifference(hoursAgo);\n        expect(result).toEqual({ days: 0, hours: 7, minutes: 0 });\n    });\n\n    test('should return correct time difference for a date with hours and minutes difference', () => {\n        const hoursAndMinutesAgo = new Date(Date.now() - (1 * 24 * 60 * 60 * 1000 + 3 * 60 * 1000)); // 1 day and 3 minutes ago\n        const result = calculateTimeDifference(hoursAndMinutesAgo);\n        expect(result).toEqual({ days: 1, hours: 0, minutes: 3 });\n    });\n\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the time difference between a given date and the current date.\n *\n * @param {Date | string} givenDate - The date to compare against the current date.\n * @returns {Object} - An object containing days, hours, and minutes elapsed.\n * {\n *         days: days,\n *         hours: remainingHours,\n *         minutes: remainingMinutes,\n * }\n */\nfunction calculateTimeDifference(givenDate) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 447,
    "code_type": "method",
    "code_signature": "/**\n * Calculate age based on the birth date string entered by the user.Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns {string|number}\n */\nfunction calculateAge(birthDateString) {\n}\n",
    "code_language": "javascript",
    "test_code": "describe('calculateAge', () => {\n    test('calculates age correctly for a birth date in the past', () => {\n        expect(calculateAge('2000-01-01')).toBe(new Date().getFullYear() - 2000);\n    });\n\n    test('calculates age correctly for a birth date in the long past', () => {\n        expect(calculateAge('1000-01-01')).toBe(new Date().getFullYear() - 1000);\n    });\n\n\n    test('calculates age correctly for a birth date today', () => {\n        const today = new Date().toISOString().split('T')[0]; // Get today's date in YYYY-MM-DD format\n        expect(calculateAge(today)).toBe(0);\n    });\n\n\n    test('calculates age correctly for a person born yesterday', () => {\n        const yesterday = new Date();\n        yesterday.setDate(yesterday.getDate() - 1); // Set to yesterday\n        const birthDateString = yesterday.toISOString().split('T')[0];\n        expect(calculateAge(birthDateString)).toBe(0);\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Calculate age based on the birth date string entered by the user.Input birthDateString format such as 2000-01-01\n * @param birthDateString\n * @returns {string|number}\n */\nfunction calculateAge(birthDateString) {\n}\n",
    "addition_info": ""
  },
  {
    "task_id": 449,
    "code_type": "method",
    "code_signature": "/**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input) {\n}",
    "code_language": "javascript",
    "test_code": "describe('Base64 Encoding Tests', () => {\n    test('Convert simple string to Base64', () => {\n        expect(convertToBase64(\"Hello, World!\")).toBe(\"SGVsbG8sIFdvcmxkIQ==\");\n    });\n\n    test('Convert empty string to Base64', () => {\n        expect(convertToBase64(\"\")).toBe(\"\");\n    });\n\n    test('Convert string with spaces to Base64', () => {\n        expect(convertToBase64(\"Test String with Spaces\")).toBe(\"VGVzdCBTdHJpbmcgd2l0aCBTcGFjZXM=\");\n    });\n\n    test('Convert string with special characters to Base64', () => {\n        expect(convertToBase64(\"Special characters: @#&*()\")).toBe(\"U3BlY2lhbCBjaGFyYWN0ZXJzOiBAIyYqKCk=\");\n    });\n\n    test('Convert string with non-ASCII characters to Base64', () => {\n        expect(convertToBase64(\"\u4f60\u597d\uff0c\u4e16\u754c\uff01\")).toBe(\"5L2g5aW977yM5LiW55WM77yB\");\n    });\n\n    test('Convert long string to Base64', () => {\n        const longString = \"This is a very long string that exceeds normal lengths for testing purposes.\";\n        expect(convertToBase64(longString)).toBe(\"VGhpcyBpcyBhIHZlcnkgbG9uZyBzdHJpbmcgdGhhdCBleGNlZWRzIG5vcm1hbCBsZW5ndGhzIGZvciB0ZXN0aW5nIHB1cnBvc2VzLg==\");\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Converts a string to Base64 encoding.\n *\n * @param {string} input - The string to be converted to Base64.\n * @returns {string} The Base64 encoded string.\n */\nfunction convertToBase64(input) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 450,
    "code_type": "method",
    "code_signature": "/**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password) {\n}",
    "code_language": "javascript",
    "test_code": "describe('Password Validator Tests', () => {\n    test('Valid password', () => {\n        expect(isValidPassword(\"Password1!\")).toBe(true);\n    });\n\n    test('Password without a number', () => {\n        expect(isValidPassword(\"Password!\")).toBe(false);\n    });\n\n    test('Password without an uppercase letter', () => {\n        expect(isValidPassword(\"password1!\")).toBe(false);\n    });\n\n    test('Password without a lowercase letter', () => {\n        expect(isValidPassword(\"PASSWORD1!\")).toBe(false);\n    });\n\n    test('Password without a punctuation mark', () => {\n        expect(isValidPassword(\"Password1\")).toBe(false);\n    });\n\n    test('Password shorter than 8 characters', () => {\n        expect(isValidPassword(\"Pass1!\")).toBe(false);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether the provided password meets the specified format requirements:\n * - At least one number\n * - At least one lowercase letter\n * - At least one uppercase letter\n * - At least one punctuation mark\n * - Minimum length of 8 characters\n *\n * @param {string} password - The password string to validate\n * @returns {boolean} Returns true if the password meets all requirements; otherwise, false.\n */\nfunction isValidPassword(password) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 528,
    "code_type": "method",
    "code_signature": "const fs = require('fs');\nconst path = require('path');\n\n/**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir) {\n}",
    "code_language": "javascript",
    "test_code": "const fs = require('fs');\nconst path = require('path');\n\njest.mock('fs');\n\ndescribe('findMarkdownFiles', () => {\n    beforeEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('should return an empty array for an empty directory', () => {\n        fs.readdirSync.mockReturnValue([]);\n        fs.statSync.mockImplementation(() => ({isDirectory: () => false}));\n\n        const result = findMarkdownFiles('emptyDir');\n        expect(result).toEqual([]);\n    });\n\n    test('should return an array with one Markdown file', () => {\n        fs.readdirSync.mockReturnValue(['file1.md']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md']);\n    });\n\n    test('should return an array with multiple Markdown files in the same directory', () => {\n        fs.readdirSync.mockReturnValue(['file1.md', 'file2.md']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file1.md', 'dir\\\\file2.md']);\n    });\n\n\n    test('should return Markdown files while ignoring non-Markdown files', () => {\n        fs.readdirSync.mockReturnValue(['file1.txt', 'file2.md', 'file3.doc']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual(['dir\\\\file2.md']);\n    });\n\n\n    test('should handle a directory with only non-Markdown files', () => {\n        fs.readdirSync.mockReturnValue(['file1.txt', 'file2.doc']);\n        fs.statSync.mockImplementation(file => ({\n            isDirectory: () => false,\n        }));\n\n        const result = findMarkdownFiles('dir');\n        expect(result).toEqual([]);\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\nconst path = require('path');\n\n/**\n * Searches for Markdown files in the specified directory and returns the path of the files as an array\n *\n * @param {string} dir - The directory path to search in.\n * @returns {string[]} - An array of paths to Markdown files.\n */\nfunction findMarkdownFiles(dir) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 529,
    "code_type": "method",
    "code_signature": "const fs = require('fs');\n\n/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data, outputFilePath) {\n}",
    "code_language": "javascript",
    "test_code": "describe('saveAsJSON', () => {\n    const mockFilePath = 'test.json';\n    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();\n    const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();\n\n    afterEach(() => {\n        // Clean up after each test\n        jest.clearAllMocks();\n        if (fs.existsSync(mockFilePath)) {\n            fs.unlinkSync(mockFilePath); // Remove test file if it exists\n        }\n    });\n\n    test('should save valid object to JSON file', () => {\n        const data = {name: \"Alice\", age: 25};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should handle empty object', () => {\n        const data = {};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save nested object to JSON file', () => {\n        const data = {user: {name: \"Bob\", age: 30}, active: true};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save array of objects to JSON file', () => {\n        const data = [\n            {product: {id: 1, name: \"Laptop\", price: 999.99}, inStock: true},\n            {product: {id: 2, name: \"Phone\", price: 499.99}, inStock: false}\n        ];\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save object with mixed data types to JSON file', () => {\n        const data = {title: \"Shopping List\", items: [\"Milk\", \"Eggs\", \"Bread\"], total: 3.50, completed: false};\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n\n    test('should save deeply nested object to JSON file', () => {\n        const data = {\n            company: {\n                name: \"TechCorp\",\n                employees: [\n                    {\n                        id: 1,\n                        name: \"Alice\",\n                        role: \"Developer\",\n                        contact: {email: \"alice@techcorp.com\", phone: \"123-456-7890\"}\n                    },\n                    {id: 2, name: \"Bob\", role: \"Designer\", contact: {email: \"bob@techcorp.com\", phone: \"098-765-4321\"}}\n                ]\n            },\n            established: 2010\n        };\n        saveAsJSON(data, mockFilePath);\n        const savedData = fs.readFileSync(mockFilePath, 'utf8');\n        expect(savedData).toBe(JSON.stringify(data, null, 2));\n    });\n});\n",
    "prompt": "please write a javascript function , the function signature as below const fs = require('fs');\n\n/**\n * Converts the data object to JSON format and saves it to the specified file path.\n * @param {Object} data - The data object to be converted to JSON.\n * @param {string} outputFilePath - The file path where the JSON will be saved.\n */\nfunction saveAsJSON(data, outputFilePath) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 530,
    "code_type": "method",
    "code_signature": "/**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows, columns, initialValue) {\n}",
    "code_language": "javascript",
    "test_code": "describe('createMatrix', () => {\n    test('should create a 2x2 matrix filled with zeros', () => {\n        const result = createMatrix(2, 2, 0);\n        expect(result).toEqual([[0, 0], [0, 0]]);\n    });\n\n    test('should create a 3x3 matrix filled with ones', () => {\n        const result = createMatrix(3, 3, 1);\n        expect(result).toEqual([[1, 1, 1], [1, 1, 1], [1, 1, 1]]);\n    });\n\n    test('should create a 4x5 matrix filled with a string', () => {\n        const result = createMatrix(4, 5, 'test');\n        expect(result).toEqual([\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n            ['test', 'test', 'test', 'test', 'test'],\n        ]);\n    });\n\n    test('should create a 0x0 matrix', () => {\n        const result = createMatrix(0, 0, null);\n        expect(result).toEqual([]);\n    });\n\n    test('should create a 1x1 matrix with a boolean', () => {\n        const result = createMatrix(1, 1, true);\n        expect(result).toEqual([[true]]);\n    });\n    test('should create a 5x5 matrix filled with negative numbers', () => {\n        const result = createMatrix(5, 5, -1);\n        expect(result).toEqual([\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n            [-1, -1, -1, -1, -1],\n        ]);\n    });\n\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Creates a matrix with the specified number of rows and columns,\n * filled with the given initial value.\n *\n * @param {number} rows - The number of rows in the matrix.\n * @param {number} columns - The number of columns in the matrix.\n * @param {*} initialValue - The value to fill the matrix with.\n *                          It can be of any type (number, string, object, etc.).\n * @returns {Array} A two-dimensional array (matrix) filled with the initial value.\n */\nfunction createMatrix(rows, columns, initialValue) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 532,
    "code_type": "method",
    "code_signature": "/**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString) {\n}",
    "code_language": "javascript",
    "test_code": "describe('countLetterChanges', () => {\n    test('should count consecutive letters correctly', () => {\n        const result = countLetterChanges(\"aaabbcdeee\");\n        expect(result).toEqual([3, 2, 1, 1, 3]);\n    });\n\n    test('should return an array with one count for a single character', () => {\n        const result = countLetterChanges(\"a\");\n        expect(result).toEqual([1]);\n    });\n\n    test('should return counts for a string with no consecutive letters', () => {\n        const result = countLetterChanges(\"abcdef\");\n        expect(result).toEqual([1, 1, 1, 1, 1, 1]);\n    });\n\n    test('should handle a string with only identical letters', () => {\n        const result = countLetterChanges(\"rrrrrr\");\n        expect(result).toEqual([6]);\n    });\n\n    test('should handle a long string with random letters', () => {\n        const result = countLetterChanges(\"xxxyyyzzzaaaab\");\n        expect(result).toEqual([3, 3, 3, 4, 1]);\n    });\n\n    test('should handle numeric characters in the string', () => {\n        const result = countLetterChanges(\"1122334455\");\n        expect(result).toEqual([2, 2, 2, 2, 2]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Counts the occurrences of consecutive identical letters in a given string.\n *\n * @param {string} inputString - The string to analyze for letter changes.\n * @returns {Array<number>} An array of counts representing the number of consecutive\n *                          identical letters before a different letter is found.\n */\nfunction countLetterChanges(inputString) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 533,
    "code_type": "method",
    "code_signature": "/**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString) {\n}",
    "code_language": "javascript",
    "test_code": "describe('shuffleString', () => {\n    test('should return a string of the same length as the input', () => {\n        const input = \"abcdef\";\n        const result = shuffleString(input);\n        expect(result.length).toBe(input.length);\n    });\n\n    test('should shuffle the characters in the string', () => {\n        const input = \"hello\";\n        const result = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n\n    test('should return an empty string when given an empty string', () => {\n        const input = \"\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"\"); // Should return an empty string\n    });\n\n    test('should handle a single character string', () => {\n        const input = \"a\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"a\"); // Should return the same single character\n    });\n\n    test('should handle strings with identical characters', () => {\n        const input = \"aaaaa\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"aaaaa\"); // Should return the same string\n    });\n\n    test('should return a shuffled string for longer strings', () => {\n        const input = \"abcdefghijklmnopqrstuvwxyz\";\n        const result = shuffleString(input);\n        expect(result).not.toBe(input); // It should be different most of the time\n        expect(result.length).toBe(input.length); // Length should be the same\n    });\n\n    test('should return the same string if all characters are the same', () => {\n        const input = \"111111\";\n        const result = shuffleString(input);\n        expect(result).toBe(\"111111\"); // Should return the same string\n    });\n\n    test('should shuffle a string containing special characters', () => {\n        const input = \"a!@#$%^&*()_+\";\n        const result = shuffleString(input);\n        expect(result.length).toBe(input.length); // Length should be the same\n        expect(result).not.toBe(input); // It should be different most of the time\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Shuffles the characters in a given string randomly.\n *\n * @param {string} inputString - The string to shuffle.\n * @returns {string} A new string with the characters shuffled.\n */\nfunction shuffleString(inputString) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 534,
    "code_type": "method",
    "code_signature": "/**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array} array - The array from which to remove the element.\n * @param {*} element - The element to remove from the array.\n * @returns {Array} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray(array, element) {\n\n}",
    "code_language": "javascript",
    "test_code": "describe('removeElementInArray', () => {\n    test('returns the original array when the element is not found', () => {\n        const result = removeElementInArray([1, 2, 3, 4], 5);\n        expect(result).toEqual([1, 2, 3, 4]);\n    });\n\n\n    test('handles an empty array correctly', () => {\n        const result = removeElementInArray([], 1);\n        expect(result).toEqual([]);\n    });\n\n    test('removes an element from an array of objects', () => {\n        const obj1 = {id: 1};\n        const obj2 = {id: 2};\n        const obj3 = {id: 3};\n        const result = removeElementInArray([obj1, obj2, obj3], obj2);\n        expect(result).toEqual([obj1, obj3]);\n    });\n\n    test('does not modify the original array', () => {\n        const originalArray = [1, 2, 3];\n        const result = removeElementInArray(originalArray, 2);\n        expect(originalArray).toEqual([1, 2, 3]);\n        expect(result).toEqual([1, 3]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Removes the first occurrence of a specified element from an array.\n *\n * @param {Array} array - The array from which to remove the element.\n * @param {*} element - The element to remove from the array.\n * @returns {Array} A new array with the element removed, or the original array if the element is not found.\n */\nfunction removeElementInArray(array, element) {\n\n}",
    "addition_info": ""
  },
  {
    "task_id": 535,
    "code_type": "method",
    "code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html) {\n}",
    "code_language": "javascript",
    "test_code": "describe('compressHtml', () => {\n    it('should remove newlines and tabs', () => {\n        const input = `\n            <div>\n                <p>Test paragraph.</p>\n            </div>\n        `;\n        const expectedOutput = '<div><p>Test paragraph.</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should replace multiple spaces with a single space', () => {\n        const input = '<div>    <p>     Test with     multiple spaces.   </p></div>';\n        const expectedOutput = '<div><p> Test with multiple spaces. </p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should remove spaces between HTML tags', () => {\n        const input = '<div> <p>Test</p> </div>';\n        const expectedOutput = '<div><p>Test</p></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle empty input', () => {\n        const input = '';\n        const expectedOutput = '';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n\n    it('should handle HTML with only spaces and newlines', () => {\n        const input = `\n            <div>      \n            </div>\n        `;\n        const expectedOutput = '<div></div>';\n        expect(compressHtml(input)).toBe(expectedOutput);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace,\n * including newlines, tabs, and extra spaces,\n * while preserving the structure of the HTML.\n *\n * @param {string} html - The input HTML string to be compressed.\n * @returns {string} - The compressed HTML string with reduced whitespace.\n */\nfunction compressHtml(html) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 536,
    "code_type": "method",
    "code_signature": "/**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate() {\n}",
    "code_language": "javascript",
    "test_code": "describe('getDate', () => {\n    // Mock the Date object to control the current date for testing\n    const mockDate = new Date('2024-10-01T00:00:00Z');\n\n    beforeAll(() => {\n        // Mock the global Date object\n        jest.spyOn(global, 'Date').mockImplementation(() => mockDate);\n    });\n\n    afterAll(() => {\n        // Restore the original Date object\n        global.Date.mockRestore();\n    });\n\n    test('returns date in \"Month Day, Year\" format', () => {\n        const result = getDate();\n        expect(result).toBe('October 1, 2024');\n    });\n\n    test('returns correct year', () => {\n        const result = getDate();\n        expect(result).toMatch(/2024/);\n    });\n\n    test('returns correct month', () => {\n        const result = getDate();\n        expect(result).toMatch(/October/);\n    });\n\n    test('returns correct day', () => {\n        const result = getDate();\n        expect(result).toMatch(/1/);\n    });\n\n\n    test('returns date as a string', () => {\n        const result = getDate();\n        expect(typeof result).toBe('string');\n    });\n\n    test('does not return undefined', () => {\n        const result = getDate();\n        expect(result).not.toBeUndefined();\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current date formatted as 'Month Day, Year'.\n *\n * @returns {string} The formatted date string.\n */\nfunction getDate() {\n}",
    "addition_info": ""
  },
  {
    "task_id": 537,
    "code_type": "method",
    "code_signature": "/**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime() {\n}",
    "code_language": "javascript",
    "test_code": "describe('getTime', () => {\n    const mockDate = (dateString) => {\n        const date = new Date(dateString);\n        jest.spyOn(global, 'Date').mockImplementation(() => date);\n    };\n\n    afterEach(() => {\n        jest.restoreAllMocks();\n    });\n\n    test('should return a string', () => {\n        mockDate('2024-10-01T10:30:00'); // Mocking a specific date and time\n        const result = getTime();\n        expect(typeof result).toBe('string');\n    });\n\n    test('should return a formatted time string including AM/PM', () => {\n        mockDate('2024-10-01T15:45:00'); // 3:45 PM\n        const result = getTime();\n        expect(result).toMatch(/^\\d{1,2}:\\d{2} (AM|PM)$/);\n    });\n\n    test('should return the correct time during AM hours', () => {\n        mockDate('2024-10-01T08:15:00'); // 8:15 AM\n        const result = getTime();\n        expect(result).toBe('8:15 AM');\n    });\n\n    test('should return the correct time during PM hours', () => {\n        mockDate('2024-10-01T17:20:00'); // 5:20 PM\n        const result = getTime();\n        expect(result).toBe('5:20 PM');\n    });\n\n    test('should return \"12:00 AM\" at midnight', () => {\n        mockDate('2024-10-01T00:00:00'); // 12:00 AM\n        const result = getTime();\n        expect(result).toBe('12:00 AM');\n    });\n\n    test('should return \"12:00 PM\" at noon', () => {\n        mockDate('2024-10-01T12:00:00'); // 12:00 PM\n        const result = getTime();\n        expect(result).toBe('12:00 PM');\n    });\n\n    test('should handle single-digit minutes correctly', () => {\n        mockDate('2024-10-01T09:05:00'); // 9:05 AM\n        const result = getTime();\n        expect(result).toBe('9:05 AM');\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Gets the current time formatted as 'hh:mm AM/PM'.\n *\n * @returns {string} The formatted time string.\n */\nfunction getTime() {\n}",
    "addition_info": ""
  },
  {
    "task_id": 538,
    "code_type": "method",
    "code_signature": "/**\n * Sorts an array of objects alphabetically based on a specified field.\n *\n * @param {Array} array - The array of objects to sort.\n * @param {String} field - The field of the objects to sort by.\n * @param {Boolean} ascending - If true, sort in ascending order; if false, sort in descending order.\n * @returns {Array} - The sorted array of objects.\n */\nfunction sortByField(array, field, ascending = true) {\n}",
    "code_language": "javascript",
    "test_code": "describe('sortByField', () => {\n    const data = [\n        {name: 'John', age: 25},\n        {name: 'Alice', age: 30},\n        {name: 'Bob', age: 22},\n        {name: 'Charlie', age: 28},\n    ];\n\n    test('should sort by name in ascending order', () => {\n        const sorted = sortByField(data, 'name', true);\n        expect(sorted).toEqual([\n            {name: 'Alice', age: 30},\n            {name: 'Bob', age: 22},\n            {name: 'Charlie', age: 28},\n            {name: 'John', age: 25},\n        ]);\n    });\n\n    test('should sort by name in descending order', () => {\n        const sorted = sortByField(data, 'name', false);\n        expect(sorted).toEqual([\n            {name: 'John', age: 25},\n            {name: 'Charlie', age: 28},\n            {name: 'Bob', age: 22},\n            {name: 'Alice', age: 30},\n        ]);\n    });\n\n    test('should sort by age in ascending order', () => {\n        const sorted = sortByField(data, 'age', true);\n        expect(sorted).toEqual([\n            {name: 'Bob', age: 22},\n            {name: 'John', age: 25},\n            {name: 'Charlie', age: 28},\n            {name: 'Alice', age: 30},\n        ]);\n    });\n\n    test('should sort by age in descending order', () => {\n        const sorted = sortByField(data, 'age', false);\n        expect(sorted).toEqual([\n            {name: 'Alice', age: 30},\n            {name: 'Charlie', age: 28},\n            {name: 'John', age: 25},\n            {name: 'Bob', age: 22},\n        ]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Sorts an array of objects alphabetically based on a specified field.\n *\n * @param {Array} array - The array of objects to sort.\n * @param {String} field - The field of the objects to sort by.\n * @param {Boolean} ascending - If true, sort in ascending order; if false, sort in descending order.\n * @returns {Array} - The sorted array of objects.\n */\nfunction sortByField(array, field, ascending = true) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 540,
    "code_type": "method",
    "code_signature": "/**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array} array - The input array from which combinations are generated.\n * @returns {Array} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs(array) {\n}",
    "code_language": "javascript",
    "test_code": "describe('generateUniquePairs', () => {\n    test('generates unique pairs from an array with three elements', () => {\n        const items = ['A', 'B', 'C'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['B', 'C']\n        ]);\n    });\n\n    test('generates unique pairs from an array with two elements', () => {\n        const items = ['A', 'B'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([['A', 'B']]);\n    });\n\n    test('returns an empty array when the input array is empty', () => {\n        const items = [];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n    test('returns an empty array when the input array has one element', () => {\n        const items = ['A'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([]);\n    });\n\n\n    test('handles an array with different types of elements', () => {\n        const items = [1, 'A', { key: 'value' }];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            [1, 'A'],\n            [1, { key: 'value' }],\n            ['A', { key: 'value' }]\n        ]);\n    });\n\n    test('generates pairs from an array with more than three elements', () => {\n        const items = ['A', 'B', 'C', 'D'];\n        const result = generateUniquePairs(items);\n        expect(result).toEqual([\n            ['A', 'B'],\n            ['A', 'C'],\n            ['A', 'D'],\n            ['B', 'C'],\n            ['B', 'D'],\n            ['C', 'D']\n        ]);\n    });\n\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Generates all unique combinations of pairs from an array.\n *\n * @param {Array} array - The input array from which combinations are generated.\n * @returns {Array} - An array of arrays, where each inner array contains a unique pair of elements.\n */\nfunction generateUniquePairs(array) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 541,
    "code_type": "method",
    "code_signature": "/**\n * Filters elements from an array based on a qualification function.\n *\n * @param {Array} unfilteredArray - The array to filter.\n * @param {Function} isQualified - The function that determines if an element qualifies.\n * @returns {Array} - A new array containing the elements that qualify.\n */\nfunction filterArray(unfilteredArray, isQualified) {\n}",
    "code_language": "javascript",
    "test_code": "describe('filterArray', () => {\n    // Qualification function that checks if a number is greater than 10\n    const isGreaterThanTen = (num) => num > 10;\n\n    test('filters out numbers less than or equal to 10', () => {\n        const unfilteredArray = [5, 12, 3, 18, 7, 10, 15];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([12, 18, 15]);\n    });\n\n    test('returns an empty array when all elements are disqualified', () => {\n        const unfilteredArray = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array when all elements are qualified', () => {\n        const unfilteredArray = [11, 12, 15, 20];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([11, 12, 15, 20]);\n    });\n\n    test('handles an empty array input', () => {\n        const unfilteredArray = [];\n        const result = filterArray(unfilteredArray, isGreaterThanTen);\n        expect(result).toEqual([]);\n    });\n\n    test('filters out strings based on length', () => {\n        const isLongerThanThreeChars = (str) => str.length > 3;\n        const unfilteredArray = ['a', 'ab', 'abc', 'abcd', 'abcde'];\n        const result = filterArray(unfilteredArray, isLongerThanThreeChars);\n        expect(result).toEqual(['abcd', 'abcde']);\n    });\n\n    test('correctly filters an array with mixed types', () => {\n        const isString = (item) => typeof item === 'string';\n        const unfilteredArray = [1, 'hello', true, 'world', null];\n        const result = filterArray(unfilteredArray, isString);\n        expect(result).toEqual(['hello', 'world']);\n    });\n\n    test('filters based on an object property', () => {\n        const hasValueGreaterThanFive = (obj) => obj.value > 5;\n        const unfilteredArray = [{ value: 3 }, { value: 5 }, { value: 7 }];\n        const result = filterArray(unfilteredArray, hasValueGreaterThanFive);\n        expect(result).toEqual([{ value: 7 }]);\n    });\n\n    test('returns an empty array when no qualifying function is provided', () => {\n        const unfilteredArray = [1, 2, 3, 4, 5];\n        const result = filterArray(unfilteredArray, () => false); // Always returns false\n        expect(result).toEqual([]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Filters elements from an array based on a qualification function.\n *\n * @param {Array} unfilteredArray - The array to filter.\n * @param {Function} isQualified - The function that determines if an element qualifies.\n * @returns {Array} - A new array containing the elements that qualify.\n */\nfunction filterArray(unfilteredArray, isQualified) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 542,
    "code_type": "method",
    "code_signature": "/**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice, actualPrice) {\n}",
    "code_language": "javascript",
    "test_code": "describe('calculateDiscount', () => {\n    test('should return 25.00% discount for original price of 100 and actual price of 75', () => {\n        expect(calculateDiscount(100, 75)).toBe(25.00);\n    });\n\n    test('should return 0.00% discount for original price of 50 and actual price of 50', () => {\n        expect(calculateDiscount(50, 50)).toBe(0.00);\n    });\n\n    test('should return 100.00% discount for original price of 100 and actual price of 0', () => {\n        expect(calculateDiscount(100, 0)).toBe(100.00);\n    });\n\n    test('should return 50.00% discount for original price of 200 and actual price of 100', () => {\n        expect(calculateDiscount(200, 100)).toBe(50.00);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Calculates the discount percentage based on the given price and the actual price paid.\n *\n * @param {number} originalPrice - The original price of the item.\n * @param {number} actualPrice - The actual price paid for the item.\n * @returns {number} - The discount percentage, rounded to two decimal places.\n */\nfunction calculateDiscount(originalPrice, actualPrice) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 543,
    "code_type": "method",
    "code_signature": "/**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num) {\n}",
    "code_language": "javascript",
    "test_code": "describe('incrementNumber', () => {\n    test('should return 6 when input is 5', () => {\n        expect(incrementNumber(5)).toBe(6);\n    });\n\n    test('should return 0 when input is 0', () => {\n        expect(incrementNumber(0)).toBe(0);\n    });\n\n    test('should return -3 when input is -3', () => {\n        expect(incrementNumber(-3)).toBe(-3);\n    });\n\n    test('should return 1 when input is 0.5', () => {\n        expect(incrementNumber(0.5)).toBe(1.5);\n    });\n\n    test('should return 1 when input is 1', () => {\n        expect(incrementNumber(1)).toBe(2);\n    });\n\n    test('should return -1 when input is -1', () => {\n        expect(incrementNumber(-1)).toBe(-1);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Increments the entered number.\n * If the number is non-positive (<= 0), returns the original value.\n * If the number is positive, returns the value plus 1.\n *\n * @param {number} num - The number to increment.\n * @returns {number} - The incremented value or the original number.\n */\nfunction incrementNumber(num) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 544,
    "code_type": "method",
    "code_signature": "/**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array) {\n}",
    "code_language": "javascript",
    "test_code": "describe('filterOutEvenNumbers', () => {\n    test('removes all even numbers from the array', () => {\n        const inputArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray = [];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if all numbers are odd', () => {\n        const inputArray = [1, 3, 5, 7, 9];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1, 3, 5, 7, 9]);\n    });\n\n    test('returns an empty array if all numbers are even', () => {\n        const inputArray = [2, 4, 6, 8, 10];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed positive and negative numbers', () => {\n        const inputArray = [-3, -2, -1, 0, 1, 2, 3];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([-3, -1, 1, 3]);\n    });\n\n    test('handles large numbers and zero correctly', () => {\n        const inputArray = [0, 1000000000, 1000000001, 1000000002, 1000000003];\n        const result = filterOutEvenNumbers(inputArray);\n        expect(result).toEqual([1000000001, 1000000003]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Filters out all even numbers from an array.\n *\n * @param {number[]} array - The array of numbers to filter.\n * @returns {number[]} - A new array containing only the odd numbers.\n */\nfunction filterOutEvenNumbers(array) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 545,
    "code_type": "method",
    "code_signature": "/**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array} array - The array to iterate through.\n * @returns {Array} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array) {\n}",
    "code_language": "javascript",
    "test_code": "\ndescribe('elementsBeforeNull', () => {\n    test('returns elements before the first null', () => {\n        const inputArray = ['element1', 'element2', null, 'element3', 'element4'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2']);\n    });\n\n    test('returns an empty array when input is empty', () => {\n        const inputArray = [];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('returns the same array if there is no null', () => {\n        const inputArray = ['element1', 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual(['element1', 'element2', 'element3']);\n    });\n\n    test('returns an empty array if the first element is null', () => {\n        const inputArray = [null, 'element2', 'element3'];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n\n    test('handles mixed types with null', () => {\n        const inputArray = [1, 'text', null, true, false];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([1, 'text']);\n    });\n\n    test('handles an array with only null', () => {\n        const inputArray = [null];\n        const result = elementsBeforeNull(inputArray);\n        expect(result).toEqual([]);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Iterates through the array of elements until the first null is encountered,\n * returning a new array that includes all elements before the null.\n *\n * @param {Array} array - The array to iterate through.\n * @returns {Array} - A new array containing elements before the first null.\n */\nfunction elementsBeforeNull(array) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 559,
    "code_type": "method",
    "code_signature": "/**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName) {\n}",
    "code_language": "javascript",
    "test_code": "describe('isCppHeaderFile', () => {\n    test('returns true for a .h file', () => {\n        expect(isCppHeaderFile('example.h')).toBe(true);\n    });\n\n    test('returns true for a .hpp file', () => {\n        expect(isCppHeaderFile('example.hpp')).toBe(true);\n    });\n\n\n\n    test('returns false for a non-header file extension', () => {\n        expect(isCppHeaderFile('example.txt')).toBe(false);\n    });\n\n    test('returns false for a file without an extension', () => {\n        expect(isCppHeaderFile('example')).toBe(false);\n    });\n\n    test('returns false for a .c file', () => {\n        expect(isCppHeaderFile('example.c')).toBe(false);\n    });\n\n});\n",
    "prompt": "please write a javascript function , the function signature as below /**\n * Checks whether a file name is a C++ header file.\n *\n * @param {string} fileName - The name of the file to check.\n * @returns {boolean} - Returns true if the file is a C++ header file, false otherwise.\n */\nfunction isCppHeaderFile(fileName) {\n}",
    "addition_info": ""
  },
  {
    "task_id": 560,
    "code_type": "method",
    "code_signature": "/**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content, index) {\n}",
    "code_language": "javascript",
    "test_code": "describe('getLineNumber', () => {\n    test('returns 1 for the first character', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 0)).toBe(1);\n    });\n\n    test('returns 1 for the last character of the first line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 5)).toBe(1);\n    });\n\n    test('returns 3 for the last character of the third line', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\", 18)).toBe(3);\n    });\n\n    test('returns 1 for a single line string', () => {\n        expect(getLineNumber(\"Single line string\", 0)).toBe(1);\n    });\n\n    test('returns 3 for an index within a multiline string with trailing newlines', () => {\n        expect(getLineNumber(\"Line 1\\nLine 2\\nLine 3\\n\\n\", 15)).toBe(3);\n    });\n});",
    "prompt": "please write a javascript function , the function signature as below /**\n * Gets the line number in the content at the specified index.\n *\n * @param {string} content - The string content to check.\n * @param {number} index - The character index to find the line number for.\n * @returns {number} - The line number corresponding to the given index.\n */\nfunction getLineNumber(content, index) {\n}",
    "addition_info": ""
  }
]