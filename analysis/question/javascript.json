[
  {
    "task_id": 87,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00', for example, 1709227200 is converted to get the string' Mar1, 1:20'\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n",
    "test_code": "describe('timestampToReadableDate', () => {\n    test('converts Unix timestamp for New Year\\'s Day', () => {\n        // January 1, 2023 00:00 GMT\n        expect(timestampToReadableDate(1672531200)).toBe('Jan 1, 8:00');\n    });\n\n    test('converts Unix timestamp for a leap day', () => {\n        // February 29, 2024 12:00 GMT (leap year)\n        expect(timestampToReadableDate(1709227200)).toBe('Mar 1, 1:20');\n    });\n\n    test('converts Unix timestamp for a summer day', () => {\n        // June 21, 2023 15:45 GMT\n        expect(timestampToReadableDate(1687362300)).toBe('Jun 21, 23:45');\n    });\n\n    test('handles minutes with leading zero', () => {\n        // October 3, 2023 02:05 GMT\n        expect(timestampToReadableDate(1696377900)).toBe('Oct 4, 8:05');\n    });\n\n    test('handles end of the year', () => {\n        // December 31, 2023 23:59 GMT\n        expect(timestampToReadableDate(1704067140)).toBe('Jan 1, 7:59');\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * convert the UNIX timestamp to the string format 'Jan 1, 8: 00', for example, 1709227200 is converted to get the string' Mar1, 1:20'\n * @param unixTimestamp\n */\nfunction timestampToReadableDate(unixTimestamp) {\n\n}\n"
  },
  {
    "task_id": 88,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}",
    "test_code": "describe('isCronBetween2And4AM', () => {\n    test('should return true for specific hours 2, 3, and 4', () => {\n        expect(isCronBetween2And4AM('0 2,3,4 * * *')).toBe(true);\n    });\n\n    test('should return true for range that includes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 1-5 * * *')).toBe(true);\n    });\n\n    test('should return false for range that excludes 2 to 4 a.m.', () => {\n        expect(isCronBetween2And4AM('0 0-1,5-23 * * *')).toBe(false);\n    });\n\n    test('should return true for wildcard in hour field', () => {\n        expect(isCronBetween2And4AM('0 * * * *')).toBe(true);\n    });\n\n    test('should throw an error for invalid cron expressions', () => {\n        expect(() => {\n            isCronBetween2And4AM('invalid input');\n        }).toThrow('Invalid cron expression');\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Parse a crom expression and determine whether it is between 2 a.m. and 4 a.m.\n * @param cronExpression\n */\nfunction isCronBetween2And4AM(cronExpression) {\n\n}"
  },
  {
    "task_id": 89,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}",
    "test_code": "describe('timePassed function', () => {\n    const originalDateNow = Date.now;\n\n    beforeEach(() => {\n        // Freeze the Date.now() to a fixed timestamp\n        Date.now = jest.fn(() => 1609459200000); // January 1, 2021, 00:00:00\n    });\n\n    afterEach(() => {\n        // Restore original Date.now() function\n        Date.now = originalDateNow;\n    });\n\n    test('should correctly calculate time passed from 1 minute ago', () => {\n        const startTime = 1609459140000; // 1 minute earlier\n        expect(timePassed(startTime)).toBe(\"1:00\");\n    });\n\n    test('should handle the boundary of 59 seconds correctly', () => {\n        const startTime = 1609459194100; // 59 seconds and 900 milliseconds earlier\n        expect(timePassed(startTime)).toBe(\"0:05\");\n    });\n\n    test('should return 0:00 when start time is the same as current time', () => {\n        expect(timePassed(1609459200000)).toBe(\"0:00\");\n    });\n\n    test('should handle negative time differences (future start time)', () => {\n        const startTime = 1609459260000; // 1 minute into the future\n        expect(timePassed(startTime)).toMatch(/-/); // Expecting negative output or some error handling\n    });\n\n    test('should handle very large time differences correctly', () => {\n        const startTime = 1483228800000; // January 1, 2017, 00:00:00 (4 years difference)\n        expect(timePassed(startTime)).toBe(\"2103840:00\"); // Calculated minutes for 4 years\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * calculates the elapsed time from a given start time in milliseconds and returns\n * it as a formatted string in \"minutes:seconds\" format.\n *\n * @param {number} startTimeInMillis - The start time in milliseconds.\n * @return {string} A string representing the elapsed time in minutes and seconds.\n */\nfunction timePassed(startTimeInMillis) {\n}"
  },
  {
    "task_id": 92,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nfunction replaceHtmlEntities(htmlString) {\n\n}",
    "test_code": "// Import the replaceHtmlEntities function if it's in another file\n// const replaceHtmlEntities = require('./path_to_your_file');\n// Mock DOMParser in global scope\nglobal.DOMParser = class {\n  parseFromString(str) {\n    return {\n      documentElement: {\n        textContent: str.replace(/&amp;/g, '&')\n                        .replace(/&lt;/g, '<')\n                        .replace(/&gt;/g, '>')\n                        .replace(/&quot;/g, '\"')\n                        .replace(/&apos;/g, '\\'')\n      }\n    };\n  }\n};\ndescribe('replaceHtmlEntities', () => {\n    test('decodes standard HTML entities', () => {\n        const input = 'The &amp; symbol should become an &quot;and&quot; sign.';\n        const expected = 'The & symbol should become an \"and\" sign.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('returns empty string for empty input', () => {\n        const input = '';\n        const expected = '';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('throws TypeError when input is not a string', () => {\n        const input = 123;\n        expect(() => replaceHtmlEntities(input)).toThrow(TypeError);\n    });\n\n    test('decodes multiple different entities in one string', () => {\n        const input = '&lt;div&gt;Hello &amp; Welcome to the &apos;World&apos;!&lt;/div&gt;';\n        const expected = '<div>Hello & Welcome to the \\'World\\'!</div>';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n\n    test('handles strings with no entities', () => {\n        const input = 'Just a normal string without entities.';\n        const expected = 'Just a normal string without entities.';\n        expect(replaceHtmlEntities(input)).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Decodes HTML entities in a given HTML string.\n * @param {string} htmlString - The HTML string containing entities to decode.\n * @returns {string} The decoded string with HTML entities converted back to their original characters.\n */\nfunction replaceHtmlEntities(htmlString) {\n\n}"
  },
  {
    "task_id": 93,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}",
    "test_code": "describe('getAllAlphabets', () => {\n    test('should return an array of 52 characters', () => {\n        const result = getAllAlphabets();\n        expect(result).toHaveLength(52);\n    });\n\n    test('should start with lowercase letters from a to z', () => {\n        const result = getAllAlphabets();\n        const lowercaseAlphabets = result.slice(0, 26);\n        expect(lowercaseAlphabets).toEqual([\n            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'\n        ]);\n    });\n\n    test('should end with uppercase letters from A to Z', () => {\n        const result = getAllAlphabets();\n        const uppercaseAlphabets = result.slice(26);\n        expect(uppercaseAlphabets).toEqual([\n            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n        ]);\n    });\n\n    test('should return \"a\" as the first element', () => {\n        const result = getAllAlphabets();\n        expect(result[0]).toBe('a');\n    });\n\n    test('should return \"Z\" as the last element', () => {\n        const result = getAllAlphabets();\n        expect(result[result.length - 1]).toBe('Z');\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * produces a character array of length 52 containing all lowercase uppercase letters in alphabetical order\n *\n * @returns {string[]} An array of alphabet characters from 'a' to 'z' and 'A' to 'Z'.\n */\nfunction getAllAlphabets(){\n\n}"
  },
  {
    "task_id": 94,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}",
    "test_code": "describe('createCircleOfFifths', () => {\n    test('should return 12 notes in the circle', () => {\n        const result = createCircleOfFifths('C');\n        expect(result).toHaveLength(12);\n    });\n\n    test('should start with the given starting note', () => {\n        const startingNote = 'G';\n        const result = createCircleOfFifths(startingNote);\n        expect(result[0]).toBe(startingNote);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from C', () => {\n        const result = createCircleOfFifths('C');\n        const expectedCircle = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from G', () => {\n        const result = createCircleOfFifths('G');\n        const expectedCircle = ['G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];\n        expect(result).toEqual(expectedCircle);\n    });\n\n    test('should correctly generate the Circle of Fifths starting from F', () => {\n        const result = createCircleOfFifths('F');\n        const expectedCircle = ['F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'];\n        expect(result).toEqual(expectedCircle);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * generates a cyclic tone sequence of five degrees of length 12 starting with the specified starting note\n *\n * @param {string} startingNote - The musical note to start the Circle of Fifths from (e.g., \"C\").\n * @returns {string[]} An array representing the Circle of Fifths.\n */\nfunction createCircleOfFifths(startingNote) {\n\n}"
  },
  {
    "task_id": 95,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * finds the matching elements and their indices in the input array according to the specified comparison function\n *\n * @param {Array} inputArray - The array to search through.\n * @param {Function} comparatorFn - The comparator function to determine the condition.\n * @returns {Array} - An array of [index, value] pairs that meet the comparator condition.\n */\nfunction getIndexValues(inputArray, comparatorFn) {\n\n}",
    "test_code": "describe('getIndexValues', () => {\n    test('should return the index of the minimum value in an array', () => {\n        const inputArray = [3, 1, 4, 1, 5, 9, 2];\n        const result = getIndexValues(inputArray, compareMin);\n        expect(result).toEqual([[1, 1], [3, 1]]);\n    });\n\n    test('should return the index of the maximum value in an array', () => {\n        const inputArray = [3, 1, 4, 1, 5, 9, 2];\n        const result = getIndexValues(inputArray, compareMax);\n        expect(result).toEqual([[5, 9]]);\n    });\n\n    test('should return multiple indices if there are multiple minimum values', () => {\n        const inputArray = [7, 5, 2, 2, 8];\n        const result = getMinIndex(inputArray);\n        expect(result).toEqual([[2, 2], [3, 2]]);\n    });\n\n    test('should return multiple indices if there are multiple maximum values', () => {\n        const inputArray = [10, 4, 10, 1];\n        const result = getMaxIndex(inputArray);\n        expect(result).toEqual([[0, 10], [2, 10]]);\n    });\n\n    test('should return the index of the minimum value when array contains negative numbers', () => {\n        const inputArray = [-3, -1, -7, -1, -5];\n        const result = getMinIndex(inputArray);\n        expect(result).toEqual([[2, -7]]);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * finds the matching elements and their indices in the input array according to the specified comparison function\n *\n * @param {Array} inputArray - The array to search through.\n * @param {Function} comparatorFn - The comparator function to determine the condition.\n * @returns {Array} - An array of [index, value] pairs that meet the comparator condition.\n */\nfunction getIndexValues(inputArray, comparatorFn) {\n\n}"
  },
  {
    "task_id": 96,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}",
    "test_code": "describe('changedClef', () => {\n    test('should insert the clef at the correct position when the clef is not specified (default to \"bass\")', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc);\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=bass\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should insert the clef at the correct position when a specific clef is provided', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"treble\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=treble\\nC D E F|G A B c|\\n\";\n        expect(result).toBe(expected);\n    });\n\n    test('should handle cases where there is no newline after the key signature.py.py', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:C\";\n        const result = changedClef(abc, \"alto\");\n        const expected = \"X:1\\nT:Test Tune\\nK:C clef=alto\";\n        expect(result).toBe(expected);\n    });\n\n    test('should not alter the ABC notation if the key signature.py.py is not found', () => {\n        const abc = \"X:1\\nT:Test Tune\\nC D E F|G A B c|\\n\";\n        const result = changedClef(abc, \"tenor\");\n        expect(result).toBe(abc); // Expect the original string to be returned unchanged\n    });\n\n    test('should correctly handle ABC notation with multiple key signatures', () => {\n        const abc = \"X:1\\nT:Test Tune\\nK:G\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        const result = changedClef(abc, \"baritone\");\n        const expected = \"X:1\\nT:Test Tune\\nK:G clef=baritone\\nG A B c|\\nK:D\\nD E F# G|\\n\";\n        expect(result).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * modify the ABC string by inserting the specified clef (e.g., \"clef=bass\") after the tone line (K: ), or \"bass\" if no clef is specified.\n *\n * @param {string} abc - The ABC notation string.\n * @param {string} [clef=\"bass\"] - The clef to set (default is \"bass\").\n * @returns {string} - The updated ABC notation string with the new clef.\n */\nfunction changedClef(abc, clef = \"bass\") {\n\n}"
  },
  {
    "task_id": 97,
    "code_type": "class",
    "code_language": "javascript",
    "code_signature": "/**\n * realize the basic functions of the data structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n\n}",
    "test_code": "describe('Queue', () => {\n    let queue;\n\n    beforeEach(() => {\n        queue = new Queue();\n    });\n\n    test('should add elements to the queue using enqueue', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        expect(queue.printQueue()).toBe('10 20 30');\n    });\n\n    test('should remove elements from the front of the queue using dequeue', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        const removedElement = queue.dequeue();\n        expect(removedElement).toBe(10);\n        expect(queue.printQueue()).toBe('20 30');\n    });\n\n    test('should return \"Underflow\" when dequeue is called on an empty queue', () => {\n        const result = queue.dequeue();\n        expect(result).toBe('Underflow');\n    });\n\n    test('should return the front element using front without removing it', () => {\n        queue.enqueue(10);\n        queue.enqueue(20);\n        const frontElement = queue.front();\n        expect(frontElement).toBe(10);\n        expect(queue.printQueue()).toBe('10 20'); // Ensure the element is not removed\n    });\n\n    test('should return true when isEmpty is called on an empty queue', () => {\n        expect(queue.isEmpty()).toBe(true);\n        queue.enqueue(10);\n        expect(queue.isEmpty()).toBe(false);\n    });\n});",
    "prompt": "please write a javascript class this class signature as below /**\n * realize the basic functions of the data structure queue: enqueue, dequeue, get the front element of the queue, judge whether it is empty, output all elements\n */\nclass Queue {\n\n}"
  },
  {
    "task_id": 99,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n",
    "test_code": "describe('Sum Function Tests', () => {\n    test('should return the sum of a normal array of positive numbers', () => {\n        expect(sum([1, 2, 3, 4, 5])).toBe(15);\n    });\n\n    test('should return the sum of an array containing negative numbers', () => {\n        expect(sum([-1, -2, -3, -4, -5])).toBe(-15);\n    });\n\n    test('should return 0 for an empty array', () => {\n        expect(sum([])).toBe(0);\n    });\n\n    test('should return the sum of an array containing both positive and negative numbers', () => {\n        expect(sum([10, -10, 5, -5, 15])).toBe(15);\n    });\n\n    test('should return the sum of an array with floating point numbers', () => {\n        expect(sum([1.5, 2.5, 3.5])).toBe(7.5);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * @description Calculates the sum of all the numbers in a numeric array and returns it as a result. For example, if you enter [1, 2, 3, 4, 5], the return value is 15\n * @param {number[]} arr - The array of numbers to sum.\n */\nfunction sum(arr) {\n    \n}\n"
  },
  {
    "task_id": 100,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n",
    "test_code": "describe('ConvertTime Function Tests', () => {\n    test('should correctly convert full ISO 8601 duration with hours, minutes, seconds, and milliseconds', () => {\n        expect(convertTime('PT1H23M45.678S')).toBe('1h23m45s678ms');\n    });\n\n    test('should correctly convert duration with only minutes and seconds including milliseconds', () => {\n        expect(convertTime('PT0M30.123S')).toBe('30s123ms');\n    });\n\n    test('should correctly convert duration with only seconds and milliseconds', () => {\n        expect(convertTime('PT45.5S')).toBe('45s500ms');\n    });\n\n    test('should correctly convert duration with hours and minutes, but no seconds', () => {\n        expect(convertTime('PT2H5M')).toBe('2h5m');\n    });\n\n    test('should correctly convert duration with only seconds, no milliseconds', () => {\n        expect(convertTime('PT20S')).toBe('20s');\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Converts an ISO 8601 duration string into a more readable format.\n * \n * @param {string} duration - The ISO 8601 duration string (e.g., \"PT1H23M45.678S\").\n * @returns {string} A human-readable duration string (e.g., \"1h23m45s678ms\").\n */\nfunction convertTime(duration) {\n    const regex = /PT(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+)(\\.\\d+)?S)?/;\n    const matches = duration.match(regex);\n\n    if (!matches) return ''; // Return an empty string if the input doesn't match the expected format\n\n    const [ , hours, minutes, seconds, fractionalSeconds ] = matches;\n    let convertedTime = '';\n\n    if (hours) {\n        convertedTime += `${hours}h`;\n    }\n\n    if (minutes) {\n        convertedTime += `${minutes}m`;\n    }\n\n    if (seconds) {\n        convertedTime += `${seconds}s`;\n    }\n\n    if (fractionalSeconds) {\n        const milliseconds = Math.round(parseFloat(fractionalSeconds) * 1000);\n        if (milliseconds > 0) {\n            convertedTime += `${milliseconds}ms`;\n        }\n    }\n\n    return convertedTime;\n}\n"
  },
  {
    "task_id": 101,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n",
    "test_code": "describe('isBreakTime Function Tests', () => {\n    test('should return true when current time is exactly at the start time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:00\")).toBe(true);\n    });\n\n    test('should return true when current time is within the break time range', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"09:30\")).toBe(true);\n    });\n\n    test('should return true when current time is exactly at the end time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:00\")).toBe(true);\n    });\n\n    test('should return false when current time is before the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"08:59\")).toBe(false);\n    });\n\n    test('should return false when current time is after the break time', () => {\n        expect(isBreakTime(\"09:00\", \"10:00\", \"10:01\")).toBe(false);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Determine whether the current time is within the specified time range (i.e., whether it is a break)\n * \n * @param {string} startTime - The start time of the break in HH:MM format.\n * @param {string} endTime - The end time of the break in HH:MM format.\n * @param {string} currentTime - The current time in HH:MM format.\n */\nfunction isBreakTime(startTime, endTime, currentTime) {\n    \n}\n"
  },
  {
    "task_id": 103,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Truncate the string to the specified length and add an ellipsis (...) if necessary. . In addition, any <p> and </p> tags are removed from the truncated string.\n * \n * @param {string} str - The string to be truncated.\n * @param {number} num - The maximum number of characters allowed. */\nfunction sliceString(str, num) {\n    \n}\n",
    "test_code": "describe('sliceString Function Tests', () => {\n    test('should return a truncated string with \"...\" if it is longer than the specified limit, containing <p> tags', () => {\n        expect(sliceString(\"<p>Hello, World!</p>\", 5)).toBe(\"He...\");\n    });\n\n    test('should return the original string if it is exactly at the specified limit', () => {\n        expect(sliceString(\"Hello\", 5)).toBe(\"Hello\");\n    });\n\n    test('should return the original string if it is shorter than the specified limit', () => {\n        expect(sliceString(\"Hi\", 5)).toBe(\"Hi\");\n    });\n\n    test('should return a truncated string with \"...\" if it is longer than the specified limit, without <p> tags', () => {\n        expect(sliceString(\"Hello, World!\", 8)).toBe(\"Hello, W...\");\n    });\n\n    test('should return a truncated string with \"...\" if it has multiple <p> tags and is longer than the specified limit', () => {\n        expect(sliceString(\"<p>Hello, <p>World!</p></p>\", 7)).toBe(\"Hello, ...\");\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Truncate the string to the specified length and add an ellipsis (...) if necessary. . In addition, any <p> and </p> tags are removed from the truncated string.\n * \n * @param {string} str - The string to be truncated.\n * @param {number} num - The maximum number of characters allowed. */\nfunction sliceString(str, num) {\n    \n}\n"
  },
  {
    "task_id": 104,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n",
    "test_code": "describe('convertThreadToJSONFile Function Tests', () => {\n    test('should return a Blob object for a basic thread object', () => {\n        const thread1 = { id: 1, title: \"First Thread\", content: \"This is the first thread.\" };\n        const blob1 = convertThreadToJSONFile(thread1);\n        expect(blob1 instanceof Blob).toBe(true);\n        expect(blob1.type).toBe(\"application/json\");\n    });\n\n    test('should return a Blob object for an empty thread object', () => {\n        const thread2 = {};\n        const blob2 = convertThreadToJSONFile(thread2);\n        expect(blob2 instanceof Blob).toBe(true);\n        expect(blob2.size).toBe(2); // \"{}\" has a size of 2 bytes\n    });\n\n    test('should return a Blob object for a thread object with nested objects', () => {\n        const thread3 = { id: 2, title: \"Second Thread\", comments: [{ user: \"Alice\", comment: \"Great post!\" }] };\n        const blob3 = convertThreadToJSONFile(thread3);\n        expect(blob3 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with special characters', () => {\n        const thread4 = { id: 3, title: \"Thread & Special <Characters>\", content: 'This is a thread with special characters: <, >, &, \".' };\n        const blob4 = convertThreadToJSONFile(thread4);\n        expect(blob4 instanceof Blob).toBe(true);\n    });\n\n    test('should return a Blob object for a thread object with arrays', () => {\n        const thread5 = { id: 4, title: \"Thread with Array\", tags: [\"JavaScript\", \"JSON\", \"Blob\"] };\n        const blob5 = convertThreadToJSONFile(thread5);\n        expect(blob5 instanceof Blob).toBe(true);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * The incoming thread object is converted into a JSON file, which is represented as a Blob object.\n * \n * @param {Object} thread - The thread object to be converted.\n */\nfunction convertThreadToJSONFile(thread) {\n    \n}\n"
  },
  {
    "task_id": 106,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image data string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n",
    "test_code": "describe('isBase64Image', () => {\n    // Test Case 1: Valid Base64 encoded PNG image\n    test('should return true for a valid Base64 encoded PNG image', () => {\n        const imageData1 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\";\n        expect(isBase64Image(imageData1)).toBe(true);\n    });\n\n    // Test Case 2: Valid Base64 encoded JPEG image\n    test('should return true for a valid Base64 encoded JPEG image', () => {\n        const imageData2 = \"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBD\";\n        expect(isBase64Image(imageData2)).toBe(true);\n    });\n\n    // Test Case 3: Invalid Base64 string without proper image MIME type\n    test('should return false for a Base64 encoded PDF, not an image', () => {\n        const imageData3 = \"data:application/pdf;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\";\n        expect(isBase64Image(imageData3)).toBe(false);\n    });\n\n    // Test Case 4: Invalid string with no Base64 encoding\n    test('should return true for a string with valid Base64 image prefix but incorrect Base64 encoding', () => {\n        const imageData4 = \"data:image/png;base64,ThisIsNotBase64Encoded\";\n        expect(isBase64Image(imageData4)).toBe(true); // Based on function logic provided in the explanation\n    });\n\n    // Test Case 5: Random string without Base64 prefix\n    test('should return false for a random string without a Base64 prefix', () => {\n        const imageData5 = \"This is not a Base64 encoded image string.\";\n        expect(isBase64Image(imageData5)).toBe(false);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Checks if the provided image data is a valid Base64 encoded image string.\n * \n * @param {string} imageData - The image data string to be validated.\n */\nfunction isBase64Image(imageData) {\n    \n}\n"
  },
  {
    "task_id": 107,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n",
    "test_code": "describe('findMedian', () => {\n    // Example usage with a large array\n    test('should find the median of a large array with 10001 random elements', () => {\n        const largeArray = Array.from({ length: 10001 }, () => Math.floor(Math.random() * 10000));\n        const medianLargeArray = findMedian(largeArray);\n        // It's difficult to assert the exact median here due to randomness,\n        // but this test can check if the function completes without error\n        expect(typeof medianLargeArray).toBe('number');\n    });\n\n    // Test Case 1: Odd number of elements\n    test('should return 3 for an array with odd number of elements', () => {\n        const arr1 = [3, 1, 4, 1, 5, 9, 2];\n        const median1 = findMedian(arr1);\n        expect(median1).toBe(3);\n    });\n\n    // Test Case 2: Even number of elements\n    test('should return 6 for an array with even number of elements', () => {\n        const arr2 = [10, 2, 3, 5, 7, 8];\n        const median2 = findMedian(arr2);\n        expect(median2).toBe(6);\n    });\n\n    // Test Case 3: Array with duplicate elements\n    test('should return 2 for an array with duplicate elements', () => {\n        const arr3 = [1, 2, 2, 2, 3];\n        const median3 = findMedian(arr3);\n        expect(median3).toBe(2);\n    });\n\n    // Test Case 4: Array with negative numbers\n    test('should return 0 for an array with negative and positive numbers', () => {\n        const arr4 = [-5, -10, 0, 5, 10];\n        const median4 = findMedian(arr4);\n        expect(median4).toBe(0);\n    });\n\n    // Test Case 5: Array with a single element\n    test('should return the only element for an array with a single element', () => {\n        const arr5 = [42];\n        const median5 = findMedian(arr5);\n        expect(median5).toBe(42);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Finds the median of a given array of numbers.\n * \n * @param {number[]} arr - The array of numbers to find the median of.\n * \n */\nfunction findMedian(arr) {\n\n}\n"
  },
  {
    "task_id": 108,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}",
    "test_code": "describe('reorderData', () => {\n\n    test('should reorder the data based on scores in ascending order', () => {\n        const imageScores = [90, 85, 95];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([85, 90, 95]);\n        expect(result.resultNames).toEqual([\"image2.png\", \"image1.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id2\", \"id1\", \"id3\"]);\n    });\n\n    test('should return the same order if scores are already in ascending order', () => {\n        const imageScores = [70, 75, 80];\n        const imageNames = [\"imageA.png\", \"imageB.png\", \"imageC.png\"];\n        const imageIDs = [\"idA\", \"idB\", \"idC\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([70, 75, 80]);\n        expect(result.resultNames).toEqual([\"imageA.png\", \"imageB.png\", \"imageC.png\"]);\n        expect(result.resultIDs).toEqual([\"idA\", \"idB\", \"idC\"]);\n    });\n\n    test('should handle an array with only one element', () => {\n        const imageScores = [50];\n        const imageNames = [\"imageSingle.png\"];\n        const imageIDs = [\"idSingle\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([50]);\n        expect(result.resultNames).toEqual([\"imageSingle.png\"]);\n        expect(result.resultIDs).toEqual([\"idSingle\"]);\n    });\n\n    test('should handle an empty array', () => {\n        const imageScores = [];\n        const imageNames = [];\n        const imageIDs = [];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([]);\n        expect(result.resultNames).toEqual([]);\n        expect(result.resultIDs).toEqual([]);\n    });\n\n    test('should reorder correctly when there are duplicate scores', () => {\n        const imageScores = [88, 88, 92];\n        const imageNames = [\"image1.png\", \"image2.png\", \"image3.png\"];\n        const imageIDs = [\"id1\", \"id2\", \"id3\"];\n\n        const result = reorderData(imageScores, imageNames, imageIDs);\n\n        expect(result.resultScores).toEqual([88, 88, 92]);\n        expect(result.resultNames).toEqual([\"image1.png\", \"image2.png\", \"image3.png\"]);\n        expect(result.resultIDs).toEqual([\"id1\", \"id2\", \"id3\"]);\n    });\n\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Sort the images in ascending order based on their scores and return the reordered image score, name, and ID\n *\n * @param {number[]} imageScores - Array of image scores.\n * @param {string[]} imageNames - Array of image names corresponding to the scores.\n * @param {string[]} imageIDs - Array of image IDs corresponding to the scores.\n * @returns {Object} An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {\n\n}"
  },
  {
    "task_id": 109,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}",
    "test_code": "describe('getObjectById', () => {\n\n    test('should return the object with the matching id', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(2, list);\n        expect(result).toEqual({ id: 2, name: 'Object 2' });\n    });\n\n    test('should return null if no object with the matching id is found', () => {\n        const list = [\n            { id: 1, name: 'Object 1' },\n            { id: 2, name: 'Object 2' },\n            { id: 3, name: 'Object 3' }\n        ];\n        const result = getObjectById(4, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if the list is empty', () => {\n        const list = [];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return null if objects in the list do not have an id property', () => {\n        const list = [\n            { name: 'Object 1' },\n            { name: 'Object 2' },\n            { name: 'Object 3' }\n        ];\n        const result = getObjectById(1, list);\n        expect(result).toBeNull();\n    });\n\n    test('should return the correct object when id is a string', () => {\n        const list = [\n            { id: 'a', name: 'Object A' },\n            { id: 'b', name: 'Object B' },\n            { id: 'c', name: 'Object C' }\n        ];\n        const result = getObjectById('b', list);\n        expect(result).toEqual({ id: 'b', name: 'Object B' });\n    });\n\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Returns the object from the list with the given ID, or null if it is not present\n *\n * @param {string|number} id - The `id` to search for in the list.\n * @param {Array<Object>} list - The list of objects to search through.\n * @returns {Object|null} The object with the matching `id`, or `null` if no match is found.\n */\nfunction getObjectById(id, list) {\n\n}"
  },
  {
    "task_id": 110,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Generate a random UUID of length 36\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}",
    "test_code": "describe('generateUUID', () => {\n\n    test('should generate a UUID of length 36', () => {\n        const uuid = generateUUID();\n        expect(uuid.length).toBe(36);\n    });\n\n    test('should generate a UUID containing only valid characters', () => {\n        const uuid = generateUUID();\n        const validChars = /^[A-Za-z0-9]+$/; // Regex to check only alphanumeric characters\n        expect(validChars.test(uuid)).toBe(true);\n    });\n\n    test('should generate different UUIDs on multiple calls', () => {\n        const uuid1 = generateUUID();\n        const uuid2 = generateUUID();\n        expect(uuid1).not.toBe(uuid2);\n    });\n\n    test('should generate a UUID without any special characters', () => {\n        const uuid = generateUUID();\n        const hasSpecialChars = /[^A-Za-z0-9]/; // Regex to find any non-alphanumeric characters\n        expect(hasSpecialChars.test(uuid)).toBe(false);\n    });\n\n    test('should generate a UUID with 36 alphanumeric characters', () => {\n        const uuid = generateUUID();\n        const validChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        for (let i = 0; i < uuid.length; i++) {\n            expect(validChars.includes(uuid[i])).toBe(true);\n        }\n    });\n\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Generate a random UUID of length 36\n *\n * @returns {string} A 36-character UUID string.\n */\nfunction generateUUID() {\n\n}"
  },
  {
    "task_id": 111,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}",
    "test_code": "describe('convertChatToMarkdown', () => {\n\n    test('should include the default title when no title is provided', () => {\n        const chat = [\"Hello\", \"Hi there!\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedStart = \"# ChatGPT Conversation\\n\\n**Human:**\\nHello\\n\\n***\\n\\n**Assistant:**\\nHi there!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should include the custom title when a title is provided', () => {\n        const chat = [\"How are you?\", \"I'm doing well, thank you!\"];\n        const title = \"Friendly Chat\";\n        const blob = convertChatToMarkdown(chat, title);\n        const expectedStart = \"# Friendly Chat\\n\\n**Human:**\\nHow are you?\\n\\n***\\n\\n**Assistant:**\\nI'm doing well, thank you!\\n\\n***\\n\\nExported on \";\n        return blob.text().then(text => {\n            expect(text.startsWith(expectedStart)).toBe(true);\n        });\n    });\n\n    test('should correctly alternate speakers between Human and Assistant', () => {\n        const chat = [\"Question?\", \"Answer.\", \"Another question?\", \"Another answer.\"];\n        const blob = convertChatToMarkdown(chat);\n        const expectedContent = `**Human:**\\nQuestion?\\n\\n***\\n\\n**Assistant:**\\nAnswer.\\n\\n***\\n\\n**Human:**\\nAnother question?\\n\\n***\\n\\n**Assistant:**\\nAnother answer.\\n\\n***\\n\\nExported on `;\n        return blob.text().then(text => {\n            expect(text.includes(expectedContent)).toBe(true);\n        });\n    });\n\n    test('should include the correct timestamp using getDate and getTime', () => {\n        const chat = [\"What's the time?\", \"It's now.\"];\n        const mockedDate = new Date(\"2024-01-01 12:00:00\");\n        global.Date = jest.fn(() => mockedDate);\n\n        const blob = convertChatToMarkdown(chat);\n        const expectedEnd = `Exported on 2024-01-01 12:00:00.`;\n        return blob.text().then(text => {\n            expect(text.endsWith(expectedEnd)).toBe(true);\n        });\n    });\n\n    test('should return a Blob of type text/markdown', () => {\n        const chat = [\"This is a test.js.\", \"Yes, it is.\"];\n        const blob = convertChatToMarkdown(chat);\n        expect(blob.type).toBe('text/markdown');\n    });\n\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Convert the chat logs to Markdown format and generate a Blob object containing them\n *\n * @param {string[]} chat - The chat conversation as an array of strings.\n * @param {string} [title=\"ChatGPT Conversation\"] - The optional title for the conversation.\n * @returns {Blob} A Blob containing the Markdown formatted string of the conversation.\n */\nfunction convertChatToMarkdown(chat, title = \"ChatGPT Conversation\") {\n\n}"
  },
  {
    "task_id": 112,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * The HTML text content is converted into Markdown format, and the ordered and unordered lists are specially processed\n *\n * @param {string} html - The HTML string to be converted.\n * @returns {string} - The converted Markdown string.\n */\nconst { JSDOM } = require('jsdom');\n\nfunction htmlToMDSyntax(html) {}",
    "test_code": "describe('htmlToMDSyntax', () => {\n    test('should convert basic HTML tags to Markdown syntax', () => {\n        const html = '<h1>Title</h1><p>Paragraph</p><code>code snippet</code>';\n        const expected = '# Title\\nParagraph\\n`code snippet`';\n        const result = htmlToMDSyntax(html);\n        expect(result).toBe(expected);\n    });\n\n    test('should convert ordered list to Markdown syntax', () => {\n        const html = '<ol><li>First</li><li>Second</li><li>Third</li></ol>';\n        const expected = '1. First\\n2. Second\\n3. Third';\n        const result = htmlToMDSyntax(html);\n        expect(result).toBe(expected);\n    });\n\n    test('should convert unordered list to Markdown syntax', () => {\n        const html = '<ul><li>First</li><li>Second</li><li>Third</li></ul>';\n        const expected = '- First\\n- Second\\n- Third';\n        const result = htmlToMDSyntax(html);\n        expect(result).toBe(expected);\n    });\n\n    test('should handle nested lists correctly such as an ordered list containing an unordered sublist', () => {\n        const html = '<ol><li>First<ul><li>Sub First</li></ul></li><li>Second</li></ol>';\n        const expected = '1. First\\n- Sub First\\n\\n\\n2. Second';\n        const result = htmlToMDSyntax(html);\n        expect(result).toBe(expected);\n    });\n\n    test('should handle mixed content with headings and lists', () => {\n        const html = '<h2>Subheading</h2><p>Some text</p><ul><li>Item</li></ul>';\n        const expected = '## Subheading\\nSome text\\n\\n- Item';\n        const result = htmlToMDSyntax(html);\n        expect(result).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * The HTML text content is converted into Markdown format, and the ordered and unordered lists are specially processed\n *\n * @param {string} html - The HTML string to be converted.\n * @returns {string} - The converted Markdown string.\n */\nconst { JSDOM } = require('jsdom');\n\nfunction htmlToMDSyntax(html) {}"
  },
  {
    "task_id": 113,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}",
    "test_code": "/**\n * @jest-environment jsdom\n */\n\ndescribe('getCSSFromSheet', () => {\n    let styleSheet;\n\n    beforeEach(() => {\n        // Create a style element with some CSS rules for testing\n        const style = document.createElement('style');\n        style.appendChild(document.createTextNode(`\n            body { background-color: red; }\n            p { color: blue; }\n        `));\n        document.head.appendChild(style);\n        styleSheet = style.sheet;\n    });\n\n    afterEach(() => {\n        // Clean up the document after each test\n        document.head.innerHTML = '';\n    });\n\n    test('Valid Stylesheet: should return combined CSS rules', () => {\n        const cssText = getCSSFromSheet(styleSheet);\n        expect(cssText).toContain('body {background-color: red;}p {color: blue;}');\n    });\n\n    test('Empty Stylesheet: should return an empty string', () => {\n        const emptyStyle = document.createElement('style');\n        document.head.appendChild(emptyStyle);\n        const emptyStyleSheet = emptyStyle.sheet;\n\n        const cssText = getCSSFromSheet(emptyStyleSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Invalid Input: should return an empty string for non-CSSStyleSheet input', () => {\n        expect(getCSSFromSheet(null)).toBe('');\n        expect(getCSSFromSheet({})).toBe('');\n        expect(getCSSFromSheet('not a stylesheet')).toBe('');\n    });\n\n    test('Cross-Origin Restrictions: should handle restricted stylesheets gracefully', () => {\n        // Simulate a cross-origin stylesheet\n        const link = document.createElement('link');\n        link.rel = 'stylesheet';\n        link.href = 'http://example.com/style.css';\n        document.head.appendChild(link);\n\n        // Accessing cssRules of a cross-origin stylesheet should throw an error\n        const restrictedSheet = link.sheet;\n\n        expect(() => {\n            getCSSFromSheet(restrictedSheet);\n        }).not.toThrow();  // The function should not throw an error\n\n        // Simulate behavior by returning an empty string\n        const cssText = getCSSFromSheet(restrictedSheet);\n        expect(cssText).toBe('');\n    });\n\n    test('Style Element with Inline CSS: should return CSS from inline style element', () => {\n        const styleElement = document.createElement('style');\n        styleElement.textContent = 'div { font-size: 16px; }';\n        document.head.appendChild(styleElement);\n\n        const cssText = getCSSFromSheet(styleElement.sheet);\n        expect(cssText).toBe('div {font-size: 16px;}');\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Extract all the CSS rules from a given CSSStyleSheet and concatenate them into a string\n *\n * @param {CSSStyleSheet} sheet - The stylesheet object from which to extract CSS rules.\n * @returns {string} A single string containing all CSS rules, or an empty string if the sheet is invalid or inaccessible.\n */\nfunction getCSSFromSheet(sheet) {\n}"
  },
  {
    "task_id": 114,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}",
    "test_code": "describe('sortByTimestamp function', () => {\n    test('should return an empty array when input is empty', () => {\n        expect(sortByTimestamp([])).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }];\n        expect(sortByTimestamp(singleElementArray)).toEqual([{ id: 1, timestamp: \"2021-07-03T12:00:00Z\" }]);\n    });\n\n    test('should sort an array of objects by timestamps correctly', () => {\n        const testData = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 1, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(testData)).toEqual(expected);\n    });\n\n    test('should not alter array if already sorted', () => {\n        const sortedArray = [\n            { id: 1, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"2021-07-02T15:30:00Z\" },\n            { id: 3, timestamp: \"2021-07-03T12:00:00Z\" }\n        ];\n        expect(sortByTimestamp(sortedArray)).toEqual(sortedArray);\n    });\n\n    test('should handle mixed format timestamps correctly', () => {\n        const mixedFormats = [\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" }\n        ];\n        const expected = [\n            { id: 3, timestamp: \"2021-07-01T09:45:00Z\" },\n            { id: 2, timestamp: \"July 2, 2021 15:30:00\" },\n            { id: 1, timestamp: \"2021/07/03 12:00:00\" }\n        ];\n        expect(sortByTimestamp(mixedFormats)).toEqual(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * sorts an array of objects by the timestamp property.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @returns {Object[]} The sorted array, based on the timestamp property.\n */\nfunction sortByTimestamp(array) {}"
  },
  {
    "task_id": 115,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}",
    "test_code": "describe('sortByKey function', () => {\n    test('should return an empty array when input is empty', () => {\n        const result = sortByKey([], 'name');\n        expect(result).toEqual([]);\n    });\n\n    test('should correctly handle an array with a single element', () => {\n        const singleElementArray = [{ name: 'Apple' }];\n        expect(sortByKey(singleElementArray, 'name')).toEqual([{ name: 'Apple' }]);\n    });\n\n    test('should sort an array of objects by the specified key', () => {\n        const testData = [\n            { name: 'banana' },\n            { name: 'apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(testData, 'name')).toEqual(expected);\n    });\n\n    test('should perform case-insensitive sorting', () => {\n        const mixedCaseArray = [\n            { name: 'banana' },\n            { name: 'Apple' },\n            { name: 'orange' }\n        ];\n        const expected = [\n            { name: 'Apple' },\n            { name: 'banana' },\n            { name: 'orange' }\n        ];\n        expect(sortByKey(mixedCaseArray, 'name')).toEqual(expected);\n    });\n\n    test('should handle objects missing the specified key', () => {\n        const incompleteData = [\n            { name: 'banana' },\n            { quantity: 20 },\n            { name: 'apple' }\n        ];\n        const expected = [\n            { quantity: 20 },  // Objects without the key go to the front if their comparison value defaults to empty\n            { name: 'apple' },\n            { name: 'banana' }\n        ];\n        expect(sortByKey(incompleteData, 'name')).toEqual(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Sorts an array of objects alphabetically by a specified key.\n *\n * @param {Object[]} array - The array of objects to be sorted.\n * @param {string} key - The key in the objects to sort by.\n * @returns {Object[]} The sorted array based on the specified key.\n */\nfunction sortByKey(array, key) {\n\n}"
  },
  {
    "task_id": 116,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}",
    "test_code": "describe('toroidalDiff', () => {\n    test('should return the direct difference when no wrapping is needed', () => {\n        const thisPoint = { x: 2, y: 3 };\n        const otherPoint = { x: 5, y: 6 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-3, -3]);\n    });\n\n    test('should handle wrapping around the x dimension', () => {\n        const thisPoint = { x: 9, y: 5 };\n        const otherPoint = { x: 1, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, 0]); // dx wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around the y dimension', () => {\n        const thisPoint = { x: 4, y: 9 };\n        const otherPoint = { x: 4, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, -2]); // dy wraps around the toroidal boundary\n    });\n\n    test('should handle wrapping around both x and y dimensions', () => {\n        const thisPoint = { x: 9, y: 9 };\n        const otherPoint = { x: 1, y: 1 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([-2, -2]); // Both dx and dy wrap around\n    });\n\n    test('should return the direct difference for points at the same position', () => {\n        const thisPoint = { x: 5, y: 5 };\n        const otherPoint = { x: 5, y: 5 };\n        const width = 10;\n        const height = 10;\n        const result = toroidalDiff(thisPoint, otherPoint, width, height);\n        expect(result).toEqual([0, 0]); // No difference\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Calculates the toroidal difference between two points.\n *\n * @param {Object} thisPoint - The first point with properties x and y.\n * @param {Object} otherPoint - The second point with properties x and y.\n * @param {number} width - The width of the toroidal space.\n * @param {number} height - The height of the toroidal space.\n * @returns {Array} - An array containing the x and y differences, accounting for wrap-around.\n */\nfunction toroidalDiff(thisPoint, otherPoint, width, height) {\n}"
  },
  {
    "task_id": 117,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}",
    "test_code": "describe('rgbToHsl function', () => {\n    test('converts pure red to HSL', () => {\n        expect(rgbToHsl(255, 0, 0)).toEqual({h: 0, s: 100, l: 50});\n    });\n\n    test('converts black to HSL', () => {\n        expect(rgbToHsl(0, 0, 0)).toEqual({h: 0, s: 0, l: 0});\n    });\n\n    test('converts white to HSL', () => {\n        expect(rgbToHsl(255, 255, 255)).toEqual({h: 0, s: 0, l: 100});\n    });\n\n    test('converts gray to HSL', () => {\n        expect(rgbToHsl(128, 128, 128)).toEqual({h: 0, s: 0, l: 50});\n    });\n\n    test('converts a color on the edge of RGB range', () => {\n        expect(rgbToHsl(0, 255, 255)).toEqual({h: 180, s: 100, l: 50});\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Converts an RGB color value to HSL.\n *\n * @param {number} r - The red component (0-255).\n * @param {number} g - The green component (0-255).\n * @param {number} b - The blue component (0-255).\n * @returns {Object} An object containing the HSL values.\n */\nfunction rgbToHsl(r, g, b) {\n}"
  },
  {
    "task_id": 118,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}",
    "test_code": "describe('hslToRgb function', () => {\n    test('converts pure red hue correctly', () => {\n        expect(hslToRgb(0, 100, 50)).toEqual({ r: 255, g: 0, b: 0 });\n    });\n\n    test('returns gray for zero saturation', () => {\n        expect(hslToRgb(240, 0, 50)).toEqual({ r: 128, g: 128, b: 128 });\n    });\n\n    test('returns white for full lightness', () => {\n        expect(hslToRgb(120, 50, 100)).toEqual({ r: 255, g: 255, b: 255 });\n    });\n\n    test('converts full saturation and mid lightness blue correctly', () => {\n        expect(hslToRgb(240, 100, 50)).toEqual({ r: 0, g: 0, b: 255 });\n    });\n\n    test('handles edge hue at 360 degrees correctly', () => {\n        expect(hslToRgb(360, 100, 50)).toEqual({ r: 255, g: 0, b: 0 }); // Should be the same as hue 0\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Converts HSL color values to RGB.\n *\n * @param {number} h - Hue (0-360 degrees).\n * @param {number} s - Saturation (0-100%).\n * @param {number} l - Lightness (0-100%).\n * @returns {Object} An object containing the RGB values.\n */\nfunction hslToRgb(h, s, l) {}"
  },
  {
    "task_id": 119,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}",
    "test_code": "/**\n * @jest-environment jsdom\n */\n\ndescribe('getCookie function tests', () => {\n    beforeEach(() => {\n        // Clear cookies before each test\n        Object.defineProperty(window.document, 'cookie', {\n            writable: true,\n            value: '',\n        });\n    });\n\n    test('returns correct cookie value for existing cookie', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n\n    test('returns null if cookie does not exist', () => {\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('user')).toBeNull();\n    });\n\n    test('correctly handles cookies with spaces before names', () => {\n        document.cookie = \" username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n\n    test('returns null when no cookies are set', () => {\n        expect(getCookie('username')).toBeNull();\n    });\n\n    test('handles multiple cookies and retrieves the correct one', () => {\n        document.cookie = \"user=JaneDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        document.cookie = \"username=JohnDoe; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/\";\n        expect(getCookie('username')).toBe('JohnDoe');\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * gets the cookie value for the specified name from the cookie in the browser. The format of the cookie is key=value;key=value;key=value\n * @param name cookie key name\n */\nfunction getCookie(name) {\n\n}"
  },
  {
    "task_id": 120,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Extract table data from a document object containing HTML tables and return the data organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  ",
    "test_code": "const { JSDOM } = require('jsdom');\n\ndescribe('HTML to CSV Extraction Tests', () => {\n  const createMockDocument = (html) => {\n    const dom = new JSDOM(html);\n    return dom.window.document;\n  };\n\n  const extractCSVDataFromHTML = (document) => {\n    const rows = document.querySelectorAll('table.waffle tbody tr');\n    return Array.from(rows).map(row =>\n      Array.from(row.cells).map(cell => cell.textContent || \"\")\n    );\n  };\n\n  test('Table with multiple rows and columns', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td>Cell 2</td></tr>\n          <tr><td>Cell 3</td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"Cell 2\"], [\"Cell 3\", \"Cell 4\"]]);\n  });\n\n  test('Table with empty cells', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Cell 1</td><td></td></tr>\n          <tr><td></td><td>Cell 4</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Cell 1\", \"\"], [\"\", \"Cell 4\"]]);\n  });\n\n  test('Table with only one row', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Single Cell 1</td><td>Single Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Single Cell 1\", \"Single Cell 2\"]]);\n  });\n\n  test('Table with only one column', () => {\n    const testCaseHTML = `\n      <table class=\"waffle\">\n        <tbody>\n          <tr><td>Column Cell 1</td></tr>\n          <tr><td>Column Cell 2</td></tr>\n        </tbody>\n      </table>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([[\"Column Cell 1\"], [\"Column Cell 2\"]]);\n  });\n\n  test('No table with the class \"waffle\" present', () => {\n    const testCaseHTML = `\n      <div>\n        <p>No table here!</p>\n      </div>`;\n    const document = createMockDocument(testCaseHTML);\n    expect(extractCSVDataFromHTML(document)).toEqual([]);\n  });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Extract table data from a document object containing HTML tables and return the data organized as a two-dimensional array.\n * @param {document} document\n */\n\nfunction extractCSVDataFromHTML(document) {\n    \n}\n  "
  },
  {
    "task_id": 121,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n",
    "test_code": "describe('adjustArrayLength function tests', () => {\n    test('Array length equal to the target length', () => {\n        const result = adjustArrayLength(5, [1, 2, 3, 4, 5]);\n        expect(result).toEqual([1, 2, 3, 4, 5]);\n    });\n\n    test('Array length shorter than the target length', () => {\n        const result = adjustArrayLength(8, [1, 2, 3]);\n        expect(result).toEqual([1, 2, 3, 1, 2, 3, 1, 2]);\n    });\n\n    test('Array length longer than the target length', () => {\n        const result = adjustArrayLength(3, [1, 2, 3, 4, 5]);\n        expect(result).toEqual([1, 2, 3]);\n    });\n\n    test('Array length shorter than the target length, target length is a multiple of array length', () => {\n        const result = adjustArrayLength(6, [10, 20]);\n        expect(result).toEqual([10, 20, 10, 20, 10, 20]);\n    });\n\n    test('Array length shorter than the target length, target length is not a multiple of array length', () => {\n        const result = adjustArrayLength(7, [7, 14, 21]);\n        expect(result).toEqual([7, 14, 21, 7, 14, 21, 7]);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Adjust the length of the input array according to the given target length (number). If the current length of the array is longer than the target length, the first part of the array is intercepted to match the target length; If the current length of the array is shorter than the target length, the elements in the array are repeated until the target length is reached.\n * \n * @param {number} targetLength - The desired length for the array.\n * @param {Array} array - The input array to be adjusted.\n * @returns {Array} - A new array that has been adjusted to the target length.\n */\nfunction adjustArrayLength(targetLength, array) {\n    // function implementation\n}\n"
  },
  {
    "task_id": 122,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n",
    "test_code": "describe('safeSplice', () => {\n    test('should remove specified elements without replacement', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 1;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        expect(result).toEqual([1, 4, 5]);\n    });\n\n    test('should remove specified elements and replace with new element', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 1;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 99, 4, 5]);\n    });\n\n    test('should handle removing elements from the end of the array', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 2;\n        const indexToRemove = 3;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove);\n        expect(result).toEqual([1, 2, 3]);\n    });\n\n    test('should handle the case where no elements are removed', () => {\n        const inputArray = [1, 2, 3, 4, 5];\n        const amountToRemove = 0;\n        const indexToRemove = 2;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([1, 2, 99, 3, 4, 5]);\n    });\n\n    test('should handle edge case with an empty input array', () => {\n        const inputArray = [];\n        const amountToRemove = 1;\n        const indexToRemove = 0;\n        const replaceWith = 99;\n        const result = safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith);\n        expect(result).toEqual([99]);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Safely splices an array by removing a specified number of elements from a given index,\n * and optionally replaces them with a new element.\n * \n * @param {Array} inputArray - The original array to be modified.\n * @param {number} amountToRemove - The number of elements to remove from the array.\n * @param {number} indexToRemove - The index at which to start removing elements.\n * @param {*} [replaceWith] - Optional. The element to replace the removed elements with.\n * @returns {Array} - A new array with the specified elements removed and optionally replaced.\n */\nfunction safeSplice(inputArray, amountToRemove, indexToRemove, replaceWith) {\n    // function implementation\n}\n"
  },
  {
    "task_id": 123,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n",
    "test_code": "describe('scaleToRange function tests', () => {\n    test('simple scaling', () => {\n        const result = scaleToRange([1, 2, 3, 4, 5], 1, 5, 10, 50);\n        expect(result).toEqual([10, 20, 30, 40, 50]);\n    });\n\n    test('scaling with negative input range', () => {\n        const result = scaleToRange([-5, 0, 5], -5, 5, 0, 100);\n        expect(result).toEqual([0, 50, 100]);\n    });\n\n    test('scaling with negative output range', () => {\n        const result = scaleToRange([0, 50, 100], 0, 100, -100, 100);\n        expect(result).toEqual([-100, 0, 100]);\n    });\n\n    test('input array containing the same value', () => {\n        const result = scaleToRange([2, 2, 2], 1, 3, 0, 10);\n        expect(result).toEqual([5, 5, 5]);\n    });\n\n    test('input value out of range should throw an error', () => {\n        expect(() => {\n            scaleToRange([1, 2, 3, 6], 1, 5, 0, 10);\n        }).toThrow();\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Scales the values in an array from one range to another.\n * \n * @param {number[]} inputArray - The array of input values to be scaled.\n * @param {number} inputMin - The minimum value in the input range.\n * @param {number} inputMax - The maximum value in the input range.\n * @param {number} outputMin - The minimum value in the output range.\n * @param {number} outputMax - The maximum value in the output range.\n * @returns {number[]} - A new array with values scaled to the output range.\n * @throws {Error} - Throws an error if any value in inputArray is outside the range [inputMin, inputMax].\n */\nfunction scaleToRange(inputArray, inputMin, inputMax, outputMin, outputMax) {\n    // function implementation\n}\n"
  },
  {
    "task_id": 124,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n",
    "test_code": "describe('shuffle function tests', () => {\n    test('shuffles an array of numbers', () => {\n        const array = [1, 2, 3, 4, 5];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n        expect(new Set(shuffledArray).size).toEqual(new Set(array).size); // Ensure no duplicates\n    });\n\n    test('shuffles an array of strings', () => {\n        const array = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with duplicate elements', () => {\n        const array = [1, 1, 2, 2, 3, 3];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(array.length);\n        expect(shuffledArray.every(item => array.includes(item))).toBeTruthy();\n    });\n\n    test('shuffles an array with a single element', () => {\n        const array = [42];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray).toEqual(array);\n    });\n\n    test('shuffles an empty array', () => {\n        const array = [];\n        const shuffledArray = shuffle([...array]);\n        expect(shuffledArray.length).toEqual(0);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Randomly shuffles the elements of the input array in place.\n *\n * @param {Array} array - The array of elements to be shuffled.\n * @returns {Array} - The shuffled array with its elements in random order.\n */\nfunction shuffle(array) {\n    // function implementation\n}\n"
  },
  {
    "task_id": 125,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <textarea>, <script>, and <style> tags.\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}",
    "test_code": "describe('compressHTML', () => {\n    test('removes unnecessary spaces around tags', () => {\n        const html = '   <div>   Content  </div>   ';\n        const expected = '<div>Content</div>';\n        expect(compressHTML(html)).toBe(expected);\n    });\n\n    test('preserves content inside <pre> tags', () => {\n        const html = '<pre>    function hello() {\\n      console.log(\"Hello, world!\");\\n    }    </pre>';\n        const expected = '<pre>    function hello() {\\n      console.log(\"Hello, world!\");\\n    }    </pre>';\n        expect(compressHTML(html)).toBe(expected);\n    });\n\n    test('removes newlines and spaces starting a newline', () => {\n        const html = 'Line 1\\n   Line 2\\r\\n Line 3\\r   Line 4';\n        const expected = 'Line 1Line 2Line 3Line 4';\n        expect(compressHTML(html)).toBe(expected);\n    });\n\n\n    test('handles empty and whitespace-only strings correctly', () => {\n        expect(compressHTML('')).toBe('');\n        expect(compressHTML('   \\n\\r  ')).toBe('');\n    });\n});\n",
    "prompt": "please write a javascript function the function signature as below /**\n * Compresses an HTML string by removing unnecessary whitespace without disrupting\n * the integrity of content within <pre>, <textarea>, <script>, and <style> tags.\n *\n * @param {string} htmlString - The HTML content to compress.\n * @returns {string} The compressed HTML content.\n */\nfunction compressHTML(htmlString) {\n\n}"
  },
  {
    "task_id": 126,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Calculates the great-circle distance between two points on the Earth\n * using their latitude and longitude based on the Haversine formula.\n *\n * @param {number} lat1 - Latitude of the first point in degrees.\n * @param {number} lon1 - Longitude of the first point in degrees.\n * @param {number} lat2 - Latitude of the second point in degrees.\n * @param {number} lon2 - Longitude of the second point in degrees.\n * @returns {number} The distance between the two points in kilometers.\n */\nfunction calculateDistance(lat1, lon1, lat2, lon2) {\n\n}",
    "test_code": "describe('calculateDistance', () => {\n    test('calculates distance between two points in the same city', () => {\n        // Coordinates for two points in Los Angeles\n        const distance = calculateDistance(34.052235, -118.243683, 34.052236, -118.243684);\n        expect(distance).toBeCloseTo(0.00013, 5);  // The distance should be very small\n    });\n\n    test('calculates distance between two major cities', () => {\n        // Coordinates for Los Angeles and New York\n        const distance = calculateDistance(34.052235, -118.243683, 40.712776, -74.005974);\n        expect(distance).toBeCloseTo(3940, 0);  // Known distance is approximately 3940 kilometers\n    });\n\n    test('calculates distance between two points in different continents', () => {\n        // Coordinates for New York in the USA and London in the UK\n        const distance = calculateDistance(40.712776, -74.005974, 51.507351, -0.127758);\n        expect(distance).toBeCloseTo(5567, 0);  // Known distance is approximately 5567 kilometers\n    });\n\n    test('handles zero distance when the same coordinates are given', () => {\n        // Same coordinates for a location in Paris\n        const distance = calculateDistance(48.8566, 2.3522, 48.8566, 2.3522);\n        expect(distance).toBe(0);  // Distance should be zero\n    });\n\n    test('calculates correct distance with negative and positive longitude and latitude', () => {\n        // Coordinates for Sydney and Auckland\n        const distance = calculateDistance(-33.8688, 151.2093, -36.8485, 174.7633);\n        expect(distance).toBeCloseTo(2159, 0);  // Known distance is approximately 2159 kilometers\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Calculates the great-circle distance between two points on the Earth\n * using their latitude and longitude based on the Haversine formula.\n *\n * @param {number} lat1 - Latitude of the first point in degrees.\n * @param {number} lon1 - Longitude of the first point in degrees.\n * @param {number} lat2 - Latitude of the second point in degrees.\n * @param {number} lon2 - Longitude of the second point in degrees.\n * @returns {number} The distance between the two points in kilometers.\n */\nfunction calculateDistance(lat1, lon1, lat2, lon2) {\n\n}"
  },
  {
    "task_id": 127,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}",
    "test_code": "describe('separateOctaveAndRoot', () => {\n    test('correctly separates MIDI notes into octaves and root notes', () => {\n        const midiNotes = [60, 61, 62];  // C4, C#4, D4\n        const expected = {\n            octaveNotes: [5, 5, 5],  // All notes are in the 5th octave\n            rootNotes: [0, 1, 2]     // Root notes are C, C#, D\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('handles single MIDI note input', () => {\n        const midiNotes = [24];  // C1\n        const expected = {\n            octaveNotes: [2],  // 2nd octave\n            rootNotes: [0]     // C note\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('returns empty arrays for an empty input array', () => {\n        const midiNotes = [];\n        const expected = {\n            octaveNotes: [],\n            rootNotes: []\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n\n    test('throws an error for invalid input types', () => {\n        const invalidInput = \"not an array\";\n        expect(() => separateOctaveAndRoot(invalidInput)).toThrow(TypeError);\n        expect(() => separateOctaveAndRoot([3.14])).toThrow(TypeError);\n    });\n\n    test('handles MIDI notes from different octaves', () => {\n        const midiNotes = [12, 25, 37];  // C1, C#2, D#3\n        const expected = {\n            octaveNotes: [1, 2, 3],  // 1st, 2nd, and 3rd octaves\n            rootNotes: [0, 1, 1]     // Root notes are C, C#, D#\n        };\n        expect(separateOctaveAndRoot(midiNotes)).toEqual(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Splits a list of MIDI note numbers into separate arrays of octaves and root notes.\n *\n * @param {number[]} midiNotes - An array of MIDI note numbers.\n * @returns {Object} An object containing arrays of octaves and root notes.\n */\nfunction separateOctaveAndRoot(midiNotes) {\n\n}"
  },
  {
    "task_id": 129,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}",
    "test_code": "describe('validURL', () => {\n    test('validates a standard HTTP URL', () => {\n        const url = 'http://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('validates a secure HTTPS URL', () => {\n        const url = 'https://www.example.com';\n        expect(validURL(url)).toBe(true);\n    });\n\n    test('rejects a malformed URL', () => {\n        const url = 'htp:/www.example.com';\n        expect(validURL(url)).toBe(false);\n    });\n\n    test('validates a URL with IP address and query parameters', () => {\n        const url = 'http://192.168.1.1:8080/search?query=test';\n        expect(validURL(url)).toBe(true);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Validates a URL string using a simplified and more comprehensive regular expression.\n *\n * @param {string} str - The URL string to validate.\n * @returns {boolean} True if the URL is valid, false otherwise.\n */\nfunction validURL(str) {\n\n}"
  },
  {
    "task_id": 130,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}",
    "test_code": "describe('computePi', () => {\n    test('should calculate pi to 5 decimal places correctly', () => {\n        const digits = 5;\n        const expected = '3.14159';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 10 decimal places correctly', () => {\n        const digits = 10;\n        const expected = '3.1415926536';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 15 decimal places correctly', () => {\n        const digits = 15;\n        const expected = '3.141592653589793';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 20 decimal places correctly', () => {\n        const digits = 20;\n        const expected = '3.14159265358979323846';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n\n    test('should calculate pi to 30 decimal places correctly', () => {\n        const digits = 30;\n        const expected = '3.141592653589793238462643383280';\n        const result = computePi(digits);\n        expect(result).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Computing PI (\u03c0) Using Gauss-Legendre Algorithm with High-precision Arithmetic Library decimal.js\n *\n * @param {number} digits - The number of decimal digits to compute \u03c0 to.\n * @returns {string} - The value of \u03c0 to the specified number of digits.\n */\nfunction computePi(digits) {\n\n}"
  },
  {
    "task_id": 131,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}",
    "test_code": "/**\n * @jest-environment jsdom\n */\n\nlet cssRuleExistsForHighlight = false;\ndescribe('checkCSSHighlightAndAdd', () => {\n    beforeEach(() => {\n        // Reset the global variable and clean up the document head before each test.js\n        cssRuleExistsForHighlight = false;\n        document.head.innerHTML = '';\n    });\n\n    test('should add a new style element with the highlight CSS rule if it does not exist', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that a style element was added to the document head\n        const styleElement = document.querySelector('style');\n        expect(styleElement).not.toBeNull();\n\n        // Check that the style element contains the correct CSS rule\n        expect(styleElement.textContent).toContain('::highlight(search-result-highlight)');\n        expect(styleElement.textContent).toContain('background-color: yellow;');\n        expect(styleElement.textContent).toContain('color: black;');\n    });\n\n    test('should set cssRuleExistsForHighlight to true after adding the CSS rule', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the flag is set to true after the rule is added\n        expect(cssRuleExistsForHighlight).toBe(true);\n    });\n\n    test('should not add a new style element if the CSS rule already exists', () => {\n        cssRuleExistsForHighlight = true;\n\n        checkCSSHighlightAndAdd();\n\n        // Check that no new style element is added\n        const styleElements = document.querySelectorAll('style');\n        expect(styleElements.length).toBe(0);\n    });\n\n    test('should add only one style element even if called multiple times', () => {\n        checkCSSHighlightAndAdd();\n        checkCSSHighlightAndAdd();  // Call the function again\n\n        // Check that only one style element is present\n        const styleElements = document.querySelectorAll('style');\n        expect(styleElements.length).toBe(1);\n    });\n\n    test('should correctly append the style element to the document head', () => {\n        checkCSSHighlightAndAdd();\n\n        // Check that the style element is indeed appended to the head\n        const styleElement = document.head.querySelector('style');\n        expect(styleElement).not.toBeNull();\n        expect(document.head.contains(styleElement)).toBe(true);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Add a CSS rule to the HTML document to highlight search results\n */\nfunction checkCSSHighlightAndAdd() {\n\n}"
  },
  {
    "task_id": 132,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes data to a file synchronously.\n *\n * @param {string} filePath - The path to the file where data will be written.\n * @param {string} data - The data to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}",
    "test_code": "jest.mock('fs');\ndescribe('File Utility Functions', () => {\n\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    test('readFile should return file content as a string', () => {\n        const mockContent = 'Hello, world!';\n        fs.readFileSync.mockReturnValue(mockContent);\n\n        const result = readFile('/path/to/file.txt');\n        expect(result).toBe(mockContent);\n        expect(fs.readFileSync).toHaveBeenCalledWith('/path/to/file.txt', 'utf8');\n    });\n\n    test('readFile should throw an error if file cannot be read', () => {\n        fs.readFileSync.mockImplementation(() => {\n            throw new Error('File not found');\n        });\n\n        expect(() => readFile('/invalid/path.txt')).toThrow('Failed to read file at /invalid/path.txt: File not found');\n    });\n\n    test('writeFile should write data to the specified file', () => {\n        const dataToWrite = 'Some data to write';\n\n        writeFile('/path/to/file.txt', dataToWrite);\n\n        expect(fs.writeFileSync).toHaveBeenCalledWith('/path/to/file.txt', dataToWrite);\n    });\n\n    test('writeFile should throw an error if file cannot be written', () => {\n        fs.writeFileSync.mockImplementation(() => {\n            throw new Error('Permission denied');\n        });\n\n        expect(() => writeFile('/invalid/path.txt', 'data')).toThrow('Failed to write file at /invalid/path.txt: Permission denied');\n    });\n\n    test('writeFile should be called with correct arguments', () => {\n        const dataToWrite = 'Test data';\n        const filePath = '/path/to/file.txt';\n\n        writeFile(filePath, dataToWrite);\n\n        expect(fs.writeFileSync).toHaveBeenCalledWith(filePath, dataToWrite);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Use ESM syntax to import the file system module and define the file read and write operation functions\n */\n\n/**\n * Reads the content of a file synchronously and returns it as a string.\n *\n * @param {string} filePath - The path to the file to be read.\n * @returns {string} - The content of the file as a UTF-8 encoded string.\n * @throws {Error} - Throws an error if the file cannot be read.\n */\nfunction readFile(filePath) {\n\n}\n\n/**\n * Writes data to a file synchronously.\n *\n * @param {string} filePath - The path to the file where data will be written.\n * @param {string} data - The data to be written to the file.\n * @throws {Error} - Throws an error if the file cannot be written.\n */\nfunction writeFile(filePath, data) {\n\n}"
  },
  {
    "task_id": 133,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Tests whether the input string is a valid number between 5 and 18\n *\n * @param {string} inputNumber - The input string to validate.\n * @returns {string|boolean} - Returns \"Not Numerical\" if the input is not a number,\n *                             \"Invalid Length, Must Be Between 5-18\" if the input length\n *                             is not within the required range, true if the input is valid,\n *                             or \"Invalid Input\" in case of unexpected errors.\n */\nfunction isValidNumber(inputNumber) {\n\n}",
    "test_code": "describe('isValidNumber', () => {\n\n    test('should return \"Not Numerical\" when input is not a number', () => {\n        const result = isValidNumber('abc123');\n        expect(result).toBe(\"Not Numerical\");\n    });\n\n    test('should return \"Invalid Length, Must Be Between 5-18\" when input length is less than 5', () => {\n        const result = isValidNumber('1234');\n        expect(result).toBe(\"Invalid Length, Must Be Between 5-18\");\n    });\n\n    test('should return \"Invalid Length, Must Be Between 5-18\" when input length is greater than 18', () => {\n        const result = isValidNumber('1234567890123456789');\n        expect(result).toBe(\"Invalid Length, Must Be Between 5-18\");\n    });\n\n    test('should return true for a valid number within the length range', () => {\n        const result = isValidNumber('123456');\n        expect(result).toBe(true);\n    });\n\n    test('should return \"Invalid Input\" when an unexpected error occurs', () => {\n        // This test.js simulates an error scenario,\n        // which is tricky since the function does not throw errors naturally.\n        // Here, we use a mock to simulate this behavior.\n        const originalTrim = String.prototype.trim;\n        String.prototype.trim = () => { throw new Error(); }; // Force an error\n\n        const result = isValidNumber(' 12345 ');\n        expect(result).toBe(\"Invalid Input\");\n\n        // Restore original trim method\n        String.prototype.trim = originalTrim;\n    });\n\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Tests whether the input string is a valid number between 5 and 18\n *\n * @param {string} inputNumber - The input string to validate.\n * @returns {string|boolean} - Returns \"Not Numerical\" if the input is not a number,\n *                             \"Invalid Length, Must Be Between 5-18\" if the input length\n *                             is not within the required range, true if the input is valid,\n *                             or \"Invalid Input\" in case of unexpected errors.\n */\nfunction isValidNumber(inputNumber) {\n\n}"
  },
  {
    "task_id": 134,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Checks whether the username is a string of length 5 to 16 that contains only alphanumeric Spaces\n *\n * @param {string} username - The input string to validate as a username.\n * @returns {string|boolean} - Returns \"Invalid Length, Must Be Between 5-16\" if the input length\n *                             is not within the required range, \"Name Can Only Contain Letters, Numbers, and White Space\"\n *                             if the input contains invalid characters, true if the input is valid,\n *                             or \"Invalid Input\" in case of unexpected errors.\n */\nfunction isValidUserName(username) {\n\n}",
    "test_code": "describe('isValidUserName', () => {\n\n    test('should return \"Invalid Length, Must Be Between 5-16\" when input length is less than 5', () => {\n        const result = isValidUserName('John');\n        expect(result).toBe(\"Invalid Length, Must Be Between 5-16\");\n    });\n\n    test('should return \"Invalid Length, Must Be Between 5-16\" when input length is greater than 16', () => {\n        const result = isValidUserName('ThisUserNameIsTooLong');\n        expect(result).toBe(\"Invalid Length, Must Be Between 5-16\");\n    });\n\n    test('should return \"Name Can Only Contain Letters, Numbers, and White Space\" when input contains invalid characters', () => {\n        const result = isValidUserName('User@Name!');\n        expect(result).toBe(\"Name Can Only Contain Letters, Numbers, and White Space\");\n    });\n\n    test('should return true for a valid username within the length range and containing only allowed characters', () => {\n        const result = isValidUserName('JohnDoe123');\n        expect(result).toBe(true);\n    });\n\n    test('should return \"Invalid Input\" when an unexpected error occurs', () => {\n        // This test.js simulates an error scenario,\n        // which is tricky since the function does not throw errors naturally.\n        // Here, we use a mock to simulate this behavior.\n        const originalTrim = String.prototype.trim;\n        String.prototype.trim = () => { throw new Error(); }; // Force an error\n\n        const result = isValidUserName(' JohnDoe ');\n        expect(result).toBe(\"Invalid Input\");\n\n        // Restore original trim method\n        String.prototype.trim = originalTrim;\n    });\n\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Checks whether the username is a string of length 5 to 16 that contains only alphanumeric Spaces\n *\n * @param {string} username - The input string to validate as a username.\n * @returns {string|boolean} - Returns \"Invalid Length, Must Be Between 5-16\" if the input length\n *                             is not within the required range, \"Name Can Only Contain Letters, Numbers, and White Space\"\n *                             if the input contains invalid characters, true if the input is valid,\n *                             or \"Invalid Input\" in case of unexpected errors.\n */\nfunction isValidUserName(username) {\n\n}"
  },
  {
    "task_id": 135,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}",
    "test_code": "describe('isValidPortNumber', () => {\n    test('returns true for a valid port number in the middle of the range', () => {\n        expect(isValidPortNumber(8080)).toBe(true);\n    });\n\n    test('returns true for the lowest valid port number', () => {\n        expect(isValidPortNumber(1)).toBe(true);\n    });\n\n    test('returns true for the highest valid port number', () => {\n        expect(isValidPortNumber(65535)).toBe(true);\n    });\n\n    test('returns false for a port number below the valid range', () => {\n        expect(isValidPortNumber(0)).toBe(false);\n    });\n\n    test('returns false for a port number above the valid range', () => {\n        expect(isValidPortNumber(65536)).toBe(false);\n    });\n\n    test('throws TypeError for non-integer values', () => {\n        expect(() => isValidPortNumber('3000')).toThrow(TypeError);\n        expect(() => isValidPortNumber(300.5)).toThrow(TypeError);\n    });\n\n    test('throws TypeError for NaN or undefined values', () => {\n        expect(() => isValidPortNumber(NaN)).toThrow(TypeError);\n        expect(() => isValidPortNumber(undefined)).toThrow(TypeError);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Checks if the provided port number is within the valid range of TCP/UDP ports.\n * Valid TCP/UDP port numbers range from 1 to 65535.\n *\n * @param {number} port - The port number to verify.\n * @returns {boolean} Returns true if the port number is valid, false otherwise.\n */\nfunction isValidPortNumber(port) {\n\n}"
  },
  {
    "task_id": 137,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}",
    "test_code": "describe('mergeObjects', () => {\n    test('correctly merges two objects with non-conflicting keys', () => {\n        const obj1 = { name: \"Alice\" };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('properties from the second object overwrite properties from the first', () => {\n        const obj1 = { name: \"Alice\", age: 25 };\n        const obj2 = { age: 30 };\n        const expected = { name: \"Alice\", age: 30 };\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('merges objects with nested structures correctly', () => {\n        const obj1 = { user: { name: \"Alice\", age: 25 } };\n        const obj2 = { user: { age: 30 } };\n        const expected = { user: { age: 30 } };  // Note: obj2 does not merge deeply, it replaces the entire 'user' object\n        expect(mergeObjects(obj1, obj2)).toEqual(expected);\n    });\n\n    test('throws TypeError if either input is not an object', () => {\n        const obj1 = \"not an object\";\n        const obj2 = { valid: true };\n        expect(() => mergeObjects(obj1, obj2)).toThrow(TypeError);\n        expect(() => mergeObjects(obj2, obj1)).toThrow(TypeError);\n    });\n\n    test('handles null and arrays correctly by throwing TypeError', () => {\n        const obj1 = null;\n        const obj2 = [];\n        expect(() => mergeObjects(obj1, obj2)).toThrow(TypeError);\n        expect(() => mergeObjects(obj2, obj1)).toThrow(TypeError);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Merges two objects into one, with properties from the second object\n * potentially overwriting those from the first if there are conflicts.\n *\n * @param {Object} obj1 - The first object.\n * @param {Object} obj2 - The second object.\n * @returns {Object} - The resulting object after merging.\n */\nfunction mergeObjects(obj1, obj2) {\n\n}"
  },
  {
    "task_id": 138,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}",
    "test_code": "describe('removePunctuation', () => {\n    test('removes punctuation from a simple sentence', () => {\n        const input = \"Hello, world!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('handles a string with no punctuation', () => {\n        const input = \"Hello world\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('converts mixed case letters to lowercase', () => {\n        const input = \"HeLLo WoRLd!\";\n        const expected = \"hello world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('removes a variety of punctuation', () => {\n        const input = \"Life, in a nutshell: eat, sleep, code!\";\n        const expected = \"life in a nutshell eat sleep code\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n\n    test('trims whitespace from the ends of the string', () => {\n        const input = \"   What a wonderful world!   \";\n        const expected = \"what a wonderful world\";\n        expect(removePunctuation(input)).toBe(expected);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Removes all punctuation from a given string, converts the string to lowercase,\n * and trims whitespace from both ends.\n *\n * @param {string} str - The string from which to remove punctuation.\n * @returns {string} The cleaned and formatted string.\n */\nfunction removePunctuation(str) {\n\n}"
  },
  {
    "task_id": 139,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized data.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}",
    "test_code": "describe('parseCategoriesFromSummary', () => {\n    test('extracts categories and cleans the summary correctly', () => {\n        const input = \"This is a summary. Categories: [Technology, Health]\";\n        const expected = {\n            summary: \"This is a summary.\",\n            categories: [\"Technology\", \"Health\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('returns empty categories and original summary when no categories are present', () => {\n        const input = \"This is a summary without categories.\";\n        const expected = {\n            summary: \"This is a summary without categories.\",\n            categories: []\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('ignores case of the category prefix', () => {\n        const input = \"Summary text. categories: [Education, Science]\";\n        const expected = {\n            summary: \"Summary text.\",\n            categories: [\"Education\", \"Science\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('handles extra spaces and malformed category strings correctly', () => {\n        const input = \"Details follow. Categories: [ Business ,  , Finance]\";\n        const expected = {\n            summary: \"Details follow.\",\n            categories: [\"Business\", \"Finance\"]  // Note the removal of an empty string due to extra commas\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n\n    test('removes the category string correctly even if it appears in the middle of the summary', () => {\n        const input = \"Beginning of summary. Categories: [Art, Design] Continuation of summary.\";\n        const expected = {\n            summary: \"Beginning of summary. Continuation of summary.\",\n            categories: [\"Art\", \"Design\"]\n        };\n        expect(parseCategoriesFromSummary(input)).toEqual(expected);\n    });\n});\n",
    "prompt": "please write a javascript function the function signature as below /**\n * Extracts categories from a summarized output string and returns the cleaned summary and categories.\n * The categories are expected to be in the format \"Categories: [category1, category2, ...]\".\n *\n * @param {string} summarizedOutput - The summary text potentially containing categorized data.\n * @returns {object} An object containing the cleaned summary text and an array of categories.\n */\nfunction parseCategoriesFromSummary(summarizedOutput = '') {\n\n}"
  },
  {
    "task_id": 292,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments){\n    \n}\n",
    "test_code": "describe('calculateRemainingPayment', () => {\n    test('calculates correct remaining payment for standard inputs', () => {\n        expect(calculateRemainingPayment(1000, 0.01, 12)).toBeCloseTo(88.85, 2);\n    });\n\n    test('handles zero interest rate', () => {\n        expect(calculateRemainingPayment(5000, 0.02, 24)).toBeCloseTo(264.36,2);\n    });\n\n    test('manages high interest rates', () => {\n        expect(calculateRemainingPayment(1500, 0.015, 36)).toBeCloseTo(54.23, 2);\n    });\n\n    test('handles zero number of payments', () => {\n        expect(calculateRemainingPayment(3000, 0.01, 60)).toBeCloseTo(66.73,2); // Depending on how you decide to handle this case, this might need adjustment\n    });\n\n    test('handles negative inputs', () => {\n        expect(calculateRemainingPayment(2500,  0.025, 48)).toBeCloseTo(90.01,2); // This expected result depends on how you handle such cases\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Calculate the remaining payment for a loan based on the given debt, monthly interest rate, and total payments.\n *\n * @param {number} principal - The initial amount of the debt.\n * @param {number} interestRate - The monthly interest rate as a decimal.\n * @param {number} numberOfPayments - The total number of payments.\n * @returns {number} - The calculated remaining payment.\n */\nfunction calculateRemainingPayment(principal, interestRate, numberOfPayments){\n    \n}\n"
  },
  {
    "task_id": 293,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Reorders image data based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n",
    "test_code": "describe('reorderData', () => {\n    test('sorts data correctly for basic inputs', () => {\n        const scores = [3, 1, 2];\n        const names = ['Image3', 'Image1', 'Image2'];\n        const ids = [103, 101, 102];\n        const expected = {\n            resultScores: [1, 2, 3],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('sorts data correctly with mixed scores', () => {\n        const scores = [5, 1, 3, 5, 2];\n        const names = ['Image5', 'Image1', 'Image3', 'Image6', 'Image2'];\n        const ids = [105, 101, 103, 106, 102];\n        const expected = {\n            resultScores: [1, 2, 3, 5, 5],\n            resultNames: ['Image1', 'Image2', 'Image3', 'Image5', 'Image6'],\n            resultIDs: [101, 102, 103, 105, 106]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles duplicate scores', () => {\n        const scores = [2, 2, 1];\n        const names = ['Image2', 'Image3', 'Image1'];\n        const ids = [102, 103, 101];\n        const expected = {\n            resultScores: [1, 2, 2],\n            resultNames: ['Image1', 'Image2', 'Image3'],\n            resultIDs: [101, 102, 103]\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n    test('handles empty arrays', () => {\n        const scores = [];\n        const names = [];\n        const ids = [];\n        const expected = {\n            resultScores: [],\n            resultNames: [],\n            resultIDs: []\n        };\n        expect(reorderData(scores, names, ids)).toEqual(expected);\n    });\n\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Reorders image data based on scores in ascending order.\n *\n * @param {number[]} imageScores - An array of numerical scores for the images.\n * @param {string[]} imageNames - An array of image names corresponding to the scores.\n * @param {string[]|number[]} imageIDs - An array of image IDs corresponding to the scores.\n * @returns {{resultScores: number[], resultNames: string[], resultIDs: (string[]|number[])}} - An object containing the sorted scores, names, and IDs.\n */\nfunction reorderData(imageScores, imageNames, imageIDs) {}\n"
  },
  {
    "task_id": 298,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}",
    "test_code": "describe('setEurValue', () => {\n    test('formats standard values correctly', () => {\n        expect(setEurValue('250')).toBe('250');\n        expect(setEurValue('2500')).toBe('2.5k');\n    });\n\n    test('handles boundary values accurately', () => {\n        expect(setEurValue('999')).toBe('999');\n        expect(setEurValue('1000')).toBe('1.0k');\n        expect(setEurValue('999999')).toBe('1000.0k');\n        expect(setEurValue('1000000')).toBe('1.0m');\n    });\n\n    test('returns correct format for zero and negative inputs', () => {\n        expect(setEurValue('0')).toBe('0');\n    });\n\n    test('returns an empty string for invalid inputs', () => {\n        expect(setEurValue('hello')).toBe('');\n        expect(setEurValue(null)).toBe('');\n        expect(setEurValue(undefined)).toBe('');\n    });\n\n    test('ensures precision for large numbers', () => {\n        expect(setEurValue('10000000')).toBe('10.0m');\n        expect(setEurValue('987654321')).toBe('987.7m');\n    });\n});\n",
    "prompt": "please write a javascript function the function signature as below /**\n * Converts a numerical value into a string representation with appropriate\n * suffixes ('k' for thousands, 'm' for millions) or returns the number as a string\n * if the value is below 1000. Returns an empty string for non-numeric or invalid inputs.\n *\n * @param {string|number} value - The value to convert.\n * @returns {string} - The formatted string or an empty string if the input is invalid.\n */\nfunction setEurValue(value) {\n}"
  },
  {
    "task_id": 299,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n",
    "test_code": "describe('setEurValue', () => {\n    test('Birthday today, should be 24 years old', () => {\n        expect(calculateAge('2000-08-23')).toBe('2000-08-23 (24)')\n    });\n\n    test('Birthday has passed this year, should be 34 years old', () => {\n        expect(calculateAge('1990-01-15')).toBe('1990-01-15 (34)')\n    });\n\n    test('Birthday at the end of the year, should be 38 years old', () => {\n        expect(calculateAge('1985-12-31')).toBe('1985-12-31 (38)')\n    });\n\n    test('Recently turned 1 year old this year', () => {\n        expect(calculateAge('2023-05-05')).toBe('2023-05-05 (1)')\n    });\n\n\n    test('Invalid date input should return an empty string', () => {\n        expect(calculateAge('invalid-date')).toBe('')\n    });\n});\n",
    "prompt": "please write a javascript function the function signature as below /**\n * Calculates the age from the given birth date string and returns a string containing the original birth date and the calculated age. If the entered date string is invalid or empty, the function returns an empty string.\n *\n * @param {string} birthDateString - The birth date as a string in a recognizable date format (e.g., 'YYYY-MM-DD').\n * @returns {string} - A string that includes the original birth date and the calculated age in the format 'birthDateString (age)', or an empty string if the input is invalid.\n */\nfunction calculateAge(birthDateString) {\n}\n"
  },
  {
    "task_id": 300,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}",
    "test_code": "/**\n * @jest-environment jsdom\n */\n\ndescribe('removeAds', () => {\n    beforeEach(() => {\n        // Reset the DOM before each test.js\n        document.body.innerHTML = '';\n    });\n\n    test('removes a single sponsored product', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(1);\n        expect(listItems[0].textContent).toBe('Regular Item');\n    });\n\n    test('removes multiple sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Regular Item</li>\n                <li><span class=\"css-16lshh0\">Sponsored</span></li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Regular Item');\n        expect(listItems[1].textContent).toBe('Another Regular Item');\n    });\n\n    test('does not remove any items if there are no sponsored products', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>Regular Item</li>\n                <li>Another Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Regular Item');\n        expect(listItems[1].textContent).toBe('Another Regular Item');\n    });\n\n    test('removes items with nested sponsored indicators', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li>\n                    <div>\n                        <span class=\"css-16lshh0\">Sponsored</span>\n                    </div>\n                </li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(1);\n        expect(listItems[0].textContent).toBe('Regular Item');\n    });\n\n    test('does not remove items with similar but non-sponsored class names', () => {\n        document.body.innerHTML = `\n            <ul>\n                <li><span class=\"css-16lshh1\">Not Sponsored</span></li>\n                <li>Regular Item</li>\n            </ul>\n        `;\n\n        removeAds();\n\n        const listItems = document.querySelectorAll('li');\n        expect(listItems.length).toBe(2);\n        expect(listItems[0].textContent).toBe('Not Sponsored');\n        expect(listItems[1].textContent).toBe('Regular Item');\n    });\n});\n",
    "prompt": "please write a javascript function the function signature as below /**\n * Iterate over list items on a web page and remove ads that contain a specific class name\n */\nfunction removeAds() {\n\n}"
  },
  {
    "task_id": 305,
    "code_type": "class",
    "code_language": "javascript",
    "code_signature": "/**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}",
    "test_code": "describe('SeededRandom', () => {\n    test('generates consistent numbers with the same seed', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(42);\n\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n        expect(seededRand1.rand()).toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('generates different numbers with different seeds', () => {\n        const seededRand1 = new SeededRandom(42);\n        const seededRand2 = new SeededRandom(24);\n\n        expect(seededRand1.rand()).not.toBeCloseTo(seededRand2.rand(), 10);\n    });\n\n    test('returns numbers between 0 and 1', () => {\n        const seededRand = new SeededRandom(123456);\n\n        for (let i = 0; i < 1000; i++) {\n            const randValue = seededRand.rand();\n            expect(randValue).toBeGreaterThanOrEqual(0);\n            expect(randValue).toBeLessThan(1);\n        }\n    });\n\n    test('produces different sequences with different seeds', () => {\n        const seededRand1 = new SeededRandom(123);\n        const seededRand2 = new SeededRandom(456);\n\n        const sequence1 = Array.from({ length: 5 }, () => seededRand1.rand());\n        const sequence2 = Array.from({ length: 5 }, () => seededRand2.rand());\n\n        expect(sequence1).not.toEqual(sequence2);\n    });\n\n    test('consistent sequence with the same seed over multiple calls', () => {\n        const seededRand = new SeededRandom(987654321);\n\n        const sequence1 = [seededRand.rand(), seededRand.rand(), seededRand.rand()];\n\n        // Re-initialize with the same seed to test.js consistency\n        const seededRand2 = new SeededRandom(987654321);\n        const sequence2 = [seededRand2.rand(), seededRand2.rand(), seededRand2.rand()];\n\n        expect(sequence1).toEqual(sequence2);\n    });\n});\n",
    "prompt": "please write a javascript class this class signature as below /**\n * Define a class called SeededRandom for generating pseudorandom numbers with a specific seed\n */\nclass SeededRandom {\n    /**\n     * Initializes a new instance of the SeededRandom class with a given seed.\n     * @param {number} seed - The initial seed value for the random number generator.\n     */\n    constructor(seed) {\n\n    }\n\n    /**\n     * Generates a random number between 0 and 1 using a Linear Congruential Generator (LCG) algorithm.\n     * @returns {number} A pseudo-random number between 0 (inclusive) and 1 (exclusive).\n     */\n    rand() {\n\n    }\n}"
  },
  {
    "task_id": 306,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}",
    "test_code": "describe('getPrice', () => {\n    test('should return a number within the default range for a given recipe ID', () => {\n        const price = getPrice('recipe123');\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n\n    test('should return the same price for the same recipe ID', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe123');\n        expect(price1).toBe(price2);\n    });\n\n    test('should return different prices for different recipe IDs', () => {\n        const price1 = getPrice('recipe123');\n        const price2 = getPrice('recipe456');\n        expect(price1).not.toBe(price2);\n    });\n\n    test('should return a price within a custom range', () => {\n        const minVal = 20;\n        const maxVal = 50;\n        const price = getPrice('recipe789', minVal, maxVal);\n        expect(price).toBeGreaterThanOrEqual(minVal);\n        expect(price).toBeLessThanOrEqual(maxVal);\n    });\n\n    test('should handle very long recipe IDs without error', () => {\n        const longRecipeId = 'recipe' + 'A'.repeat(1000);\n        const price = getPrice(longRecipeId);\n        expect(price).toBeGreaterThanOrEqual(10);\n        expect(price).toBeLessThanOrEqual(30);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * The recipe ID is hashed to produce a price in the specified range\n *\n * @param {string} recipeId - The ID of the recipe to hash.\n * @param {number} [minVal=10] - The minimum value of the price range.\n * @param {number} [maxVal=30] - The maximum value of the price range.\n * @returns {number} - The hashed price, mapped to the specified range with two decimal places.\n */\nfunction getPrice(recipeId, minVal = 10, maxVal = 30) {\n\n}"
  },
  {
    "task_id": 308,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}",
    "test_code": "describe('getCurrentDate', () => {\n    test('should return a string in the format YYYY-MM-DD', () => {\n        const date = getCurrentDate();\n        expect(typeof date).toBe('string');\n        expect(date).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n    });\n\n    test('should return the correct date for today', () => {\n        const expectedDate = new Date().toISOString().split('T')[0];\n        const actualDate = getCurrentDate();\n        expect(actualDate).toBe(expectedDate);\n    });\n\n    test('should return the correct year part in YYYY-MM-DD', () => {\n        const currentYear = new Date().getFullYear().toString();\n        const actualDate = getCurrentDate();\n        expect(actualDate.startsWith(currentYear)).toBe(true);\n    });\n\n    test('should return the correct month part in YYYY-MM-DD', () => {\n        const currentMonth = (`0${new Date().getMonth() + 1}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(5, 7)).toBe(currentMonth);\n    });\n\n    test('should return the correct day part in YYYY-MM-DD', () => {\n        const currentDay = (`0${new Date().getDate()}`).slice(-2); // Add leading zero if needed\n        const actualDate = getCurrentDate();\n        expect(actualDate.slice(8, 10)).toBe(currentDay);\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * Gets the current date and returns it as YYYY-MM-DD\n *\n * @returns {string} The current date formatted as YYYY-MM-DD.\n */\nfunction getCurrentDate() {\n\n}"
  },
  {
    "task_id": 313,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}",
    "test_code": "/**\n * @jest-environment jsdom\n */\n\ndescribe('isBackgroundTooDarkOrBright', () => {\n    let mainElement;\n\n    beforeEach(() => {\n        // Create a 'main' element and append it to the document body\n        mainElement = document.createElement('main');\n        document.body.appendChild(mainElement);\n    });\n\n    afterEach(() => {\n        // Clean up by removing the 'main' element after each test.js\n        document.body.removeChild(mainElement);\n    });\n\n    test('should return \"dark\" for a dark background color', () => {\n        // Set a dark background color\n        mainElement.style.backgroundColor = 'rgb(30, 30, 30)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n\n    test('should return \"bright\" for a bright background color', () => {\n        // Set a bright background color\n        mainElement.style.backgroundColor = 'rgb(250, 250, 250)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('bright');\n    });\n\n    test('should return \"normal\" for a background color with normal brightness', () => {\n        // Set a background color with normal brightness\n        mainElement.style.backgroundColor = 'rgb(150, 150, 150)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a bright color with high red component', () => {\n        // Set a bright color with a high red component\n        mainElement.style.backgroundColor = 'rgb(255, 100, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('normal');\n    });\n\n    test('should correctly handle a dark color with low green and blue components', () => {\n        // Set a dark color with low green and blue components\n        mainElement.style.backgroundColor = 'rgb(10, 10, 100)';\n\n        const result = isBackgroundTooDarkOrBright();\n        expect(result).toBe('dark');\n    });\n});\n",
    "prompt": "please write a javascript function the function signature as below /**\n * Detecting the light or dark state of the background element of a major element of a web page and returning the corresponding description string\n *\n * @returns {string} - Returns \"dark\" if the background is too dark, \"bright\" if it is too bright, or \"normal\" if it is neither.\n */\nfunction isBackgroundTooDarkOrBright() {\n\n}"
  },
  {
    "task_id": 315,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * extract the file name from the given URL\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {}",
    "test_code": "// Jest test cases for getFileIdFromUrl function\ndescribe('getFileIdFromUrl', () => {\n    test('should return the correct file ID for a valid URL', () => {\n        const result = getFileIdFromUrl('https://example.com/upload/v1234/someFileId.jpg');\n        expect(result).toBe('someFileId'); // 'someFileId' is the expected file ID\n    });\n\n    test('should return null for a URL without the expected pattern', () => {\n        const result = getFileIdFromUrl('https://example.com/invalid/url');\n        expect(result).toBeNull(); // No valid pattern, should return null\n    });\n\n    test('should return the correct file ID for a valid URL with different file types', () => {\n        const result = getFileIdFromUrl('https://example.com/upload/v5678/anotherFile123.pdf');\n        expect(result).toBe('anotherFile123'); // 'anotherFile123' is the expected file ID\n    });\n\n    test('should return the correct file ID for a URL with complex file ID', () => {\n        const result = getFileIdFromUrl('https://example.com/upload/v9876/file-id_456.png');\n        expect(result).toBe('file-id_456'); // 'file-id_456' is the expected file ID\n    });\n\n    test('should return null for an empty string', () => {\n        const result = getFileIdFromUrl('');\n        expect(result).toBeNull(); // An empty string should return null\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * extract the file name from the given URL\n *\n * @param {string} url - The URL from which the file ID is to be extracted.\n * @returns {string|null} - The extracted file ID if present, otherwise null if the URL does not conform to the expected format.\n */\nfunction getFileIdFromUrl(url) {}"
  },
  {
    "task_id": 317,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count alphabetic characters.\n * @returns {number} - The count of alphabetic letters in the string.\n */\nfunction countLetters(str) {\n}",
    "test_code": "// Jest test cases for countLetters function\ndescribe('countLetters', () => {\n    test('should return the correct count for a string with only letters', () => {\n        const result = countLetters('HelloWorld');\n        expect(result).toBe(10); // 'HelloWorld' contains ten letters\n    });\n\n    test('should return 0 for a string with no letters', () => {\n        const result = countLetters('12345!@#$%');\n        expect(result).toBe(0); // '12345!@#$%' contains no letters\n    });\n\n    test('should return the correct count for a string with mixed characters', () => {\n        const result = countLetters('H3ll0 W0rld!');\n        expect(result).toBe(7); // 'H3ll0 W0rld!' contains seven letters\n    });\n\n    test('should return the correct count for a string with uppercase and lowercase letters', () => {\n        const result = countLetters('JavaScript');\n        expect(result).toBe(10); // 'JavaScript' contains ten letters\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countLetters('');\n        expect(result).toBe(0); // An empty string contains no letters\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count alphabetic characters.\n * @returns {number} - The count of alphabetic letters in the string.\n */\nfunction countLetters(str) {\n}"
  },
  {
    "task_id": 318,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}",
    "test_code": "// Jest test cases for countNumbers function\ndescribe('countNumbers', () => {\n    test('should return the correct count for a string with multiple numbers', () => {\n        const result = countNumbers('There are 123 numbers in this string.');\n        expect(result).toBe(3); // '123' contains three numeric characters\n    });\n\n    test('should return 0 for a string with no numbers', () => {\n        const result = countNumbers('No numbers here!');\n        expect(result).toBe(0); // No numeric characters in 'No numbers here!'\n    });\n\n    test('should return the correct count for a string with mixed characters', () => {\n        const result = countNumbers('Room 101 and Room 102');\n        expect(result).toBe(6); // '101' and '102' together contain six numeric characters\n    });\n\n    test('should return the correct count for a string with only numbers', () => {\n        const result = countNumbers('1234567890');\n        expect(result).toBe(10); // '1234567890' contains ten numeric characters\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countNumbers('');\n        expect(result).toBe(0); // An empty string contains no numeric characters\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * count the number of numbers in a string\n *\n * @param {string} str - The string from which to count numeric digits.\n * @returns {number} - The total count of numeric digits found in the string.\n */\nfunction countNumbers(str) {\n}"
  },
  {
    "task_id": 319,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}",
    "test_code": "describe('countDashes', () => {\n    test('should return 0 for a string with no dashes', () => {\n        const result = countDashes('hello world');\n        expect(result).toBe(0); // 'hello world' contains no dashes\n    });\n\n    test('should return 1 for a string with one dash', () => {\n        const result = countDashes('hello-world');\n        expect(result).toBe(1); // 'hello-world' contains one dash\n    });\n\n    test('should return 4 for a string with multiple dashes', () => {\n        const result = countDashes('a-b-c-d-e');\n        expect(result).toBe(4); // 'a-b-c-d-e' contains four dashes\n    });\n\n    test('should return 2 for a string with dashes at the beginning and end', () => {\n        const result = countDashes('-start-end-');\n        expect(result).toBe(3); // '-start-end-' contains two dashes\n    });\n\n    test('should return 0 for an empty string', () => {\n        const result = countDashes('');\n        expect(result).toBe(0); // An empty string contains no dashes\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * count the number of dashes in a string\n *\n * @param {string} str - The string from which to count dash characters.\n * @returns {number} - The total count of dash characters found in the string.\n */\nfunction countDashes(str) {\n}"
  },
  {
    "task_id": 320,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}",
    "test_code": "describe('getArrayAverage', () => {\n    test('should return the average of an array of positive integers', () => {\n        const result = getArrayAverage([1, 2, 3, 4, 5]);\n        expect(result).toBe(3); // (1 + 2 + 3 + 4 + 5) / 5 = 3\n    });\n\n    test('should return the average of an array with negative numbers', () => {\n        const result = getArrayAverage([-1, -2, -3, -4, -5]);\n        expect(result).toBe(-3); // (-1 + -2 + -3 + -4 + -5) / 5 = -3\n    });\n\n    test('should return the average of an array with mixed positive and negative numbers', () => {\n        const result = getArrayAverage([1, -1, 2, -2, 3, -3]);\n        expect(result).toBe(0); // (1 + -1 + 2 + -2 + 3 + -3) / 6 = 0\n    });\n\n    test('should handle an empty array (edge case)', () => {\n        const result = getArrayAverage([]);\n        expect(result).toBeNaN(); // Division by zero, expected result is NaN\n    });\n\n    test('should return the single element when the array contains one item', () => {\n        const result = getArrayAverage([7]);\n        expect(result).toBe(7); // The average of [7] is 7\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * calculate the average of an array of numbers\n *\n * @param {number[]} array - An array of numbers for which the average is to be calculated.\n * @returns {number} - The average (mean) of the array's elements, or NaN if the array is empty.\n */\nfunction getArrayAverage(array) {\n}"
  },
  {
    "task_id": 322,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}",
    "test_code": "describe('isValidEmail', () => {\n    test('should return true for a valid simple email', () => {\n        const result = isValidEmail('test@example.com');\n        expect(result).toBe(true); // 'test@example.com' is a valid email\n    });\n\n    test('should return true for a valid email with subdomain', () => {\n        const result = isValidEmail('user@mail.example.com');\n        expect(result).toBe(true); // 'user@mail.example.com' is a valid email\n    });\n\n    test('should return false for an email missing the @ symbol', () => {\n        const result = isValidEmail('invalid-email.com');\n        expect(result).toBe(false); // 'invalid-email.com' is missing the @ symbol\n    });\n\n    test('should return false for an email missing the domain part', () => {\n        const result = isValidEmail('user@.com');\n        expect(result).toBe(false); // 'user@.com' is missing a valid domain name\n    });\n\n    test('should return false for an email with spaces', () => {\n        const result = isValidEmail('user name@example.com');\n        expect(result).toBe(false); // 'user name@example.com' contains spaces\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * verify that a string is a valid email address\n *\n * @param {string} email - The email address to be validated.\n * @returns {boolean} - Returns true if the email matches the regex pattern, indicating it is valid,\n *                      or false otherwise.\n */\nfunction isValidEmail(email) {\n}"
  },
  {
    "task_id": 323,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n",
    "test_code": "describe('isValidUsername', () => {\n    test('should return true for a valid username with letters, numbers, and underscores', () => {\n        const result = isValidUsername('user_123');\n        expect(result).toBe(true); // 'user_123' is a valid username\n    });\n\n    test('should return true for a valid username with only letters', () => {\n        const result = isValidUsername('username');\n        expect(result).toBe(true); // 'username' is a valid username\n    });\n\n    test('should return false for a username with special characters', () => {\n        const result = isValidUsername('user-name');\n        expect(result).toBe(false); // 'user-name' contains a hyphen\n    });\n\n    test('should return false for a username with spaces', () => {\n        const result = isValidUsername('user name');\n        expect(result).toBe(false); // 'user name' contains spaces\n    });\n\n    test('should return true for a valid username with only numbers', () => {\n        const result = isValidUsername('12345');\n        expect(result).toBe(true); // '12345' is a valid username\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * verify that a string is a valid username and check that the username contains only letters, numbers, and underscores\n *\n * @param {string} username - The username to be validated.\n * @returns {boolean} - Returns true if the username matches the regex pattern, indicating it is valid;\n *                      returns false if the username contains any characters outside of letters, numbers, and underscores.\n */\nfunction isValidUsername(username) {\n}\n"
  },
  {
    "task_id": 326,
    "code_type": "method",
    "code_language": "javascript",
    "code_signature": "/**\n * calculate the time difference between the given date and the current date, and convert this time difference to days, hours, and minutes, returning the string Day: Hour: Minutes.for example return Day: 3 Hour: 3 Minutes: 15 means 3 days, 3 hours, 15 minutes before.Day: -2 Hour: -19 Minutes: -15 means 2 days, 5 hours, 45 minutes in the future\n *\n * @param {string|Date} date - The past date from which to calculate the time difference. Can be a Date object or a string that is parseable by the Date constructor.\n * @returns {string} - A formatted string representing the time difference in days, hours, and minutes.\n */\nfunction getTimeDifference(date) {\n}",
    "test_code": "// Mock current date for consistent test results\nconst mockCurrentDate = new Date('2024-08-23T15:45:00');\njest.useFakeTimers().setSystemTime(mockCurrentDate);\n\ndescribe('getTimeDifference', () => {\n    test('should return correct difference for a past date', () => {\n        const result = getTimeDifference('2024-08-20T12:30:00');\n        expect(result).toBe('Day: 3 Hour: 3 Minutes: 15'); // 3 days, 3 hours, 15 minutes difference\n    });\n\n    test('should return correct difference for a future date', () => {\n        const result = getTimeDifference('2024-08-25T10:00:00');\n        expect(result).toBe('Day: -2 Hour: -19 Minutes: -15'); // 2 days, 5 hours, 45 minutes in the future\n    });\n\n    test('should return correct difference for same day with different time', () => {\n        const result = getTimeDifference('2024-08-23T10:00:00');\n        expect(result).toBe('Day: 0 Hour: 5 Minutes: 45'); // 5 hours, 45 minutes difference on the same day\n    });\n\n    test('should return correct difference for date exactly one day ago', () => {\n        const result = getTimeDifference('2024-08-22T15:45:00');\n        expect(result).toBe('Day: 1 Hour: 0 Minutes: 0'); // 1 day difference exactly\n    });\n\n    test('should return correct difference for a few minutes ago', () => {\n        const result = getTimeDifference('2024-08-23T15:40:00');\n        expect(result).toBe('Day: 0 Hour: 0 Minutes: 5'); // 5 minutes ago\n    });\n});",
    "prompt": "please write a javascript function the function signature as below /**\n * calculate the time difference between the given date and the current date, and convert this time difference to days, hours, and minutes, returning the string Day: Hour: Minutes.for example return Day: 3 Hour: 3 Minutes: 15 means 3 days, 3 hours, 15 minutes before.Day: -2 Hour: -19 Minutes: -15 means 2 days, 5 hours, 45 minutes in the future\n *\n * @param {string|Date} date - The past date from which to calculate the time difference. Can be a Date object or a string that is parseable by the Date constructor.\n * @returns {string} - A formatted string representing the time difference in days, hours, and minutes.\n */\nfunction getTimeDifference(date) {\n}"
  }
]