describe('getIndexValues', () => {
    test('should return the index of the minimum value in an array', () => {
        const inputArray = [3, 1, 4, 1, 5, 9, 2];
        const result = getIndexValues(inputArray, compareMin);
        expect(result).toEqual([[1, 1], [3, 1]]);
    });

    test('should return the index of the maximum value in an array', () => {
        const inputArray = [3, 1, 4, 1, 5, 9, 2];
        const result = getIndexValues(inputArray, compareMax);
        expect(result).toEqual([[5, 9]]);
    });

    test('should return multiple indices if there are multiple minimum values', () => {
        const inputArray = [7, 5, 2, 2, 8];
        const result = getMinIndex(inputArray);
        expect(result).toEqual([[2, 2], [3, 2]]);
    });

    test('should return multiple indices if there are multiple maximum values', () => {
        const inputArray = [10, 4, 10, 1];
        const result = getMaxIndex(inputArray);
        expect(result).toEqual([[0, 10], [2, 10]]);
    });

    test('should return the index of the minimum value when array contains negative numbers', () => {
        const inputArray = [-3, -1, -7, -1, -5];
        const result = getMinIndex(inputArray);
        expect(result).toEqual([[2, -7]]);
    });
});
/**
 * finds the matching elements and their indices in the input array according to the specified comparison function
 *
 * @param {Array} inputArray - The array to search through.
 * @param {Function} comparatorFn - The comparator function to determine the condition.
 * @returns {Array} - An array of [index, value] pairs that meet the comparator condition.
 */
function getIndexValues(inputArray, comparatorFn) {
    let currentIndexValues = [];

    for (let i = 0; i < inputArray.length; i++) {
        const currentValue = inputArray[i];

        if (currentIndexValues.length === 0) {
            // Start with the first element
            currentIndexValues.push([i, currentValue]);
        } else {
            const comparisonResult = comparatorFn(currentValue, currentIndexValues[0][1]);

            if (comparisonResult < 0) {
                // Found a new minimum/maximum, reset the array
                currentIndexValues = [[i, currentValue]];
            } else if (comparisonResult === 0) {
                // Found a value equal to the current min/max, add it
                currentIndexValues.push([i, currentValue]);
            }
        }
    }

    return currentIndexValues;
}

//Generated by chatgpt:
// Comparator function for finding the minimum value
function compareMin(a, b) {
    return a - b;
}

//Generated by chatgpt:
// Comparator function for finding the maximum value
function compareMax(a, b) {
    return b - a;
}

//Generated by chatgpt:
// Specific functions for finding the minimum and maximum index values
function getMinIndex(inputArray) {
    return getIndexValues(inputArray, compareMin);
}

//Generated by chatgpt:
function getMaxIndex(inputArray) {
    return getIndexValues(inputArray, compareMax);
}