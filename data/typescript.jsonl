{"task_id": 140, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}", "test_code": "describe('getTimeSinceBornUntilNow', () => {\n    beforeAll(() => {\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-23T15:45:00'));\n    });\n\n    afterAll(() => {\n        jest.useRealTimers();\n    });\n\n    test('should return the correct difference for a typical birth date', () => {\n        const birthDate = new Date('1990-05-15T10:30:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([34, 3, 8, 5, 15]); // Example output: 34 years, 3 months, 8 days, 5 hours, 15 minutes\n    });\n\n    test('should return the correct difference for a recent birth date', () => {\n        const birthDate = new Date('2024-08-20T12:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 3, 3, 45]); // 3 days, 3 hours, 45 minutes\n    });\n\n    test('should return zero differences for an exact birth date match', () => {\n        const birthDate = new Date('2024-08-23T15:45:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 0, 0, 0, 0]); // Exact match\n    });\n\n    test('should return negative values for a birth date in the future', () => {\n        const birthDate = new Date('2025-01-01T00:00:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([-1, 4, 7, 15, 45]); // Negative years, months, days, etc.\n    });\n\n    test('should handle edge cases at the end of the year', () => {\n        const birthDate = new Date('2023-12-31T23:59:00');\n        const result = getTimeSinceBornUntilNow(birthDate);\n        expect(result).toEqual([0, 7, 22, 15, 46]); // 7 months, 22 days, 15 hours, 46 minutes\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * calculate the years, months, days, hours, and minutes that have passed from the birth date to the current date and return them as an array. The contents of the array are the values of these units\n * @param birthDate\n */\nfunction getTimeSinceBornUntilNow(birthDate: Date): [number, number, number, number, number] {\n\n}"}
{"task_id": 141, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * implement a generic compareArrays function that compares the elements of two arrays to each other\n * @param arr1\n * @param arr2\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n\n}", "test_code": "describe('compareArrays', () => {\n    test('should return true for identical arrays with same order', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return true for identical arrays with different order', () => {\n        const arr1 = [3, 2, 1];\n        const arr2 = [1, 2, 3];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n\n    test('should return false for arrays with different elements', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [4, 5, 6];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return false for arrays with different lengths', () => {\n        const arr1 = [1, 2, 3];\n        const arr2 = [1, 2];\n        expect(compareArrays(arr1, arr2)).toBe(false);\n    });\n\n    test('should return true for arrays with duplicate elements but same unique set', () => {\n        const arr1 = [1, 1, 2, 3, 3];\n        const arr2 = [3, 2, 1, 1];\n        expect(compareArrays(arr1, arr2)).toBe(true);\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * implement a generic compareArrays function that compares the elements of two arrays to each other\n * @param arr1\n * @param arr2\n */\nfunction compareArrays<T>(arr1: Array<T>, arr2: Array<T>): boolean {\n\n}"}
{"task_id": 142, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * convert a string with hump nomenclature to a string with spaces and capitalize the initial letter\n * @param input\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n\n}", "test_code": "describe('convertCamelCaseToSentence', () => {\n    test('should convert a simple camelCase string to a sentence', () => {\n        const input = \"thisIsTest\";\n        const expectedOutput = \"This is test\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle single word starting with lowercase', () => {\n        const input = \"example\";\n        const expectedOutput = \"Example\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a camelCase string with multiple uppercase letters', () => {\n        const input = \"thisIsAnExampleString\";\n        const expectedOutput = \"This is an example string\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a single uppercase letter', () => {\n        const input = \"aSingleUppercaseLetterX\";\n        const expectedOutput = \"A single uppercase letter x\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n\n    test('should handle an already capitalized string', () => {\n        const input = \"AlreadyCapitalized\";\n        const expectedOutput = \"Already capitalized\";\n        expect(camelCaseToCapitalizedWithSpaces(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * convert a string with hump nomenclature to a string with spaces and capitalize the initial letter\n * @param input\n */\nfunction camelCaseToCapitalizedWithSpaces(input: string): string {\n\n}"}
{"task_id": 143, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}", "test_code": "describe('arabicToEnglishNumbers', () => {\n    test('should convert Arabic numerals to English numerals', () => {\n        const input = \"\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\u0660\";\n        const expectedOutput = \"1234567890\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should return the same string if there are no Arabic numerals', () => {\n        const input = \"Hello, World!\";\n        const expectedOutput = \"Hello, World!\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a mix of Arabic numerals and English characters', () => {\n        const input = \"\u0631\u0642\u0645 \u0661\u0662\u0663 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        const expectedOutput = \"\u0631\u0642\u0645 123 \u0647\u0648 \u0627\u0644\u0645\u062b\u0627\u0644\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle empty string', () => {\n        const input = \"\";\n        const expectedOutput = \"\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n\n    test('should handle a string with mixed Arabic and English numerals', () => {\n        const input = \"The number is \u0663\u0665\u0666 and 789.\";\n        const expectedOutput = \"The number is 356 and 789.\";\n        expect(arabicToEnglishNumbers(input)).toBe(expectedOutput);\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * convert Arabic digits in the string to corresponding English digits\n * @param str\n */\nfunction arabicToEnglishNumbers(str: string): string {\n\n}"}
{"task_id": 144, "code_type": "method", "code_language": "typescript", "code_signature": "// Helper function to convert Arabic numerals to English numerals\nconst arabicToEnglishNumbers: (value: string) => string = (value) => {\n    const arabicToEnglishMap: { [key: string]: string } = {\n        '\u0660': '0', '\u0661': '1', '\u0662': '2', '\u0663': '3', '\u0664': '4',\n        '\u0665': '5', '\u0666': '6', '\u0667': '7', '\u0668': '8', '\u0669': '9'\n    };\n    return value.replace(/[\u0660-\u0669]/g, char => arabicToEnglishMap[char] || char);\n};\n\n// Zod validation schema for numbers with preprocessing\nexport const zNumber = z.preprocess((value: unknown) => {\n    if (typeof value === \"string\") {\n        const converted = arabicToEnglishNumbers(value);\n        const parsedNumber = parseFloat(converted);\n        return isNaN(parsedNumber) ? value : parsedNumber;\n    }\n    return value;\n}, z.number({ invalid_type_error: \"must be a number\" }));\n\n// Function to get the text direction based on the locale\nexport const getLocaleDirection: (locale: string) => \"rtl\" | \"ltr\" = (locale) => {\n    const RTL_LOCALES = [\"ar\", \"he\", \"fa\", \"ur\"];\n    const language = locale?.split(\"-\")[0];\n    return RTL_LOCALES.includes(language) ? \"rtl\" : \"ltr\";\n};\n", "test_code": "\n// Test function\nfunction runTests() {\n    samples.forEach(({ input, expected }, index) => {\n        try {\n            const result = zNumber.parse(input);\n            if (expected === \"error\") {\n                console.log(`Test ${index + 1} failed: Expected an error, but got ${result}`);\n            } else {\n                console.log(`Test ${index + 1} passed: Expected ${expected}, got ${result}`);\n            }\n        } catch (error) {\n            if (expected === \"error\") {\n                console.log(`Test ${index + 1} passed: Expected an error and got an error`);\n            } else {\n                console.log(`Test ${index + 1} failed: Expected ${expected}, but got an error`);\n            }\n        }\n    });\n}\n", "prompt": "please write a typescript function the function signature as below // Helper function to convert Arabic numerals to English numerals\nconst arabicToEnglishNumbers: (value: string) => string = (value) => {\n    const arabicToEnglishMap: { [key: string]: string } = {\n        '\u0660': '0', '\u0661': '1', '\u0662': '2', '\u0663': '3', '\u0664': '4',\n        '\u0665': '5', '\u0666': '6', '\u0667': '7', '\u0668': '8', '\u0669': '9'\n    };\n    return value.replace(/[\u0660-\u0669]/g, char => arabicToEnglishMap[char] || char);\n};\n\n// Zod validation schema for numbers with preprocessing\nexport const zNumber = z.preprocess((value: unknown) => {\n    if (typeof value === \"string\") {\n        const converted = arabicToEnglishNumbers(value);\n        const parsedNumber = parseFloat(converted);\n        return isNaN(parsedNumber) ? value : parsedNumber;\n    }\n    return value;\n}, z.number({ invalid_type_error: \"must be a number\" }));\n\n// Function to get the text direction based on the locale\nexport const getLocaleDirection: (locale: string) => \"rtl\" | \"ltr\" = (locale) => {\n    const RTL_LOCALES = [\"ar\", \"he\", \"fa\", \"ur\"];\n    const language = locale?.split(\"-\")[0];\n    return RTL_LOCALES.includes(language) ? \"rtl\" : \"ltr\";\n};\n"}
{"task_id": 146, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n", "test_code": "describe('formatBytes', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        const result = formatBytes(0);\n        expect(result).toBe('0 Byte');\n    });\n\n    test('should return \"2.0 KB\" for 2048 bytes', () => {\n        const result = formatBytes(2048);\n        expect(result).toBe('2.0 KB');\n    });\n\n    test('should return \"2.0 KiB\" for 2048 bytes with sizeType \"accurate\"', () => {\n        const result = formatBytes(2048, { sizeType: \"accurate\" });\n        expect(result).toBe('2.0 KiB');\n    });\n\n    test('should return \"5.0 MB\" for 5242880 bytes', () => {\n        const result = formatBytes(5242880);\n        expect(result).toBe('5.0 MB');\n    });\n\n    test('should return \"5.00 MiB\" for 5242880 bytes with 2 decimal places and sizeType \"accurate\"', () => {\n        const result = formatBytes(5242880, { decimals: 2, sizeType: \"accurate\" });\n        expect(result).toBe('5.00 MiB');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Formats a given number of bytes into a human-readable string representation,\n * using either the SI (decimal) or binary (accurate) size notation.\n *\n * @param {number} bytes - The number of bytes to format.\n * @param {Object} options - Optional settings to customize the output.\n * @param {number} [options.decimals=0] - Number of decimal places to include in the result.\n * @param {\"accurate\" | \"normal\"} [options.sizeType=\"normal\"] -\n *        Specifies whether to use binary (\"accurate\") or decimal (\"normal\") units.\n *        \"accurate\" uses units like KiB, MiB (base 1024).\n *        \"normal\" uses units like KB, MB (base 1000).\n * @returns {string} A string representation of the byte size in a human-readable format.\n */\nfunction formatBytes(\n    bytes: number,\n    options?: {\n      decimals?: number;\n      sizeType?: \"accurate\" | \"normal\";\n    }\n): string;\n"}
{"task_id": 147, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n", "test_code": "describe('arrayBufferToString', () => {\n    test('should return an empty string for an empty ArrayBuffer', () => {\n        const buffer1 = new ArrayBuffer(0);\n        const result = arrayBufferToString(buffer1);\n        expect(result).toBe(''); // Expected: \"\"\n    });\n\n    test('should return \"A\" for a buffer containing the character \"A\"', () => {\n        const buffer2 = new TextEncoder().encode(\"A\").buffer;\n        const result = arrayBufferToString(buffer2);\n        expect(result).toBe('A'); // Expected: \"A\"\n    });\n\n    test('should return \"Hello\" for a buffer containing the string \"Hello\"', () => {\n        const buffer3 = new TextEncoder().encode(\"Hello\").buffer;\n        const result = arrayBufferToString(buffer3);\n        expect(result).toBe('Hello'); // Expected: \"Hello\"\n    });\n\n    test('should return \"\u00a1Hola!\" for a buffer containing the string \"\u00a1Hola!\"', () => {\n        const buffer4 = new TextEncoder().encode(\"\u00a1Hola!\").buffer;\n        const result = arrayBufferToString(buffer4);\n        expect(result).toBe('\u00a1Hola!'); // Expected: \"\u00a1Hola!\"\n    });\n\n    test('should return \"Hello \ud83c\udf0d\" for a buffer containing the string \"Hello \ud83c\udf0d\"', () => {\n        const buffer5 = new TextEncoder().encode(\"Hello \ud83c\udf0d\").buffer;\n        const result = arrayBufferToString(buffer5);\n        expect(result).toBe('Hello \ud83c\udf0d'); // Expected: \"Hello \ud83c\udf0d\"\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Converts an ArrayBuffer to a string.\n *\n * @param buffer - The ArrayBuffer to be converted.\n * @returns The string representation of the ArrayBuffer.\n */\nfunction arrayBufferToString(buffer: ArrayBuffer): string;\n"}
{"task_id": 148, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n", "test_code": "describe('base64ToArrayBuffer function', () => {\n    // Test Case 1\n    test('should decode \"SGVsbG8sIFdvcmxkIQ==\" to \"Hello, World!\"', () => {\n        const base64 = \"SGVsbG8sIFdvcmxkIQ==\";\n        const expected = \"Hello, World!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 2\n    test('should decode \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\" to \"Some text with sparing and working!\"', () => {\n        const base64 = \"U29tZSB0ZXh0IHdpdGggc3BhcmluZyBhbmQgd29ya2luZyE=\";\n        const expected = \"Some text with sparing and working!\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 3\n    test('should decode \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\" to \"Base64 encoding is a common log For binary data\"', () => {\n        const base64 = \"QmFzZTY0IGVuY29kaW5nIGlzIGEgY29tbW9ubG9nIEZvciBiaW5hcnkgZGF0YQ==\";\n        const expected = \"Base64 encoding is a common log For binary data\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 4\n    test('should decode \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\" to \"Give me along a path to complete start page.\"', () => {\n        const base64 = \"R2l2ZSBtZSBhbG9uZyBhIHBhdGggdG8gY29tcGxldGUgc3RhcnQgcGFnZS4=\";\n        const expected = \"Give me along a path to complete start page.\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n\n    // Test Case 5\n    test('should decode \"SW4gYmFzZTY0IGVuY29kaW5nLCB0aGlzIGlzIGFuIGV4YW1wbGUgYXJlYS=\" to \"In base64 encoding, this is an example area.\"', () => {\n        const base64 = \"SW4gYmFzZTY0IGVuY29kaW5nLCB0aGlzIGlzIGFuIGV4YW1wbGUgYXJlYS=\";\n        const expected = \"In base64 encoding, this is an example area.\";\n        const arrayBuffer = base64ToArrayBuffer(base64);\n        const result = new TextDecoder().decode(arrayBuffer);\n        expect(result).toBe(expected);\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Converts a Base64-encoded string to an ArrayBuffer.\n *\n * @param base64 - The Base64-encoded string to convert.\n * @returns An ArrayBuffer representing the decoded bytes.\n */\nexport function base64ToArrayBuffer(base64: string){\n\n}\n"}
{"task_id": 149, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Code implementation for converting HSL color values \u200b\u200bto RGB color values\n */\nexport function hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n\n}", "test_code": "describe('hslToRgb', () => {\n\n    // \u57fa\u672c\u903b\u8f91\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(0, 100%, 50%) \u8f6c\u6362\u4e3a RGB(255, 0, 0)\n    test('should convert HSL(0, 100%, 50%) to RGB(255, 0, 0)', () => {\n        const hue = 0;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u8fb9\u754c\u503c\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(360, 100%, 50%) \u8f6c\u6362\u4e3a RGB(255, 0, 0)\n    test('should handle hue of 360 degrees correctly as RGB(255, 0, 0)', () => {\n        const hue = 360;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u8fb9\u754c\u503c\u529f\u80fd\u6d4b\u8bd5\uff1a\u5c06 HSL(120, 100%, 50%) \u8f6c\u6362\u4e3a RGB(0, 255, 0)\n    test('should convert HSL(120, 100%, 50%) to RGB(0, 255, 0)', () => {\n        const hue = 120;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 0, g: 255, b: 0 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u5c06 HSL(-30, 100%, 50%) \u8f6c\u6362\u4e3a\u6b63\u5e38\u8303\u56f4\u5185\u7684 RGB \u503c\n    test('should handle negative hue values correctly and convert HSL(-30, 100%, 50%) to RGB(255, 85, 0)', () => {\n        const hue = -30;\n        const saturation = 100;\n        const lightness = 50;\n        const expectedOutput = { r: 255, g: 0, b: 128 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n    // \u5f02\u5e38\u503c\u6d4b\u8bd5\uff1a\u5f53\u9971\u548c\u5ea6\u548c\u4eae\u5ea6\u4e3a 0 \u65f6\u5e94\u8f93\u51fa\u7070\u5ea6\u8272 RGB(128, 128, 128)\n    test('should return a grayscale color RGB(128, 128, 128) when saturation and lightness are both 0', () => {\n        const hue = 120;\n        const saturation = 0;\n        const lightness = 50;\n        const expectedOutput = { r: 128, g: 128, b: 128 };\n        expect(hslToRgb(hue, saturation, lightness)).toEqual(expectedOutput);\n    });\n\n});\n", "prompt": "please write a typescript function the function signature as below /**\n * Code implementation for converting HSL color values \u200b\u200bto RGB color values\n */\nexport function hslToRgb(hue: number, saturation: number, lightness: number): { r: number, g: number, b: number } {\n\n}"}
{"task_id": 150, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n", "test_code": "describe('rgbToHex and hexToRgb', () => {\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert RGB to HEX', () => {\n        const rgb = { r: 255, g: 99, b: 71 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#ff6347'); // Expected HEX code for RGB(255, 99, 71)\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u57fa\u672c\u903b\u8f91\u529f\u80fd\n    test('should correctly convert HEX to RGB', () => {\n        const hex = '#ff6347';\n        const result = hexToRgb(hex);\n        expect(result).toEqual({ r: 255, g: 99, b: 71 }); // Expected RGB object for HEX #ff6347\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should handle invalid RGB components gracefully', () => {\n        const rgb = { r: 300, g: -10, b: 128 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#12c-a80'); // Invalid values (300, -10) should be clamped to \"00\", valid value should convert to \"80\"\n    });\n\n    // \u6d4b\u8bd5 hexToRgb \u51fd\u6570\u7684\u5f02\u5e38\u503c\u5904\u7406\n    test('should return null for invalid HEX strings', () => {\n        const invalidHex = '#ggg123';\n        const result = hexToRgb(invalidHex);\n        expect(result).toBeNull(); // Invalid HEX code should return null\n    });\n\n    // \u6d4b\u8bd5 rgbToHex \u51fd\u6570\u7684\u8fb9\u754c\u503c\n    test('should handle boundary values in RGB correctly', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHex(rgb);\n        expect(result).toBe('#000000'); // Boundary RGB(0, 0, 0) should convert to #000000\n\n        const rgbWhite = { r: 255, g: 255, b: 255 };\n        const resultWhite = rgbToHex(rgbWhite);\n        expect(resultWhite).toBe('#ffffff'); // Boundary RGB(255, 255, 255) should convert to #ffffff\n    });\n});\n", "prompt": "please write a typescript function the function signature as below /**\n * Convert an RGB color object to a HEX color string.\n * @param rgb - An object containing the red, green, and blue components of the color.\n * @returns A string representing the HEX color code.\n */\nexport function rgbToHex(rgb: { r: number; g: number; b: number }): string {\n\n}\n\n/**\n * Convert a HEX color string to an RGB color object.\n * @param hex - A string representing the HEX color code.\n * @returns An object containing the red, green, and blue components of the color, or null if the HEX code is invalid.\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n\n}\n"}
{"task_id": 151, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nexport function rgbToHsl({ r, g, b }: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n", "test_code": "describe('rgbToHsl', () => {\n\n    test('should convert basic RGB values correctly (red)', () => {\n        const rgb = { r: 255, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 100, l: 50 });\n    });\n\n    test('should handle grayscale values (middle gray)', () => {\n        const rgb = { r: 128, g: 128, b: 128 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 50 });\n    });\n\n    test('should handle edge cases (white color)', () => {\n        const rgb = { r: 255, g: 255, b: 255 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 100 });\n    });\n\n    test('should handle edge cases (black color)', () => {\n        const rgb = { r: 0, g: 0, b: 0 };\n        const result = rgbToHsl(rgb);\n        expect(result).toEqual({ h: 0, s: 0, l: 0 });\n    });\n\n    test('should throw an error for invalid RGB values (negative values)', () => {\n        const rgb = { r: -50, g: 50, b: 50 };\n        expect(() => rgbToHsl(rgb)).toThrow('Invalid RGB value. Each value must be between 0 and 255.');\n    });\n\n});\n", "prompt": "please write a typescript function the function signature as below /**\n * Converts RGB color values to HSL (Hue, Saturation, Lightness) color values.\n * The input RGB values should be in the range of 0 to 255, and the output HSL values will have:\n * - `h` (Hue) in the range of 0 to 360,\n * - `s` (Saturation) in the range of 0 to 100 (percentage),\n * - `l` (Lightness) in the range of 0 to 100 (percentage).\n *\n * @param {Object} rgb - The RGB color values.\n * @param {number} rgb.r - The red color value (0-255).\n * @param {number} rgb.g - The green color value (0-255).\n * @param {number} rgb.b - The blue color value (0-255).\n * @returns {Object} An object representing the HSL color values.\n * @returns {number} h - The hue value (0-360).\n * @returns {number} s - The saturation value (0-100).\n * @returns {number} l - The lightness value (0-100).\n */\nexport function rgbToHsl({ r, g, b }: { r: number; g: number; b: number }): { h: number; s: number; l: number } {\n\n}\n"}
{"task_id": 152, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}", "test_code": "describe('convertToMathematicalSansSerifItalic', () => {\n    test('should return an empty string when input is an empty string', () => {\n        const input = '';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe(''); // Edge case: empty string\n    });\n\n    test('should correctly convert all uppercase and lowercase letters to mathematical sans-serif italic', () => {\n        const input = 'HelloWorld';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc6f\ud835\udc86\ud835\udc8d\ud835\udc8d\ud835\udc90\ud835\udc7e\ud835\udc90\ud835\udc93\ud835\udc8d\ud835\udc85'); // Basic logic: mixed case\n    });\n\n    test('should leave characters unchanged if they have no corresponding mathematical sans-serif italic equivalent', () => {\n        const input = '12345!@#';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udfe3\ud835\udfe4\ud835\udfe5\ud835\udfe6\ud835\udfe7!@#'); // Basic logic: numbers with special characters\n    });\n\n    test('should handle input with a mix of convertible and non-convertible characters', () => {\n        const input = 'Math123!';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc74\ud835\udc82\ud835\udc95\ud835\udc89\ud835\udfe3\ud835\udfe4\ud835\udfe5!'); // Basic logic: mix of letters, numbers, and special characters\n    });\n\n    test('should handle edge case where input is at the boundary of supported characters', () => {\n        const input = 'A0z9';\n        const result = convertToMathematicalSansSerifItalic(input);\n        expect(result).toBe('\ud835\udc68\ud835\udfe2\ud835\udc9b\ud835\udfeb'); // Boundary values: 'A', '0', 'z', '9'\n    });\n});\n\n\n", "prompt": "please write a typescript function the function signature as below /**\n * Converts a given string into its corresponding mathematical sans-serif italic characters.\n *\n * @param input The input string to be converted.\n * @returns The converted string with each character replaced by its mathematical sans-serif italic equivalent.\n */\nfunction convertToMathematicalSansSerifItalic(input: string): string {\n\n}"}
{"task_id": 153, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}", "test_code": "// @ts-ignore\nconst crypto = require('crypto');\n\ndescribe('compressHash', () => {\n\n    test('should return a string of length 5', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result.length).toBe(5);\n    });\n\n    test('should return different strings for different inputs', () => {\n        // @ts-ignore\n        const hash1 = crypto.createHash('sha256').update('test1').digest();\n        // @ts-ignore\n        const hash2 = crypto.createHash('sha256').update('test2').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash1);\n        // @ts-ignore\n        const result2 = compressHash(hash2);\n        expect(result1).not.toBe(result2);\n    });\n\n    test('should return a consistent result for the same input', () => {\n        // @ts-ignore\n        const hash = crypto.createHash('sha256').update('test').digest();\n        // @ts-ignore\n        const result1 = compressHash(hash);\n        // @ts-ignore\n        const result2 = compressHash(hash);\n        expect(result1).toBe(result2);\n    });\n\n    test('should handle a hash of all zeros', () => {\n        const hash = Buffer.alloc(32, 0); // 32 bytes of zeros\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n\n    test('should handle a hash of all ones', () => {\n        const hash = Buffer.alloc(32, 255); // 32 bytes of 0xFF (255 in decimal)\n        // @ts-ignore\n        const result = compressHash(hash);\n        expect(result).toMatch(/^[0-9a-zA-Z]{5}$/);\n    });\n});\n", "prompt": "please write a typescript function the function signature as below /**\n * The input hash buffer is compressed into a number letter string of length no less than 5\n *\n * @param {Buffer} hash - The hash buffer to be compressed.\n * @returns {string} A compressed string representation of the hash.\n */\n// @ts-ignore\nfunction compressHash(hash: Buffer): string {\n\n}"}
{"task_id": 154, "code_type": "method", "code_language": "typescript", "code_signature": "// Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}", "test_code": "describe('parseGitDiff', () => {\n\n    test('should parse a simple file addition', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nnew file mode 100644\nindex 0000000..e69de29\n--- /dev/null\n+++ b/file.txt`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].newFileMode).toBe('100644');\n    });\n\n    test('should parse a simple file deletion', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\ndeleted file mode 100644\nindex e69de29..0000000\n--- a/file.txt\n+++ /dev/null`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(1);\n        expect(result[0].oldPath).toBe('file.txt');\n        expect(result[0].newPath).toBe('file.txt');\n        expect(result[0].deletedFileMode).toBe('100644');\n    });\n\n    test('should parse a file modification with changes', () => {\n        const diffText = `diff --git a/file.txt b/file.txt\nindex e69de29..d95f3ad 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -0,0 +1 @@\n+Hello World`;\n\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n\n        expect(result).toHaveLength(1); // Ensure only one file diff is parsed\n        expect(result[0].oldPath).toBe('file.txt'); // Validate old file path\n        expect(result[0].newPath).toBe('file.txt'); // Validate new file path\n        expect(result[0].index).toBe('e69de29..d95f3ad'); // Validate index value\n        expect(result[0].changes).toEqual([\n            {code: \"--- a/file.txt\"}, // Validate old file path line\n            {code: \"+++ b/file.txt\"}, // Validate new file path line\n            {diff: '@@ -0,0 +1 @@'},  // Validate diff header\n            {code: '+Hello World'}     // Validate code addition\n        ]); // Validate changes array\n    });\n\n    test('should handle multiple file diffs', () => {\n        const diffText = `diff --git a/file1.txt b/file1.txt\nindex e69de29..d95f3ad 100644\n--- a/file1.txt\n+++ b/file1.txt\n@@ -0,0 +1 @@\n+Hello World\ndiff --git a/file2.txt b/file2.txt\nindex 0a1b2c3..d4e5f6a 100644\n--- a/file2.txt\n+++ b/file2.txt\n@@ -1 +1 @@\n-Hello\n+Hi`;\n        // @ts-ignore\n        const result = parseGitDiff(diffText);\n        expect(result).toHaveLength(2);\n        expect(result[0].oldPath).toBe('file1.txt');\n        expect(result[1].oldPath).toBe('file2.txt');\n    });\n\n    test('should return an empty array for empty diff text', () => {\n        // @ts-ignore\n        const result = parseGitDiff('');\n        expect(result).toEqual([]);\n    });\n\n});", "prompt": "please write a typescript function the function signature as below // Define the types for the objects we're working with\ninterface GitDiffChange {\n    diff?: string;\n    code?: string;\n}\n\ninterface GitDiffFile {\n    oldPath: string;\n    newPath: string;\n    changes: GitDiffChange[];\n    newFileMode: string | null;\n    deletedFileMode: string | null;\n    index: string | null;\n}\n\n/**\n * Parsing a string containing the contents of a Git diff returns an array of objects with details of each file's changes\n *\n * @param {string} diffText - The Git diff text to parse.\n * @returns {GitDiffFile[]} - An array of objects representing the diff for each file.\n */\n// @ts-ignore\nexport function parseGitDiff(diffText: string): GitDiffFile[] {\n\n}"}
{"task_id": 155, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}", "test_code": "describe('getTimestamp', () => {\n    test('should return \"1 second ago\" for a date 1 second ago', () => {\n        const oneSecondAgo = new Date(new Date().getTime() - 1000); // 1 second ago\n        // @ts-ignore\n        expect(getTimestamp(oneSecondAgo)).toBe('1 second ago');\n    });\n\n    test('should return \"5 minutes ago\" for a date 5 minutes ago', () => {\n        const fiveMinutesAgo = new Date(new Date().getTime() - 5 * 60 * 1000); // 5 minutes ago\n        // @ts-ignore\n        expect(getTimestamp(fiveMinutesAgo)).toBe('5 minutes ago');\n    });\n\n    test('should return \"2 hours ago\" for a date 2 hours ago', () => {\n        const twoHoursAgo = new Date(new Date().getTime() - 2 * 60 * 60 * 1000); // 2 hours ago\n        // @ts-ignore\n        expect(getTimestamp(twoHoursAgo)).toBe('2 hours ago');\n    });\n\n    test('should return \"3 days ago\" for a date 3 days ago', () => {\n        const threeDaysAgo = new Date(new Date().getTime() - 3 * 24 * 60 * 60 * 1000); // 3 days ago\n        // @ts-ignore\n        expect(getTimestamp(threeDaysAgo)).toBe('3 days ago');\n    });\n\n    test('should return \"1 year ago\" for a date 1 year ago', () => {\n        const oneYearAgo = new Date(new Date().getTime() - 365 * 24 * 60 * 60 * 1000); // 1 year ago\n        // @ts-ignore\n        expect(getTimestamp(oneYearAgo)).toBe('1 year ago');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Computes the difference between the specified date and the current time, returning it in a human-readable way\n *\n * @param {Date} createdAt - The date to calculate the time difference from.\n * @returns {string} A string indicating the time elapsed, e.g., \"3 days ago\", \"5 hours ago\".\n */\n// @ts-ignore\nexport const getTimestamp = (createdAt: Date): string => {\n\n}"}
{"task_id": 156, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}", "test_code": "describe('formatNumber', () => {\n    test('should format numbers greater than or equal to 1,000,000 with \"M\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(1500000)).toBe('1.5M');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n\n    test('should format numbers greater than or equal to 1,000 but less than 1,000,000 with \"K\" suffix', () => {\n        // @ts-ignore\n        expect(formatNumber(2500)).toBe('2.5K');\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n    });\n\n    test('should return the number as a string if it is less than 1,000', () => {\n        // @ts-ignore\n        expect(formatNumber(999)).toBe('999');\n        // @ts-ignore\n        expect(formatNumber(500)).toBe('500');\n    });\n\n    test('should format numbers close to 1,000,000 correctly', () => {\n        // @ts-ignore\n        expect(formatNumber(999999)).toBe('999.9K'); // Corrected to reflect 'K' formatting\n        // @ts-ignore\n        expect(formatNumber(999500)).toBe('999.5K'); // Corrected to reflect 'K' formatting\n    });\n\n    test('should handle edge cases like exactly 1,000 or 1,000,000', () => {\n        // @ts-ignore\n        expect(formatNumber(1000)).toBe('1.0K');\n        // @ts-ignore\n        expect(formatNumber(1000000)).toBe('1.0M');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Format the number into a more readable string representation, returning the original form if the number is less than 1,000. If it is greater than or equal to a thousand and less than a million, it is formatted as \"x.xK\". For a million or more, format it as \"x.xM\".\n *\n * @param {number} num - The number to be formatted.\n * @returns {string} The formatted number as a string.\n */\n// @ts-ignore\nexport const formatNumber = (num: number): string => {\n\n}"}
{"task_id": 157, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\n// @ts-ignore\nexport function bytesToSize(bytes: number): string {\n\n}", "test_code": "describe('bytesToSize', () => {\n    test('should return \"0 Byte\" for 0 bytes', () => {\n        // @ts-ignore\n        expect(bytesToSize(0)).toBe('0 Byte');\n    });\n\n    test('should convert bytes to KB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1024)).toBe('1.00 KB');\n        // @ts-ignore\n        expect(bytesToSize(2048)).toBe('2.00 KB');\n    });\n\n    test('should convert bytes to MB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1048576)).toBe('1.00 MB');\n        // @ts-ignore\n        expect(bytesToSize(2097152)).toBe('2.00 MB');\n    });\n\n    test('should convert bytes to GB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1073741824)).toBe('1.00 GB');\n        // @ts-ignore\n        expect(bytesToSize(2147483648)).toBe('2.00 GB');\n    });\n\n    test('should convert bytes to TB correctly', () => {\n        // @ts-ignore\n        expect(bytesToSize(1099511627776)).toBe('1.00 TB');\n        // @ts-ignore\n        expect(bytesToSize(2199023255552)).toBe('2.00 TB');\n    });\n});\n", "prompt": "please write a typescript function the function signature as below /**\n * Converts a given number of Bytes into a readable string representation with the appropriate units (Bytes, KB, MB, GB, or TB) and keeps two decimal places *\n *\n * @param {number} bytes - The number of bytes to be converted.\n * @returns {string} - A string representation of the size in Bytes, KB, MB, GB, or TB.\n */\n// @ts-ignore\nexport function bytesToSize(bytes: number): string {\n\n}"}
{"task_id": 158, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\n// @ts-ignore\nexport function getFileExtension(file_name: string): string {\n\n}", "test_code": "describe('getFileExtension', () => {\n    test('should return the file extension for a standard file', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.txt')).toBe('txt');\n    });\n\n    test('should return an empty string for files without an extension', () => {\n        // @ts-ignore\n        expect(getFileExtension('example')).toBe('');\n    });\n\n    test('should handle files with multiple dots', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.with.many.dots.jpg')).toBe('jpg');\n    });\n\n    test('should return an empty string for filenames that end with a dot', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.')).toBe('');\n    });\n\n    test('should correctly handle case sensitivity', () => {\n        // @ts-ignore\n        expect(getFileExtension('example.JPG')).toBe('JPG');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Extract the file extension and return it if it exists. If not, an empty string is returned\n *\n * @param {string} file_name - The full name of the file from which to extract the extension.\n * @returns {string} The file extension without the dot, or an empty string if no extension is found.\n */\n// @ts-ignore\nexport function getFileExtension(file_name: string): string {\n\n}"}
{"task_id": 159, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\n// @ts-ignore\nexport function removeFileExtension(file_name: string): string {\n\n}", "test_code": "describe('removeFileExtension', () => {\n    test('should remove the file extension from a standard file', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.txt')).toBe('document');\n    });\n\n    test('should return the original filename for files without an extension', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document')).toBe('document');\n    });\n\n    test('should handle files with multiple dots correctly', () => {\n        // @ts-ignore\n        expect(removeFileExtension('my.file.with.many.extensions.pdf')).toBe('my.file.with.many.extensions');\n    });\n\n    test('should return the original filename if it ends with a dot', () => {\n        // @ts-ignore\n        expect(removeFileExtension('document.')).toBe('document');\n    });\n\n    test('should correctly handle filenames with dots in directory names', () => {\n        // @ts-ignore\n        expect(removeFileExtension('path.to/my.file.txt')).toBe('path.to/my.file');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Removes the extension of the given filename and returns the remainder\n *\n * @param {string} file_name - The full name of the file from which to remove the extension.\n * @returns {string} The file name without the extension. If no extension is found, returns the original file name.\n */\n// @ts-ignore\nexport function removeFileExtension(file_name: string): string {\n\n}"}
{"task_id": 160, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\n// @ts-ignore\nexport function compressFileName(fileName: string, maxLength: number = 18): string {\n\n}", "test_code": "describe('compressFileName', () => {\n    test('returns the original file name if within maxLength', () => {\n        // @ts-ignore\n        expect(compressFileName('example.txt', 12)).toBe('example.txt');\n    });\n\n    test('compresses the file name correctly when it exceeds maxLength', () => {\n        // @ts-ignore\n        expect(compressFileName('longfilenameexample.txt', 18)).toBe('longf...xample.txt');\n    });\n\n    test('handles file names without extension correctly', () => {\n        // @ts-ignore\n        expect(compressFileName('averylongfilenamewithoutanextension', 20)).toBe('averylon...extension');\n    });\n\n    test('returns the original file name when maxLength is larger than file name', () => {\n        // @ts-ignore\n        expect(compressFileName('short.txt', 20)).toBe('short.txt');\n    });\n\n    test('compresses file names with special characters correctly', () => {\n        // @ts-ignore\n        expect(compressFileName('my$pecialfilename.txt', 18)).toBe('my$pe...lename.txt');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Compresses long filenames to the specified maximum length by inserting an ellipsis in the middle while preserving the filename extension, which defaults to 18 characters\n *\n * @param {string} fileName - The original file name to be compressed.\n * @param {number} maxLength - The maximum allowed length for the compressed file name. Defaults to 18.\n * @returns {string} The compressed file name, with the middle section replaced by ellipses ('...'), or the original file name if it is within the maximum length.\n */\n// @ts-ignore\nexport function compressFileName(fileName: string, maxLength: number = 18): string {\n\n}"}
{"task_id": 161, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}", "test_code": "describe('generateCombinations', () => {\n    test('generates combinations for a single key with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2, 3]]]);\n        const expected = [[1], [2], [3]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with single values', () => {\n        const map = new Map<string, number[]>([['a', [1]], ['b', [2]]]);\n        const expected = [[1, 2]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('generates combinations for multiple keys with multiple values', () => {\n        const map = new Map<string, number[]>([['a', [1, 2]], ['b', [3, 4]]]);\n        const expected = [\n            [1, 3], [1, 4],\n            [2, 3], [2, 4]\n        ];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles an empty map', () => {\n        const map = new Map<string, number[]>();\n        const expected: number[][] = [[]];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n\n    test('handles keys with empty arrays as values', () => {\n        const map = new Map<string, number[]>([['a', []], ['b', [1, 2]]]);\n        const expected: number[][] = [];\n        // @ts-ignore\n        expect(generateCombinations(map)).toEqual(expected);\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Produces all combinations of numeric arrays for each key in the given map object and returns them as a two-dimensional array\n *\n * @param {Map<string, number[]>} map - A map where each key is a string, and each value is an array of numbers.\n * @returns {number[][]} An array of arrays, where each sub-array is a unique combination of numbers from the Map's values.\n */\n// @ts-ignore\nfunction generateCombinations(map: Map<string, number[]>): number[][] {\n\n}"}
{"task_id": 162, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}", "test_code": "describe('boolArrayToBinaryString', () => {\n    test('converts an array of all true values', () => {\n        const boolArray = [true, true, true];\n        const expected = '111';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array of all false values', () => {\n        const boolArray = [false, false, false];\n        const expected = '000';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('converts an array with a mix of true and false values', () => {\n        const boolArray = [true, false, true, false];\n        const expected = '1010';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles an empty array', () => {\n        const boolArray: boolean[] = [];\n        const expected = '';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n\n    test('handles a single boolean value', () => {\n        const boolArray = [true];\n        const expected = '1';\n        // @ts-ignore\n        expect(boolArrayToBinaryString(boolArray)).toBe(expected);\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Converts the array of Boolean values to a binary string representation, which converts to the character 1 if the Boolean value is true. Otherwise, it is converted to the character 0, and the final string is returned\n *\n * @param {boolean[]} boolArray - An array of boolean values.\n * @returns {string} A binary string where '1' represents true and '0' represents false.\n */\n// @ts-ignore\nfunction boolArrayToBinaryString(boolArray: boolean[]): string {\n\n}"}
{"task_id": 163, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary data.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}", "test_code": "describe('binaryStringToUint8Array', () => {\n    test('should convert a full byte binary string', () => {\n        const binaryStr = '11001010';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202]));\n    });\n\n    test('should convert multiple full byte binary strings', () => {\n        const binaryStr = '1100101011110000';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202, 240]));\n    });\n\n    test('should convert a binary string with fewer than 8 bits', () => {\n        const binaryStr = '110';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([6]));\n    });\n\n    test('should convert a binary string with non-multiples of 8 bits', () => {\n        const binaryStr = '110010101';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([202, 1]));\n    });\n\n    test('should handle an empty binary string', () => {\n        const binaryStr = '';\n        // @ts-ignore\n        const result = binaryStringToUint8Array(binaryStr);\n        expect(result).toEqual(new Uint8Array([]));\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Stores a second-level string in a set of 8-bit conversion integers in a Unit8Array and returns\n *\n * @param {string} binaryStr - The binary string to be converted.\n * @returns {Uint8Array} - The resulting Uint8Array containing the binary data.\n */\n// @ts-ignore\nfunction binaryStringToUint8Array(binaryStr: string): Uint8Array {\n\n}"}
{"task_id": 164, "code_type": "method", "code_language": "typescript", "code_signature": "", "test_code": "describe('uint8ArrayToBase64', () => {\n    test('should convert an empty Uint8Array', () => {\n        const uint8Array = new Uint8Array([]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('');\n    });\n\n    test('should convert a Uint8Array with one byte', () => {\n        const uint8Array = new Uint8Array([255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('/w==');\n    });\n\n    test('should convert a Uint8Array with two bytes', () => {\n        const uint8Array = new Uint8Array([255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('//8=');\n    });\n\n    test('should convert a Uint8Array with three bytes', () => {\n        const uint8Array = new Uint8Array([255, 255, 255]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('////');\n    });\n\n    test('should convert a Uint8Array with four bytes', () => {\n        const uint8Array = new Uint8Array([72, 101, 108, 108]);\n        // @ts-ignore\n        const result = uint8ArrayToBase64(uint8Array);\n        expect(result).toBe('SGVsbA==');\n    });\n});", "prompt": "please write a typescript function the function signature as below "}
{"task_id": 165, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}", "test_code": "describe('base64ToUrlSafe', () => {\n\n    test('should correctly convert a standard Base64 string to URL-safe format', () => {\n        const base64 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4+/w==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"YW55IGNhcm5hbCBwbGVhc3VyZS4-_w\");\n    });\n\n    test('should return an empty string when the input is an empty string', () => {\n        const base64 = \"\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"\");\n    });\n\n    test('should remove only the trailing \"=\" characters', () => {\n        const base64 = \"dGVzdA==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle strings without any characters that need replacement', () => {\n        const base64 = \"dGVzdA\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"dGVzdA\");\n    });\n\n    test('should handle a base64 string with multiple \"+\" and \"/\" characters', () => {\n        const base64 = \"aGVsbG8rL3dvcmxkLw==\";\n        const result = base64ToUrlSafe(base64);\n        expect(result).toBe(\"aGVsbG8rL3dvcmxkLw\");\n    });\n\n    test('should throw an error when input is not a string', () => {\n        expect(() => base64ToUrlSafe((null as unknown) as string)).toThrow(TypeError);\n    });\n\n});\n", "prompt": "please write a typescript function the function signature as below /**\n * Converts a standard Base64 encoded string into a URL-safe Base64 encoded string.\n *\n * @param {string} base64 - The standard Base64 encoded string to be converted.\n * @returns {string} The URL-safe Base64 encoded string.\n */\nexport function base64ToUrlSafe(base64: string): string {\n\n}"}
{"task_id": 166, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}", "test_code": "describe('nextGreatestLetter', () => {\n\n    test('should return the first letter when target is greater than all letters in the array', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'j';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should return the next greatest letter for a typical input', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'a';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('c'); // Expected output: 'c'\n    });\n\n    test('should handle the edge case where target is in between two letters', () => {\n        const letters = ['c', 'f', 'j'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('f'); // Expected output: 'f'\n    });\n\n    test('should return the first letter when the target is equal to the largest letter', () => {\n        const letters = ['a', 'b', 'c', 'd'];\n        const target = 'd';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n    test('should return the correct letter when the array contains only one letter', () => {\n        const letters = ['a'];\n        const target = 'z';\n        const result = nextGreatestLetter(letters, target);\n        expect(result).toBe('a'); // Expected output: 'a'\n    });\n\n});\n", "prompt": "please write a typescript function the function signature as below /**\n * Finds and returns the smallest letter in a sorted array that is larger than the given target letter.\n * If the target letter is greater than or equal to all letters in the array, the function returns the first letter in the array.\n *\n * @param {string[]} letters - A sorted array of letters.\n * @param {string} target - The target letter to find the next greatest letter for.\n * @returns {string} The smallest letter in the array that is larger than the target letter.\n */\nexport function nextGreatestLetter(letters: string[], target: string): string {\n\n}"}
{"task_id": 167, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n *\n * The function removes the \".bit\" suffix, checks if the remaining part is a number,\n * and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nexport function assert999(bitName: string): boolean {\n\n}", "test_code": "\ndescribe('assert999', () => {\n    /**\n     * Test case for a valid 3-digit number with the \".bit\" suffix.\n     * Expected to return true.\n     */\n    test('should return true for a valid 3-digit number with \".bit\" suffix', () => {\n        const input = \"123.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string without the \".bit\" suffix.\n     * Expected to return false.\n     */\n    test('should return true for a valid 2-digit number with \".bit\" suffix', () => {\n        const input = \"12.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for a string containing non-numeric characters after removing \".bit\".\n     * Expected to return false.\n     */\n    test('should return false for a string with non-numeric characters after removing \".bit\"', () => {\n        const input = \"12a.bit\";\n        const result = assert999(input);\n        expect(result).toBe(false);\n    });\n\n    /**\n     * Test case for the lower boundary value \"0.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the lower boundary value \"0.bit\"', () => {\n        const input = \"0.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n\n    /**\n     * Test case for the upper boundary value \"999.bit\".\n     * Expected to return true.\n     */\n    test('should return true for the upper boundary value \"999.bit\"', () => {\n        const input = \"999.bit\";\n        const result = assert999(input);\n        expect(result).toBe(true);\n    });\n});\n\n", "prompt": "please write a typescript function the function signature as below /**\n * Determines whether a given string (assumed to end with \".bit\") is a valid 3-digit integer.\n *\n * The function removes the \".bit\" suffix, checks if the remaining part is a number,\n * and verifies if it falls within the range of 0 to 999.\n *\n * @param {string} bitName - The string to validate.\n * @returns {boolean} True if the remaining part after removing \".bit\" is a valid 3-digit integer, otherwise false.\n */\nexport function assert999(bitName: string): boolean {\n\n}"}
{"task_id": 168, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts a date string into a relative time description.\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nexport function formatDate(dateString: string): string {\n\n}", "test_code": "describe('formatDate', () => {\n    beforeAll(() => {\n        // Set the system time to a fixed date for consistent testing\n        jest.useFakeTimers().setSystemTime(new Date('2024-08-25T12:00:00'));\n    });\n\n    afterAll(() => {\n        // Restore the real system time after tests\n        jest.useRealTimers();\n    });\n\n    test('should return \"1 day ago\" for a date exactly one day before', () => {\n        const dateString = '2024-08-24T12:00:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('1 day ago');\n    });\n\n    test('should return \"5 hours ago\" for a date 5 hours before the current time', () => {\n        const dateString = '2024-08-25T07:00:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('5 hours ago');\n    });\n\n    test('should return \"2 minutes ago\" for a date 2 minutes before the current time', () => {\n        const dateString = '2024-08-25T11:58:00';\n        const result = formatDate(dateString);\n        expect(result).toBe('2 minutes ago');\n    });\n\n    test('should return \"just now\" for a date within the last second', () => {\n        const dateString = '2024-08-25T11:59:59';\n        const result = formatDate(dateString);\n        expect(result).toBe('1 second ago');\n    });\n\n    test('should handle invalid date string gracefully', () => {\n    const dateString = 'invalid-date';\n    expect(() => formatDate(dateString)).toThrow('Invalid Date');\n});\n\n});\n\n\n", "prompt": "please write a typescript function the function signature as below /**\n * Converts a date string into a relative time description.\n *\n * @param {string} dateString - The date string to convert.\n * @returns {string} A user-friendly string representing the relative time difference from the current date.\n */\nexport function formatDate(dateString: string): string {\n\n}"}
{"task_id": 169, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nexport function convertToRoman(num: number): string {\n\n}", "test_code": "describe('convertToRoman', () => {\n\n    test('should return the correct Roman numeral for a typical number', () => {\n        const result = convertToRoman(1987);\n        expect(result).toBe('MCMLXXXVII'); // 1987 = M + CM + LXXX + VII\n    });\n\n    test('should return the correct Roman numeral for the minimum value (1)', () => {\n        const result = convertToRoman(1);\n        expect(result).toBe('I'); // 1 = I\n    });\n\n    test('should return the correct Roman numeral for a large number (3999)', () => {\n        const result = convertToRoman(3999);\n        expect(result).toBe('MMMCMXCIX'); // 3999 = MMM + CM + XC + IX\n    });\n\n   test('should handle zero or negative values gracefully (edge case)', () => {\n    expect(() => {\n        convertToRoman(0);\n    }).toThrowError('Input must be a positive integer');\n\n    expect(() => {\n        convertToRoman(-5);\n    }).toThrowError('Input must be a positive integer');\n    });\n\n    test('should throw an error for non-integer input (exception case)', () => {\n        expect(() => {\n            convertToRoman(3.14);\n        }).toThrowError('Input must be a positive integer');\n    });\n\n});", "prompt": "please write a typescript function the function signature as below /**\n * Converts an Arabic numeral to its Roman numeral equivalent.\n *\n * @param {number} num - The number to convert.\n * @returns {string} The Roman numeral representation of the input number.\n */\nexport function convertToRoman(num: number): string {\n\n}"}
{"task_id": 331, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}", "test_code": "describe('calculateFinalPrice', () => {\n    test('should calculate the final price correctly with valid inputs', () => {\n        const result = calculateFinalPrice('200', '10');\n        expect(result).toBe(180);\n    });\n\n    test('should return the original price when the discount is 0%', () => {\n        const result = calculateFinalPrice('150', '0');\n        expect(result).toBe(150);\n    });\n\n    test('should return zero when the discount is 100%', () => {\n        const result = calculateFinalPrice('100', '100');\n        expect(result).toBe(0);\n    });\n\n    test('should throw an error for invalid numerical input', () => {\n        expect(() => calculateFinalPrice('abc', '10')).toThrow('Invalid price or discount value.');\n        expect(() => calculateFinalPrice('100', 'xyz')).toThrow('Invalid price or discount value.');\n    });\n\n    test('should throw an error when discount is out of range', () => {\n        expect(() => calculateFinalPrice('100', '-1')).toThrow('Discount percentage must be between 0 and 100.');\n        expect(() => calculateFinalPrice('100', '101')).toThrow('Discount percentage must be between 0 and 100.');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Calculates the final price after applying a discount to the original price.\n * Both price and discount are expected as strings and should represent valid numbers.\n * The discount should be a percentage value between 0 and 100.\n *\n * @param price The original price as a string.\n * @param discount The discount percentage as a string.\n * @returns The final price after applying the discount, rounded to two decimal places.\n * @throws Will throw an error if price or discount aren't valid numbers or if the discount is out of the expected range.\n */\nfunction calculateFinalPrice(price: string, discount: string): number {\n\n}"}
{"task_id": 334, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * calculate the date of Good Friday in a given year\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}", "test_code": "describe('calculateGoodFriday', () => {\n    test('Good Friday calculation for a typical year (2023)', () => {\n        const result = calculateGoodFriday(2023);\n        expect(result.toDateString()).toBe('Fri Apr 07 2023');\n    });\n\n    test('Good Friday calculation for a leap year (2024)', () => {\n        const result = calculateGoodFriday(2024);\n        expect(result.toDateString()).toBe('Fri Mar 29 2024');\n    });\n\n    test('Good Friday calculation for an early Easter (2016)', () => {\n        const result = calculateGoodFriday(2016);\n        expect(result.toDateString()).toBe('Fri Mar 25 2016');\n    });\n\n    test('Good Friday calculation for a late Easter (2019)', () => {\n        const result = calculateGoodFriday(2019);\n        expect(result.toDateString()).toBe('Fri Apr 19 2019');\n    });\n\n    test('Good Friday calculation for a boundary year (2000)', () => {\n        const result = calculateGoodFriday(2000);\n        expect(result.toDateString()).toBe('Fri Apr 21 2000');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * calculate the date of Good Friday in a given year\n * @param year\n */\nfunction calculateGoodFriday(year: number): Date {\n\n}"}
{"task_id": 341, "code_type": "method", "code_language": "typescript", "code_signature": "/**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nconst convertTimeHmsStringToMs = (str: string): number => {\n}", "test_code": "describe('convertTimeHmsStringToMs', () => {\n    test('converts typical time string correctly (1h30m15s)', () => {\n        const result = convertTimeHmsStringToMs('1h30m15s');\n        expect(result).toBe(5415000);  // 1 hour + 30 minutes + 15 seconds in ms\n    });\n\n    test('handles time string with missing units correctly (45m30s)', () => {\n        const result = convertTimeHmsStringToMs('45m30s');\n        expect(result).toBe(2730000);  // 45 minutes + 30 seconds in ms\n    });\n\n    test('correctly converts string with zero values (0h0m0s)', () => {\n        const result = convertTimeHmsStringToMs('0h0m0s');\n        expect(result).toBe(0);  // 0 ms\n    });\n\n    test('throws error on empty string', () => {\n        expect(() => convertTimeHmsStringToMs('')).toThrow('Cannot convert hms string \"\" to ms!');\n    });\n\n    test('throws error on invalid format (not following hms pattern)', () => {\n        expect(() => convertTimeHmsStringToMs('2hours15mins')).toThrow('Cannot convert hms string \"2hours15mins\" to ms!');\n    });\n});", "prompt": "please write a typescript function the function signature as below /**\n * Converts a time string in the format \"XhYmZs\" (hours, minutes, seconds) into milliseconds.\n *\n * @param str The input string representing the time duration.\n * @returns The time in milliseconds.\n * @throws Error if the input string does not match the expected format.\n */\nconst convertTimeHmsStringToMs = (str: string): number => {\n}"}
