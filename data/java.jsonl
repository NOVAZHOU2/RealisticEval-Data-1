{"task_id": 170, "code_type": "method", "code_language": "java", "code_signature": "/**\n * convert the HTML string to the corresponding MarkDown formatted text. HTML tags that support conversion include a, strong, code, em, p, br, u, ul, li, ol\n * @param html\n * @return\n */\npublic static String convert(String html) {\n\n}", "test_code": "package com.real.t170;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.real.t170.Adapted.*;\n\npublic class TestClass {\n    @Test\n    public void testSimpleParagraph() {\n        String html = \"<p>This is a test.</p>\";\n        String expected = \"This is a test.\\n\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testComplexNestedTags() {\n        String html = \"<p>This is <strong>bold and <em>italic</em></strong> text.</p>\";\n        String expected = \"This is **bold and *italic*** text.\\n\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testLinks() {\n        String html = \"<p>Check out this <a href='http://example.com'>link</a>.</p>\";\n        String expected = \"Check out this <a href='http://example.com'>link</a>.\\n\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testListItems() {\n        String html = \"<ul><li>Item 1</li><li>Item 2</li></ul>\";\n        String expected = \"* Item 1\\n* Item 2\\n\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n\n    @Test\n    public void testEmptyString() {\n        String html = \"\";\n        String expected = \"\";\n        assertEquals(expected, Adapted.convert(html));\n    }\n}\n", "prompt": "please write a java function the function signature as below /**\n * convert the HTML string to the corresponding MarkDown formatted text. HTML tags that support conversion include a, strong, code, em, p, br, u, ul, li, ol\n * @param html\n * @return\n */\npublic static String convert(String html) {\n\n}"}
{"task_id": 173, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n", "test_code": "package com.real.t173;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\npublic class TestClass {\n\n    @Test\n    public void testCubicBezier_t0() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.0;\n        double[] expected = {0.0, 0.0};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t1() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 1.0;\n        double[] expected = {1.0, 0.0};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3));\n    }\n\n    @Test\n    public void testCubicBezier_t0_5() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 1.0};\n        double[] p2 = {1.0, 1.0};\n        double[] p3 = {1.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {0.5, 0.75};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_midPoint() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {1.0, 1.0};\n        double[] p2 = {2.0, 1.0};\n        double[] p3 = {3.0, 0.0};\n\n        double t = 0.5;\n        double[] expected = {1.5, 0.75};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n    @Test\n    public void testCubicBezier_arbitraryT() {\n        double[] p0 = {0.0, 0.0};\n        double[] p1 = {0.0, 2.0};\n        double[] p2 = {2.0, 2.0};\n        double[] p3 = {2.0, 0.0};\n        double t = 0.75;\n        double[] expected = {1.6875, 1.125};\n        assertArrayEquals(expected, Adapted.cubicBezier(t, p0, p1, p2, p3), 1e-9);\n    }\n\n}\n", "prompt": "please write a java class this class signature as below /**\n * Calculate the coordinates of a cubic B\u00e9zier curve at a given parametert(typically between 0 and 1).\n * @param t  A double representing the parameter along the curve, where 0 <= t <= 1.\n * @param p0 A double array of size 2 representing the x and y coordinates of the start point.\n * @param p1 A double array of size 2 representing the x and y coordinates of the first control point.\n * @param p2 A double array of size 2 representing the x and y coordinates of the second control point.\n * @param p3 A double array of size 2 representing the x and y coordinates of the end point.\n * @return   A double array of size 2 containing the x and y coordinates of the point on the curve corresponding to the parameter t.\n */\npublic static double[] cubicBezier(double t, double[] p0, double[] p1, double[] p2, double[] p3) {}\n"}
{"task_id": 176, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {}", "test_code": "package com.real.t176;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.real.t176.Adapted.*;\n\n\npublic class TestClass {\n    @Test\n    public void testFindKNearestNeighbors_SimpleCase() {\n        Adapted knn = new Adapted();\n        Adapted.Point[] points = {\n                new Adapted.Point(1, 2),\n                new Adapted.Point(3, 4),\n                new Adapted.Point(1, -1),\n                new Adapted.Point(5, 2)\n        };\n        Adapted.Point queryPoint = new Adapted.Point(2, 2);\n        int k = 2;\n\n        Adapted.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Adapted.Point(1, 2)));\n        assertTrue(containsPoint(result, new Adapted.Point(3, 4)));\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_ExactMatch() {\n        Adapted knn = new Adapted();\n        Adapted.Point[] points = {\n                new Adapted.Point(1, 2),\n                new Adapted.Point(2, 2),\n                new Adapted.Point(3, 3)\n        };\n        Adapted.Point queryPoint = new Adapted.Point(2, 2);\n        int k = 1;\n\n        Adapted.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(1, result.length);\n        assertEquals(2.0, result[0].x, 0.001);\n        assertEquals(2.0, result[0].y, 0.001);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_LargerK() {\n        Adapted knn = new Adapted();\n        Adapted.Point[] points = {\n                new Adapted.Point(1, 2),\n                new Adapted.Point(3, 4),\n                new Adapted.Point(1, -1),\n                new Adapted.Point(5, 2)\n        };\n        Adapted.Point queryPoint = new Adapted.Point(2, 2);\n        int k = 5;  // k is larger than the number of points\n\n        Adapted.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(4, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_EmptyPoints() {\n        Adapted knn = new Adapted();\n        Adapted.Point[] points = {};\n        Adapted.Point queryPoint = new Adapted.Point(2, 2);\n        int k = 3;\n\n        Adapted.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(0, result.length);\n    }\n\n    @Test\n    public void testFindKNearestNeighbors_AllPointsEquidistant() {\n        Adapted knn = new Adapted();\n        Adapted.Point[] points = {\n                new Adapted.Point(2, 3),\n                new Adapted.Point(3, 2),\n                new Adapted.Point(1, 2),\n                new Adapted.Point(2, 1)\n        };\n        Adapted.Point queryPoint = new Adapted.Point(2, 2);\n        int k = 2;\n\n        Adapted.Point[] result = knn.findKNearestNeighbors(points, queryPoint, k);\n\n        assertEquals(2, result.length);\n        assertTrue(containsPoint(result, new Adapted.Point(2, 3)));\n        assertTrue(containsPoint(result, new Adapted.Point(3, 2)));\n    }\n\n    private boolean containsPoint(Adapted.Point[] points, Adapted.Point point) {\n        for (Adapted.Point p : points) {\n            if (Math.abs(p.x - point.x) < 0.001 && Math.abs(p.y - point.y) < 0.001) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "prompt": "please write a java class this class signature as below /**\n * Given a set of points and a query point, write an algorithm to find the K nearest neighbors to the query point. The algorithm should efficiently handle large datasets, and the output should include the coordinates or indices of these neighbors.\n *\n * @param points Array of points from which to find the nearest neighbors.\n * @param queryPoint The point to which the nearest neighbors are found.\n * @param k The number of nearest neighbors to find.\n * @return An array containing the k nearest neighbors.\n */\npublic Point[] findKNearestNeighbors(Point[] points, Point queryPoint, int k) {}"}
{"task_id": 177, "code_type": "method", "code_language": "java", "code_signature": "/**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {}", "test_code": "package com.real.t177;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.real.t177.Adapted.*;\n\npublic class TestClass {\n\n    /**\n     * Test that the hashPasswordWithSalt method returns a byte array with the correct length.\n     * The length should be 48 bytes (16 bytes of salt + 32 bytes of SHA-256 hash).\n     */\n    @Test\n    public void testHashPasswordWithSaltLength() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Adapted.hashPasswordWithSalt(password);\n\n        // SHA-256 hash length is 32 bytes, and the salt length is 16 bytes\n        assertEquals(48, result.length, \"The combined salt and hashed password length should be 48 bytes.\");\n    }\n\n    /**\n     * Test that the salt is correctly generated and included in the hash result.\n     * The first 16 bytes of the result should represent the salt.\n     */\n    @Test\n    public void testSaltIsIncludedInResult() throws NoSuchAlgorithmException {\n        String password = \"testPassword\";\n        byte[] result = Adapted.hashPasswordWithSalt(password);\n\n        byte[] salt = Arrays.copyOfRange(result, 0, 16);\n\n        assertNotNull(salt, \"Salt should not be null.\");\n        assertEquals(16, salt.length, \"Salt length should be 16 bytes.\");\n    }\n\n    /**\n     * Test that two different passwords produce different hashes, even with the same salt.\n     */\n    @Test\n    public void testDifferentPasswordsProduceDifferentHashes() throws NoSuchAlgorithmException {\n        String password1 = \"password123\";\n        String password2 = \"password456\";\n\n        byte[] hash1 = Adapted.hashPasswordWithSalt(password1);\n        byte[] hash2 = Adapted.hashPasswordWithSalt(password2);\n\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"Different passwords should produce different hashes.\");\n    }\n\n    /**\n     * Test that the same password produces different hashes when hashed with different salts.\n     */\n    @Test\n    public void testSamePasswordDifferentSalts() throws NoSuchAlgorithmException {\n        String password = \"password123\";\n\n        byte[] hash1 = Adapted.hashPasswordWithSalt(password);\n        byte[] hash2 = Adapted.hashPasswordWithSalt(password);\n\n        // The salt is generated randomly, so the hashes should be different.\n        assertNotEquals(Arrays.toString(hash1), Arrays.toString(hash2), \"The same password should produce different hashes with different salts.\");\n    }\n\n    /**\n     * Test that the same password and salt produce the same hash.\n     * This ensures that the hashing function is deterministic given the same inputs.\n     */\n    @Test\n    public void testSamePasswordAndSaltProduceSameHash() throws NoSuchAlgorithmException {\n        String password = \"password123\";\n        byte[] salt = Adapted.hashPasswordWithSalt(password);\n        byte[] extractedSalt = Arrays.copyOfRange(salt, 0, 16);\n\n        byte[] hash1 = Adapted.hashWithSHA256(password, extractedSalt);\n        byte[] hash2 = Adapted.hashWithSHA256(password, extractedSalt);\n\n        assertArrayEquals(hash1, hash2, \"The same password and salt should produce the same hash.\");\n    }\n}\n", "prompt": "please write a java function the function signature as below /**\n * Generates a 16-byte random salt value, hashes the provided password with that salt\n * using the SHA-256 hash algorithm, and returns the combined salt and hashed password.\n *\n * @param password The password to be hashed.\n * @return A byte array containing the salt followed by the hashed password.\n * @throws NoSuchAlgorithmException If the SHA-256 algorithm is not available.\n */\npublic static byte[] hashPasswordWithSalt(String password) throws NoSuchAlgorithmException {}"}
{"task_id": 178, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {}", "test_code": "package com.real.t178;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.real.t178.Adapted.*;\npublic class TestClass {\n    @Test\n    public void testNonDecreasingSequence() {\n        int[] nums = {5, 7, 4, 8, 6, 10, 2, 11};\n        List<Integer> expected = Arrays.asList(5, 7, 8, 10, 11);\n        assertEquals(expected, Adapted.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllIncreasing() {\n        int[] nums = {1, 2, 3, 4, 5};\n        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5);\n        assertEquals(expected, Adapted.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testAllDecreasing() {\n        int[] nums = {5, 4, 3, 2, 1};\n        List<Integer> expected = Arrays.asList(5);\n        assertEquals(expected, Adapted.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testSingleElement() {\n        int[] nums = {10};\n        List<Integer> expected = Arrays.asList(10);\n        assertEquals(expected, Adapted.findLongestNonDecreasingSubsequence(nums));\n    }\n\n    @Test\n    public void testEmptyArray() {\n        int[] nums = {};\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Adapted.findLongestNonDecreasingSubsequence(nums));\n    }\n}\n", "prompt": "please write a java class this class signature as below /**\n * Find the longest non-decreasing subsequence in the given list.\n *\n * @param nums The input array of integers.\n * @return A list containing the longest non-decreasing subsequence.\n */\npublic static List<Integer> findLongestNonDecreasingSubsequence(int[] nums) {}"}
{"task_id": 179, "code_type": "method", "code_language": "java", "code_signature": "/**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {}", "test_code": "package com.real.t179;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.real.t179.Adapted.*;\npublic class TestClass {\n    private File sourceDir;\n    private File targetDir;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        sourceDir = new File(\"testSourceDir\");\n        targetDir = new File(\"testTargetDir\");\n\n        if (!sourceDir.exists()) {\n            sourceDir.mkdir();\n        }\n\n        if (!targetDir.exists()) {\n            targetDir.mkdir();\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        deleteDirectory(sourceDir);\n        deleteDirectory(targetDir);\n    }\n\n    /**\n     * Test copying an empty directory.\n     */\n    @Test\n    public void testCopyEmptyDirectory() throws IOException {\n        Adapted.copyDirectory(sourceDir, targetDir);\n        assertTrue(targetDir.exists(), \"Target directory should exist after copying.\");\n        assertTrue(targetDir.isDirectory(), \"Target directory should be a directory.\");\n        assertEquals(0, targetDir.listFiles().length, \"Target directory should be empty.\");\n    }\n\n    /**\n     * Test copying a directory with files.\n     */\n    @Test\n    public void testCopyDirectoryWithFiles() throws IOException {\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Adapted.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(copiedFile.exists(), \"File should be copied to target directory.\");\n        assertEquals(testFile.length(), copiedFile.length(), \"File size should be the same after copying.\");\n    }\n\n    /**\n     * Test handling of non-existent source directory.\n     */\n    @Test\n    public void testNonExistentSourceDirectory() {\n        File nonExistentDir = new File(\"nonExistentDir\");\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () ->\n            Adapted.copyDirectory(nonExistentDir, targetDir), \"Expected exception for non-existent source directory.\");\n\n        assertTrue(exception.getMessage().contains(\"Source directory does not exist\"), \"Exception message should indicate non-existent source directory.\");\n    }\n\n    /**\n     * Test copying a directory with subdirectories.\n     */\n    @Test\n    public void testCopyDirectoryWithSubdirectories() throws IOException {\n        File subDir = new File(sourceDir, \"subDir\");\n        subDir.mkdir();\n        File testFile = new File(subDir, \"testFile.txt\");\n        Files.createFile(testFile.toPath());\n\n        Adapted.copyDirectory(sourceDir, targetDir);\n        File copiedSubDir = new File(targetDir, \"subDir\");\n        File copiedFile = new File(copiedSubDir, \"testFile.txt\");\n\n        assertTrue(copiedSubDir.exists(), \"Subdirectory should be copied to target directory.\");\n        assertTrue(copiedFile.exists(), \"File within subdirectory should be copied to target directory.\");\n    }\n\n    /**\n     * Test overwriting files in the target directory.\n     */\n    @Test\n    public void testOverwriteFileInTargetDirectory() throws IOException {\n        // Create a source file with some content\n        File testFile = new File(sourceDir, \"testFile.txt\");\n        Files.writeString(testFile.toPath(), \"Source content\");\n\n        // Create a target file with different content\n        File targetFile = new File(targetDir, \"testFile.txt\");\n        Files.writeString(targetFile.toPath(), \"Target content\");\n\n        // Copy the directory, which should overwrite the target file\n        Adapted.copyDirectory(sourceDir, targetDir);\n        File copiedFile = new File(targetDir, \"testFile.txt\");\n\n        assertTrue(copiedFile.exists(), \"File should be copied to target directory.\");\n\n        // Check that the content of the file is now the same as the source file\n        String copiedContent = Files.readString(copiedFile.toPath());\n        assertEquals(\"Source content\", copiedContent, \"File in target directory should be overwritten with source content.\");\n    }\n\n\n    /**\n     * Helper method to delete a directory and its contents.\n     *\n     * @param dir The directory to delete.\n     */\n    private void deleteDirectory(File dir) {\n        File[] files = dir.listFiles();\n        if (files != null) {\n            for (File file : files) {\n                if (file.isDirectory()) {\n                    deleteDirectory(file);\n                } else {\n                    file.delete();\n                }\n            }\n        }\n        dir.delete();\n    }\n}\n", "prompt": "please write a java function the function signature as below /**\n* Copies all files and subdirectories from the source directory to the target directory.\n*\n* @param sourceDir The source directory from which files and subdirectories will be copied.\n* @param targetDir The target directory to which files and subdirectories will be copied.\n* @throws IOException If an I/O error occurs while copying files or directories.\n*/\npublic static void copyDirectory(File sourceDir, File targetDir) throws IOException {}"}
{"task_id": 180, "code_type": "method", "code_language": "java", "code_signature": "/**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {}", "test_code": "package com.real.t180;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.real.t180.Adapted.*;\npublic class TestClass {\n    /**\n     * Test when the target is present in the array.\n     */\n    @Test\n    public void testTargetPresent() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 7;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(3, result, \"Target should be found at index 3.\");\n    }\n\n    /**\n     * Test when the target is not present and the closest element is smaller.\n     */\n    @Test\n    public void testClosestElementSmaller() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 6;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(2, result, \"Closest element should be 5 at index 2.\");\n    }\n\n    /**\n     * Test when the target is not present and the closest element is larger.\n     */\n    @Test\n    public void testClosestElementLarger() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 8;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(3, result, \"Closest element should be 7 at index 3.\");\n    }\n\n    /**\n     * Test when the target is smaller than all elements in the array.\n     */\n    @Test\n    public void testTargetSmallerThanAll() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 0;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(0, result, \"Closest element should be 1 at index 0.\");\n    }\n\n    /**\n     * Test when the target is larger than all elements in the array.\n     */\n    @Test\n    public void testTargetLargerThanAll() {\n        int[] array = {1, 3, 5, 7, 9, 11};\n        int target = 12;\n        int result = Adapted.binarySearchClosest(array, target);\n        assertEquals(5, result, \"Closest element should be 11 at index 5.\");\n    }\n}\n", "prompt": "please write a java function the function signature as below /**\n* Implement binary search to find the target or the location closest to the target in the sorted array\n*\n* @param array  The sorted array in which to search.\n* @param target The target value to search for.\n* @return The index of the target or the index of the closest value if the target is not found.\n*/\npublic static int binarySearchClosest(int[] array, int target) {}"}
{"task_id": 181, "code_type": "method", "code_language": "java", "code_signature": "/**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {}", "test_code": "package com.real.t181;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.real.t181.Adapted.*;\npublic class TestClass {\n\n    private File testFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        testFile = new File(\"testFile.txt\");\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(\"Test content\".getBytes());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (testFile.exists()) {\n            testFile.delete();\n        }\n    }\n\n    /**\n     * Test reading a file that exists and has content.\n     */\n    @Test\n    public void testReadFileWithContent() throws IOException {\n        byte[] content = Adapted.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(\"Test content\", new String(content), \"The file content should match the expected string.\");\n    }\n\n    /**\n     * Test reading an empty file.\n     */\n    @Test\n    public void testReadEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n\n        byte[] content = Adapted.readFileToByteArray(emptyFile.getAbsolutePath());\n        assertEquals(0, content.length, \"The content of an empty file should be a byte array of length 0.\");\n\n        emptyFile.delete();\n    }\n\n    /**\n     * Test reading a file that does not exist.\n     */\n    @Test\n    public void testReadNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(IllegalArgumentException.class, () -> {\n            Adapted.readFileToByteArray(nonExistentFilePath);\n        }, \"Reading a non-existent file should throw an IllegalArgumentException.\");\n    }\n\n    /**\n     * Test reading a file with special characters in its content.\n     */\n    @Test\n    public void testReadFileWithSpecialCharacters() throws IOException {\n        String specialContent = \"Special content: !@#$%^&*()_+\";\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(specialContent.getBytes());\n        }\n\n        byte[] content = Adapted.readFileToByteArray(testFile.getAbsolutePath());\n        assertEquals(specialContent, new String(content), \"The file content should match the special characters string.\");\n    }\n\n    /**\n     * Test reading a large file.\n     */\n    @Test\n    public void testReadLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(testFile)) {\n            fos.write(largeContent);\n        }\n\n        byte[] content = Adapted.readFileToByteArray(testFile.getAbsolutePath());\n        assertArrayEquals(largeContent, content, \"The content of the large file should match the expected byte array.\");\n    }\n}\n", "prompt": "please write a java function the function signature as below /**\n* Reads the content of the file specified by the file path and returns it as a byte array.\n*\n* @param filePath The path to the file that needs to be read.\n* @return A byte array containing the content of the file.\n* @throws IOException If an I/O error occurs while reading the file.\n*/\npublic static byte[] readFileToByteArray(String filePath) throws IOException {}"}
{"task_id": 182, "code_type": "method", "code_language": "java", "code_signature": "/**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {}", "test_code": "package com.real.t182;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport com.real.t182.Adapted.*;\npublic class TestClass {\n    private File sourceFile;\n    private File destinationFile;\n\n    @BeforeEach\n    public void setUp() throws IOException {\n        sourceFile = new File(\"testSourceFile.txt\");\n        destinationFile = new File(\"testDestinationFile.txt\");\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(\"This is a test file content.\".getBytes());\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (sourceFile.exists()) {\n            sourceFile.delete();\n        }\n        if (destinationFile.exists()) {\n            destinationFile.delete();\n        }\n    }\n\n    /**\n     * Test copying a file with content.\n     */\n    @Test\n    public void testCopyFileWithContent() throws IOException {\n        long timeTaken = Adapted.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match.\");\n        assertTrue(timeTaken >= 0, \"Time taken should be non-negative.\");\n    }\n\n    /**\n     * Test copying an empty file.\n     */\n    @Test\n    public void testCopyEmptyFile() throws IOException {\n        File emptyFile = new File(\"emptyFile.txt\");\n        emptyFile.createNewFile();\n        File destinationEmptyFile = new File(\"destinationEmptyFile.txt\");\n\n        long timeTaken = Adapted.copyFileWithBufferedStream(emptyFile.getAbsolutePath(), destinationEmptyFile.getAbsolutePath());\n        assertTrue(destinationEmptyFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(0, destinationEmptyFile.length(), \"Empty file should have length 0.\");\n        assertTrue(timeTaken >= 0, \"Time taken should be non-negative.\");\n\n        emptyFile.delete();\n        destinationEmptyFile.delete();\n    }\n\n    /**\n     * Test copying a non-existent source file.\n     */\n    @Test\n    public void testCopyNonExistentFile() {\n        String nonExistentFilePath = \"nonExistentFile.txt\";\n        assertThrows(IOException.class, () -> {\n            Adapted.copyFileWithBufferedStream(nonExistentFilePath, destinationFile.getAbsolutePath());\n        }, \"Copying a non-existent file should throw an IOException.\");\n    }\n\n    /**\n     * Test copying a file to an existing destination file (overwriting).\n     */\n    @Test\n    public void testCopyFileOverwrite() throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(destinationFile)) {\n            fos.write(\"Old content\".getBytes());\n        }\n\n        long timeTaken = Adapted.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match after overwriting.\");\n        assertTrue(timeTaken > 0, \"Time taken should be greater than 0.\");\n    }\n\n    /**\n     * Test copying a large file.\n     */\n    @Test\n    public void testCopyLargeFile() throws IOException {\n        byte[] largeContent = new byte[10 * 1024 * 1024]; // 10 MB\n        for (int i = 0; i < largeContent.length; i++) {\n            largeContent[i] = (byte) (i % 256);\n        }\n\n        try (FileOutputStream fos = new FileOutputStream(sourceFile)) {\n            fos.write(largeContent);\n        }\n\n        long timeTaken = Adapted.copyFileWithBufferedStream(sourceFile.getAbsolutePath(), destinationFile.getAbsolutePath());\n        assertTrue(destinationFile.exists(), \"Destination file should exist after copying.\");\n        assertEquals(sourceFile.length(), destinationFile.length(), \"File sizes should match.\");\n        assertTrue(timeTaken > 0, \"Time taken should be greater than 0.\");\n    }\n}\n", "prompt": "please write a java function the function signature as below /**\n* Copies the contents of the source file to the destination file using a buffered stream\n* and measures the time it takes to complete the operation.\n*\n* @param sourceFilePath      The path to the source file.\n* @param destinationFilePath The path to the destination file.\n* @return The time taken to copy the file in milliseconds.\n* @throws IOException If an I/O error occurs during the copy operation.\n*/\npublic static long copyFileWithBufferedStream(String sourceFilePath, String destinationFilePath) throws IOException {}"}
{"task_id": 348, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n", "test_code": "package com.real.t348;\nimport org.junit.jupiter.api.Test;\n\nimport com.real.t348.Adapted.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestClass {\n    @Test\n    public void testFindPrimesInRange() {\n        List<Integer> expected = Arrays.asList(2, 3, 5, 7, 11);\n        assertEquals(expected, Adapted.findPrimes(1, 12), \"Check primes between 1 and 12\");\n    }\n\n    @Test\n    public void testFindPrimesSinglePrime() {\n        List<Integer> expected = Arrays.asList(29);\n        assertEquals(expected, Adapted.findPrimes(29, 29), \"Check single prime number\");\n    }\n\n    @Test\n    public void testFindPrimesNoPrimes() {\n        List<Integer> expected = Arrays.asList();\n        assertEquals(expected, Adapted.findPrimes(0, 1), \"Check range with no primes\");\n    }\n\n    @Test\n    public void testComputeSumOfPrimes() {\n        List<Integer> primes = Arrays.asList(2, 3, 5, 7);\n        int expectedSum = 17;\n        assertEquals(expectedSum, Adapted.computeSumOfPrimes(primes), \"Sum of first four primes\");\n    }\n\n    @Test\n    public void testIsPrime() {\n        assertTrue(Adapted.isPrime(23), \"Check if 23 is prime\");\n        assertFalse(Adapted.isPrime(25), \"Check if 25 is not prime\");\n    }\n    \n}\n", "prompt": "please write a java class this class signature as below /**\n * Find all primes in a given range and calculate the sum of those primes\n *\n * @param lowerBound The starting point of the range to check for prime numbers. Must be a non-negative integer.\n * @param upperBound The endpoint of the range to check for prime numbers. Must be equal to or greater than lowerBound.\n * @return A List<Integer> containing all the prime numbers found in the specified range. The list will be empty if no primes are found.\n */\npublic static List<Integer> findPrimes(int lowerBound, int upperBound) {}\n"}
{"task_id": 349, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {}", "test_code": "package com.real.t349;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class TestClass {\n    @Test\n    public void testEmptyInput() {\n        Adapted<String> generator = new Adapted<>();\n        List<List<String>> input = new ArrayList<>();\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with empty input\");\n    }\n\n    @Test\n    public void testSingleEmptyList() {\n        Adapted<String> generator = new Adapted<>();\n        List<List<String>> input = Arrays.asList(new ArrayList<>());\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single empty list\");\n    }\n\n    @Test\n    public void testSingleNonEmptyList() {\n        Adapted<String> generator = new Adapted<>();\n        List<List<String>> input = Arrays.asList(Arrays.asList(\"a\", \"b\", \"c\"));\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\"), Arrays.asList(\"b\"), Arrays.asList(\"c\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with a single non-empty list\");\n    }\n\n    @Test\n    public void testMultipleLists() {\n        Adapted<String> generator = new Adapted<>();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = Arrays.asList(\n                Arrays.asList(\"a\", \"1\"), Arrays.asList(\"a\", \"2\"),\n                Arrays.asList(\"b\", \"1\"), Arrays.asList(\"b\", \"2\")\n        );\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with multiple lists\");\n    }\n\n    @Test\n    public void testInputContainingEmptyList() {\n        Adapted<String> generator = new Adapted<>();\n        List<List<String>> input = Arrays.asList(\n                Arrays.asList(\"a\", \"b\"),\n                new ArrayList<>(),\n                Arrays.asList(\"1\", \"2\")\n        );\n        List<List<String>> expected = new ArrayList<>();\n        assertEquals(expected, generator.generateCombinations(input), \"Testing with an input that contains an empty list\");\n    }\n}\n", "prompt": "please write a java class this class signature as below /**\n * Generates all possible combinations of elements from a list of lists, where each combination consists of\n * picking exactly one element from each list in the input list of lists. This method is useful for generating\n * product variations, scenarios in decision-making tools, or any other context where all possible combinations\n * of a set of options need to be explored.\n *\n * @param inputLists A list of lists containing the elements to combine. The lists must not be null but can contain any type of elements.\n * @return A list of lists, where each list represents a possible combination of elements taken from the input lists.\n *         Returns an empty list if the input list is null or empty.\n */\npublic List<List<T>> generateCombinations(List<List<T>> inputLists) {}"}
{"task_id": 350, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {}", "test_code": "package com.real.t350;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class TestClass {\n    @Test\n    void testEmptyByteArray() {\n        byte[] input = new byte[0];\n        assertEquals(\"\", Adapted.byteArrayToHexString(input), \"Empty array should return empty string\");\n    }\n\n    @Test\n    void testSingleByte() {\n        byte[] input = {0x0F}; // 15 in decimal\n        assertEquals(\"0F\", Adapted.byteArrayToHexString(input), \"Single byte array should return correct hex string\");\n    }\n\n    @Test\n    void testMultipleBytes() {\n        byte[] input = {0x01, 0x0A, (byte) 0xFF};\n        assertEquals(\"010AFF\", Adapted.byteArrayToHexString(input), \"Multiple bytes should be converted to correct hex string\");\n    }\n\n    @Test\n    void testZeroBytes() {\n        byte[] input = {0x00, 0x00, 0x00};\n        assertEquals(\"000000\", Adapted.byteArrayToHexString(input), \"Zero bytes should be converted to '000000'\");\n    }\n\n    @Test\n    void testNegativeBytes() {\n        byte[] input = {(byte) 0x80, (byte) 0xFF}; // 128 and 255 in signed byte representation\n        assertEquals(\"80FF\", Adapted.byteArrayToHexString(input), \"Negative bytes should be treated as unsigned and converted correctly\");\n    }\n}\n", "prompt": "please write a java class this class signature as below /**\n * Converts a byte array into its corresponding hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hexadecimal string.\n * @return A string representing the hexadecimal values of the bytes in the input array. If the input array\n *         is empty, returns an empty string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {}"}
{"task_id": 351, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t  The parameter value between 0 and 1 that represents a position along the curve.\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @param p3 The fourth control point, typically where the curve ends.\n * @return The point on the Bezier curve corresponding to the parameter t.\n */\npublic static double bezier(double t, double p0, double p1, double p2, double p3) {}", "test_code": "package com.real.t351;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class TestClass {\n    @Test\n    void testBezierAtStart() {\n        assertEquals(1.0, Adapted.bezier(0, 1, 3, 3, 1), \"Bezier at t=0 should return the first control point p0\");\n    }\n\n    @Test\n    void testBezierAtEnd() {\n        assertEquals(1.0, Adapted.bezier(1, 1, 3, 3, 1), \"Bezier at t=1 should return the last control point p3\");\n    }\n\n    @Test\n    void testBezierAtMiddle() {\n        double expected = 1.0 * 0.125 + 3 * 0.375 + 3 * 0.375 + 1 * 0.125; // Calculate manually for t=0.5\n        assertEquals(expected, Adapted.bezier(0.5, 1, 3, 3, 1), 0.001, \"Bezier at t=0.5 should return the correct middle value\");\n    }\n\n    @Test\n    void testBezierParameterOutOfRange() {\n        assertThrows(IllegalArgumentException.class, () -> Adapted.bezier(-0.1, 1, 3, 3, 1),\n                \"Bezier should throw IllegalArgumentException for t out of range\");\n        assertThrows(IllegalArgumentException.class, () -> Adapted.bezier(1.1, 1, 3, 3, 1),\n                \"Bezier should throw IllegalArgumentException for t out of range\");\n    }\n\n    @Test\n    void testBezierWithIdenticalControlPoints() {\n        assertEquals(2.0, Adapted.bezier(0.5, 2, 2, 2, 2), \"Bezier with all control points the same should return that value\");\n    }\n}\n", "prompt": "please write a java class this class signature as below /**\n * Calculates the value of a cubic Bezier curve at a given parameter t.\n *\n * @param t  The parameter value between 0 and 1 that represents a position along the curve.\n * @param p0 The first control point of the curve, typically where the curve starts.\n * @param p1 The second control point, which influences the tangent at the beginning of the curve.\n * @param p2 The third control point, which influences the tangent at the end of the curve.\n * @param p3 The fourth control point, typically where the curve ends.\n * @return The point on the Bezier curve corresponding to the parameter t.\n */\npublic static double bezier(double t, double p0, double p1, double p2, double p3) {}"}
{"task_id": 352, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {}", "test_code": "package com.real.t352;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TestClass {\n    @Test\n    void testNormalHexString() {\n        String hex = \"1a3f\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Adapted.hexStringToByteArray(hex), \"Should correctly convert a normal hex string\");\n    }\n\n    @Test\n    void testOddLengthHexString() {\n        String hex = \"123\";\n        byte[] expected = { (byte) 0x01, (byte) 0x23 };\n        assertArrayEquals(expected, Adapted.hexStringToByteArray(hex), \"Should handle odd-length hex strings by prepending zero\");\n    }\n\n    @Test\n    void testEmptyString() {\n        String hex = \"\";\n        byte[] expected = new byte[0];\n        assertArrayEquals(expected, Adapted.hexStringToByteArray(hex), \"Should return an empty array for an empty string\");\n    }\n\n    @Test\n    void testHexStringWithUppercase() {\n        String hex = \"1A3F\";\n        byte[] expected = { (byte) 0x1A, (byte) 0x3F };\n        assertArrayEquals(expected, Adapted.hexStringToByteArray(hex), \"Should correctly handle hex strings with uppercase letters\");\n    }\n\n    @Test\n    void testInvalidHexString() {\n        String hex = \"1A3G\"; // 'G' is not a valid hex character\n        assertThrows(NumberFormatException.class, () -> Adapted.hexStringToByteArray(hex), \"Should throw NumberFormatException for non-hex characters\");\n    }\n}\n", "prompt": "please write a java class this class signature as below /**\n * Converts a hexadecimal string into a byte array. Hexadecimal strings are often used to represent binary data\n * in a readable format, especially in networking, cryptography, and systems programming.\n *\n * @param hex The hexadecimal string to be converted. This string should only contain hexadecimal characters\n *            (0-9, A-F, a-f). If the string has an odd number of characters, a leading zero is added to ensure\n *            proper conversion.\n * @return A byte array representing the binary data encoded in the hex string.\n */\npublic static byte[] hexStringToByteArray(String hex) {}"}
{"task_id": 353, "code_type": "class", "code_language": "java", "code_signature": "/**\n * Converts a byte array into a hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hex string. This should not be null.\n * @return A String representing the hexadecimal values of the bytes in the input array. Each byte is represented\n *         by two hexadecimal characters in the string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {", "test_code": "package com.real.t353;\n\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport com.real.t353.Adapted.*;\n\npublic class TestClass {\n    @Test\n    public void testEmptyArray() {\n        byte[] emptyArray = {};\n        String result = Adapted.bytesToHex(emptyArray);\n        assertEquals(\"\", result, \"Empty array should return an empty string\");\n    }\n\n    @Test\n    public void testSingleByte() {\n        byte[] singleByte = {0x0F};\n        String result = Adapted.bytesToHex(singleByte);\n        assertEquals(\"0f\", result, \"Single byte 0x0F should return '0f'\");\n    }\n\n    @Test\n    public void testMultipleBytes() {\n        byte[] byteArray = {0x01, 0x2A, (byte) 0xFF, 0x4C};\n        String result = Adapted.bytesToHex(byteArray);\n        assertEquals(\"012aff4c\", result, \"Array {0x01, 0x2A, 0xFF, 0x4C} should return '012aff4c'\");\n    }\n\n    @Test\n    public void testLeadingZeroes() {\n        byte[] byteArray = {0x00, 0x01, 0x0A};\n        String result = Adapted.bytesToHex(byteArray);\n        assertEquals(\"00010a\", result, \"Array {0x00, 0x01, 0x0A} should return '00010a'\");\n    }\n\n    @Test\n    public void testAllPossibleBytes() {\n        byte[] byteArray = {0x00, 0x7F, (byte) 0x80, (byte) 0xFF};\n        String result = Adapted.bytesToHex(byteArray);\n        assertEquals(\"007f80ff\", result, \"Array {0x00, 0x7F, 0x80, 0xFF} should return '007f80ff'\");\n    }\n}\n", "prompt": "please write a java class this class signature as below /**\n * Converts a byte array into a hexadecimal string representation.\n *\n * @param byteArray An array of bytes to be converted into a hex string. This should not be null.\n * @return A String representing the hexadecimal values of the bytes in the input array. Each byte is represented\n *         by two hexadecimal characters in the string.\n */\npublic static String byteArrayToHexString(byte[] byteArray) {"}
